"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/livekit-client@1.15.13";
exports.ids = ["vendor-chunks/livekit-client@1.15.13"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/livekit-client@1.15.13/node_modules/livekit-client/dist/livekit-client.esm.mjs":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/livekit-client@1.15.13/node_modules/livekit-client/dist/livekit-client.esm.mjs ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AudioPresets: () => (/* binding */ AudioPresets),\n/* harmony export */   BaseKeyProvider: () => (/* binding */ BaseKeyProvider),\n/* harmony export */   ConnectionCheck: () => (/* binding */ ConnectionCheck),\n/* harmony export */   ConnectionError: () => (/* binding */ ConnectionError),\n/* harmony export */   ConnectionQuality: () => (/* binding */ ConnectionQuality),\n/* harmony export */   ConnectionState: () => (/* binding */ ConnectionState),\n/* harmony export */   CriticalTimers: () => (/* binding */ CriticalTimers),\n/* harmony export */   CryptorEvent: () => (/* binding */ CryptorEvent),\n/* harmony export */   DataPacket_Kind: () => (/* binding */ DataPacket_Kind),\n/* harmony export */   DefaultReconnectPolicy: () => (/* binding */ DefaultReconnectPolicy),\n/* harmony export */   DeviceUnsupportedError: () => (/* binding */ DeviceUnsupportedError),\n/* harmony export */   DisconnectReason: () => (/* binding */ DisconnectReason),\n/* harmony export */   EncryptionEvent: () => (/* binding */ EncryptionEvent),\n/* harmony export */   EngineEvent: () => (/* binding */ EngineEvent),\n/* harmony export */   ExternalE2EEKeyProvider: () => (/* binding */ ExternalE2EEKeyProvider),\n/* harmony export */   KeyHandlerEvent: () => (/* binding */ KeyHandlerEvent),\n/* harmony export */   KeyProviderEvent: () => (/* binding */ KeyProviderEvent),\n/* harmony export */   LivekitError: () => (/* binding */ LivekitError),\n/* harmony export */   LocalAudioTrack: () => (/* binding */ LocalAudioTrack),\n/* harmony export */   LocalParticipant: () => (/* binding */ LocalParticipant),\n/* harmony export */   LocalTrack: () => (/* binding */ LocalTrack),\n/* harmony export */   LocalTrackPublication: () => (/* binding */ LocalTrackPublication),\n/* harmony export */   LocalVideoTrack: () => (/* binding */ LocalVideoTrack),\n/* harmony export */   LogLevel: () => (/* binding */ LogLevel),\n/* harmony export */   MediaDeviceFailure: () => (/* binding */ MediaDeviceFailure),\n/* harmony export */   NegotiationError: () => (/* binding */ NegotiationError),\n/* harmony export */   Participant: () => (/* binding */ Participant),\n/* harmony export */   ParticipantEvent: () => (/* binding */ ParticipantEvent),\n/* harmony export */   PublishDataError: () => (/* binding */ PublishDataError),\n/* harmony export */   RemoteAudioTrack: () => (/* binding */ RemoteAudioTrack),\n/* harmony export */   RemoteParticipant: () => (/* binding */ RemoteParticipant),\n/* harmony export */   RemoteTrack: () => (/* binding */ RemoteTrack),\n/* harmony export */   RemoteTrackPublication: () => (/* binding */ RemoteTrackPublication),\n/* harmony export */   RemoteVideoTrack: () => (/* binding */ RemoteVideoTrack),\n/* harmony export */   Room: () => (/* binding */ Room),\n/* harmony export */   RoomEvent: () => (/* binding */ RoomEvent),\n/* harmony export */   RoomState: () => (/* binding */ RoomState),\n/* harmony export */   ScreenSharePresets: () => (/* binding */ ScreenSharePresets),\n/* harmony export */   Track: () => (/* binding */ Track),\n/* harmony export */   TrackEvent: () => (/* binding */ TrackEvent),\n/* harmony export */   TrackInvalidError: () => (/* binding */ TrackInvalidError),\n/* harmony export */   TrackPublication: () => (/* binding */ TrackPublication),\n/* harmony export */   UnexpectedConnectionState: () => (/* binding */ UnexpectedConnectionState),\n/* harmony export */   UnsupportedServer: () => (/* binding */ UnsupportedServer),\n/* harmony export */   VideoPreset: () => (/* binding */ VideoPreset),\n/* harmony export */   VideoPresets: () => (/* binding */ VideoPresets),\n/* harmony export */   VideoPresets43: () => (/* binding */ VideoPresets43),\n/* harmony export */   VideoQuality: () => (/* binding */ VideoQuality),\n/* harmony export */   attachToElement: () => (/* binding */ attachToElement),\n/* harmony export */   createAudioAnalyser: () => (/* binding */ createAudioAnalyser),\n/* harmony export */   createE2EEKey: () => (/* binding */ createE2EEKey),\n/* harmony export */   createKeyMaterialFromBuffer: () => (/* binding */ createKeyMaterialFromBuffer),\n/* harmony export */   createKeyMaterialFromString: () => (/* binding */ createKeyMaterialFromString),\n/* harmony export */   createLocalAudioTrack: () => (/* binding */ createLocalAudioTrack),\n/* harmony export */   createLocalScreenTracks: () => (/* binding */ createLocalScreenTracks),\n/* harmony export */   createLocalTracks: () => (/* binding */ createLocalTracks),\n/* harmony export */   createLocalVideoTrack: () => (/* binding */ createLocalVideoTrack),\n/* harmony export */   deriveKeys: () => (/* binding */ deriveKeys),\n/* harmony export */   detachTrack: () => (/* binding */ detachTrack),\n/* harmony export */   facingModeFromDeviceLabel: () => (/* binding */ facingModeFromDeviceLabel),\n/* harmony export */   facingModeFromLocalTrack: () => (/* binding */ facingModeFromLocalTrack),\n/* harmony export */   getEmptyAudioStreamTrack: () => (/* binding */ getEmptyAudioStreamTrack),\n/* harmony export */   getEmptyVideoStreamTrack: () => (/* binding */ getEmptyVideoStreamTrack),\n/* harmony export */   getLogger: () => (/* binding */ getLogger),\n/* harmony export */   importKey: () => (/* binding */ importKey),\n/* harmony export */   isBackupCodec: () => (/* binding */ isBackupCodec),\n/* harmony export */   isBrowserSupported: () => (/* binding */ isBrowserSupported),\n/* harmony export */   isE2EESupported: () => (/* binding */ isE2EESupported),\n/* harmony export */   isInsertableStreamSupported: () => (/* binding */ isInsertableStreamSupported),\n/* harmony export */   isScriptTransformSupported: () => (/* binding */ isScriptTransformSupported),\n/* harmony export */   isVideoFrame: () => (/* binding */ isVideoFrame),\n/* harmony export */   needsRbspUnescaping: () => (/* binding */ needsRbspUnescaping),\n/* harmony export */   parseRbsp: () => (/* binding */ parseRbsp),\n/* harmony export */   protocolVersion: () => (/* binding */ protocolVersion),\n/* harmony export */   ratchet: () => (/* binding */ ratchet),\n/* harmony export */   setLogExtension: () => (/* binding */ setLogExtension),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel),\n/* harmony export */   supportsAV1: () => (/* binding */ supportsAV1),\n/* harmony export */   supportsAdaptiveStream: () => (/* binding */ supportsAdaptiveStream),\n/* harmony export */   supportsDynacast: () => (/* binding */ supportsDynacast),\n/* harmony export */   supportsVP9: () => (/* binding */ supportsVP9),\n/* harmony export */   version: () => (/* binding */ version),\n/* harmony export */   videoCodecs: () => (/* binding */ videoCodecs),\n/* harmony export */   writeRbsp: () => (/* binding */ writeRbsp)\n/* harmony export */ });\nfunction _mergeNamespaces(n, m) {\n    m.forEach(function(e) {\n        e && typeof e !== 'string' && !Array.isArray(e) && Object.keys(e).forEach(function(k) {\n            if (k !== 'default' && !(k in n)) {\n                var d = Object.getOwnPropertyDescriptor(e, k);\n                Object.defineProperty(n, k, d.get ? d : {\n                    enumerable: true,\n                    get: function() {\n                        return e[k];\n                    }\n                });\n            }\n        });\n    });\n    return Object.freeze(n);\n}\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis :  false ? 0 : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\nfunction getDefaultExportFromCjs(x) {\n    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\nvar loglevel = {\n    exports: {}\n};\n/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/ (function(module) {\n    (function(root, definition) {\n        if (module.exports) {\n            module.exports = definition();\n        } else {\n            root.log = definition();\n        }\n    })(commonjsGlobal, function() {\n        // Slightly dubious tricks to cut down minimized file size\n        var noop = function() {};\n        var undefinedType = \"undefined\";\n        var isIE = \"undefined\" !== undefinedType && typeof window.navigator !== undefinedType && /Trident\\/|MSIE /.test(window.navigator.userAgent);\n        var logMethods = [\n            \"trace\",\n            \"debug\",\n            \"info\",\n            \"warn\",\n            \"error\"\n        ];\n        // Cross-browser bind equivalent that works at least back to IE6\n        function bindMethod(obj, methodName) {\n            var method = obj[methodName];\n            if (typeof method.bind === 'function') {\n                return method.bind(obj);\n            } else {\n                try {\n                    return Function.prototype.bind.call(method, obj);\n                } catch (e) {\n                    // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                    return function() {\n                        return Function.prototype.apply.apply(method, [\n                            obj,\n                            arguments\n                        ]);\n                    };\n                }\n            }\n        }\n        // Trace() doesn't print the message in IE, so for that case we need to wrap it\n        function traceForIE() {\n            if (console.log) {\n                if (console.log.apply) {\n                    console.log.apply(console, arguments);\n                } else {\n                    // In old IE, native console methods themselves don't have apply().\n                    Function.prototype.apply.apply(console.log, [\n                        console,\n                        arguments\n                    ]);\n                }\n            }\n            if (console.trace) console.trace();\n        }\n        // Build the best logging method possible for this env\n        // Wherever possible we want to bind, not wrap, to preserve stack traces\n        function realMethod(methodName) {\n            if (methodName === 'debug') {\n                methodName = 'log';\n            }\n            if (typeof console === undefinedType) {\n                return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n            } else if (methodName === 'trace' && isIE) {\n                return traceForIE;\n            } else if (console[methodName] !== undefined) {\n                return bindMethod(console, methodName);\n            } else if (console.log !== undefined) {\n                return bindMethod(console, 'log');\n            } else {\n                return noop;\n            }\n        }\n        // These private functions always need `this` to be set properly\n        function replaceLoggingMethods(level, loggerName) {\n            /*jshint validthis:true */ for(var i = 0; i < logMethods.length; i++){\n                var methodName = logMethods[i];\n                this[methodName] = i < level ? noop : this.methodFactory(methodName, level, loggerName);\n            }\n            // Define log.log as an alias for log.debug\n            this.log = this.debug;\n        }\n        // In old IE versions, the console isn't present until you first open it.\n        // We build realMethod() replacements here that regenerate logging methods\n        function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\n            return function() {\n                if (typeof console !== undefinedType) {\n                    replaceLoggingMethods.call(this, level, loggerName);\n                    this[methodName].apply(this, arguments);\n                }\n            };\n        }\n        // By default, we use closely bound real methods wherever possible, and\n        // otherwise we wait for a console to appear, and then try again.\n        function defaultMethodFactory(methodName, level, loggerName) {\n            /*jshint validthis:true */ return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);\n        }\n        function Logger(name, defaultLevel, factory) {\n            var self1 = this;\n            var currentLevel;\n            defaultLevel = defaultLevel == null ? \"WARN\" : defaultLevel;\n            var storageKey = \"loglevel\";\n            if (typeof name === \"string\") {\n                storageKey += \":\" + name;\n            } else if (typeof name === \"symbol\") {\n                storageKey = undefined;\n            }\n            function persistLevelIfPossible(levelNum) {\n                var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\n                if (\"undefined\" === undefinedType || !storageKey) return;\n                // Use localStorage if available\n                try {\n                    window.localStorage[storageKey] = levelName;\n                    return;\n                } catch (ignore) {}\n                // Use session cookie as fallback\n                try {\n                    window.document.cookie = encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n                } catch (ignore) {}\n            }\n            function getPersistedLevel() {\n                var storedLevel;\n                if (\"undefined\" === undefinedType || !storageKey) return;\n                try {\n                    storedLevel = window.localStorage[storageKey];\n                } catch (ignore) {}\n                // Fallback to cookies if local storage gives us nothing\n                if (typeof storedLevel === undefinedType) {\n                    try {\n                        var cookie = window.document.cookie;\n                        var location = cookie.indexOf(encodeURIComponent(storageKey) + \"=\");\n                        if (location !== -1) {\n                            storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\n                        }\n                    } catch (ignore) {}\n                }\n                // If the stored level is not valid, treat it as if nothing was stored.\n                if (self1.levels[storedLevel] === undefined) {\n                    storedLevel = undefined;\n                }\n                return storedLevel;\n            }\n            function clearPersistedLevel() {\n                if (\"undefined\" === undefinedType || !storageKey) return;\n                // Use localStorage if available\n                try {\n                    window.localStorage.removeItem(storageKey);\n                    return;\n                } catch (ignore) {}\n                // Use session cookie as fallback\n                try {\n                    window.document.cookie = encodeURIComponent(storageKey) + \"=; expires=Thu, 01 Jan 1970 00:00:00 UTC\";\n                } catch (ignore) {}\n            }\n            /*\n       *\n       * Public logger API - see https://github.com/pimterry/loglevel for details\n       *\n       */ self1.name = name;\n            self1.levels = {\n                \"TRACE\": 0,\n                \"DEBUG\": 1,\n                \"INFO\": 2,\n                \"WARN\": 3,\n                \"ERROR\": 4,\n                \"SILENT\": 5\n            };\n            self1.methodFactory = factory || defaultMethodFactory;\n            self1.getLevel = function() {\n                return currentLevel;\n            };\n            self1.setLevel = function(level, persist) {\n                if (typeof level === \"string\" && self1.levels[level.toUpperCase()] !== undefined) {\n                    level = self1.levels[level.toUpperCase()];\n                }\n                if (typeof level === \"number\" && level >= 0 && level <= self1.levels.SILENT) {\n                    currentLevel = level;\n                    if (persist !== false) {\n                        // defaults to true\n                        persistLevelIfPossible(level);\n                    }\n                    replaceLoggingMethods.call(self1, level, name);\n                    if (typeof console === undefinedType && level < self1.levels.SILENT) {\n                        return \"No console available for logging\";\n                    }\n                } else {\n                    throw \"log.setLevel() called with invalid level: \" + level;\n                }\n            };\n            self1.setDefaultLevel = function(level) {\n                defaultLevel = level;\n                if (!getPersistedLevel()) {\n                    self1.setLevel(level, false);\n                }\n            };\n            self1.resetLevel = function() {\n                self1.setLevel(defaultLevel, false);\n                clearPersistedLevel();\n            };\n            self1.enableAll = function(persist) {\n                self1.setLevel(self1.levels.TRACE, persist);\n            };\n            self1.disableAll = function(persist) {\n                self1.setLevel(self1.levels.SILENT, persist);\n            };\n            // Initialize with the right level\n            var initialLevel = getPersistedLevel();\n            if (initialLevel == null) {\n                initialLevel = defaultLevel;\n            }\n            self1.setLevel(initialLevel, false);\n        }\n        /*\n     *\n     * Top-level API\n     *\n     */ var defaultLogger = new Logger();\n        var _loggersByName = {};\n        defaultLogger.getLogger = function getLogger(name) {\n            if (typeof name !== \"symbol\" && typeof name !== \"string\" || name === \"\") {\n                throw new TypeError(\"You must supply a name when creating a logger.\");\n            }\n            var logger = _loggersByName[name];\n            if (!logger) {\n                logger = _loggersByName[name] = new Logger(name, defaultLogger.getLevel(), defaultLogger.methodFactory);\n            }\n            return logger;\n        };\n        // Grab the current global log variable in case of overwrite\n        var _log = \"undefined\" !== undefinedType ? window.log : undefined;\n        defaultLogger.noConflict = function() {\n            if (\"undefined\" !== undefinedType && window.log === defaultLogger) {\n                window.log = _log;\n            }\n            return defaultLogger;\n        };\n        defaultLogger.getLoggers = function getLoggers() {\n            return _loggersByName;\n        };\n        // ES6 default export, for compatibility\n        defaultLogger['default'] = defaultLogger;\n        return defaultLogger;\n    });\n})(loglevel);\nvar loglevelExports = loglevel.exports;\nvar LogLevel;\n(function(LogLevel) {\n    LogLevel[LogLevel[\"trace\"] = 0] = \"trace\";\n    LogLevel[LogLevel[\"debug\"] = 1] = \"debug\";\n    LogLevel[LogLevel[\"info\"] = 2] = \"info\";\n    LogLevel[LogLevel[\"warn\"] = 3] = \"warn\";\n    LogLevel[LogLevel[\"error\"] = 4] = \"error\";\n    LogLevel[LogLevel[\"silent\"] = 5] = \"silent\";\n})(LogLevel || (LogLevel = {}));\nvar LoggerNames;\n(function(LoggerNames) {\n    LoggerNames[\"Default\"] = \"livekit\";\n    LoggerNames[\"Room\"] = \"livekit-room\";\n    LoggerNames[\"Participant\"] = \"livekit-participant\";\n    LoggerNames[\"Track\"] = \"livekit-track\";\n    LoggerNames[\"Publication\"] = \"livekit-track-publication\";\n    LoggerNames[\"Engine\"] = \"livekit-engine\";\n    LoggerNames[\"Signal\"] = \"livekit-signal\";\n    LoggerNames[\"PCManager\"] = \"livekit-pc-manager\";\n    LoggerNames[\"PCTransport\"] = \"livekit-pc-transport\";\n    LoggerNames[\"E2EE\"] = \"lk-e2ee\";\n})(LoggerNames || (LoggerNames = {}));\nlet livekitLogger = loglevelExports.getLogger('livekit');\nlivekitLogger.setDefaultLevel(LogLevel.info);\n/**\n * @internal\n */ function getLogger(name) {\n    const logger = loglevelExports.getLogger(name);\n    logger.setDefaultLevel(livekitLogger.getLevel());\n    return logger;\n}\nfunction setLogLevel(level, loggerName) {\n    if (loggerName) {\n        loglevelExports.getLogger(loggerName).setLevel(level);\n    }\n    for (const logger of Object.entries(loglevelExports.getLoggers()).filter((_ref)=>{\n        let [logrName] = _ref;\n        return logrName.startsWith('livekit');\n    }).map((_ref2)=>{\n        let [, logr] = _ref2;\n        return logr;\n    })){\n        logger.setLevel(level);\n    }\n}\n/**\n * use this to hook into the logging function to allow sending internal livekit logs to third party services\n * if set, the browser logs will lose their stacktrace information (see https://github.com/pimterry/loglevel#writing-plugins)\n */ function setLogExtension(extension) {\n    let logger = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : livekitLogger;\n    const originalFactory = logger.methodFactory;\n    logger.methodFactory = (methodName, configLevel, loggerName)=>{\n        const rawMethod = originalFactory(methodName, configLevel, loggerName);\n        const logLevel = LogLevel[methodName];\n        const needLog = logLevel >= configLevel && logLevel < LogLevel.silent;\n        return (msg, context)=>{\n            if (context) rawMethod(msg, context);\n            else rawMethod(msg);\n            if (needLog) {\n                extension(logLevel, msg, context);\n            }\n        };\n    };\n    logger.setLevel(logger.getLevel()); // Be sure to call setLevel method in order to apply plugin\n}\nloglevelExports.getLogger('lk-e2ee');\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Assert that condition is truthy or throw error (with message)\n */ function assert(condition, msg) {\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions -- we want the implicit conversion to boolean\n    if (!condition) {\n        throw new Error(msg);\n    }\n}\nconst FLOAT32_MAX = 3.4028234663852886e38, FLOAT32_MIN = -3.4028234663852886e38, UINT32_MAX = 0xffffffff, INT32_MAX = 0x7fffffff, INT32_MIN = -0x80000000;\n/**\n * Assert a valid signed protobuf 32-bit integer.\n */ function assertInt32(arg) {\n    if (typeof arg !== \"number\") throw new Error(\"invalid int 32: \" + typeof arg);\n    if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN) throw new Error(\"invalid int 32: \" + arg); // eslint-disable-line @typescript-eslint/restrict-plus-operands -- we want the implicit conversion to string\n}\n/**\n * Assert a valid unsigned protobuf 32-bit integer.\n */ function assertUInt32(arg) {\n    if (typeof arg !== \"number\") throw new Error(\"invalid uint 32: \" + typeof arg);\n    if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0) throw new Error(\"invalid uint 32: \" + arg); // eslint-disable-line @typescript-eslint/restrict-plus-operands -- we want the implicit conversion to string\n}\n/**\n * Assert a valid protobuf float value.\n */ function assertFloat32(arg) {\n    if (typeof arg !== \"number\") throw new Error(\"invalid float 32: \" + typeof arg);\n    if (!Number.isFinite(arg)) return;\n    if (arg > FLOAT32_MAX || arg < FLOAT32_MIN) throw new Error(\"invalid float 32: \" + arg); // eslint-disable-line @typescript-eslint/restrict-plus-operands -- we want the implicit conversion to string\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nconst enumTypeSymbol = Symbol(\"@bufbuild/protobuf/enum-type\");\n/**\n * Get reflection information from a generated enum.\n * If this function is called on something other than a generated\n * enum, it raises an error.\n */ function getEnumType(enumObject) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-explicit-any\n    const t = enumObject[enumTypeSymbol];\n    assert(t, \"missing enum type on enum object\");\n    return t; // eslint-disable-line @typescript-eslint/no-unsafe-return\n}\n/**\n * Sets reflection information on a generated enum.\n */ function setEnumType(enumObject, typeName, values, opt) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any\n    enumObject[enumTypeSymbol] = makeEnumType(typeName, values.map((v)=>({\n            no: v.no,\n            name: v.name,\n            localName: enumObject[v.no]\n        })));\n}\n/**\n * Create a new EnumType with the given values.\n */ function makeEnumType(typeName, values, // eslint-disable-next-line @typescript-eslint/no-unused-vars\n_opt) {\n    const names = Object.create(null);\n    const numbers = Object.create(null);\n    const normalValues = [];\n    for (const value of values){\n        // We do not surface options at this time\n        // const value: EnumValueInfo = {...v, options: v.options ?? emptyReadonlyObject};\n        const n = normalizeEnumValue(value);\n        normalValues.push(n);\n        names[value.name] = n;\n        numbers[value.no] = n;\n    }\n    return {\n        typeName,\n        values: normalValues,\n        // We do not surface options at this time\n        // options: opt?.options ?? Object.create(null),\n        findName (name) {\n            return names[name];\n        },\n        findNumber (no) {\n            return numbers[no];\n        }\n    };\n}\n/**\n * Create a new enum object with the given values.\n * Sets reflection information.\n */ function makeEnum(typeName, values, opt) {\n    const enumObject = {};\n    for (const value of values){\n        const n = normalizeEnumValue(value);\n        enumObject[n.localName] = n.no;\n        enumObject[n.no] = n.localName;\n    }\n    setEnumType(enumObject, typeName, values);\n    return enumObject;\n}\nfunction normalizeEnumValue(value) {\n    if (\"localName\" in value) {\n        return value;\n    }\n    return Object.assign(Object.assign({}, value), {\n        localName: value.name\n    });\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Message is the base class of every message, generated, or created at\n * runtime.\n *\n * It is _not_ safe to extend this class. If you want to create a message at\n * run time, use proto3.makeMessageType().\n */ class Message {\n    /**\n   * Compare with a message of the same type.\n   */ equals(other) {\n        return this.getType().runtime.util.equals(this.getType(), this, other);\n    }\n    /**\n   * Create a deep copy.\n   */ clone() {\n        return this.getType().runtime.util.clone(this);\n    }\n    /**\n   * Parse from binary data, merging fields.\n   *\n   * Repeated fields are appended. Map entries are added, overwriting\n   * existing keys.\n   *\n   * If a message field is already present, it will be merged with the\n   * new data.\n   */ fromBinary(bytes, options) {\n        const type = this.getType(), format = type.runtime.bin, opt = format.makeReadOptions(options);\n        format.readMessage(this, opt.readerFactory(bytes), bytes.byteLength, opt);\n        return this;\n    }\n    /**\n   * Parse a message from a JSON value.\n   */ fromJson(jsonValue, options) {\n        const type = this.getType(), format = type.runtime.json, opt = format.makeReadOptions(options);\n        format.readMessage(type, jsonValue, opt, this);\n        return this;\n    }\n    /**\n   * Parse a message from a JSON string.\n   */ fromJsonString(jsonString, options) {\n        let json;\n        try {\n            json = JSON.parse(jsonString);\n        } catch (e) {\n            throw new Error(\"cannot decode \".concat(this.getType().typeName, \" from JSON: \").concat(e instanceof Error ? e.message : String(e)));\n        }\n        return this.fromJson(json, options);\n    }\n    /**\n   * Serialize the message to binary data.\n   */ toBinary(options) {\n        const type = this.getType(), bin = type.runtime.bin, opt = bin.makeWriteOptions(options), writer = opt.writerFactory();\n        bin.writeMessage(this, writer, opt);\n        return writer.finish();\n    }\n    /**\n   * Serialize the message to a JSON value, a JavaScript value that can be\n   * passed to JSON.stringify().\n   */ toJson(options) {\n        const type = this.getType(), json = type.runtime.json, opt = json.makeWriteOptions(options);\n        return json.writeMessage(this, opt);\n    }\n    /**\n   * Serialize the message to a JSON string.\n   */ toJsonString(options) {\n        var _a;\n        const value = this.toJson(options);\n        return JSON.stringify(value, null, (_a = options === null || options === void 0 ? void 0 : options.prettySpaces) !== null && _a !== void 0 ? _a : 0);\n    }\n    /**\n   * Override for serialization behavior. This will be invoked when calling\n   * JSON.stringify on this message (i.e. JSON.stringify(msg)).\n   *\n   * Note that this will not serialize google.protobuf.Any with a packed\n   * message because the protobuf JSON format specifies that it needs to be\n   * unpacked, and this is only possible with a type registry to look up the\n   * message type.  As a result, attempting to serialize a message with this\n   * type will throw an Error.\n   *\n   * This method is protected because you should not need to invoke it\n   * directly -- instead use JSON.stringify or toJsonString for\n   * stringified JSON.  Alternatively, if actual JSON is desired, you should\n   * use toJson.\n   */ toJSON() {\n        return this.toJson({\n            emitDefaultValues: true\n        });\n    }\n    /**\n   * Retrieve the MessageType of this message - a singleton that represents\n   * the protobuf message declaration and provides metadata for reflection-\n   * based operations.\n   */ getType() {\n        // Any class that extends Message _must_ provide a complete static\n        // implementation of MessageType.\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-return\n        return Object.getPrototypeOf(this).constructor;\n    }\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Create a new message type using the given runtime.\n */ function makeMessageType(runtime, typeName, fields, opt) {\n    var _a;\n    const localName = (_a = opt === null || opt === void 0 ? void 0 : opt.localName) !== null && _a !== void 0 ? _a : typeName.substring(typeName.lastIndexOf(\".\") + 1);\n    const type = {\n        [localName]: function(data) {\n            runtime.util.initFields(this);\n            runtime.util.initPartial(data, this);\n        }\n    }[localName];\n    Object.setPrototypeOf(type.prototype, new Message());\n    Object.assign(type, {\n        runtime,\n        typeName,\n        fields: runtime.util.newFieldList(fields),\n        fromBinary (bytes, options) {\n            return new type().fromBinary(bytes, options);\n        },\n        fromJson (jsonValue, options) {\n            return new type().fromJson(jsonValue, options);\n        },\n        fromJsonString (jsonString, options) {\n            return new type().fromJsonString(jsonString, options);\n        },\n        equals (a, b) {\n            return runtime.util.equals(type, a, b);\n        }\n    });\n    return type;\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nfunction makeProtoRuntime(syntax, json, bin, util) {\n    return {\n        syntax,\n        json,\n        bin,\n        util,\n        makeMessageType (typeName, fields, opt) {\n            return makeMessageType(this, typeName, fields, opt);\n        },\n        makeEnum,\n        makeEnumType,\n        getEnumType\n    };\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Scalar value types. This is a subset of field types declared by protobuf\n * enum google.protobuf.FieldDescriptorProto.Type The types GROUP and MESSAGE\n * are omitted, but the numerical values are identical.\n */ var ScalarType;\n(function(ScalarType) {\n    // 0 is reserved for errors.\n    // Order is weird for historical reasons.\n    ScalarType[ScalarType[\"DOUBLE\"] = 1] = \"DOUBLE\";\n    ScalarType[ScalarType[\"FLOAT\"] = 2] = \"FLOAT\";\n    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if\n    // negative values are likely.\n    ScalarType[ScalarType[\"INT64\"] = 3] = \"INT64\";\n    ScalarType[ScalarType[\"UINT64\"] = 4] = \"UINT64\";\n    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if\n    // negative values are likely.\n    ScalarType[ScalarType[\"INT32\"] = 5] = \"INT32\";\n    ScalarType[ScalarType[\"FIXED64\"] = 6] = \"FIXED64\";\n    ScalarType[ScalarType[\"FIXED32\"] = 7] = \"FIXED32\";\n    ScalarType[ScalarType[\"BOOL\"] = 8] = \"BOOL\";\n    ScalarType[ScalarType[\"STRING\"] = 9] = \"STRING\";\n    // Tag-delimited aggregate.\n    // Group type is deprecated and not supported in proto3. However, Proto3\n    // implementations should still be able to parse the group wire format and\n    // treat group fields as unknown fields.\n    // TYPE_GROUP = 10,\n    // TYPE_MESSAGE = 11,  // Length-delimited aggregate.\n    // New in version 2.\n    ScalarType[ScalarType[\"BYTES\"] = 12] = \"BYTES\";\n    ScalarType[ScalarType[\"UINT32\"] = 13] = \"UINT32\";\n    // TYPE_ENUM = 14,\n    ScalarType[ScalarType[\"SFIXED32\"] = 15] = \"SFIXED32\";\n    ScalarType[ScalarType[\"SFIXED64\"] = 16] = \"SFIXED64\";\n    ScalarType[ScalarType[\"SINT32\"] = 17] = \"SINT32\";\n    ScalarType[ScalarType[\"SINT64\"] = 18] = \"SINT64\";\n})(ScalarType || (ScalarType = {}));\n/**\n * JavaScript representation of fields with 64 bit integral types (int64, uint64,\n * sint64, fixed64, sfixed64).\n *\n * This is a subset of google.protobuf.FieldOptions.JSType, which defines JS_NORMAL,\n * JS_STRING, and JS_NUMBER. Protobuf-ES uses BigInt by default, but will use\n * String if `[jstype = JS_STRING]` is specified.\n *\n * ```protobuf\n * uint64 field_a = 1; // BigInt\n * uint64 field_b = 2 [jstype = JS_NORMAL]; // BigInt\n * uint64 field_b = 2 [jstype = JS_NUMBER]; // BigInt\n * uint64 field_b = 2 [jstype = JS_STRING]; // String\n * ```\n */ var LongType;\n(function(LongType) {\n    /**\n   * Use JavaScript BigInt.\n   */ LongType[LongType[\"BIGINT\"] = 0] = \"BIGINT\";\n    /**\n   * Use JavaScript String.\n   *\n   * Field option `[jstype = JS_STRING]`.\n   */ LongType[LongType[\"STRING\"] = 1] = \"STRING\";\n})(LongType || (LongType = {}));\n// Copyright 2008 Google Inc.  All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n// * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n// * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Code generated by the Protocol Buffer compiler is owned by the owner\n// of the input file used when generating it.  This code is not\n// standalone and requires a support library to be linked with it.  This\n// support library is itself covered by the above license.\n/* eslint-disable prefer-const,@typescript-eslint/restrict-plus-operands */ /**\n * Read a 64 bit varint as two JS numbers.\n *\n * Returns tuple:\n * [0]: low bits\n * [1]: high bits\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L175\n */ function varint64read() {\n    let lowBits = 0;\n    let highBits = 0;\n    for(let shift = 0; shift < 28; shift += 7){\n        let b = this.buf[this.pos++];\n        lowBits |= (b & 0x7f) << shift;\n        if ((b & 0x80) == 0) {\n            this.assertBounds();\n            return [\n                lowBits,\n                highBits\n            ];\n        }\n    }\n    let middleByte = this.buf[this.pos++];\n    // last four bits of the first 32 bit number\n    lowBits |= (middleByte & 0x0f) << 28;\n    // 3 upper bits are part of the next 32 bit number\n    highBits = (middleByte & 0x70) >> 4;\n    if ((middleByte & 0x80) == 0) {\n        this.assertBounds();\n        return [\n            lowBits,\n            highBits\n        ];\n    }\n    for(let shift = 3; shift <= 31; shift += 7){\n        let b = this.buf[this.pos++];\n        highBits |= (b & 0x7f) << shift;\n        if ((b & 0x80) == 0) {\n            this.assertBounds();\n            return [\n                lowBits,\n                highBits\n            ];\n        }\n    }\n    throw new Error(\"invalid varint\");\n}\n/**\n * Write a 64 bit varint, given as two JS numbers, to the given bytes array.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/writer.js#L344\n */ function varint64write(lo, hi, bytes) {\n    for(let i = 0; i < 28; i = i + 7){\n        const shift = lo >>> i;\n        const hasNext = !(shift >>> 7 == 0 && hi == 0);\n        const byte = (hasNext ? shift | 0x80 : shift) & 0xff;\n        bytes.push(byte);\n        if (!hasNext) {\n            return;\n        }\n    }\n    const splitBits = lo >>> 28 & 0x0f | (hi & 0x07) << 4;\n    const hasMoreBits = !(hi >> 3 == 0);\n    bytes.push((hasMoreBits ? splitBits | 0x80 : splitBits) & 0xff);\n    if (!hasMoreBits) {\n        return;\n    }\n    for(let i = 3; i < 31; i = i + 7){\n        const shift = hi >>> i;\n        const hasNext = !(shift >>> 7 == 0);\n        const byte = (hasNext ? shift | 0x80 : shift) & 0xff;\n        bytes.push(byte);\n        if (!hasNext) {\n            return;\n        }\n    }\n    bytes.push(hi >>> 31 & 0x01);\n}\n// constants for binary math\nconst TWO_PWR_32_DBL = 0x100000000;\n/**\n * Parse decimal string of 64 bit integer value as two JS numbers.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10\n */ function int64FromString(dec) {\n    // Check for minus sign.\n    const minus = dec[0] === \"-\";\n    if (minus) {\n        dec = dec.slice(1);\n    }\n    // Work 6 decimal digits at a time, acting like we're converting base 1e6\n    // digits to binary. This is safe to do with floating point math because\n    // Number.isSafeInteger(ALL_32_BITS * 1e6) == true.\n    const base = 1e6;\n    let lowBits = 0;\n    let highBits = 0;\n    function add1e6digit(begin, end) {\n        // Note: Number('') is 0.\n        const digit1e6 = Number(dec.slice(begin, end));\n        highBits *= base;\n        lowBits = lowBits * base + digit1e6;\n        // Carry bits from lowBits to\n        if (lowBits >= TWO_PWR_32_DBL) {\n            highBits = highBits + (lowBits / TWO_PWR_32_DBL | 0);\n            lowBits = lowBits % TWO_PWR_32_DBL;\n        }\n    }\n    add1e6digit(-24, -18);\n    add1e6digit(-18, -12);\n    add1e6digit(-12, -6);\n    add1e6digit(-6);\n    return minus ? negate(lowBits, highBits) : newBits(lowBits, highBits);\n}\n/**\n * Losslessly converts a 64-bit signed integer in 32:32 split representation\n * into a decimal string.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10\n */ function int64ToString(lo, hi) {\n    let bits = newBits(lo, hi);\n    // If we're treating the input as a signed value and the high bit is set, do\n    // a manual two's complement conversion before the decimal conversion.\n    const negative = bits.hi & 0x80000000;\n    if (negative) {\n        bits = negate(bits.lo, bits.hi);\n    }\n    const result = uInt64ToString(bits.lo, bits.hi);\n    return negative ? \"-\" + result : result;\n}\n/**\n * Losslessly converts a 64-bit unsigned integer in 32:32 split representation\n * into a decimal string.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10\n */ function uInt64ToString(lo, hi) {\n    ({ lo, hi } = toUnsigned(lo, hi));\n    // Skip the expensive conversion if the number is small enough to use the\n    // built-in conversions.\n    // Number.MAX_SAFE_INTEGER = 0x001FFFFF FFFFFFFF, thus any number with\n    // highBits <= 0x1FFFFF can be safely expressed with a double and retain\n    // integer precision.\n    // Proven by: Number.isSafeInteger(0x1FFFFF * 2**32 + 0xFFFFFFFF) == true.\n    if (hi <= 0x1FFFFF) {\n        return String(TWO_PWR_32_DBL * hi + lo);\n    }\n    // What this code is doing is essentially converting the input number from\n    // base-2 to base-1e7, which allows us to represent the 64-bit range with\n    // only 3 (very large) digits. Those digits are then trivial to convert to\n    // a base-10 string.\n    // The magic numbers used here are -\n    // 2^24 = 16777216 = (1,6777216) in base-1e7.\n    // 2^48 = 281474976710656 = (2,8147497,6710656) in base-1e7.\n    // Split 32:32 representation into 16:24:24 representation so our\n    // intermediate digits don't overflow.\n    const low = lo & 0xFFFFFF;\n    const mid = (lo >>> 24 | hi << 8) & 0xFFFFFF;\n    const high = hi >> 16 & 0xFFFF;\n    // Assemble our three base-1e7 digits, ignoring carries. The maximum\n    // value in a digit at this step is representable as a 48-bit integer, which\n    // can be stored in a 64-bit floating point number.\n    let digitA = low + mid * 6777216 + high * 6710656;\n    let digitB = mid + high * 8147497;\n    let digitC = high * 2;\n    // Apply carries from A to B and from B to C.\n    const base = 10000000;\n    if (digitA >= base) {\n        digitB += Math.floor(digitA / base);\n        digitA %= base;\n    }\n    if (digitB >= base) {\n        digitC += Math.floor(digitB / base);\n        digitB %= base;\n    }\n    // If digitC is 0, then we should have returned in the trivial code path\n    // at the top for non-safe integers. Given this, we can assume both digitB\n    // and digitA need leading zeros.\n    return digitC.toString() + decimalFrom1e7WithLeadingZeros(digitB) + decimalFrom1e7WithLeadingZeros(digitA);\n}\nfunction toUnsigned(lo, hi) {\n    return {\n        lo: lo >>> 0,\n        hi: hi >>> 0\n    };\n}\nfunction newBits(lo, hi) {\n    return {\n        lo: lo | 0,\n        hi: hi | 0\n    };\n}\n/**\n * Returns two's compliment negation of input.\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Signed_32-bit_integers\n */ function negate(lowBits, highBits) {\n    highBits = ~highBits;\n    if (lowBits) {\n        lowBits = ~lowBits + 1;\n    } else {\n        // If lowBits is 0, then bitwise-not is 0xFFFFFFFF,\n        // adding 1 to that, results in 0x100000000, which leaves\n        // the low bits 0x0 and simply adds one to the high bits.\n        highBits += 1;\n    }\n    return newBits(lowBits, highBits);\n}\n/**\n * Returns decimal representation of digit1e7 with leading zeros.\n */ const decimalFrom1e7WithLeadingZeros = (digit1e7)=>{\n    const partial = String(digit1e7);\n    return \"0000000\".slice(partial.length) + partial;\n};\n/**\n * Write a 32 bit varint, signed or unsigned. Same as `varint64write(0, value, bytes)`\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/1b18833f4f2a2f681f4e4a25cdf3b0a43115ec26/js/binary/encoder.js#L144\n */ function varint32write(value, bytes) {\n    if (value >= 0) {\n        // write value as varint 32\n        while(value > 0x7f){\n            bytes.push(value & 0x7f | 0x80);\n            value = value >>> 7;\n        }\n        bytes.push(value);\n    } else {\n        for(let i = 0; i < 9; i++){\n            bytes.push(value & 127 | 128);\n            value = value >> 7;\n        }\n        bytes.push(1);\n    }\n}\n/**\n * Read an unsigned 32 bit varint.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L220\n */ function varint32read() {\n    let b = this.buf[this.pos++];\n    let result = b & 0x7f;\n    if ((b & 0x80) == 0) {\n        this.assertBounds();\n        return result;\n    }\n    b = this.buf[this.pos++];\n    result |= (b & 0x7f) << 7;\n    if ((b & 0x80) == 0) {\n        this.assertBounds();\n        return result;\n    }\n    b = this.buf[this.pos++];\n    result |= (b & 0x7f) << 14;\n    if ((b & 0x80) == 0) {\n        this.assertBounds();\n        return result;\n    }\n    b = this.buf[this.pos++];\n    result |= (b & 0x7f) << 21;\n    if ((b & 0x80) == 0) {\n        this.assertBounds();\n        return result;\n    }\n    // Extract only last 4 bits\n    b = this.buf[this.pos++];\n    result |= (b & 0x0f) << 28;\n    for(let readBytes = 5; (b & 0x80) !== 0 && readBytes < 10; readBytes++)b = this.buf[this.pos++];\n    if ((b & 0x80) != 0) throw new Error(\"invalid varint\");\n    this.assertBounds();\n    // Result can have 32 bits, convert it to unsigned\n    return result >>> 0;\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nfunction makeInt64Support() {\n    const dv = new DataView(new ArrayBuffer(8));\n    // note that Safari 14 implements BigInt, but not the DataView methods\n    const ok = typeof BigInt === \"function\" && typeof dv.getBigInt64 === \"function\" && typeof dv.getBigUint64 === \"function\" && typeof dv.setBigInt64 === \"function\" && typeof dv.setBigUint64 === \"function\" && (typeof process != \"object\" || typeof process.env != \"object\" || process.env.BUF_BIGINT_DISABLE !== \"1\");\n    if (ok) {\n        const MIN = BigInt(\"-9223372036854775808\"), MAX = BigInt(\"9223372036854775807\"), UMIN = BigInt(\"0\"), UMAX = BigInt(\"18446744073709551615\");\n        return {\n            zero: BigInt(0),\n            supported: true,\n            parse (value) {\n                const bi = typeof value == \"bigint\" ? value : BigInt(value);\n                if (bi > MAX || bi < MIN) {\n                    throw new Error(\"int64 invalid: \".concat(value));\n                }\n                return bi;\n            },\n            uParse (value) {\n                const bi = typeof value == \"bigint\" ? value : BigInt(value);\n                if (bi > UMAX || bi < UMIN) {\n                    throw new Error(\"uint64 invalid: \".concat(value));\n                }\n                return bi;\n            },\n            enc (value) {\n                dv.setBigInt64(0, this.parse(value), true);\n                return {\n                    lo: dv.getInt32(0, true),\n                    hi: dv.getInt32(4, true)\n                };\n            },\n            uEnc (value) {\n                dv.setBigInt64(0, this.uParse(value), true);\n                return {\n                    lo: dv.getInt32(0, true),\n                    hi: dv.getInt32(4, true)\n                };\n            },\n            dec (lo, hi) {\n                dv.setInt32(0, lo, true);\n                dv.setInt32(4, hi, true);\n                return dv.getBigInt64(0, true);\n            },\n            uDec (lo, hi) {\n                dv.setInt32(0, lo, true);\n                dv.setInt32(4, hi, true);\n                return dv.getBigUint64(0, true);\n            }\n        };\n    }\n    const assertInt64String = (value)=>assert(/^-?[0-9]+$/.test(value), \"int64 invalid: \".concat(value));\n    const assertUInt64String = (value)=>assert(/^[0-9]+$/.test(value), \"uint64 invalid: \".concat(value));\n    return {\n        zero: \"0\",\n        supported: false,\n        parse (value) {\n            if (typeof value != \"string\") {\n                value = value.toString();\n            }\n            assertInt64String(value);\n            return value;\n        },\n        uParse (value) {\n            if (typeof value != \"string\") {\n                value = value.toString();\n            }\n            assertUInt64String(value);\n            return value;\n        },\n        enc (value) {\n            if (typeof value != \"string\") {\n                value = value.toString();\n            }\n            assertInt64String(value);\n            return int64FromString(value);\n        },\n        uEnc (value) {\n            if (typeof value != \"string\") {\n                value = value.toString();\n            }\n            assertUInt64String(value);\n            return int64FromString(value);\n        },\n        dec (lo, hi) {\n            return int64ToString(lo, hi);\n        },\n        uDec (lo, hi) {\n            return uInt64ToString(lo, hi);\n        }\n    };\n}\nconst protoInt64 = makeInt64Support();\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable prefer-const,no-case-declarations,@typescript-eslint/restrict-plus-operands */ /**\n * Protobuf binary format wire types.\n *\n * A wire type provides just enough information to find the length of the\n * following value.\n *\n * See https://developers.google.com/protocol-buffers/docs/encoding#structure\n */ var WireType;\n(function(WireType) {\n    /**\n   * Used for int32, int64, uint32, uint64, sint32, sint64, bool, enum\n   */ WireType[WireType[\"Varint\"] = 0] = \"Varint\";\n    /**\n   * Used for fixed64, sfixed64, double.\n   * Always 8 bytes with little-endian byte order.\n   */ WireType[WireType[\"Bit64\"] = 1] = \"Bit64\";\n    /**\n   * Used for string, bytes, embedded messages, packed repeated fields\n   *\n   * Only repeated numeric types (types which use the varint, 32-bit,\n   * or 64-bit wire types) can be packed. In proto3, such fields are\n   * packed by default.\n   */ WireType[WireType[\"LengthDelimited\"] = 2] = \"LengthDelimited\";\n    /**\n   * Used for groups\n   * @deprecated\n   */ WireType[WireType[\"StartGroup\"] = 3] = \"StartGroup\";\n    /**\n   * Used for groups\n   * @deprecated\n   */ WireType[WireType[\"EndGroup\"] = 4] = \"EndGroup\";\n    /**\n   * Used for fixed32, sfixed32, float.\n   * Always 4 bytes with little-endian byte order.\n   */ WireType[WireType[\"Bit32\"] = 5] = \"Bit32\";\n})(WireType || (WireType = {}));\nclass BinaryWriter {\n    constructor(textEncoder){\n        /**\n     * Previous fork states.\n     */ this.stack = [];\n        this.textEncoder = textEncoder !== null && textEncoder !== void 0 ? textEncoder : new TextEncoder();\n        this.chunks = [];\n        this.buf = [];\n    }\n    /**\n   * Return all bytes written and reset this writer.\n   */ finish() {\n        this.chunks.push(new Uint8Array(this.buf)); // flush the buffer\n        let len = 0;\n        for(let i = 0; i < this.chunks.length; i++)len += this.chunks[i].length;\n        let bytes = new Uint8Array(len);\n        let offset = 0;\n        for(let i = 0; i < this.chunks.length; i++){\n            bytes.set(this.chunks[i], offset);\n            offset += this.chunks[i].length;\n        }\n        this.chunks = [];\n        return bytes;\n    }\n    /**\n   * Start a new fork for length-delimited data like a message\n   * or a packed repeated field.\n   *\n   * Must be joined later with `join()`.\n   */ fork() {\n        this.stack.push({\n            chunks: this.chunks,\n            buf: this.buf\n        });\n        this.chunks = [];\n        this.buf = [];\n        return this;\n    }\n    /**\n   * Join the last fork. Write its length and bytes, then\n   * return to the previous state.\n   */ join() {\n        // get chunk of fork\n        let chunk = this.finish();\n        // restore previous state\n        let prev = this.stack.pop();\n        if (!prev) throw new Error(\"invalid state, fork stack empty\");\n        this.chunks = prev.chunks;\n        this.buf = prev.buf;\n        // write length of chunk as varint\n        this.uint32(chunk.byteLength);\n        return this.raw(chunk);\n    }\n    /**\n   * Writes a tag (field number and wire type).\n   *\n   * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.\n   *\n   * Generated code should compute the tag ahead of time and call `uint32()`.\n   */ tag(fieldNo, type) {\n        return this.uint32((fieldNo << 3 | type) >>> 0);\n    }\n    /**\n   * Write a chunk of raw bytes.\n   */ raw(chunk) {\n        if (this.buf.length) {\n            this.chunks.push(new Uint8Array(this.buf));\n            this.buf = [];\n        }\n        this.chunks.push(chunk);\n        return this;\n    }\n    /**\n   * Write a `uint32` value, an unsigned 32 bit varint.\n   */ uint32(value) {\n        assertUInt32(value);\n        // write value as varint 32, inlined for speed\n        while(value > 0x7f){\n            this.buf.push(value & 0x7f | 0x80);\n            value = value >>> 7;\n        }\n        this.buf.push(value);\n        return this;\n    }\n    /**\n   * Write a `int32` value, a signed 32 bit varint.\n   */ int32(value) {\n        assertInt32(value);\n        varint32write(value, this.buf);\n        return this;\n    }\n    /**\n   * Write a `bool` value, a variant.\n   */ bool(value) {\n        this.buf.push(value ? 1 : 0);\n        return this;\n    }\n    /**\n   * Write a `bytes` value, length-delimited arbitrary data.\n   */ bytes(value) {\n        this.uint32(value.byteLength); // write length of chunk as varint\n        return this.raw(value);\n    }\n    /**\n   * Write a `string` value, length-delimited data converted to UTF-8 text.\n   */ string(value) {\n        let chunk = this.textEncoder.encode(value);\n        this.uint32(chunk.byteLength); // write length of chunk as varint\n        return this.raw(chunk);\n    }\n    /**\n   * Write a `float` value, 32-bit floating point number.\n   */ float(value) {\n        assertFloat32(value);\n        let chunk = new Uint8Array(4);\n        new DataView(chunk.buffer).setFloat32(0, value, true);\n        return this.raw(chunk);\n    }\n    /**\n   * Write a `double` value, a 64-bit floating point number.\n   */ double(value) {\n        let chunk = new Uint8Array(8);\n        new DataView(chunk.buffer).setFloat64(0, value, true);\n        return this.raw(chunk);\n    }\n    /**\n   * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.\n   */ fixed32(value) {\n        assertUInt32(value);\n        let chunk = new Uint8Array(4);\n        new DataView(chunk.buffer).setUint32(0, value, true);\n        return this.raw(chunk);\n    }\n    /**\n   * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.\n   */ sfixed32(value) {\n        assertInt32(value);\n        let chunk = new Uint8Array(4);\n        new DataView(chunk.buffer).setInt32(0, value, true);\n        return this.raw(chunk);\n    }\n    /**\n   * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.\n   */ sint32(value) {\n        assertInt32(value);\n        // zigzag encode\n        value = (value << 1 ^ value >> 31) >>> 0;\n        varint32write(value, this.buf);\n        return this;\n    }\n    /**\n   * Write a `fixed64` value, a signed, fixed-length 64-bit integer.\n   */ sfixed64(value) {\n        let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.enc(value);\n        view.setInt32(0, tc.lo, true);\n        view.setInt32(4, tc.hi, true);\n        return this.raw(chunk);\n    }\n    /**\n   * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.\n   */ fixed64(value) {\n        let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.uEnc(value);\n        view.setInt32(0, tc.lo, true);\n        view.setInt32(4, tc.hi, true);\n        return this.raw(chunk);\n    }\n    /**\n   * Write a `int64` value, a signed 64-bit varint.\n   */ int64(value) {\n        let tc = protoInt64.enc(value);\n        varint64write(tc.lo, tc.hi, this.buf);\n        return this;\n    }\n    /**\n   * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.\n   */ sint64(value) {\n        let tc = protoInt64.enc(value), // zigzag encode\n        sign = tc.hi >> 31, lo = tc.lo << 1 ^ sign, hi = (tc.hi << 1 | tc.lo >>> 31) ^ sign;\n        varint64write(lo, hi, this.buf);\n        return this;\n    }\n    /**\n   * Write a `uint64` value, an unsigned 64-bit varint.\n   */ uint64(value) {\n        let tc = protoInt64.uEnc(value);\n        varint64write(tc.lo, tc.hi, this.buf);\n        return this;\n    }\n}\nclass BinaryReader {\n    constructor(buf, textDecoder){\n        this.varint64 = varint64read; // dirty cast for `this`\n        /**\n     * Read a `uint32` field, an unsigned 32 bit varint.\n     */ this.uint32 = varint32read; // dirty cast for `this` and access to protected `buf`\n        this.buf = buf;\n        this.len = buf.length;\n        this.pos = 0;\n        this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        this.textDecoder = textDecoder !== null && textDecoder !== void 0 ? textDecoder : new TextDecoder();\n    }\n    /**\n   * Reads a tag - field number and wire type.\n   */ tag() {\n        let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;\n        if (fieldNo <= 0 || wireType < 0 || wireType > 5) throw new Error(\"illegal tag: field no \" + fieldNo + \" wire type \" + wireType);\n        return [\n            fieldNo,\n            wireType\n        ];\n    }\n    /**\n   * Skip one element on the wire and return the skipped data.\n   * Supports WireType.StartGroup since v2.0.0-alpha.23.\n   */ skip(wireType) {\n        let start = this.pos;\n        switch(wireType){\n            case WireType.Varint:\n                while(this.buf[this.pos++] & 0x80){\n                // ignore\n                }\n                break;\n            // eslint-disable-next-line\n            // @ts-ignore TS7029: Fallthrough case in switch\n            case WireType.Bit64:\n                this.pos += 4;\n            // eslint-disable-next-line\n            // @ts-ignore TS7029: Fallthrough case in switch\n            case WireType.Bit32:\n                this.pos += 4;\n                break;\n            case WireType.LengthDelimited:\n                let len = this.uint32();\n                this.pos += len;\n                break;\n            case WireType.StartGroup:\n                // From descriptor.proto: Group type is deprecated, not supported in proto3.\n                // But we must still be able to parse and treat as unknown.\n                let t;\n                while((t = this.tag()[1]) !== WireType.EndGroup){\n                    this.skip(t);\n                }\n                break;\n            default:\n                throw new Error(\"cant skip wire type \" + wireType);\n        }\n        this.assertBounds();\n        return this.buf.subarray(start, this.pos);\n    }\n    /**\n   * Throws error if position in byte array is out of range.\n   */ assertBounds() {\n        if (this.pos > this.len) throw new RangeError(\"premature EOF\");\n    }\n    /**\n   * Read a `int32` field, a signed 32 bit varint.\n   */ int32() {\n        return this.uint32() | 0;\n    }\n    /**\n   * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.\n   */ sint32() {\n        let zze = this.uint32();\n        // decode zigzag\n        return zze >>> 1 ^ -(zze & 1);\n    }\n    /**\n   * Read a `int64` field, a signed 64-bit varint.\n   */ int64() {\n        return protoInt64.dec(...this.varint64());\n    }\n    /**\n   * Read a `uint64` field, an unsigned 64-bit varint.\n   */ uint64() {\n        return protoInt64.uDec(...this.varint64());\n    }\n    /**\n   * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.\n   */ sint64() {\n        let [lo, hi] = this.varint64();\n        // decode zig zag\n        let s = -(lo & 1);\n        lo = (lo >>> 1 | (hi & 1) << 31) ^ s;\n        hi = hi >>> 1 ^ s;\n        return protoInt64.dec(lo, hi);\n    }\n    /**\n   * Read a `bool` field, a variant.\n   */ bool() {\n        let [lo, hi] = this.varint64();\n        return lo !== 0 || hi !== 0;\n    }\n    /**\n   * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.\n   */ fixed32() {\n        return this.view.getUint32((this.pos += 4) - 4, true);\n    }\n    /**\n   * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.\n   */ sfixed32() {\n        return this.view.getInt32((this.pos += 4) - 4, true);\n    }\n    /**\n   * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.\n   */ fixed64() {\n        return protoInt64.uDec(this.sfixed32(), this.sfixed32());\n    }\n    /**\n   * Read a `fixed64` field, a signed, fixed-length 64-bit integer.\n   */ sfixed64() {\n        return protoInt64.dec(this.sfixed32(), this.sfixed32());\n    }\n    /**\n   * Read a `float` field, 32-bit floating point number.\n   */ float() {\n        return this.view.getFloat32((this.pos += 4) - 4, true);\n    }\n    /**\n   * Read a `double` field, a 64-bit floating point number.\n   */ double() {\n        return this.view.getFloat64((this.pos += 8) - 8, true);\n    }\n    /**\n   * Read a `bytes` field, length-delimited arbitrary data.\n   */ bytes() {\n        let len = this.uint32(), start = this.pos;\n        this.pos += len;\n        this.assertBounds();\n        return this.buf.subarray(start, start + len);\n    }\n    /**\n   * Read a `string` field, length-delimited data converted to UTF-8 text.\n   */ string() {\n        return this.textDecoder.decode(this.bytes());\n    }\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Wrap a primitive message field value in its corresponding wrapper\n * message. This function is idempotent.\n */ function wrapField(type, value) {\n    if (value instanceof Message || !type.fieldWrapper) {\n        return value;\n    }\n    return type.fieldWrapper.wrapField(value);\n}\n({\n    \"google.protobuf.DoubleValue\": ScalarType.DOUBLE,\n    \"google.protobuf.FloatValue\": ScalarType.FLOAT,\n    \"google.protobuf.Int64Value\": ScalarType.INT64,\n    \"google.protobuf.UInt64Value\": ScalarType.UINT64,\n    \"google.protobuf.Int32Value\": ScalarType.INT32,\n    \"google.protobuf.UInt32Value\": ScalarType.UINT32,\n    \"google.protobuf.BoolValue\": ScalarType.BOOL,\n    \"google.protobuf.StringValue\": ScalarType.STRING,\n    \"google.protobuf.BytesValue\": ScalarType.BYTES\n});\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable @typescript-eslint/no-explicit-any */ /**\n * Returns true if both scalar values are equal.\n */ function scalarEquals(type, a, b) {\n    if (a === b) {\n        // This correctly matches equal values except BYTES and (possibly) 64-bit integers.\n        return true;\n    }\n    // Special case BYTES - we need to compare each byte individually\n    if (type == ScalarType.BYTES) {\n        if (!(a instanceof Uint8Array) || !(b instanceof Uint8Array)) {\n            return false;\n        }\n        if (a.length !== b.length) {\n            return false;\n        }\n        for(let i = 0; i < a.length; i++){\n            if (a[i] !== b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    // Special case 64-bit integers - we support number, string and bigint representation.\n    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\n    switch(type){\n        case ScalarType.UINT64:\n        case ScalarType.FIXED64:\n        case ScalarType.INT64:\n        case ScalarType.SFIXED64:\n        case ScalarType.SINT64:\n            // Loose comparison will match between 0n, 0 and \"0\".\n            return a == b;\n    }\n    // Anything that hasn't been caught by strict comparison or special cased\n    // BYTES and 64-bit integers is not equal.\n    return false;\n}\n/**\n * Returns the default value for the given scalar type, following\n * proto3 semantics.\n */ function scalarDefaultValue(type, longType) {\n    switch(type){\n        case ScalarType.BOOL:\n            return false;\n        case ScalarType.UINT64:\n        case ScalarType.FIXED64:\n        case ScalarType.INT64:\n        case ScalarType.SFIXED64:\n        case ScalarType.SINT64:\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison -- acceptable since it's covered by tests\n            return longType == 0 ? protoInt64.zero : \"0\";\n        case ScalarType.DOUBLE:\n        case ScalarType.FLOAT:\n            return 0.0;\n        case ScalarType.BYTES:\n            return new Uint8Array(0);\n        case ScalarType.STRING:\n            return \"\";\n        default:\n            // Handles INT32, UINT32, SINT32, FIXED32, SFIXED32.\n            // We do not use individual cases to save a few bytes code size.\n            return 0;\n    }\n}\n/**\n * Get information for writing a scalar value.\n *\n * Returns tuple:\n * [0]: appropriate WireType\n * [1]: name of the appropriate method of IBinaryWriter\n * [2]: whether the given value is a default value for proto3 semantics\n *\n * If argument `value` is omitted, [2] is always false.\n */ function scalarTypeInfo(type, value) {\n    const isUndefined = value === undefined;\n    let wireType = WireType.Varint;\n    let isIntrinsicDefault = value === 0;\n    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- INT32, UINT32, SINT32 are covered by the defaults\n    switch(type){\n        case ScalarType.STRING:\n            isIntrinsicDefault = isUndefined || !value.length;\n            wireType = WireType.LengthDelimited;\n            break;\n        case ScalarType.BOOL:\n            isIntrinsicDefault = value === false;\n            break;\n        case ScalarType.DOUBLE:\n            wireType = WireType.Bit64;\n            break;\n        case ScalarType.FLOAT:\n            wireType = WireType.Bit32;\n            break;\n        case ScalarType.INT64:\n            isIntrinsicDefault = isUndefined || value == 0; // Loose comparison matches 0n, 0 and \"0\"\n            break;\n        case ScalarType.UINT64:\n            isIntrinsicDefault = isUndefined || value == 0; // Loose comparison matches 0n, 0 and \"0\"\n            break;\n        case ScalarType.FIXED64:\n            isIntrinsicDefault = isUndefined || value == 0; // Loose comparison matches 0n, 0 and \"0\"\n            wireType = WireType.Bit64;\n            break;\n        case ScalarType.BYTES:\n            isIntrinsicDefault = isUndefined || !value.byteLength;\n            wireType = WireType.LengthDelimited;\n            break;\n        case ScalarType.FIXED32:\n            wireType = WireType.Bit32;\n            break;\n        case ScalarType.SFIXED32:\n            wireType = WireType.Bit32;\n            break;\n        case ScalarType.SFIXED64:\n            isIntrinsicDefault = isUndefined || value == 0;\n            wireType = WireType.Bit64;\n            break;\n        case ScalarType.SINT64:\n            isIntrinsicDefault = isUndefined || value == 0;\n            break;\n    }\n    const method = ScalarType[type].toLowerCase();\n    return [\n        wireType,\n        method,\n        isUndefined || isIntrinsicDefault\n    ];\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unnecessary-condition, no-case-declarations, prefer-const */ const unknownFieldsSymbol = Symbol(\"@bufbuild/protobuf/unknown-fields\");\n// Default options for parsing binary data.\nconst readDefaults = {\n    readUnknownFields: true,\n    readerFactory: (bytes)=>new BinaryReader(bytes)\n};\n// Default options for serializing binary data.\nconst writeDefaults = {\n    writeUnknownFields: true,\n    writerFactory: ()=>new BinaryWriter()\n};\nfunction makeReadOptions$1(options) {\n    return options ? Object.assign(Object.assign({}, readDefaults), options) : readDefaults;\n}\nfunction makeWriteOptions$1(options) {\n    return options ? Object.assign(Object.assign({}, writeDefaults), options) : writeDefaults;\n}\nfunction makeBinaryFormatCommon() {\n    return {\n        makeReadOptions: makeReadOptions$1,\n        makeWriteOptions: makeWriteOptions$1,\n        listUnknownFields (message) {\n            var _a;\n            return (_a = message[unknownFieldsSymbol]) !== null && _a !== void 0 ? _a : [];\n        },\n        discardUnknownFields (message) {\n            delete message[unknownFieldsSymbol];\n        },\n        writeUnknownFields (message, writer) {\n            const m = message;\n            const c = m[unknownFieldsSymbol];\n            if (c) {\n                for (const f of c){\n                    writer.tag(f.no, f.wireType).raw(f.data);\n                }\n            }\n        },\n        onUnknownField (message, no, wireType, data) {\n            const m = message;\n            if (!Array.isArray(m[unknownFieldsSymbol])) {\n                m[unknownFieldsSymbol] = [];\n            }\n            m[unknownFieldsSymbol].push({\n                no,\n                wireType,\n                data\n            });\n        },\n        readMessage (message, reader, length, options) {\n            const type = message.getType();\n            const end = length === undefined ? reader.len : reader.pos + length;\n            while(reader.pos < end){\n                const [fieldNo, wireType] = reader.tag(), field = type.fields.find(fieldNo);\n                if (!field) {\n                    const data = reader.skip(wireType);\n                    if (options.readUnknownFields) {\n                        this.onUnknownField(message, fieldNo, wireType, data);\n                    }\n                    continue;\n                }\n                let target = message, repeated = field.repeated, localName = field.localName;\n                if (field.oneof) {\n                    target = target[field.oneof.localName];\n                    if (target.case != localName) {\n                        delete target.value;\n                    }\n                    target.case = localName;\n                    localName = \"value\";\n                }\n                switch(field.kind){\n                    case \"scalar\":\n                    case \"enum\":\n                        const scalarType = field.kind == \"enum\" ? ScalarType.INT32 : field.T;\n                        let read = readScalar$1;\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison -- acceptable since it's covered by tests\n                        if (field.kind == \"scalar\" && field.L > 0) {\n                            read = readScalarLTString;\n                        }\n                        if (repeated) {\n                            let arr = target[localName]; // safe to assume presence of array, oneof cannot contain repeated values\n                            if (wireType == WireType.LengthDelimited && scalarType != ScalarType.STRING && scalarType != ScalarType.BYTES) {\n                                let e = reader.uint32() + reader.pos;\n                                while(reader.pos < e){\n                                    arr.push(read(reader, scalarType));\n                                }\n                            } else {\n                                arr.push(read(reader, scalarType));\n                            }\n                        } else {\n                            target[localName] = read(reader, scalarType);\n                        }\n                        break;\n                    case \"message\":\n                        const messageType = field.T;\n                        if (repeated) {\n                            // safe to assume presence of array, oneof cannot contain repeated values\n                            target[localName].push(readMessageField(reader, new messageType(), options));\n                        } else {\n                            if (target[localName] instanceof Message) {\n                                readMessageField(reader, target[localName], options);\n                            } else {\n                                target[localName] = readMessageField(reader, new messageType(), options);\n                                if (messageType.fieldWrapper && !field.oneof && !field.repeated) {\n                                    target[localName] = messageType.fieldWrapper.unwrapField(target[localName]);\n                                }\n                            }\n                        }\n                        break;\n                    case \"map\":\n                        let [mapKey, mapVal] = readMapEntry(field, reader, options);\n                        // safe to assume presence of map object, oneof cannot contain repeated values\n                        target[localName][mapKey] = mapVal;\n                        break;\n                }\n            }\n        }\n    };\n}\n// Read a message, avoiding MessageType.fromBinary() to re-use the\n// BinaryReadOptions and the IBinaryReader.\nfunction readMessageField(reader, message, options) {\n    const format = message.getType().runtime.bin;\n    format.readMessage(message, reader, reader.uint32(), options);\n    return message;\n}\n// Read a map field, expecting key field = 1, value field = 2\nfunction readMapEntry(field, reader, options) {\n    const length = reader.uint32(), end = reader.pos + length;\n    let key, val;\n    while(reader.pos < end){\n        let [fieldNo] = reader.tag();\n        switch(fieldNo){\n            case 1:\n                key = readScalar$1(reader, field.K);\n                break;\n            case 2:\n                switch(field.V.kind){\n                    case \"scalar\":\n                        val = readScalar$1(reader, field.V.T);\n                        break;\n                    case \"enum\":\n                        val = reader.int32();\n                        break;\n                    case \"message\":\n                        val = readMessageField(reader, new field.V.T(), options);\n                        break;\n                }\n                break;\n        }\n    }\n    if (key === undefined) {\n        let keyRaw = scalarDefaultValue(field.K, LongType.BIGINT);\n        key = field.K == ScalarType.BOOL ? keyRaw.toString() : keyRaw;\n    }\n    if (typeof key != \"string\" && typeof key != \"number\") {\n        key = key.toString();\n    }\n    if (val === undefined) {\n        switch(field.V.kind){\n            case \"scalar\":\n                val = scalarDefaultValue(field.V.T, LongType.BIGINT);\n                break;\n            case \"enum\":\n                val = 0;\n                break;\n            case \"message\":\n                val = new field.V.T();\n                break;\n        }\n    }\n    return [\n        key,\n        val\n    ];\n}\n// Read a scalar value, but return 64 bit integral types (int64, uint64,\n// sint64, fixed64, sfixed64) as string instead of bigint.\nfunction readScalarLTString(reader, type) {\n    const v = readScalar$1(reader, type);\n    return typeof v == \"bigint\" ? v.toString() : v;\n}\n// Does not use scalarTypeInfo() for better performance.\nfunction readScalar$1(reader, type) {\n    switch(type){\n        case ScalarType.STRING:\n            return reader.string();\n        case ScalarType.BOOL:\n            return reader.bool();\n        case ScalarType.DOUBLE:\n            return reader.double();\n        case ScalarType.FLOAT:\n            return reader.float();\n        case ScalarType.INT32:\n            return reader.int32();\n        case ScalarType.INT64:\n            return reader.int64();\n        case ScalarType.UINT64:\n            return reader.uint64();\n        case ScalarType.FIXED64:\n            return reader.fixed64();\n        case ScalarType.BYTES:\n            return reader.bytes();\n        case ScalarType.FIXED32:\n            return reader.fixed32();\n        case ScalarType.SFIXED32:\n            return reader.sfixed32();\n        case ScalarType.SFIXED64:\n            return reader.sfixed64();\n        case ScalarType.SINT64:\n            return reader.sint64();\n        case ScalarType.UINT32:\n            return reader.uint32();\n        case ScalarType.SINT32:\n            return reader.sint32();\n    }\n}\nfunction writeMapEntry(writer, options, field, key, value) {\n    writer.tag(field.no, WireType.LengthDelimited);\n    writer.fork();\n    // javascript only allows number or string for object properties\n    // we convert from our representation to the protobuf type\n    let keyValue = key;\n    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- we deliberately handle just the special cases for map keys\n    switch(field.K){\n        case ScalarType.INT32:\n        case ScalarType.FIXED32:\n        case ScalarType.UINT32:\n        case ScalarType.SFIXED32:\n        case ScalarType.SINT32:\n            keyValue = Number.parseInt(key);\n            break;\n        case ScalarType.BOOL:\n            assert(key == \"true\" || key == \"false\");\n            keyValue = key == \"true\";\n            break;\n    }\n    // write key, expecting key field number = 1\n    writeScalar$1(writer, field.K, 1, keyValue, true);\n    // write value, expecting value field number = 2\n    switch(field.V.kind){\n        case \"scalar\":\n            writeScalar$1(writer, field.V.T, 2, value, true);\n            break;\n        case \"enum\":\n            writeScalar$1(writer, ScalarType.INT32, 2, value, true);\n            break;\n        case \"message\":\n            writeMessageField(writer, options, field.V.T, 2, value);\n            break;\n    }\n    writer.join();\n}\nfunction writeMessageField(writer, options, type, fieldNo, value) {\n    if (value !== undefined) {\n        const message = wrapField(type, value);\n        writer.tag(fieldNo, WireType.LengthDelimited).bytes(message.toBinary(options));\n    }\n}\nfunction writeScalar$1(writer, type, fieldNo, value, emitIntrinsicDefault) {\n    let [wireType, method, isIntrinsicDefault] = scalarTypeInfo(type, value);\n    if (!isIntrinsicDefault || emitIntrinsicDefault) {\n        writer.tag(fieldNo, wireType)[method](value);\n    }\n}\nfunction writePacked(writer, type, fieldNo, value) {\n    if (!value.length) {\n        return;\n    }\n    writer.tag(fieldNo, WireType.LengthDelimited).fork();\n    let [, method] = scalarTypeInfo(type);\n    for(let i = 0; i < value.length; i++){\n        writer[method](value[i]);\n    }\n    writer.join();\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unnecessary-condition, @typescript-eslint/strict-boolean-expressions, prefer-const, no-case-declarations */ function makeBinaryFormatProto3() {\n    return Object.assign(Object.assign({}, makeBinaryFormatCommon()), {\n        writeMessage (message, writer, options) {\n            const type = message.getType();\n            for (const field of type.fields.byNumber()){\n                let value, // this will be our field value, whether it is member of a oneof or regular field\n                repeated = field.repeated, localName = field.localName;\n                if (field.oneof) {\n                    const oneof = message[field.oneof.localName];\n                    if (oneof.case !== localName) {\n                        continue; // field is not selected, skip\n                    }\n                    value = oneof.value;\n                } else {\n                    value = message[localName];\n                }\n                switch(field.kind){\n                    case \"scalar\":\n                    case \"enum\":\n                        let scalarType = field.kind == \"enum\" ? ScalarType.INT32 : field.T;\n                        if (repeated) {\n                            if (field.packed) {\n                                writePacked(writer, scalarType, field.no, value);\n                            } else {\n                                for (const item of value){\n                                    writeScalar$1(writer, scalarType, field.no, item, true);\n                                }\n                            }\n                        } else {\n                            if (value !== undefined) {\n                                writeScalar$1(writer, scalarType, field.no, value, !!field.oneof || field.opt);\n                            }\n                        }\n                        break;\n                    case \"message\":\n                        if (repeated) {\n                            for (const item of value){\n                                writeMessageField(writer, options, field.T, field.no, item);\n                            }\n                        } else {\n                            writeMessageField(writer, options, field.T, field.no, value);\n                        }\n                        break;\n                    case \"map\":\n                        for (const [key, val] of Object.entries(value)){\n                            writeMapEntry(writer, options, field, key, val);\n                        }\n                        break;\n                }\n            }\n            if (options.writeUnknownFields) {\n                this.writeUnknownFields(message, writer);\n            }\n            return writer;\n        }\n    });\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable @typescript-eslint/ban-ts-comment, @typescript-eslint/no-unnecessary-condition, prefer-const */ // lookup table from base64 character to byte\nlet encTable = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".split(\"\");\n// lookup table from base64 character *code* to byte because lookup by number is fast\nlet decTable = [];\nfor(let i = 0; i < encTable.length; i++)decTable[encTable[i].charCodeAt(0)] = i;\n// support base64url variants\ndecTable[\"-\".charCodeAt(0)] = encTable.indexOf(\"+\");\ndecTable[\"_\".charCodeAt(0)] = encTable.indexOf(\"/\");\nconst protoBase64 = {\n    /**\n   * Decodes a base64 string to a byte array.\n   *\n   * - ignores white-space, including line breaks and tabs\n   * - allows inner padding (can decode concatenated base64 strings)\n   * - does not require padding\n   * - understands base64url encoding:\n   *   \"-\" instead of \"+\",\n   *   \"_\" instead of \"/\",\n   *   no padding\n   */ dec (base64Str) {\n        // estimate byte size, not accounting for inner padding and whitespace\n        let es = base64Str.length * 3 / 4;\n        if (base64Str[base64Str.length - 2] == \"=\") es -= 2;\n        else if (base64Str[base64Str.length - 1] == \"=\") es -= 1;\n        let bytes = new Uint8Array(es), bytePos = 0, // position in byte array\n        groupPos = 0, // position in base64 group\n        b, // current byte\n        p = 0; // previous byte\n        for(let i = 0; i < base64Str.length; i++){\n            b = decTable[base64Str.charCodeAt(i)];\n            if (b === undefined) {\n                switch(base64Str[i]){\n                    // @ts-ignore TS7029: Fallthrough case in switch\n                    case \"=\":\n                        groupPos = 0;\n                    // reset state when padding found\n                    // @ts-ignore TS7029: Fallthrough case in switch\n                    case \"\\n\":\n                    case \"\\r\":\n                    case \"\\t\":\n                    case \" \":\n                        continue;\n                    // skip white-space, and padding\n                    default:\n                        throw Error(\"invalid base64 string.\");\n                }\n            }\n            switch(groupPos){\n                case 0:\n                    p = b;\n                    groupPos = 1;\n                    break;\n                case 1:\n                    bytes[bytePos++] = p << 2 | (b & 48) >> 4;\n                    p = b;\n                    groupPos = 2;\n                    break;\n                case 2:\n                    bytes[bytePos++] = (p & 15) << 4 | (b & 60) >> 2;\n                    p = b;\n                    groupPos = 3;\n                    break;\n                case 3:\n                    bytes[bytePos++] = (p & 3) << 6 | b;\n                    groupPos = 0;\n                    break;\n            }\n        }\n        if (groupPos == 1) throw Error(\"invalid base64 string.\");\n        return bytes.subarray(0, bytePos);\n    },\n    /**\n   * Encode a byte array to a base64 string.\n   */ enc (bytes) {\n        let base64 = \"\", groupPos = 0, // position in base64 group\n        b, // current byte\n        p = 0; // carry over from previous byte\n        for(let i = 0; i < bytes.length; i++){\n            b = bytes[i];\n            switch(groupPos){\n                case 0:\n                    base64 += encTable[b >> 2];\n                    p = (b & 3) << 4;\n                    groupPos = 1;\n                    break;\n                case 1:\n                    base64 += encTable[p | b >> 4];\n                    p = (b & 15) << 2;\n                    groupPos = 2;\n                    break;\n                case 2:\n                    base64 += encTable[p | b >> 6];\n                    base64 += encTable[b & 63];\n                    groupPos = 0;\n                    break;\n            }\n        }\n        // add output padding\n        if (groupPos) {\n            base64 += encTable[p];\n            base64 += \"=\";\n            if (groupPos == 1) base64 += \"=\";\n        }\n        return base64;\n    }\n};\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable no-case-declarations, @typescript-eslint/restrict-plus-operands,@typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-call,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-argument */ // Default options for parsing JSON.\nconst jsonReadDefaults = {\n    ignoreUnknownFields: false\n};\n// Default options for serializing to JSON.\nconst jsonWriteDefaults = {\n    emitDefaultValues: false,\n    enumAsInteger: false,\n    useProtoFieldName: false,\n    prettySpaces: 0\n};\nfunction makeReadOptions(options) {\n    return options ? Object.assign(Object.assign({}, jsonReadDefaults), options) : jsonReadDefaults;\n}\nfunction makeWriteOptions(options) {\n    return options ? Object.assign(Object.assign({}, jsonWriteDefaults), options) : jsonWriteDefaults;\n}\nfunction makeJsonFormatCommon(makeWriteField) {\n    const writeField = makeWriteField(writeEnum, writeScalar);\n    return {\n        makeReadOptions,\n        makeWriteOptions,\n        readMessage (type, json, options, message) {\n            if (json == null || Array.isArray(json) || typeof json != \"object\") {\n                throw new Error(\"cannot decode message \".concat(type.typeName, \" from JSON: \").concat(this.debug(json)));\n            }\n            message = message !== null && message !== void 0 ? message : new type();\n            const oneofSeen = {};\n            for (const [jsonKey, jsonValue] of Object.entries(json)){\n                const field = type.fields.findJsonName(jsonKey);\n                if (!field) {\n                    if (!options.ignoreUnknownFields) {\n                        throw new Error(\"cannot decode message \".concat(type.typeName, \" from JSON: key \\\"\").concat(jsonKey, \"\\\" is unknown\"));\n                    }\n                    continue;\n                }\n                let localName = field.localName;\n                let target = message;\n                if (field.oneof) {\n                    if (jsonValue === null && field.kind == \"scalar\") {\n                        continue;\n                    }\n                    const seen = oneofSeen[field.oneof.localName];\n                    if (seen) {\n                        throw new Error(\"cannot decode message \".concat(type.typeName, \" from JSON: multiple keys for oneof \\\"\").concat(field.oneof.name, \"\\\" present: \\\"\").concat(seen, \"\\\", \\\"\").concat(jsonKey, \"\\\"\"));\n                    }\n                    oneofSeen[field.oneof.localName] = jsonKey;\n                    target = target[field.oneof.localName] = {\n                        case: localName\n                    };\n                    localName = \"value\";\n                }\n                if (field.repeated) {\n                    if (jsonValue === null) {\n                        continue;\n                    }\n                    if (!Array.isArray(jsonValue)) {\n                        throw new Error(\"cannot decode field \".concat(type.typeName, \".\").concat(field.name, \" from JSON: \").concat(this.debug(jsonValue)));\n                    }\n                    const targetArray = target[localName];\n                    for (const jsonItem of jsonValue){\n                        if (jsonItem === null) {\n                            throw new Error(\"cannot decode field \".concat(type.typeName, \".\").concat(field.name, \" from JSON: \").concat(this.debug(jsonItem)));\n                        }\n                        let val;\n                        // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- \"map\" is invalid for repeated fields\n                        switch(field.kind){\n                            case \"message\":\n                                val = field.T.fromJson(jsonItem, options);\n                                break;\n                            case \"enum\":\n                                val = readEnum(field.T, jsonItem, options.ignoreUnknownFields);\n                                if (val === undefined) continue;\n                                break;\n                            case \"scalar\":\n                                try {\n                                    val = readScalar(field.T, jsonItem, field.L);\n                                } catch (e) {\n                                    let m = \"cannot decode field \".concat(type.typeName, \".\").concat(field.name, \" from JSON: \").concat(this.debug(jsonItem));\n                                    if (e instanceof Error && e.message.length > 0) {\n                                        m += \": \".concat(e.message);\n                                    }\n                                    throw new Error(m);\n                                }\n                                break;\n                        }\n                        targetArray.push(val);\n                    }\n                } else if (field.kind == \"map\") {\n                    if (jsonValue === null) {\n                        continue;\n                    }\n                    if (Array.isArray(jsonValue) || typeof jsonValue != \"object\") {\n                        throw new Error(\"cannot decode field \".concat(type.typeName, \".\").concat(field.name, \" from JSON: \").concat(this.debug(jsonValue)));\n                    }\n                    const targetMap = target[localName];\n                    for (const [jsonMapKey, jsonMapValue] of Object.entries(jsonValue)){\n                        if (jsonMapValue === null) {\n                            throw new Error(\"cannot decode field \".concat(type.typeName, \".\").concat(field.name, \" from JSON: map value null\"));\n                        }\n                        let val;\n                        switch(field.V.kind){\n                            case \"message\":\n                                val = field.V.T.fromJson(jsonMapValue, options);\n                                break;\n                            case \"enum\":\n                                val = readEnum(field.V.T, jsonMapValue, options.ignoreUnknownFields);\n                                if (val === undefined) continue;\n                                break;\n                            case \"scalar\":\n                                try {\n                                    val = readScalar(field.V.T, jsonMapValue, LongType.BIGINT);\n                                } catch (e) {\n                                    let m = \"cannot decode map value for field \".concat(type.typeName, \".\").concat(field.name, \" from JSON: \").concat(this.debug(jsonValue));\n                                    if (e instanceof Error && e.message.length > 0) {\n                                        m += \": \".concat(e.message);\n                                    }\n                                    throw new Error(m);\n                                }\n                                break;\n                        }\n                        try {\n                            targetMap[readScalar(field.K, field.K == ScalarType.BOOL ? jsonMapKey == \"true\" ? true : jsonMapKey == \"false\" ? false : jsonMapKey : jsonMapKey, LongType.BIGINT).toString()] = val;\n                        } catch (e) {\n                            let m = \"cannot decode map key for field \".concat(type.typeName, \".\").concat(field.name, \" from JSON: \").concat(this.debug(jsonValue));\n                            if (e instanceof Error && e.message.length > 0) {\n                                m += \": \".concat(e.message);\n                            }\n                            throw new Error(m);\n                        }\n                    }\n                } else {\n                    switch(field.kind){\n                        case \"message\":\n                            const messageType = field.T;\n                            if (jsonValue === null && messageType.typeName != \"google.protobuf.Value\") {\n                                if (field.oneof) {\n                                    throw new Error(\"cannot decode field \".concat(type.typeName, \".\").concat(field.name, \" from JSON: null is invalid for oneof field \\\"\").concat(jsonKey, \"\\\"\"));\n                                }\n                                continue;\n                            }\n                            if (target[localName] instanceof Message) {\n                                target[localName].fromJson(jsonValue, options);\n                            } else {\n                                target[localName] = messageType.fromJson(jsonValue, options);\n                                if (messageType.fieldWrapper && !field.oneof) {\n                                    target[localName] = messageType.fieldWrapper.unwrapField(target[localName]);\n                                }\n                            }\n                            break;\n                        case \"enum\":\n                            const enumValue = readEnum(field.T, jsonValue, options.ignoreUnknownFields);\n                            if (enumValue !== undefined) {\n                                target[localName] = enumValue;\n                            }\n                            break;\n                        case \"scalar\":\n                            try {\n                                target[localName] = readScalar(field.T, jsonValue, field.L);\n                            } catch (e) {\n                                let m = \"cannot decode field \".concat(type.typeName, \".\").concat(field.name, \" from JSON: \").concat(this.debug(jsonValue));\n                                if (e instanceof Error && e.message.length > 0) {\n                                    m += \": \".concat(e.message);\n                                }\n                                throw new Error(m);\n                            }\n                            break;\n                    }\n                }\n            }\n            return message;\n        },\n        writeMessage (message, options) {\n            const type = message.getType();\n            const json = {};\n            let field;\n            try {\n                for (const member of type.fields.byMember()){\n                    let jsonValue;\n                    if (member.kind == \"oneof\") {\n                        const oneof = message[member.localName];\n                        if (oneof.value === undefined) {\n                            continue;\n                        }\n                        field = member.findField(oneof.case);\n                        if (!field) {\n                            throw \"oneof case not found: \" + oneof.case;\n                        }\n                        jsonValue = writeField(field, oneof.value, options);\n                    } else {\n                        field = member;\n                        jsonValue = writeField(field, message[field.localName], options);\n                    }\n                    if (jsonValue !== undefined) {\n                        json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;\n                    }\n                }\n            } catch (e) {\n                const m = field ? \"cannot encode field \".concat(type.typeName, \".\").concat(field.name, \" to JSON\") : \"cannot encode message \".concat(type.typeName, \" to JSON\");\n                const r = e instanceof Error ? e.message : String(e);\n                throw new Error(m + (r.length > 0 ? \": \".concat(r) : \"\"));\n            }\n            return json;\n        },\n        readScalar,\n        writeScalar,\n        debug: debugJsonValue\n    };\n}\nfunction debugJsonValue(json) {\n    if (json === null) {\n        return \"null\";\n    }\n    switch(typeof json){\n        case \"object\":\n            return Array.isArray(json) ? \"array\" : \"object\";\n        case \"string\":\n            return json.length > 100 ? \"string\" : \"\\\"\".concat(json.split('\"').join('\\\\\"'), \"\\\"\");\n        default:\n            return String(json);\n    }\n}\n// May throw an error. If the error message is non-blank, it should be shown.\n// It is up to the caller to provide context.\nfunction readScalar(type, json, longType) {\n    // every valid case in the switch below returns, and every fall\n    // through is regarded as a failure.\n    switch(type){\n        // float, double: JSON value will be a number or one of the special string values \"NaN\", \"Infinity\", and \"-Infinity\".\n        // Either numbers or strings are accepted. Exponent notation is also accepted.\n        case ScalarType.DOUBLE:\n        case ScalarType.FLOAT:\n            if (json === null) return 0.0;\n            if (json === \"NaN\") return Number.NaN;\n            if (json === \"Infinity\") return Number.POSITIVE_INFINITY;\n            if (json === \"-Infinity\") return Number.NEGATIVE_INFINITY;\n            if (json === \"\") {\n                break;\n            }\n            if (typeof json == \"string\" && json.trim().length !== json.length) {\n                break;\n            }\n            if (typeof json != \"string\" && typeof json != \"number\") {\n                break;\n            }\n            const float = Number(json);\n            if (Number.isNaN(float)) {\n                break;\n            }\n            if (!Number.isFinite(float)) {\n                break;\n            }\n            if (type == ScalarType.FLOAT) assertFloat32(float);\n            return float;\n        // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.\n        case ScalarType.INT32:\n        case ScalarType.FIXED32:\n        case ScalarType.SFIXED32:\n        case ScalarType.SINT32:\n        case ScalarType.UINT32:\n            if (json === null) return 0;\n            let int32;\n            if (typeof json == \"number\") int32 = json;\n            else if (typeof json == \"string\" && json.length > 0) {\n                if (json.trim().length === json.length) int32 = Number(json);\n            }\n            if (int32 === undefined) break;\n            if (type == ScalarType.UINT32) assertUInt32(int32);\n            else assertInt32(int32);\n            return int32;\n        // int64, fixed64, uint64: JSON value will be a decimal string. Either numbers or strings are accepted.\n        case ScalarType.INT64:\n        case ScalarType.SFIXED64:\n        case ScalarType.SINT64:\n            if (json === null) return protoInt64.zero;\n            if (typeof json != \"number\" && typeof json != \"string\") break;\n            const long = protoInt64.parse(json);\n            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n            return longType ? long.toString() : long;\n        case ScalarType.FIXED64:\n        case ScalarType.UINT64:\n            if (json === null) return protoInt64.zero;\n            if (typeof json != \"number\" && typeof json != \"string\") break;\n            const uLong = protoInt64.uParse(json);\n            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n            return longType ? uLong.toString() : uLong;\n        // bool:\n        case ScalarType.BOOL:\n            if (json === null) return false;\n            if (typeof json !== \"boolean\") break;\n            return json;\n        // string:\n        case ScalarType.STRING:\n            if (json === null) return \"\";\n            if (typeof json !== \"string\") {\n                break;\n            }\n            // A string must always contain UTF-8 encoded or 7-bit ASCII.\n            // We validate with encodeURIComponent, which appears to be the fastest widely available option.\n            try {\n                encodeURIComponent(json);\n            } catch (e) {\n                throw new Error(\"invalid UTF8\");\n            }\n            return json;\n        // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.\n        // Either standard or URL-safe base64 encoding with/without paddings are accepted.\n        case ScalarType.BYTES:\n            if (json === null || json === \"\") return new Uint8Array(0);\n            if (typeof json !== \"string\") break;\n            return protoBase64.dec(json);\n    }\n    throw new Error();\n}\nfunction readEnum(type, json, ignoreUnknownFields) {\n    if (json === null) {\n        // proto3 requires 0 to be default value for all enums\n        return 0;\n    }\n    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\n    switch(typeof json){\n        case \"number\":\n            if (Number.isInteger(json)) {\n                return json;\n            }\n            break;\n        case \"string\":\n            const value = type.findName(json);\n            // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n            if (value || ignoreUnknownFields) {\n                return value === null || value === void 0 ? void 0 : value.no;\n            }\n            break;\n    }\n    throw new Error(\"cannot decode enum \".concat(type.typeName, \" from JSON: \").concat(debugJsonValue(json)));\n}\nfunction writeEnum(type, value, emitIntrinsicDefault, enumAsInteger) {\n    var _a;\n    if (value === undefined) {\n        return value;\n    }\n    if (value === 0 && !emitIntrinsicDefault) {\n        // proto3 requires 0 to be default value for all enums\n        return undefined;\n    }\n    if (enumAsInteger) {\n        return value;\n    }\n    if (type.typeName == \"google.protobuf.NullValue\") {\n        return null;\n    }\n    const val = type.findNumber(value);\n    return (_a = val === null || val === void 0 ? void 0 : val.name) !== null && _a !== void 0 ? _a : value; // if we don't know the enum value, just return the number\n}\nfunction writeScalar(type, value, emitIntrinsicDefault) {\n    if (value === undefined) {\n        return undefined;\n    }\n    switch(type){\n        // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.\n        case ScalarType.INT32:\n        case ScalarType.SFIXED32:\n        case ScalarType.SINT32:\n        case ScalarType.FIXED32:\n        case ScalarType.UINT32:\n            assert(typeof value == \"number\");\n            return value != 0 || emitIntrinsicDefault ? value : undefined;\n        // float, double: JSON value will be a number or one of the special string values \"NaN\", \"Infinity\", and \"-Infinity\".\n        // Either numbers or strings are accepted. Exponent notation is also accepted.\n        case ScalarType.FLOAT:\n        // assertFloat32(value);\n        case ScalarType.DOUBLE:\n            // eslint-disable-line no-fallthrough\n            assert(typeof value == \"number\");\n            if (Number.isNaN(value)) return \"NaN\";\n            if (value === Number.POSITIVE_INFINITY) return \"Infinity\";\n            if (value === Number.NEGATIVE_INFINITY) return \"-Infinity\";\n            return value !== 0 || emitIntrinsicDefault ? value : undefined;\n        // string:\n        case ScalarType.STRING:\n            assert(typeof value == \"string\");\n            return value.length > 0 || emitIntrinsicDefault ? value : undefined;\n        // bool:\n        case ScalarType.BOOL:\n            assert(typeof value == \"boolean\");\n            return value || emitIntrinsicDefault ? value : undefined;\n        // JSON value will be a decimal string. Either numbers or strings are accepted.\n        case ScalarType.UINT64:\n        case ScalarType.FIXED64:\n        case ScalarType.INT64:\n        case ScalarType.SFIXED64:\n        case ScalarType.SINT64:\n            assert(typeof value == \"bigint\" || typeof value == \"string\" || typeof value == \"number\");\n            // We use implicit conversion with `value != 0` to catch both 0n and \"0\"\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            return emitIntrinsicDefault || value != 0 ? value.toString(10) : undefined;\n        // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.\n        // Either standard or URL-safe base64 encoding with/without paddings are accepted.\n        case ScalarType.BYTES:\n            assert(value instanceof Uint8Array);\n            return emitIntrinsicDefault || value.byteLength > 0 ? protoBase64.enc(value) : undefined;\n    }\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable no-case-declarations, @typescript-eslint/restrict-plus-operands,@typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-call,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-argument */ function makeJsonFormatProto3() {\n    return makeJsonFormatCommon((writeEnum, writeScalar)=>{\n        return function writeField(field, value, options) {\n            if (field.kind == \"map\") {\n                const jsonObj = {};\n                switch(field.V.kind){\n                    case \"scalar\":\n                        for (const [entryKey, entryValue] of Object.entries(value)){\n                            const val = writeScalar(field.V.T, entryValue, true);\n                            assert(val !== undefined);\n                            jsonObj[entryKey.toString()] = val; // JSON standard allows only (double quoted) string as property key\n                        }\n                        break;\n                    case \"message\":\n                        for (const [entryKey, entryValue] of Object.entries(value)){\n                            // JSON standard allows only (double quoted) string as property key\n                            jsonObj[entryKey.toString()] = entryValue.toJson(options);\n                        }\n                        break;\n                    case \"enum\":\n                        const enumType = field.V.T;\n                        for (const [entryKey, entryValue] of Object.entries(value)){\n                            assert(entryValue === undefined || typeof entryValue == \"number\");\n                            const val = writeEnum(enumType, entryValue, true, options.enumAsInteger);\n                            assert(val !== undefined);\n                            jsonObj[entryKey.toString()] = val; // JSON standard allows only (double quoted) string as property key\n                        }\n                        break;\n                }\n                return options.emitDefaultValues || Object.keys(jsonObj).length > 0 ? jsonObj : undefined;\n            } else if (field.repeated) {\n                const jsonArr = [];\n                switch(field.kind){\n                    case \"scalar\":\n                        for(let i = 0; i < value.length; i++){\n                            jsonArr.push(writeScalar(field.T, value[i], true));\n                        }\n                        break;\n                    case \"enum\":\n                        for(let i = 0; i < value.length; i++){\n                            jsonArr.push(writeEnum(field.T, value[i], true, options.enumAsInteger));\n                        }\n                        break;\n                    case \"message\":\n                        for(let i = 0; i < value.length; i++){\n                            jsonArr.push(wrapField(field.T, value[i]).toJson(options));\n                        }\n                        break;\n                }\n                return options.emitDefaultValues || jsonArr.length > 0 ? jsonArr : undefined;\n            } else {\n                switch(field.kind){\n                    case \"scalar\":\n                        return writeScalar(field.T, value, !!field.oneof || field.opt || options.emitDefaultValues);\n                    case \"enum\":\n                        return writeEnum(field.T, value, !!field.oneof || field.opt || options.emitDefaultValues, options.enumAsInteger);\n                    case \"message\":\n                        return value !== undefined ? wrapField(field.T, value).toJson(options) : undefined;\n                }\n            }\n        };\n    });\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable @typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-argument,no-case-declarations */ function makeUtilCommon() {\n    return {\n        setEnumType,\n        initPartial (source, target) {\n            if (source === undefined) {\n                return;\n            }\n            const type = target.getType();\n            for (const member of type.fields.byMember()){\n                const localName = member.localName, t = target, s = source;\n                if (s[localName] === undefined) {\n                    continue;\n                }\n                switch(member.kind){\n                    case \"oneof\":\n                        const sk = s[localName].case;\n                        if (sk === undefined) {\n                            continue;\n                        }\n                        const sourceField = member.findField(sk);\n                        let val = s[localName].value;\n                        if (sourceField && sourceField.kind == \"message\" && !(val instanceof sourceField.T)) {\n                            val = new sourceField.T(val);\n                        } else if (sourceField && sourceField.kind === \"scalar\" && sourceField.T === ScalarType.BYTES) {\n                            val = toU8Arr(val);\n                        }\n                        t[localName] = {\n                            case: sk,\n                            value: val\n                        };\n                        break;\n                    case \"scalar\":\n                    case \"enum\":\n                        let copy = s[localName];\n                        if (member.T === ScalarType.BYTES) {\n                            copy = member.repeated ? copy.map(toU8Arr) : toU8Arr(copy);\n                        }\n                        t[localName] = copy;\n                        break;\n                    case \"map\":\n                        switch(member.V.kind){\n                            case \"scalar\":\n                            case \"enum\":\n                                if (member.V.T === ScalarType.BYTES) {\n                                    for (const [k, v] of Object.entries(s[localName])){\n                                        t[localName][k] = toU8Arr(v);\n                                    }\n                                } else {\n                                    Object.assign(t[localName], s[localName]);\n                                }\n                                break;\n                            case \"message\":\n                                const messageType = member.V.T;\n                                for (const k of Object.keys(s[localName])){\n                                    let val = s[localName][k];\n                                    if (!messageType.fieldWrapper) {\n                                        // We only take partial input for messages that are not a wrapper type.\n                                        // For those messages, we recursively normalize the partial input.\n                                        val = new messageType(val);\n                                    }\n                                    t[localName][k] = val;\n                                }\n                                break;\n                        }\n                        break;\n                    case \"message\":\n                        const mt = member.T;\n                        if (member.repeated) {\n                            t[localName] = s[localName].map((val)=>val instanceof mt ? val : new mt(val));\n                        } else if (s[localName] !== undefined) {\n                            const val = s[localName];\n                            if (mt.fieldWrapper) {\n                                if (// We can't use BytesValue.typeName as that will create a circular import\n                                mt.typeName === \"google.protobuf.BytesValue\") {\n                                    t[localName] = toU8Arr(val);\n                                } else {\n                                    t[localName] = val;\n                                }\n                            } else {\n                                t[localName] = val instanceof mt ? val : new mt(val);\n                            }\n                        }\n                        break;\n                }\n            }\n        },\n        equals (type, a, b) {\n            if (a === b) {\n                return true;\n            }\n            if (!a || !b) {\n                return false;\n            }\n            return type.fields.byMember().every((m)=>{\n                const va = a[m.localName];\n                const vb = b[m.localName];\n                if (m.repeated) {\n                    if (va.length !== vb.length) {\n                        return false;\n                    }\n                    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- repeated fields are never \"map\"\n                    switch(m.kind){\n                        case \"message\":\n                            return va.every((a, i)=>m.T.equals(a, vb[i]));\n                        case \"scalar\":\n                            return va.every((a, i)=>scalarEquals(m.T, a, vb[i]));\n                        case \"enum\":\n                            return va.every((a, i)=>scalarEquals(ScalarType.INT32, a, vb[i]));\n                    }\n                    throw new Error(\"repeated cannot contain \".concat(m.kind));\n                }\n                switch(m.kind){\n                    case \"message\":\n                        return m.T.equals(va, vb);\n                    case \"enum\":\n                        return scalarEquals(ScalarType.INT32, va, vb);\n                    case \"scalar\":\n                        return scalarEquals(m.T, va, vb);\n                    case \"oneof\":\n                        if (va.case !== vb.case) {\n                            return false;\n                        }\n                        const s = m.findField(va.case);\n                        if (s === undefined) {\n                            return true;\n                        }\n                        // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- oneof fields are never \"map\"\n                        switch(s.kind){\n                            case \"message\":\n                                return s.T.equals(va.value, vb.value);\n                            case \"enum\":\n                                return scalarEquals(ScalarType.INT32, va.value, vb.value);\n                            case \"scalar\":\n                                return scalarEquals(s.T, va.value, vb.value);\n                        }\n                        throw new Error(\"oneof cannot contain \".concat(s.kind));\n                    case \"map\":\n                        const keys = Object.keys(va).concat(Object.keys(vb));\n                        switch(m.V.kind){\n                            case \"message\":\n                                const messageType = m.V.T;\n                                return keys.every((k)=>messageType.equals(va[k], vb[k]));\n                            case \"enum\":\n                                return keys.every((k)=>scalarEquals(ScalarType.INT32, va[k], vb[k]));\n                            case \"scalar\":\n                                const scalarType = m.V.T;\n                                return keys.every((k)=>scalarEquals(scalarType, va[k], vb[k]));\n                        }\n                        break;\n                }\n            });\n        },\n        clone (message) {\n            const type = message.getType(), target = new type(), any = target;\n            for (const member of type.fields.byMember()){\n                const source = message[member.localName];\n                let copy;\n                if (member.repeated) {\n                    copy = source.map(cloneSingularField);\n                } else if (member.kind == \"map\") {\n                    copy = any[member.localName];\n                    for (const [key, v] of Object.entries(source)){\n                        copy[key] = cloneSingularField(v);\n                    }\n                } else if (member.kind == \"oneof\") {\n                    const f = member.findField(source.case);\n                    copy = f ? {\n                        case: source.case,\n                        value: cloneSingularField(source.value)\n                    } : {\n                        case: undefined\n                    };\n                } else {\n                    copy = cloneSingularField(source);\n                }\n                any[member.localName] = copy;\n            }\n            return target;\n        }\n    };\n}\n// clone a single field value - i.e. the element type of repeated fields, the value type of maps\nfunction cloneSingularField(value) {\n    if (value === undefined) {\n        return value;\n    }\n    if (value instanceof Message) {\n        return value.clone();\n    }\n    if (value instanceof Uint8Array) {\n        const c = new Uint8Array(value.byteLength);\n        c.set(value);\n        return c;\n    }\n    return value;\n}\n// converts any ArrayLike<number> to Uint8Array if necessary.\nfunction toU8Arr(input) {\n    return input instanceof Uint8Array ? input : new Uint8Array(input);\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nclass InternalFieldList {\n    constructor(fields, normalizer){\n        this._fields = fields;\n        this._normalizer = normalizer;\n    }\n    findJsonName(jsonName) {\n        if (!this.jsonNames) {\n            const t = {};\n            for (const f of this.list()){\n                t[f.jsonName] = t[f.name] = f;\n            }\n            this.jsonNames = t;\n        }\n        return this.jsonNames[jsonName];\n    }\n    find(fieldNo) {\n        if (!this.numbers) {\n            const t = {};\n            for (const f of this.list()){\n                t[f.no] = f;\n            }\n            this.numbers = t;\n        }\n        return this.numbers[fieldNo];\n    }\n    list() {\n        if (!this.all) {\n            this.all = this._normalizer(this._fields);\n        }\n        return this.all;\n    }\n    byNumber() {\n        if (!this.numbersAsc) {\n            this.numbersAsc = this.list().concat().sort((a, b)=>a.no - b.no);\n        }\n        return this.numbersAsc;\n    }\n    byMember() {\n        if (!this.members) {\n            this.members = [];\n            const a = this.members;\n            let o;\n            for (const f of this.list()){\n                if (f.oneof) {\n                    if (f.oneof !== o) {\n                        o = f.oneof;\n                        a.push(o);\n                    }\n                } else {\n                    a.push(f);\n                }\n            }\n        }\n        return this.members;\n    }\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Returns the name of a protobuf element in generated code.\n *\n * Field names - including oneofs - are converted to lowerCamelCase. For\n * messages, enumerations and services, the package name is stripped from\n * the type name. For nested messages and enumerations, the names are joined\n * with an underscore. For methods, the first character is made lowercase.\n */ /**\n * Returns the name of a field in generated code.\n */ function localFieldName(protoName, inOneof) {\n    const name = protoCamelCase(protoName);\n    if (inOneof) {\n        // oneof member names are not properties, but values of the `case` property.\n        return name;\n    }\n    return safeObjectProperty(safeMessageProperty(name));\n}\n/**\n * Returns the name of a oneof group in generated code.\n */ function localOneofName(protoName) {\n    return localFieldName(protoName, false);\n}\n/**\n * Returns the JSON name for a protobuf field, exactly like protoc does.\n */ const fieldJsonName = protoCamelCase;\n/**\n * Converts snake_case to protoCamelCase according to the convention\n * used by protoc to convert a field name to a JSON name.\n */ function protoCamelCase(snakeCase) {\n    let capNext = false;\n    const b = [];\n    for(let i = 0; i < snakeCase.length; i++){\n        let c = snakeCase.charAt(i);\n        switch(c){\n            case \"_\":\n                capNext = true;\n                break;\n            case \"0\":\n            case \"1\":\n            case \"2\":\n            case \"3\":\n            case \"4\":\n            case \"5\":\n            case \"6\":\n            case \"7\":\n            case \"8\":\n            case \"9\":\n                b.push(c);\n                capNext = false;\n                break;\n            default:\n                if (capNext) {\n                    capNext = false;\n                    c = c.toUpperCase();\n                }\n                b.push(c);\n                break;\n        }\n    }\n    return b.join(\"\");\n}\n/**\n * Names that cannot be used for object properties because they are reserved\n * by built-in JavaScript properties.\n */ const reservedObjectProperties = new Set([\n    // names reserved by JavaScript\n    \"constructor\",\n    \"toString\",\n    \"toJSON\",\n    \"valueOf\"\n]);\n/**\n * Names that cannot be used for object properties because they are reserved\n * by the runtime.\n */ const reservedMessageProperties = new Set([\n    // names reserved by the runtime\n    \"getType\",\n    \"clone\",\n    \"equals\",\n    \"fromBinary\",\n    \"fromJson\",\n    \"fromJsonString\",\n    \"toBinary\",\n    \"toJson\",\n    \"toJsonString\",\n    // names reserved by the runtime for the future\n    \"toObject\"\n]);\nconst fallback = (name)=>\"\".concat(name, \"$\");\n/**\n * Will wrap names that are Object prototype properties or names reserved\n * for `Message`s.\n */ const safeMessageProperty = (name)=>{\n    if (reservedMessageProperties.has(name)) {\n        return fallback(name);\n    }\n    return name;\n};\n/**\n * Names that cannot be used for object properties because they are reserved\n * by built-in JavaScript properties.\n */ const safeObjectProperty = (name)=>{\n    if (reservedObjectProperties.has(name)) {\n        return fallback(name);\n    }\n    return name;\n};\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nclass InternalOneofInfo {\n    constructor(name){\n        this.kind = \"oneof\";\n        this.repeated = false;\n        this.packed = false;\n        this.opt = false;\n        this.default = undefined;\n        this.fields = [];\n        this.name = name;\n        this.localName = localOneofName(name);\n    }\n    addField(field) {\n        assert(field.oneof === this, \"field \".concat(field.name, \" not one of \").concat(this.name));\n        this.fields.push(field);\n    }\n    findField(localName) {\n        if (!this._lookup) {\n            this._lookup = Object.create(null);\n            for(let i = 0; i < this.fields.length; i++){\n                this._lookup[this.fields[i].localName] = this.fields[i];\n            }\n        }\n        return this._lookup[localName];\n    }\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Provides functionality for messages defined with the proto3 syntax.\n */ const proto3 = makeProtoRuntime(\"proto3\", makeJsonFormatProto3(), makeBinaryFormatProto3(), Object.assign(Object.assign({}, makeUtilCommon()), {\n    newFieldList (fields) {\n        return new InternalFieldList(fields, normalizeFieldInfosProto3);\n    },\n    initFields (target) {\n        for (const member of target.getType().fields.byMember()){\n            if (member.opt) {\n                continue;\n            }\n            const name = member.localName, t = target;\n            if (member.repeated) {\n                t[name] = [];\n                continue;\n            }\n            switch(member.kind){\n                case \"oneof\":\n                    t[name] = {\n                        case: undefined\n                    };\n                    break;\n                case \"enum\":\n                    t[name] = 0;\n                    break;\n                case \"map\":\n                    t[name] = {};\n                    break;\n                case \"scalar\":\n                    t[name] = scalarDefaultValue(member.T, member.L); // eslint-disable-line @typescript-eslint/no-unsafe-assignment\n                    break;\n            }\n        }\n    }\n}));\n/* eslint-disable @typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-argument */ function normalizeFieldInfosProto3(fieldInfos) {\n    var _a, _b, _c, _d;\n    const r = [];\n    let o;\n    for (const field of typeof fieldInfos == \"function\" ? fieldInfos() : fieldInfos){\n        const f = field;\n        f.localName = localFieldName(field.name, field.oneof !== undefined);\n        f.jsonName = (_a = field.jsonName) !== null && _a !== void 0 ? _a : fieldJsonName(field.name);\n        f.repeated = (_b = field.repeated) !== null && _b !== void 0 ? _b : false;\n        if (field.kind == \"scalar\") {\n            f.L = (_c = field.L) !== null && _c !== void 0 ? _c : LongType.BIGINT;\n        }\n        // From the proto3 language guide:\n        // > In proto3, repeated fields of scalar numeric types are packed by default.\n        // This information is incomplete - according to the conformance tests, BOOL\n        // and ENUM are packed by default as well. This means only STRING and BYTES\n        // are not packed by default, which makes sense because they are length-delimited.\n        f.packed = (_d = field.packed) !== null && _d !== void 0 ? _d : field.kind == \"enum\" || field.kind == \"scalar\" && field.T != ScalarType.BYTES && field.T != ScalarType.STRING;\n        // We do not surface options at this time\n        // f.options = field.options ?? emptyReadonlyObject;\n        if (field.oneof !== undefined) {\n            const ooname = typeof field.oneof == \"string\" ? field.oneof : field.oneof.name;\n            if (!o || o.name != ooname) {\n                o = new InternalOneofInfo(ooname);\n            }\n            f.oneof = o;\n            o.addField(f);\n        }\n        r.push(f);\n    }\n    return r;\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * A Timestamp represents a point in time independent of any time zone or local\n * calendar, encoded as a count of seconds and fractions of seconds at\n * nanosecond resolution. The count is relative to an epoch at UTC midnight on\n * January 1, 1970, in the proleptic Gregorian calendar which extends the\n * Gregorian calendar backwards to year one.\n *\n * All minutes are 60 seconds long. Leap seconds are \"smeared\" so that no leap\n * second table is needed for interpretation, using a [24-hour linear\n * smear](https://developers.google.com/time/smear).\n *\n * The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By\n * restricting to that range, we ensure that we can convert to and from [RFC\n * 3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.\n *\n * # Examples\n *\n * Example 1: Compute Timestamp from POSIX `time()`.\n *\n *     Timestamp timestamp;\n *     timestamp.set_seconds(time(NULL));\n *     timestamp.set_nanos(0);\n *\n * Example 2: Compute Timestamp from POSIX `gettimeofday()`.\n *\n *     struct timeval tv;\n *     gettimeofday(&tv, NULL);\n *\n *     Timestamp timestamp;\n *     timestamp.set_seconds(tv.tv_sec);\n *     timestamp.set_nanos(tv.tv_usec * 1000);\n *\n * Example 3: Compute Timestamp from Win32 `GetSystemTimeAsFileTime()`.\n *\n *     FILETIME ft;\n *     GetSystemTimeAsFileTime(&ft);\n *     UINT64 ticks = (((UINT64)ft.dwHighDateTime) << 32) | ft.dwLowDateTime;\n *\n *     // A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z\n *     // is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z.\n *     Timestamp timestamp;\n *     timestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL));\n *     timestamp.set_nanos((INT32) ((ticks % 10000000) * 100));\n *\n * Example 4: Compute Timestamp from Java `System.currentTimeMillis()`.\n *\n *     long millis = System.currentTimeMillis();\n *\n *     Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)\n *         .setNanos((int) ((millis % 1000) * 1000000)).build();\n *\n * Example 5: Compute Timestamp from Java `Instant.now()`.\n *\n *     Instant now = Instant.now();\n *\n *     Timestamp timestamp =\n *         Timestamp.newBuilder().setSeconds(now.getEpochSecond())\n *             .setNanos(now.getNano()).build();\n *\n * Example 6: Compute Timestamp from current time in Python.\n *\n *     timestamp = Timestamp()\n *     timestamp.GetCurrentTime()\n *\n * # JSON Mapping\n *\n * In JSON format, the Timestamp type is encoded as a string in the\n * [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format. That is, the\n * format is \"{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z\"\n * where {year} is always expressed using four digits while {month}, {day},\n * {hour}, {min}, and {sec} are zero-padded to two digits each. The fractional\n * seconds, which can go up to 9 digits (i.e. up to 1 nanosecond resolution),\n * are optional. The \"Z\" suffix indicates the timezone (\"UTC\"); the timezone\n * is required. A proto3 JSON serializer should always use UTC (as indicated by\n * \"Z\") when printing the Timestamp type and a proto3 JSON parser should be\n * able to accept both UTC and other timezones (as indicated by an offset).\n *\n * For example, \"2017-01-15T01:30:15.01Z\" encodes 15.01 seconds past\n * 01:30 UTC on January 15, 2017.\n *\n * In JavaScript, one can convert a Date object to this format using the\n * standard\n * [toISOString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)\n * method. In Python, a standard `datetime.datetime` object can be converted\n * to this format using\n * [`strftime`](https://docs.python.org/2/library/time.html#time.strftime) with\n * the time format spec '%Y-%m-%dT%H:%M:%S.%fZ'. Likewise, in Java, one can use\n * the Joda Time's [`ISODateTimeFormat.dateTime()`](\n * http://joda-time.sourceforge.net/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime()\n * ) to obtain a formatter capable of generating timestamps in this format.\n *\n *\n * @generated from message google.protobuf.Timestamp\n */ class Timestamp extends Message {\n    constructor(data){\n        super();\n        /**\n     * Represents seconds of UTC time since Unix epoch\n     * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\n     * 9999-12-31T23:59:59Z inclusive.\n     *\n     * @generated from field: int64 seconds = 1;\n     */ this.seconds = protoInt64.zero;\n        /**\n     * Non-negative fractions of a second at nanosecond resolution. Negative\n     * second values with fractions must still have non-negative nanos values\n     * that count forward in time. Must be from 0 to 999,999,999\n     * inclusive.\n     *\n     * @generated from field: int32 nanos = 2;\n     */ this.nanos = 0;\n        proto3.util.initPartial(data, this);\n    }\n    fromJson(json, options) {\n        if (typeof json !== \"string\") {\n            throw new Error(\"cannot decode google.protobuf.Timestamp from JSON: \".concat(proto3.json.debug(json)));\n        }\n        const matches = json.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|\\.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/);\n        if (!matches) {\n            throw new Error(\"cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string\");\n        }\n        const ms = Date.parse(matches[1] + \"-\" + matches[2] + \"-\" + matches[3] + \"T\" + matches[4] + \":\" + matches[5] + \":\" + matches[6] + (matches[8] ? matches[8] : \"Z\"));\n        if (Number.isNaN(ms)) {\n            throw new Error(\"cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string\");\n        }\n        if (ms < Date.parse(\"0001-01-01T00:00:00Z\") || ms > Date.parse(\"9999-12-31T23:59:59Z\")) {\n            throw new Error(\"cannot decode message google.protobuf.Timestamp from JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive\");\n        }\n        this.seconds = protoInt64.parse(ms / 1000);\n        this.nanos = 0;\n        if (matches[7]) {\n            this.nanos = parseInt(\"1\" + matches[7] + \"0\".repeat(9 - matches[7].length)) - 1000000000;\n        }\n        return this;\n    }\n    toJson(options) {\n        const ms = Number(this.seconds) * 1000;\n        if (ms < Date.parse(\"0001-01-01T00:00:00Z\") || ms > Date.parse(\"9999-12-31T23:59:59Z\")) {\n            throw new Error(\"cannot encode google.protobuf.Timestamp to JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive\");\n        }\n        if (this.nanos < 0) {\n            throw new Error(\"cannot encode google.protobuf.Timestamp to JSON: nanos must not be negative\");\n        }\n        let z = \"Z\";\n        if (this.nanos > 0) {\n            const nanosStr = (this.nanos + 1000000000).toString().substring(1);\n            if (nanosStr.substring(3) === \"000000\") {\n                z = \".\" + nanosStr.substring(0, 3) + \"Z\";\n            } else if (nanosStr.substring(6) === \"000\") {\n                z = \".\" + nanosStr.substring(0, 6) + \"Z\";\n            } else {\n                z = \".\" + nanosStr + \"Z\";\n            }\n        }\n        return new Date(ms).toISOString().replace(\".000Z\", z);\n    }\n    toDate() {\n        return new Date(Number(this.seconds) * 1000 + Math.ceil(this.nanos / 1000000));\n    }\n    static now() {\n        return Timestamp.fromDate(new Date());\n    }\n    static fromDate(date) {\n        const ms = date.getTime();\n        return new Timestamp({\n            seconds: protoInt64.parse(Math.floor(ms / 1000)),\n            nanos: ms % 1000 * 1000000\n        });\n    }\n    static fromBinary(bytes, options) {\n        return new Timestamp().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new Timestamp().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new Timestamp().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(Timestamp, a, b);\n    }\n}\nTimestamp.runtime = proto3;\nTimestamp.typeName = \"google.protobuf.Timestamp\";\nTimestamp.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"seconds\",\n            kind: \"scalar\",\n            T: 3 /* ScalarType.INT64 */ \n        },\n        {\n            no: 2,\n            name: \"nanos\",\n            kind: \"scalar\",\n            T: 5 /* ScalarType.INT32 */ \n        }\n    ]);\n// Copyright 2023 LiveKit, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * @generated from enum livekit.AudioCodec\n */ var AudioCodec;\n(function(AudioCodec) {\n    /**\n   * @generated from enum value: DEFAULT_AC = 0;\n   */ AudioCodec[AudioCodec[\"DEFAULT_AC\"] = 0] = \"DEFAULT_AC\";\n    /**\n   * @generated from enum value: OPUS = 1;\n   */ AudioCodec[AudioCodec[\"OPUS\"] = 1] = \"OPUS\";\n    /**\n   * @generated from enum value: AAC = 2;\n   */ AudioCodec[AudioCodec[\"AAC\"] = 2] = \"AAC\";\n})(AudioCodec || (AudioCodec = {}));\n// Retrieve enum metadata with: proto3.getEnumType(AudioCodec)\nproto3.util.setEnumType(AudioCodec, \"livekit.AudioCodec\", [\n    {\n        no: 0,\n        name: \"DEFAULT_AC\"\n    },\n    {\n        no: 1,\n        name: \"OPUS\"\n    },\n    {\n        no: 2,\n        name: \"AAC\"\n    }\n]);\n/**\n * @generated from enum livekit.VideoCodec\n */ var VideoCodec;\n(function(VideoCodec) {\n    /**\n   * @generated from enum value: DEFAULT_VC = 0;\n   */ VideoCodec[VideoCodec[\"DEFAULT_VC\"] = 0] = \"DEFAULT_VC\";\n    /**\n   * @generated from enum value: H264_BASELINE = 1;\n   */ VideoCodec[VideoCodec[\"H264_BASELINE\"] = 1] = \"H264_BASELINE\";\n    /**\n   * @generated from enum value: H264_MAIN = 2;\n   */ VideoCodec[VideoCodec[\"H264_MAIN\"] = 2] = \"H264_MAIN\";\n    /**\n   * @generated from enum value: H264_HIGH = 3;\n   */ VideoCodec[VideoCodec[\"H264_HIGH\"] = 3] = \"H264_HIGH\";\n    /**\n   * @generated from enum value: VP8 = 4;\n   */ VideoCodec[VideoCodec[\"VP8\"] = 4] = \"VP8\";\n})(VideoCodec || (VideoCodec = {}));\n// Retrieve enum metadata with: proto3.getEnumType(VideoCodec)\nproto3.util.setEnumType(VideoCodec, \"livekit.VideoCodec\", [\n    {\n        no: 0,\n        name: \"DEFAULT_VC\"\n    },\n    {\n        no: 1,\n        name: \"H264_BASELINE\"\n    },\n    {\n        no: 2,\n        name: \"H264_MAIN\"\n    },\n    {\n        no: 3,\n        name: \"H264_HIGH\"\n    },\n    {\n        no: 4,\n        name: \"VP8\"\n    }\n]);\n/**\n * @generated from enum livekit.ImageCodec\n */ var ImageCodec;\n(function(ImageCodec) {\n    /**\n   * @generated from enum value: IC_DEFAULT = 0;\n   */ ImageCodec[ImageCodec[\"IC_DEFAULT\"] = 0] = \"IC_DEFAULT\";\n    /**\n   * @generated from enum value: IC_JPEG = 1;\n   */ ImageCodec[ImageCodec[\"IC_JPEG\"] = 1] = \"IC_JPEG\";\n})(ImageCodec || (ImageCodec = {}));\n// Retrieve enum metadata with: proto3.getEnumType(ImageCodec)\nproto3.util.setEnumType(ImageCodec, \"livekit.ImageCodec\", [\n    {\n        no: 0,\n        name: \"IC_DEFAULT\"\n    },\n    {\n        no: 1,\n        name: \"IC_JPEG\"\n    }\n]);\n/**\n * @generated from enum livekit.TrackType\n */ var TrackType;\n(function(TrackType) {\n    /**\n   * @generated from enum value: AUDIO = 0;\n   */ TrackType[TrackType[\"AUDIO\"] = 0] = \"AUDIO\";\n    /**\n   * @generated from enum value: VIDEO = 1;\n   */ TrackType[TrackType[\"VIDEO\"] = 1] = \"VIDEO\";\n    /**\n   * @generated from enum value: DATA = 2;\n   */ TrackType[TrackType[\"DATA\"] = 2] = \"DATA\";\n})(TrackType || (TrackType = {}));\n// Retrieve enum metadata with: proto3.getEnumType(TrackType)\nproto3.util.setEnumType(TrackType, \"livekit.TrackType\", [\n    {\n        no: 0,\n        name: \"AUDIO\"\n    },\n    {\n        no: 1,\n        name: \"VIDEO\"\n    },\n    {\n        no: 2,\n        name: \"DATA\"\n    }\n]);\n/**\n * @generated from enum livekit.TrackSource\n */ var TrackSource;\n(function(TrackSource) {\n    /**\n   * @generated from enum value: UNKNOWN = 0;\n   */ TrackSource[TrackSource[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n    /**\n   * @generated from enum value: CAMERA = 1;\n   */ TrackSource[TrackSource[\"CAMERA\"] = 1] = \"CAMERA\";\n    /**\n   * @generated from enum value: MICROPHONE = 2;\n   */ TrackSource[TrackSource[\"MICROPHONE\"] = 2] = \"MICROPHONE\";\n    /**\n   * @generated from enum value: SCREEN_SHARE = 3;\n   */ TrackSource[TrackSource[\"SCREEN_SHARE\"] = 3] = \"SCREEN_SHARE\";\n    /**\n   * @generated from enum value: SCREEN_SHARE_AUDIO = 4;\n   */ TrackSource[TrackSource[\"SCREEN_SHARE_AUDIO\"] = 4] = \"SCREEN_SHARE_AUDIO\";\n})(TrackSource || (TrackSource = {}));\n// Retrieve enum metadata with: proto3.getEnumType(TrackSource)\nproto3.util.setEnumType(TrackSource, \"livekit.TrackSource\", [\n    {\n        no: 0,\n        name: \"UNKNOWN\"\n    },\n    {\n        no: 1,\n        name: \"CAMERA\"\n    },\n    {\n        no: 2,\n        name: \"MICROPHONE\"\n    },\n    {\n        no: 3,\n        name: \"SCREEN_SHARE\"\n    },\n    {\n        no: 4,\n        name: \"SCREEN_SHARE_AUDIO\"\n    }\n]);\n/**\n * @generated from enum livekit.VideoQuality\n */ var VideoQuality;\n(function(VideoQuality) {\n    /**\n   * @generated from enum value: LOW = 0;\n   */ VideoQuality[VideoQuality[\"LOW\"] = 0] = \"LOW\";\n    /**\n   * @generated from enum value: MEDIUM = 1;\n   */ VideoQuality[VideoQuality[\"MEDIUM\"] = 1] = \"MEDIUM\";\n    /**\n   * @generated from enum value: HIGH = 2;\n   */ VideoQuality[VideoQuality[\"HIGH\"] = 2] = \"HIGH\";\n    /**\n   * @generated from enum value: OFF = 3;\n   */ VideoQuality[VideoQuality[\"OFF\"] = 3] = \"OFF\";\n})(VideoQuality || (VideoQuality = {}));\n// Retrieve enum metadata with: proto3.getEnumType(VideoQuality)\nproto3.util.setEnumType(VideoQuality, \"livekit.VideoQuality\", [\n    {\n        no: 0,\n        name: \"LOW\"\n    },\n    {\n        no: 1,\n        name: \"MEDIUM\"\n    },\n    {\n        no: 2,\n        name: \"HIGH\"\n    },\n    {\n        no: 3,\n        name: \"OFF\"\n    }\n]);\n/**\n * @generated from enum livekit.ConnectionQuality\n */ var ConnectionQuality$1;\n(function(ConnectionQuality) {\n    /**\n   * @generated from enum value: POOR = 0;\n   */ ConnectionQuality[ConnectionQuality[\"POOR\"] = 0] = \"POOR\";\n    /**\n   * @generated from enum value: GOOD = 1;\n   */ ConnectionQuality[ConnectionQuality[\"GOOD\"] = 1] = \"GOOD\";\n    /**\n   * @generated from enum value: EXCELLENT = 2;\n   */ ConnectionQuality[ConnectionQuality[\"EXCELLENT\"] = 2] = \"EXCELLENT\";\n    /**\n   * @generated from enum value: LOST = 3;\n   */ ConnectionQuality[ConnectionQuality[\"LOST\"] = 3] = \"LOST\";\n})(ConnectionQuality$1 || (ConnectionQuality$1 = {}));\n// Retrieve enum metadata with: proto3.getEnumType(ConnectionQuality)\nproto3.util.setEnumType(ConnectionQuality$1, \"livekit.ConnectionQuality\", [\n    {\n        no: 0,\n        name: \"POOR\"\n    },\n    {\n        no: 1,\n        name: \"GOOD\"\n    },\n    {\n        no: 2,\n        name: \"EXCELLENT\"\n    },\n    {\n        no: 3,\n        name: \"LOST\"\n    }\n]);\n/**\n * @generated from enum livekit.ClientConfigSetting\n */ var ClientConfigSetting;\n(function(ClientConfigSetting) {\n    /**\n   * @generated from enum value: UNSET = 0;\n   */ ClientConfigSetting[ClientConfigSetting[\"UNSET\"] = 0] = \"UNSET\";\n    /**\n   * @generated from enum value: DISABLED = 1;\n   */ ClientConfigSetting[ClientConfigSetting[\"DISABLED\"] = 1] = \"DISABLED\";\n    /**\n   * @generated from enum value: ENABLED = 2;\n   */ ClientConfigSetting[ClientConfigSetting[\"ENABLED\"] = 2] = \"ENABLED\";\n})(ClientConfigSetting || (ClientConfigSetting = {}));\n// Retrieve enum metadata with: proto3.getEnumType(ClientConfigSetting)\nproto3.util.setEnumType(ClientConfigSetting, \"livekit.ClientConfigSetting\", [\n    {\n        no: 0,\n        name: \"UNSET\"\n    },\n    {\n        no: 1,\n        name: \"DISABLED\"\n    },\n    {\n        no: 2,\n        name: \"ENABLED\"\n    }\n]);\n/**\n * @generated from enum livekit.DisconnectReason\n */ var DisconnectReason;\n(function(DisconnectReason) {\n    /**\n   * @generated from enum value: UNKNOWN_REASON = 0;\n   */ DisconnectReason[DisconnectReason[\"UNKNOWN_REASON\"] = 0] = \"UNKNOWN_REASON\";\n    /**\n   * @generated from enum value: CLIENT_INITIATED = 1;\n   */ DisconnectReason[DisconnectReason[\"CLIENT_INITIATED\"] = 1] = \"CLIENT_INITIATED\";\n    /**\n   * @generated from enum value: DUPLICATE_IDENTITY = 2;\n   */ DisconnectReason[DisconnectReason[\"DUPLICATE_IDENTITY\"] = 2] = \"DUPLICATE_IDENTITY\";\n    /**\n   * @generated from enum value: SERVER_SHUTDOWN = 3;\n   */ DisconnectReason[DisconnectReason[\"SERVER_SHUTDOWN\"] = 3] = \"SERVER_SHUTDOWN\";\n    /**\n   * @generated from enum value: PARTICIPANT_REMOVED = 4;\n   */ DisconnectReason[DisconnectReason[\"PARTICIPANT_REMOVED\"] = 4] = \"PARTICIPANT_REMOVED\";\n    /**\n   * @generated from enum value: ROOM_DELETED = 5;\n   */ DisconnectReason[DisconnectReason[\"ROOM_DELETED\"] = 5] = \"ROOM_DELETED\";\n    /**\n   * @generated from enum value: STATE_MISMATCH = 6;\n   */ DisconnectReason[DisconnectReason[\"STATE_MISMATCH\"] = 6] = \"STATE_MISMATCH\";\n    /**\n   * @generated from enum value: JOIN_FAILURE = 7;\n   */ DisconnectReason[DisconnectReason[\"JOIN_FAILURE\"] = 7] = \"JOIN_FAILURE\";\n})(DisconnectReason || (DisconnectReason = {}));\n// Retrieve enum metadata with: proto3.getEnumType(DisconnectReason)\nproto3.util.setEnumType(DisconnectReason, \"livekit.DisconnectReason\", [\n    {\n        no: 0,\n        name: \"UNKNOWN_REASON\"\n    },\n    {\n        no: 1,\n        name: \"CLIENT_INITIATED\"\n    },\n    {\n        no: 2,\n        name: \"DUPLICATE_IDENTITY\"\n    },\n    {\n        no: 3,\n        name: \"SERVER_SHUTDOWN\"\n    },\n    {\n        no: 4,\n        name: \"PARTICIPANT_REMOVED\"\n    },\n    {\n        no: 5,\n        name: \"ROOM_DELETED\"\n    },\n    {\n        no: 6,\n        name: \"STATE_MISMATCH\"\n    },\n    {\n        no: 7,\n        name: \"JOIN_FAILURE\"\n    }\n]);\n/**\n * @generated from enum livekit.ReconnectReason\n */ var ReconnectReason;\n(function(ReconnectReason) {\n    /**\n   * @generated from enum value: RR_UNKNOWN = 0;\n   */ ReconnectReason[ReconnectReason[\"RR_UNKNOWN\"] = 0] = \"RR_UNKNOWN\";\n    /**\n   * @generated from enum value: RR_SIGNAL_DISCONNECTED = 1;\n   */ ReconnectReason[ReconnectReason[\"RR_SIGNAL_DISCONNECTED\"] = 1] = \"RR_SIGNAL_DISCONNECTED\";\n    /**\n   * @generated from enum value: RR_PUBLISHER_FAILED = 2;\n   */ ReconnectReason[ReconnectReason[\"RR_PUBLISHER_FAILED\"] = 2] = \"RR_PUBLISHER_FAILED\";\n    /**\n   * @generated from enum value: RR_SUBSCRIBER_FAILED = 3;\n   */ ReconnectReason[ReconnectReason[\"RR_SUBSCRIBER_FAILED\"] = 3] = \"RR_SUBSCRIBER_FAILED\";\n    /**\n   * @generated from enum value: RR_SWITCH_CANDIDATE = 4;\n   */ ReconnectReason[ReconnectReason[\"RR_SWITCH_CANDIDATE\"] = 4] = \"RR_SWITCH_CANDIDATE\";\n})(ReconnectReason || (ReconnectReason = {}));\n// Retrieve enum metadata with: proto3.getEnumType(ReconnectReason)\nproto3.util.setEnumType(ReconnectReason, \"livekit.ReconnectReason\", [\n    {\n        no: 0,\n        name: \"RR_UNKNOWN\"\n    },\n    {\n        no: 1,\n        name: \"RR_SIGNAL_DISCONNECTED\"\n    },\n    {\n        no: 2,\n        name: \"RR_PUBLISHER_FAILED\"\n    },\n    {\n        no: 3,\n        name: \"RR_SUBSCRIBER_FAILED\"\n    },\n    {\n        no: 4,\n        name: \"RR_SWITCH_CANDIDATE\"\n    }\n]);\n/**\n * @generated from enum livekit.SubscriptionError\n */ var SubscriptionError;\n(function(SubscriptionError) {\n    /**\n   * @generated from enum value: SE_UNKNOWN = 0;\n   */ SubscriptionError[SubscriptionError[\"SE_UNKNOWN\"] = 0] = \"SE_UNKNOWN\";\n    /**\n   * @generated from enum value: SE_CODEC_UNSUPPORTED = 1;\n   */ SubscriptionError[SubscriptionError[\"SE_CODEC_UNSUPPORTED\"] = 1] = \"SE_CODEC_UNSUPPORTED\";\n    /**\n   * @generated from enum value: SE_TRACK_NOTFOUND = 2;\n   */ SubscriptionError[SubscriptionError[\"SE_TRACK_NOTFOUND\"] = 2] = \"SE_TRACK_NOTFOUND\";\n})(SubscriptionError || (SubscriptionError = {}));\n// Retrieve enum metadata with: proto3.getEnumType(SubscriptionError)\nproto3.util.setEnumType(SubscriptionError, \"livekit.SubscriptionError\", [\n    {\n        no: 0,\n        name: \"SE_UNKNOWN\"\n    },\n    {\n        no: 1,\n        name: \"SE_CODEC_UNSUPPORTED\"\n    },\n    {\n        no: 2,\n        name: \"SE_TRACK_NOTFOUND\"\n    }\n]);\n/**\n * @generated from message livekit.Room\n */ let Room$1 = class Room extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string sid = 1;\n     */ this.sid = \"\";\n        /**\n     * @generated from field: string name = 2;\n     */ this.name = \"\";\n        /**\n     * @generated from field: uint32 empty_timeout = 3;\n     */ this.emptyTimeout = 0;\n        /**\n     * @generated from field: uint32 max_participants = 4;\n     */ this.maxParticipants = 0;\n        /**\n     * @generated from field: int64 creation_time = 5;\n     */ this.creationTime = protoInt64.zero;\n        /**\n     * @generated from field: string turn_password = 6;\n     */ this.turnPassword = \"\";\n        /**\n     * @generated from field: repeated livekit.Codec enabled_codecs = 7;\n     */ this.enabledCodecs = [];\n        /**\n     * @generated from field: string metadata = 8;\n     */ this.metadata = \"\";\n        /**\n     * @generated from field: uint32 num_participants = 9;\n     */ this.numParticipants = 0;\n        /**\n     * @generated from field: uint32 num_publishers = 11;\n     */ this.numPublishers = 0;\n        /**\n     * @generated from field: bool active_recording = 10;\n     */ this.activeRecording = false;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new Room().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new Room().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new Room().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(Room, a, b);\n    }\n};\nRoom$1.runtime = proto3;\nRoom$1.typeName = \"livekit.Room\";\nRoom$1.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"name\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 3,\n            name: \"empty_timeout\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 4,\n            name: \"max_participants\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 5,\n            name: \"creation_time\",\n            kind: \"scalar\",\n            T: 3 /* ScalarType.INT64 */ \n        },\n        {\n            no: 6,\n            name: \"turn_password\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 7,\n            name: \"enabled_codecs\",\n            kind: \"message\",\n            T: Codec,\n            repeated: true\n        },\n        {\n            no: 8,\n            name: \"metadata\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 9,\n            name: \"num_participants\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 11,\n            name: \"num_publishers\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 10,\n            name: \"active_recording\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        }\n    ]);\n/**\n * @generated from message livekit.Codec\n */ class Codec extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string mime = 1;\n     */ this.mime = \"\";\n        /**\n     * @generated from field: string fmtp_line = 2;\n     */ this.fmtpLine = \"\";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new Codec().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new Codec().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new Codec().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(Codec, a, b);\n    }\n}\nCodec.runtime = proto3;\nCodec.typeName = \"livekit.Codec\";\nCodec.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"mime\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"fmtp_line\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * @generated from message livekit.PlayoutDelay\n */ class PlayoutDelay extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: bool enabled = 1;\n     */ this.enabled = false;\n        /**\n     * @generated from field: uint32 min = 2;\n     */ this.min = 0;\n        /**\n     * @generated from field: uint32 max = 3;\n     */ this.max = 0;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new PlayoutDelay().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new PlayoutDelay().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new PlayoutDelay().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(PlayoutDelay, a, b);\n    }\n}\nPlayoutDelay.runtime = proto3;\nPlayoutDelay.typeName = \"livekit.PlayoutDelay\";\nPlayoutDelay.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"enabled\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 2,\n            name: \"min\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 3,\n            name: \"max\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        }\n    ]);\n/**\n * @generated from message livekit.ParticipantPermission\n */ class ParticipantPermission extends Message {\n    constructor(data){\n        super();\n        /**\n     * allow participant to subscribe to other tracks in the room\n     *\n     * @generated from field: bool can_subscribe = 1;\n     */ this.canSubscribe = false;\n        /**\n     * allow participant to publish new tracks to room\n     *\n     * @generated from field: bool can_publish = 2;\n     */ this.canPublish = false;\n        /**\n     * allow participant to publish data\n     *\n     * @generated from field: bool can_publish_data = 3;\n     */ this.canPublishData = false;\n        /**\n     * sources that are allowed to be published\n     *\n     * @generated from field: repeated livekit.TrackSource can_publish_sources = 9;\n     */ this.canPublishSources = [];\n        /**\n     * indicates that it's hidden to others\n     *\n     * @generated from field: bool hidden = 7;\n     */ this.hidden = false;\n        /**\n     * indicates it's a recorder instance\n     *\n     * @generated from field: bool recorder = 8;\n     */ this.recorder = false;\n        /**\n     * indicates that participant can update own metadata\n     *\n     * @generated from field: bool can_update_metadata = 10;\n     */ this.canUpdateMetadata = false;\n        /**\n     * indicates that participant is an agent\n     *\n     * @generated from field: bool agent = 11;\n     */ this.agent = false;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ParticipantPermission().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ParticipantPermission().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ParticipantPermission().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ParticipantPermission, a, b);\n    }\n}\nParticipantPermission.runtime = proto3;\nParticipantPermission.typeName = \"livekit.ParticipantPermission\";\nParticipantPermission.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"can_subscribe\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 2,\n            name: \"can_publish\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 3,\n            name: \"can_publish_data\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 9,\n            name: \"can_publish_sources\",\n            kind: \"enum\",\n            T: proto3.getEnumType(TrackSource),\n            repeated: true\n        },\n        {\n            no: 7,\n            name: \"hidden\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 8,\n            name: \"recorder\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 10,\n            name: \"can_update_metadata\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 11,\n            name: \"agent\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        }\n    ]);\n/**\n * @generated from message livekit.ParticipantInfo\n */ class ParticipantInfo extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string sid = 1;\n     */ this.sid = \"\";\n        /**\n     * @generated from field: string identity = 2;\n     */ this.identity = \"\";\n        /**\n     * @generated from field: livekit.ParticipantInfo.State state = 3;\n     */ this.state = ParticipantInfo_State.JOINING;\n        /**\n     * @generated from field: repeated livekit.TrackInfo tracks = 4;\n     */ this.tracks = [];\n        /**\n     * @generated from field: string metadata = 5;\n     */ this.metadata = \"\";\n        /**\n     * timestamp when participant joined room, in seconds\n     *\n     * @generated from field: int64 joined_at = 6;\n     */ this.joinedAt = protoInt64.zero;\n        /**\n     * @generated from field: string name = 9;\n     */ this.name = \"\";\n        /**\n     * @generated from field: uint32 version = 10;\n     */ this.version = 0;\n        /**\n     * @generated from field: string region = 12;\n     */ this.region = \"\";\n        /**\n     * indicates the participant has an active publisher connection\n     * and can publish to the server\n     *\n     * @generated from field: bool is_publisher = 13;\n     */ this.isPublisher = false;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ParticipantInfo().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ParticipantInfo().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ParticipantInfo().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ParticipantInfo, a, b);\n    }\n}\nParticipantInfo.runtime = proto3;\nParticipantInfo.typeName = \"livekit.ParticipantInfo\";\nParticipantInfo.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"identity\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 3,\n            name: \"state\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ParticipantInfo_State)\n        },\n        {\n            no: 4,\n            name: \"tracks\",\n            kind: \"message\",\n            T: TrackInfo,\n            repeated: true\n        },\n        {\n            no: 5,\n            name: \"metadata\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 6,\n            name: \"joined_at\",\n            kind: \"scalar\",\n            T: 3 /* ScalarType.INT64 */ \n        },\n        {\n            no: 9,\n            name: \"name\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 10,\n            name: \"version\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 11,\n            name: \"permission\",\n            kind: \"message\",\n            T: ParticipantPermission\n        },\n        {\n            no: 12,\n            name: \"region\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 13,\n            name: \"is_publisher\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        }\n    ]);\n/**\n * @generated from enum livekit.ParticipantInfo.State\n */ var ParticipantInfo_State;\n(function(ParticipantInfo_State) {\n    /**\n   * websocket' connected, but not offered yet\n   *\n   * @generated from enum value: JOINING = 0;\n   */ ParticipantInfo_State[ParticipantInfo_State[\"JOINING\"] = 0] = \"JOINING\";\n    /**\n   * server received client offer\n   *\n   * @generated from enum value: JOINED = 1;\n   */ ParticipantInfo_State[ParticipantInfo_State[\"JOINED\"] = 1] = \"JOINED\";\n    /**\n   * ICE connectivity established\n   *\n   * @generated from enum value: ACTIVE = 2;\n   */ ParticipantInfo_State[ParticipantInfo_State[\"ACTIVE\"] = 2] = \"ACTIVE\";\n    /**\n   * WS disconnected\n   *\n   * @generated from enum value: DISCONNECTED = 3;\n   */ ParticipantInfo_State[ParticipantInfo_State[\"DISCONNECTED\"] = 3] = \"DISCONNECTED\";\n})(ParticipantInfo_State || (ParticipantInfo_State = {}));\n// Retrieve enum metadata with: proto3.getEnumType(ParticipantInfo_State)\nproto3.util.setEnumType(ParticipantInfo_State, \"livekit.ParticipantInfo.State\", [\n    {\n        no: 0,\n        name: \"JOINING\"\n    },\n    {\n        no: 1,\n        name: \"JOINED\"\n    },\n    {\n        no: 2,\n        name: \"ACTIVE\"\n    },\n    {\n        no: 3,\n        name: \"DISCONNECTED\"\n    }\n]);\n/**\n * @generated from message livekit.Encryption\n */ class Encryption extends Message {\n    constructor(data){\n        super();\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new Encryption().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new Encryption().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new Encryption().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(Encryption, a, b);\n    }\n}\nEncryption.runtime = proto3;\nEncryption.typeName = \"livekit.Encryption\";\nEncryption.fields = proto3.util.newFieldList(()=>[]);\n/**\n * @generated from enum livekit.Encryption.Type\n */ var Encryption_Type;\n(function(Encryption_Type) {\n    /**\n   * @generated from enum value: NONE = 0;\n   */ Encryption_Type[Encryption_Type[\"NONE\"] = 0] = \"NONE\";\n    /**\n   * @generated from enum value: GCM = 1;\n   */ Encryption_Type[Encryption_Type[\"GCM\"] = 1] = \"GCM\";\n    /**\n   * @generated from enum value: CUSTOM = 2;\n   */ Encryption_Type[Encryption_Type[\"CUSTOM\"] = 2] = \"CUSTOM\";\n})(Encryption_Type || (Encryption_Type = {}));\n// Retrieve enum metadata with: proto3.getEnumType(Encryption_Type)\nproto3.util.setEnumType(Encryption_Type, \"livekit.Encryption.Type\", [\n    {\n        no: 0,\n        name: \"NONE\"\n    },\n    {\n        no: 1,\n        name: \"GCM\"\n    },\n    {\n        no: 2,\n        name: \"CUSTOM\"\n    }\n]);\n/**\n * @generated from message livekit.SimulcastCodecInfo\n */ class SimulcastCodecInfo extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string mime_type = 1;\n     */ this.mimeType = \"\";\n        /**\n     * @generated from field: string mid = 2;\n     */ this.mid = \"\";\n        /**\n     * @generated from field: string cid = 3;\n     */ this.cid = \"\";\n        /**\n     * @generated from field: repeated livekit.VideoLayer layers = 4;\n     */ this.layers = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SimulcastCodecInfo().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SimulcastCodecInfo().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SimulcastCodecInfo().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SimulcastCodecInfo, a, b);\n    }\n}\nSimulcastCodecInfo.runtime = proto3;\nSimulcastCodecInfo.typeName = \"livekit.SimulcastCodecInfo\";\nSimulcastCodecInfo.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"mime_type\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"mid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 3,\n            name: \"cid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 4,\n            name: \"layers\",\n            kind: \"message\",\n            T: VideoLayer,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.TrackInfo\n */ class TrackInfo extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string sid = 1;\n     */ this.sid = \"\";\n        /**\n     * @generated from field: livekit.TrackType type = 2;\n     */ this.type = TrackType.AUDIO;\n        /**\n     * @generated from field: string name = 3;\n     */ this.name = \"\";\n        /**\n     * @generated from field: bool muted = 4;\n     */ this.muted = false;\n        /**\n     * original width of video (unset for audio)\n     * clients may receive a lower resolution version with simulcast\n     *\n     * @generated from field: uint32 width = 5;\n     */ this.width = 0;\n        /**\n     * original height of video (unset for audio)\n     *\n     * @generated from field: uint32 height = 6;\n     */ this.height = 0;\n        /**\n     * true if track is simulcasted\n     *\n     * @generated from field: bool simulcast = 7;\n     */ this.simulcast = false;\n        /**\n     * true if DTX (Discontinuous Transmission) is disabled for audio\n     *\n     * @generated from field: bool disable_dtx = 8;\n     */ this.disableDtx = false;\n        /**\n     * source of media\n     *\n     * @generated from field: livekit.TrackSource source = 9;\n     */ this.source = TrackSource.UNKNOWN;\n        /**\n     * @generated from field: repeated livekit.VideoLayer layers = 10;\n     */ this.layers = [];\n        /**\n     * mime type of codec\n     *\n     * @generated from field: string mime_type = 11;\n     */ this.mimeType = \"\";\n        /**\n     * @generated from field: string mid = 12;\n     */ this.mid = \"\";\n        /**\n     * @generated from field: repeated livekit.SimulcastCodecInfo codecs = 13;\n     */ this.codecs = [];\n        /**\n     * @generated from field: bool stereo = 14;\n     */ this.stereo = false;\n        /**\n     * true if RED (Redundant Encoding) is disabled for audio\n     *\n     * @generated from field: bool disable_red = 15;\n     */ this.disableRed = false;\n        /**\n     * @generated from field: livekit.Encryption.Type encryption = 16;\n     */ this.encryption = Encryption_Type.NONE;\n        /**\n     * @generated from field: string stream = 17;\n     */ this.stream = \"\";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new TrackInfo().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new TrackInfo().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new TrackInfo().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(TrackInfo, a, b);\n    }\n}\nTrackInfo.runtime = proto3;\nTrackInfo.typeName = \"livekit.TrackInfo\";\nTrackInfo.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"type\",\n            kind: \"enum\",\n            T: proto3.getEnumType(TrackType)\n        },\n        {\n            no: 3,\n            name: \"name\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 4,\n            name: \"muted\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 5,\n            name: \"width\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 6,\n            name: \"height\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 7,\n            name: \"simulcast\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 8,\n            name: \"disable_dtx\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 9,\n            name: \"source\",\n            kind: \"enum\",\n            T: proto3.getEnumType(TrackSource)\n        },\n        {\n            no: 10,\n            name: \"layers\",\n            kind: \"message\",\n            T: VideoLayer,\n            repeated: true\n        },\n        {\n            no: 11,\n            name: \"mime_type\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 12,\n            name: \"mid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 13,\n            name: \"codecs\",\n            kind: \"message\",\n            T: SimulcastCodecInfo,\n            repeated: true\n        },\n        {\n            no: 14,\n            name: \"stereo\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 15,\n            name: \"disable_red\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 16,\n            name: \"encryption\",\n            kind: \"enum\",\n            T: proto3.getEnumType(Encryption_Type)\n        },\n        {\n            no: 17,\n            name: \"stream\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * provide information about available spatial layers\n *\n * @generated from message livekit.VideoLayer\n */ class VideoLayer extends Message {\n    constructor(data){\n        super();\n        /**\n     * for tracks with a single layer, this should be HIGH\n     *\n     * @generated from field: livekit.VideoQuality quality = 1;\n     */ this.quality = VideoQuality.LOW;\n        /**\n     * @generated from field: uint32 width = 2;\n     */ this.width = 0;\n        /**\n     * @generated from field: uint32 height = 3;\n     */ this.height = 0;\n        /**\n     * target bitrate in bit per second (bps), server will measure actual\n     *\n     * @generated from field: uint32 bitrate = 4;\n     */ this.bitrate = 0;\n        /**\n     * @generated from field: uint32 ssrc = 5;\n     */ this.ssrc = 0;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new VideoLayer().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new VideoLayer().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new VideoLayer().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(VideoLayer, a, b);\n    }\n}\nVideoLayer.runtime = proto3;\nVideoLayer.typeName = \"livekit.VideoLayer\";\nVideoLayer.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"quality\",\n            kind: \"enum\",\n            T: proto3.getEnumType(VideoQuality)\n        },\n        {\n            no: 2,\n            name: \"width\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 3,\n            name: \"height\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 4,\n            name: \"bitrate\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 5,\n            name: \"ssrc\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        }\n    ]);\n/**\n * new DataPacket API\n *\n * @generated from message livekit.DataPacket\n */ class DataPacket extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: livekit.DataPacket.Kind kind = 1;\n     */ this.kind = DataPacket_Kind.RELIABLE;\n        /**\n     * @generated from oneof livekit.DataPacket.value\n     */ this.value = {\n            case: undefined\n        };\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new DataPacket().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new DataPacket().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new DataPacket().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(DataPacket, a, b);\n    }\n}\nDataPacket.runtime = proto3;\nDataPacket.typeName = \"livekit.DataPacket\";\nDataPacket.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"kind\",\n            kind: \"enum\",\n            T: proto3.getEnumType(DataPacket_Kind)\n        },\n        {\n            no: 2,\n            name: \"user\",\n            kind: \"message\",\n            T: UserPacket,\n            oneof: \"value\"\n        },\n        {\n            no: 3,\n            name: \"speaker\",\n            kind: \"message\",\n            T: ActiveSpeakerUpdate,\n            oneof: \"value\"\n        }\n    ]);\n/**\n * @generated from enum livekit.DataPacket.Kind\n */ var DataPacket_Kind;\n(function(DataPacket_Kind) {\n    /**\n   * @generated from enum value: RELIABLE = 0;\n   */ DataPacket_Kind[DataPacket_Kind[\"RELIABLE\"] = 0] = \"RELIABLE\";\n    /**\n   * @generated from enum value: LOSSY = 1;\n   */ DataPacket_Kind[DataPacket_Kind[\"LOSSY\"] = 1] = \"LOSSY\";\n})(DataPacket_Kind || (DataPacket_Kind = {}));\n// Retrieve enum metadata with: proto3.getEnumType(DataPacket_Kind)\nproto3.util.setEnumType(DataPacket_Kind, \"livekit.DataPacket.Kind\", [\n    {\n        no: 0,\n        name: \"RELIABLE\"\n    },\n    {\n        no: 1,\n        name: \"LOSSY\"\n    }\n]);\n/**\n * @generated from message livekit.ActiveSpeakerUpdate\n */ class ActiveSpeakerUpdate extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated livekit.SpeakerInfo speakers = 1;\n     */ this.speakers = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ActiveSpeakerUpdate().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ActiveSpeakerUpdate().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ActiveSpeakerUpdate().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ActiveSpeakerUpdate, a, b);\n    }\n}\nActiveSpeakerUpdate.runtime = proto3;\nActiveSpeakerUpdate.typeName = \"livekit.ActiveSpeakerUpdate\";\nActiveSpeakerUpdate.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"speakers\",\n            kind: \"message\",\n            T: SpeakerInfo,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.SpeakerInfo\n */ class SpeakerInfo extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string sid = 1;\n     */ this.sid = \"\";\n        /**\n     * audio level, 0-1.0, 1 is loudest\n     *\n     * @generated from field: float level = 2;\n     */ this.level = 0;\n        /**\n     * true if speaker is currently active\n     *\n     * @generated from field: bool active = 3;\n     */ this.active = false;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SpeakerInfo().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SpeakerInfo().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SpeakerInfo().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SpeakerInfo, a, b);\n    }\n}\nSpeakerInfo.runtime = proto3;\nSpeakerInfo.typeName = \"livekit.SpeakerInfo\";\nSpeakerInfo.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"level\",\n            kind: \"scalar\",\n            T: 2 /* ScalarType.FLOAT */ \n        },\n        {\n            no: 3,\n            name: \"active\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        }\n    ]);\n/**\n * @generated from message livekit.UserPacket\n */ class UserPacket extends Message {\n    constructor(data){\n        super();\n        /**\n     * participant ID of user that sent the message\n     *\n     * @generated from field: string participant_sid = 1;\n     */ this.participantSid = \"\";\n        /**\n     * @generated from field: string participant_identity = 5;\n     */ this.participantIdentity = \"\";\n        /**\n     * user defined payload\n     *\n     * @generated from field: bytes payload = 2;\n     */ this.payload = new Uint8Array(0);\n        /**\n     * the ID of the participants who will receive the message (sent to all by default)\n     *\n     * @generated from field: repeated string destination_sids = 3;\n     */ this.destinationSids = [];\n        /**\n     * identities of participants who will receive the message (sent to all by default)\n     *\n     * @generated from field: repeated string destination_identities = 6;\n     */ this.destinationIdentities = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new UserPacket().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new UserPacket().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new UserPacket().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(UserPacket, a, b);\n    }\n}\nUserPacket.runtime = proto3;\nUserPacket.typeName = \"livekit.UserPacket\";\nUserPacket.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"participant_sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 5,\n            name: \"participant_identity\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"payload\",\n            kind: \"scalar\",\n            T: 12 /* ScalarType.BYTES */ \n        },\n        {\n            no: 3,\n            name: \"destination_sids\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ ,\n            repeated: true\n        },\n        {\n            no: 6,\n            name: \"destination_identities\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ ,\n            repeated: true\n        },\n        {\n            no: 4,\n            name: \"topic\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ ,\n            opt: true\n        }\n    ]);\n/**\n * @generated from message livekit.ParticipantTracks\n */ class ParticipantTracks extends Message {\n    constructor(data){\n        super();\n        /**\n     * participant ID of participant to whom the tracks belong\n     *\n     * @generated from field: string participant_sid = 1;\n     */ this.participantSid = \"\";\n        /**\n     * @generated from field: repeated string track_sids = 2;\n     */ this.trackSids = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ParticipantTracks().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ParticipantTracks().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ParticipantTracks().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ParticipantTracks, a, b);\n    }\n}\nParticipantTracks.runtime = proto3;\nParticipantTracks.typeName = \"livekit.ParticipantTracks\";\nParticipantTracks.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"participant_sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"track_sids\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ ,\n            repeated: true\n        }\n    ]);\n/**\n * details about the server\n *\n * @generated from message livekit.ServerInfo\n */ class ServerInfo extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: livekit.ServerInfo.Edition edition = 1;\n     */ this.edition = ServerInfo_Edition.Standard;\n        /**\n     * @generated from field: string version = 2;\n     */ this.version = \"\";\n        /**\n     * @generated from field: int32 protocol = 3;\n     */ this.protocol = 0;\n        /**\n     * @generated from field: string region = 4;\n     */ this.region = \"\";\n        /**\n     * @generated from field: string node_id = 5;\n     */ this.nodeId = \"\";\n        /**\n     * additional debugging information. sent only if server is in development mode\n     *\n     * @generated from field: string debug_info = 6;\n     */ this.debugInfo = \"\";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ServerInfo().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ServerInfo().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ServerInfo().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ServerInfo, a, b);\n    }\n}\nServerInfo.runtime = proto3;\nServerInfo.typeName = \"livekit.ServerInfo\";\nServerInfo.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"edition\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ServerInfo_Edition)\n        },\n        {\n            no: 2,\n            name: \"version\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 3,\n            name: \"protocol\",\n            kind: \"scalar\",\n            T: 5 /* ScalarType.INT32 */ \n        },\n        {\n            no: 4,\n            name: \"region\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 5,\n            name: \"node_id\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 6,\n            name: \"debug_info\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * @generated from enum livekit.ServerInfo.Edition\n */ var ServerInfo_Edition;\n(function(ServerInfo_Edition) {\n    /**\n   * @generated from enum value: Standard = 0;\n   */ ServerInfo_Edition[ServerInfo_Edition[\"Standard\"] = 0] = \"Standard\";\n    /**\n   * @generated from enum value: Cloud = 1;\n   */ ServerInfo_Edition[ServerInfo_Edition[\"Cloud\"] = 1] = \"Cloud\";\n})(ServerInfo_Edition || (ServerInfo_Edition = {}));\n// Retrieve enum metadata with: proto3.getEnumType(ServerInfo_Edition)\nproto3.util.setEnumType(ServerInfo_Edition, \"livekit.ServerInfo.Edition\", [\n    {\n        no: 0,\n        name: \"Standard\"\n    },\n    {\n        no: 1,\n        name: \"Cloud\"\n    }\n]);\n/**\n * details about the client\n *\n * @generated from message livekit.ClientInfo\n */ class ClientInfo extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: livekit.ClientInfo.SDK sdk = 1;\n     */ this.sdk = ClientInfo_SDK.UNKNOWN;\n        /**\n     * @generated from field: string version = 2;\n     */ this.version = \"\";\n        /**\n     * @generated from field: int32 protocol = 3;\n     */ this.protocol = 0;\n        /**\n     * @generated from field: string os = 4;\n     */ this.os = \"\";\n        /**\n     * @generated from field: string os_version = 5;\n     */ this.osVersion = \"\";\n        /**\n     * @generated from field: string device_model = 6;\n     */ this.deviceModel = \"\";\n        /**\n     * @generated from field: string browser = 7;\n     */ this.browser = \"\";\n        /**\n     * @generated from field: string browser_version = 8;\n     */ this.browserVersion = \"\";\n        /**\n     * @generated from field: string address = 9;\n     */ this.address = \"\";\n        /**\n     * wifi, wired, cellular, vpn, empty if not known\n     *\n     * @generated from field: string network = 10;\n     */ this.network = \"\";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ClientInfo().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ClientInfo().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ClientInfo().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ClientInfo, a, b);\n    }\n}\nClientInfo.runtime = proto3;\nClientInfo.typeName = \"livekit.ClientInfo\";\nClientInfo.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"sdk\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ClientInfo_SDK)\n        },\n        {\n            no: 2,\n            name: \"version\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 3,\n            name: \"protocol\",\n            kind: \"scalar\",\n            T: 5 /* ScalarType.INT32 */ \n        },\n        {\n            no: 4,\n            name: \"os\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 5,\n            name: \"os_version\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 6,\n            name: \"device_model\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 7,\n            name: \"browser\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 8,\n            name: \"browser_version\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 9,\n            name: \"address\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 10,\n            name: \"network\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * @generated from enum livekit.ClientInfo.SDK\n */ var ClientInfo_SDK;\n(function(ClientInfo_SDK) {\n    /**\n   * @generated from enum value: UNKNOWN = 0;\n   */ ClientInfo_SDK[ClientInfo_SDK[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n    /**\n   * @generated from enum value: JS = 1;\n   */ ClientInfo_SDK[ClientInfo_SDK[\"JS\"] = 1] = \"JS\";\n    /**\n   * @generated from enum value: SWIFT = 2;\n   */ ClientInfo_SDK[ClientInfo_SDK[\"SWIFT\"] = 2] = \"SWIFT\";\n    /**\n   * @generated from enum value: ANDROID = 3;\n   */ ClientInfo_SDK[ClientInfo_SDK[\"ANDROID\"] = 3] = \"ANDROID\";\n    /**\n   * @generated from enum value: FLUTTER = 4;\n   */ ClientInfo_SDK[ClientInfo_SDK[\"FLUTTER\"] = 4] = \"FLUTTER\";\n    /**\n   * @generated from enum value: GO = 5;\n   */ ClientInfo_SDK[ClientInfo_SDK[\"GO\"] = 5] = \"GO\";\n    /**\n   * @generated from enum value: UNITY = 6;\n   */ ClientInfo_SDK[ClientInfo_SDK[\"UNITY\"] = 6] = \"UNITY\";\n    /**\n   * @generated from enum value: REACT_NATIVE = 7;\n   */ ClientInfo_SDK[ClientInfo_SDK[\"REACT_NATIVE\"] = 7] = \"REACT_NATIVE\";\n    /**\n   * @generated from enum value: RUST = 8;\n   */ ClientInfo_SDK[ClientInfo_SDK[\"RUST\"] = 8] = \"RUST\";\n    /**\n   * @generated from enum value: PYTHON = 9;\n   */ ClientInfo_SDK[ClientInfo_SDK[\"PYTHON\"] = 9] = \"PYTHON\";\n    /**\n   * @generated from enum value: CPP = 10;\n   */ ClientInfo_SDK[ClientInfo_SDK[\"CPP\"] = 10] = \"CPP\";\n})(ClientInfo_SDK || (ClientInfo_SDK = {}));\n// Retrieve enum metadata with: proto3.getEnumType(ClientInfo_SDK)\nproto3.util.setEnumType(ClientInfo_SDK, \"livekit.ClientInfo.SDK\", [\n    {\n        no: 0,\n        name: \"UNKNOWN\"\n    },\n    {\n        no: 1,\n        name: \"JS\"\n    },\n    {\n        no: 2,\n        name: \"SWIFT\"\n    },\n    {\n        no: 3,\n        name: \"ANDROID\"\n    },\n    {\n        no: 4,\n        name: \"FLUTTER\"\n    },\n    {\n        no: 5,\n        name: \"GO\"\n    },\n    {\n        no: 6,\n        name: \"UNITY\"\n    },\n    {\n        no: 7,\n        name: \"REACT_NATIVE\"\n    },\n    {\n        no: 8,\n        name: \"RUST\"\n    },\n    {\n        no: 9,\n        name: \"PYTHON\"\n    },\n    {\n        no: 10,\n        name: \"CPP\"\n    }\n]);\n/**\n * server provided client configuration\n *\n * @generated from message livekit.ClientConfiguration\n */ class ClientConfiguration extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: livekit.ClientConfigSetting resume_connection = 3;\n     */ this.resumeConnection = ClientConfigSetting.UNSET;\n        /**\n     * @generated from field: livekit.ClientConfigSetting force_relay = 5;\n     */ this.forceRelay = ClientConfigSetting.UNSET;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ClientConfiguration().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ClientConfiguration().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ClientConfiguration().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ClientConfiguration, a, b);\n    }\n}\nClientConfiguration.runtime = proto3;\nClientConfiguration.typeName = \"livekit.ClientConfiguration\";\nClientConfiguration.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"video\",\n            kind: \"message\",\n            T: VideoConfiguration\n        },\n        {\n            no: 2,\n            name: \"screen\",\n            kind: \"message\",\n            T: VideoConfiguration\n        },\n        {\n            no: 3,\n            name: \"resume_connection\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ClientConfigSetting)\n        },\n        {\n            no: 4,\n            name: \"disabled_codecs\",\n            kind: \"message\",\n            T: DisabledCodecs\n        },\n        {\n            no: 5,\n            name: \"force_relay\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ClientConfigSetting)\n        }\n    ]);\n/**\n * @generated from message livekit.VideoConfiguration\n */ class VideoConfiguration extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: livekit.ClientConfigSetting hardware_encoder = 1;\n     */ this.hardwareEncoder = ClientConfigSetting.UNSET;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new VideoConfiguration().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new VideoConfiguration().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new VideoConfiguration().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(VideoConfiguration, a, b);\n    }\n}\nVideoConfiguration.runtime = proto3;\nVideoConfiguration.typeName = \"livekit.VideoConfiguration\";\nVideoConfiguration.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"hardware_encoder\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ClientConfigSetting)\n        }\n    ]);\n/**\n * @generated from message livekit.DisabledCodecs\n */ class DisabledCodecs extends Message {\n    constructor(data){\n        super();\n        /**\n     * disabled for both publish and subscribe\n     *\n     * @generated from field: repeated livekit.Codec codecs = 1;\n     */ this.codecs = [];\n        /**\n     * only disable for publish\n     *\n     * @generated from field: repeated livekit.Codec publish = 2;\n     */ this.publish = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new DisabledCodecs().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new DisabledCodecs().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new DisabledCodecs().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(DisabledCodecs, a, b);\n    }\n}\nDisabledCodecs.runtime = proto3;\nDisabledCodecs.typeName = \"livekit.DisabledCodecs\";\nDisabledCodecs.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"codecs\",\n            kind: \"message\",\n            T: Codec,\n            repeated: true\n        },\n        {\n            no: 2,\n            name: \"publish\",\n            kind: \"message\",\n            T: Codec,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.RTPDrift\n */ class RTPDrift extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: double duration = 3;\n     */ this.duration = 0;\n        /**\n     * @generated from field: uint64 start_timestamp = 4;\n     */ this.startTimestamp = protoInt64.zero;\n        /**\n     * @generated from field: uint64 end_timestamp = 5;\n     */ this.endTimestamp = protoInt64.zero;\n        /**\n     * @generated from field: uint64 rtp_clock_ticks = 6;\n     */ this.rtpClockTicks = protoInt64.zero;\n        /**\n     * @generated from field: int64 drift_samples = 7;\n     */ this.driftSamples = protoInt64.zero;\n        /**\n     * @generated from field: double drift_ms = 8;\n     */ this.driftMs = 0;\n        /**\n     * @generated from field: double clock_rate = 9;\n     */ this.clockRate = 0;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new RTPDrift().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new RTPDrift().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new RTPDrift().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(RTPDrift, a, b);\n    }\n}\nRTPDrift.runtime = proto3;\nRTPDrift.typeName = \"livekit.RTPDrift\";\nRTPDrift.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"start_time\",\n            kind: \"message\",\n            T: Timestamp\n        },\n        {\n            no: 2,\n            name: \"end_time\",\n            kind: \"message\",\n            T: Timestamp\n        },\n        {\n            no: 3,\n            name: \"duration\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 4,\n            name: \"start_timestamp\",\n            kind: \"scalar\",\n            T: 4 /* ScalarType.UINT64 */ \n        },\n        {\n            no: 5,\n            name: \"end_timestamp\",\n            kind: \"scalar\",\n            T: 4 /* ScalarType.UINT64 */ \n        },\n        {\n            no: 6,\n            name: \"rtp_clock_ticks\",\n            kind: \"scalar\",\n            T: 4 /* ScalarType.UINT64 */ \n        },\n        {\n            no: 7,\n            name: \"drift_samples\",\n            kind: \"scalar\",\n            T: 3 /* ScalarType.INT64 */ \n        },\n        {\n            no: 8,\n            name: \"drift_ms\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 9,\n            name: \"clock_rate\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ \n        }\n    ]);\n/**\n * @generated from message livekit.RTPStats\n */ class RTPStats extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: double duration = 3;\n     */ this.duration = 0;\n        /**\n     * @generated from field: uint32 packets = 4;\n     */ this.packets = 0;\n        /**\n     * @generated from field: double packet_rate = 5;\n     */ this.packetRate = 0;\n        /**\n     * @generated from field: uint64 bytes = 6;\n     */ this.bytes = protoInt64.zero;\n        /**\n     * @generated from field: uint64 header_bytes = 39;\n     */ this.headerBytes = protoInt64.zero;\n        /**\n     * @generated from field: double bitrate = 7;\n     */ this.bitrate = 0;\n        /**\n     * @generated from field: uint32 packets_lost = 8;\n     */ this.packetsLost = 0;\n        /**\n     * @generated from field: double packet_loss_rate = 9;\n     */ this.packetLossRate = 0;\n        /**\n     * @generated from field: float packet_loss_percentage = 10;\n     */ this.packetLossPercentage = 0;\n        /**\n     * @generated from field: uint32 packets_duplicate = 11;\n     */ this.packetsDuplicate = 0;\n        /**\n     * @generated from field: double packet_duplicate_rate = 12;\n     */ this.packetDuplicateRate = 0;\n        /**\n     * @generated from field: uint64 bytes_duplicate = 13;\n     */ this.bytesDuplicate = protoInt64.zero;\n        /**\n     * @generated from field: uint64 header_bytes_duplicate = 40;\n     */ this.headerBytesDuplicate = protoInt64.zero;\n        /**\n     * @generated from field: double bitrate_duplicate = 14;\n     */ this.bitrateDuplicate = 0;\n        /**\n     * @generated from field: uint32 packets_padding = 15;\n     */ this.packetsPadding = 0;\n        /**\n     * @generated from field: double packet_padding_rate = 16;\n     */ this.packetPaddingRate = 0;\n        /**\n     * @generated from field: uint64 bytes_padding = 17;\n     */ this.bytesPadding = protoInt64.zero;\n        /**\n     * @generated from field: uint64 header_bytes_padding = 41;\n     */ this.headerBytesPadding = protoInt64.zero;\n        /**\n     * @generated from field: double bitrate_padding = 18;\n     */ this.bitratePadding = 0;\n        /**\n     * @generated from field: uint32 packets_out_of_order = 19;\n     */ this.packetsOutOfOrder = 0;\n        /**\n     * @generated from field: uint32 frames = 20;\n     */ this.frames = 0;\n        /**\n     * @generated from field: double frame_rate = 21;\n     */ this.frameRate = 0;\n        /**\n     * @generated from field: double jitter_current = 22;\n     */ this.jitterCurrent = 0;\n        /**\n     * @generated from field: double jitter_max = 23;\n     */ this.jitterMax = 0;\n        /**\n     * @generated from field: map<int32, uint32> gap_histogram = 24;\n     */ this.gapHistogram = {};\n        /**\n     * @generated from field: uint32 nacks = 25;\n     */ this.nacks = 0;\n        /**\n     * @generated from field: uint32 nack_acks = 37;\n     */ this.nackAcks = 0;\n        /**\n     * @generated from field: uint32 nack_misses = 26;\n     */ this.nackMisses = 0;\n        /**\n     * @generated from field: uint32 nack_repeated = 38;\n     */ this.nackRepeated = 0;\n        /**\n     * @generated from field: uint32 plis = 27;\n     */ this.plis = 0;\n        /**\n     * @generated from field: uint32 firs = 29;\n     */ this.firs = 0;\n        /**\n     * @generated from field: uint32 rtt_current = 31;\n     */ this.rttCurrent = 0;\n        /**\n     * @generated from field: uint32 rtt_max = 32;\n     */ this.rttMax = 0;\n        /**\n     * @generated from field: uint32 key_frames = 33;\n     */ this.keyFrames = 0;\n        /**\n     * @generated from field: uint32 layer_lock_plis = 35;\n     */ this.layerLockPlis = 0;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new RTPStats().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new RTPStats().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new RTPStats().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(RTPStats, a, b);\n    }\n}\nRTPStats.runtime = proto3;\nRTPStats.typeName = \"livekit.RTPStats\";\nRTPStats.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"start_time\",\n            kind: \"message\",\n            T: Timestamp\n        },\n        {\n            no: 2,\n            name: \"end_time\",\n            kind: \"message\",\n            T: Timestamp\n        },\n        {\n            no: 3,\n            name: \"duration\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 4,\n            name: \"packets\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 5,\n            name: \"packet_rate\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 6,\n            name: \"bytes\",\n            kind: \"scalar\",\n            T: 4 /* ScalarType.UINT64 */ \n        },\n        {\n            no: 39,\n            name: \"header_bytes\",\n            kind: \"scalar\",\n            T: 4 /* ScalarType.UINT64 */ \n        },\n        {\n            no: 7,\n            name: \"bitrate\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 8,\n            name: \"packets_lost\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 9,\n            name: \"packet_loss_rate\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 10,\n            name: \"packet_loss_percentage\",\n            kind: \"scalar\",\n            T: 2 /* ScalarType.FLOAT */ \n        },\n        {\n            no: 11,\n            name: \"packets_duplicate\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 12,\n            name: \"packet_duplicate_rate\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 13,\n            name: \"bytes_duplicate\",\n            kind: \"scalar\",\n            T: 4 /* ScalarType.UINT64 */ \n        },\n        {\n            no: 40,\n            name: \"header_bytes_duplicate\",\n            kind: \"scalar\",\n            T: 4 /* ScalarType.UINT64 */ \n        },\n        {\n            no: 14,\n            name: \"bitrate_duplicate\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 15,\n            name: \"packets_padding\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 16,\n            name: \"packet_padding_rate\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 17,\n            name: \"bytes_padding\",\n            kind: \"scalar\",\n            T: 4 /* ScalarType.UINT64 */ \n        },\n        {\n            no: 41,\n            name: \"header_bytes_padding\",\n            kind: \"scalar\",\n            T: 4 /* ScalarType.UINT64 */ \n        },\n        {\n            no: 18,\n            name: \"bitrate_padding\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 19,\n            name: \"packets_out_of_order\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 20,\n            name: \"frames\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 21,\n            name: \"frame_rate\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 22,\n            name: \"jitter_current\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 23,\n            name: \"jitter_max\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 24,\n            name: \"gap_histogram\",\n            kind: \"map\",\n            K: 5 /* ScalarType.INT32 */ ,\n            V: {\n                kind: \"scalar\",\n                T: 13 /* ScalarType.UINT32 */ \n            }\n        },\n        {\n            no: 25,\n            name: \"nacks\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 37,\n            name: \"nack_acks\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 26,\n            name: \"nack_misses\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 38,\n            name: \"nack_repeated\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 27,\n            name: \"plis\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 28,\n            name: \"last_pli\",\n            kind: \"message\",\n            T: Timestamp\n        },\n        {\n            no: 29,\n            name: \"firs\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 30,\n            name: \"last_fir\",\n            kind: \"message\",\n            T: Timestamp\n        },\n        {\n            no: 31,\n            name: \"rtt_current\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 32,\n            name: \"rtt_max\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 33,\n            name: \"key_frames\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 34,\n            name: \"last_key_frame\",\n            kind: \"message\",\n            T: Timestamp\n        },\n        {\n            no: 35,\n            name: \"layer_lock_plis\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 36,\n            name: \"last_layer_lock_pli\",\n            kind: \"message\",\n            T: Timestamp\n        },\n        {\n            no: 44,\n            name: \"packet_drift\",\n            kind: \"message\",\n            T: RTPDrift\n        },\n        {\n            no: 45,\n            name: \"report_drift\",\n            kind: \"message\",\n            T: RTPDrift\n        }\n    ]);\n/**\n * @generated from message livekit.TimedVersion\n */ class TimedVersion extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: int64 unix_micro = 1;\n     */ this.unixMicro = protoInt64.zero;\n        /**\n     * @generated from field: int32 ticks = 2;\n     */ this.ticks = 0;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new TimedVersion().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new TimedVersion().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new TimedVersion().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(TimedVersion, a, b);\n    }\n}\nTimedVersion.runtime = proto3;\nTimedVersion.typeName = \"livekit.TimedVersion\";\nTimedVersion.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"unix_micro\",\n            kind: \"scalar\",\n            T: 3 /* ScalarType.INT64 */ \n        },\n        {\n            no: 2,\n            name: \"ticks\",\n            kind: \"scalar\",\n            T: 5 /* ScalarType.INT32 */ \n        }\n    ]);\nconst maxRetryDelay = 7000;\nconst DEFAULT_RETRY_DELAYS_IN_MS = [\n    0,\n    300,\n    2 * 2 * 300,\n    3 * 3 * 300,\n    4 * 4 * 300,\n    maxRetryDelay,\n    maxRetryDelay,\n    maxRetryDelay,\n    maxRetryDelay,\n    maxRetryDelay\n];\nclass DefaultReconnectPolicy {\n    constructor(retryDelays){\n        this._retryDelays = retryDelays !== undefined ? [\n            ...retryDelays\n        ] : DEFAULT_RETRY_DELAYS_IN_MS;\n    }\n    nextRetryDelayInMs(context) {\n        if (context.retryCount >= this._retryDelays.length) return null;\n        const retryDelay = this._retryDelays[context.retryCount];\n        if (context.retryCount <= 1) return retryDelay;\n        return retryDelay + Math.random() * 1000;\n    }\n}\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ /* global Reflect, Promise, SuppressedError, Symbol */ function __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\nfunction __values(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function() {\n            if (o && i >= o.length) o = void 0;\n            return {\n                value: o && o[i++],\n                done: !o\n            };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nfunction __asyncValues(o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i);\n    function verb(n) {\n        i[n] = o[n] && function(v) {\n            return new Promise(function(resolve, reject) {\n                v = o[n](v), settle(resolve, reject, v.done, v.value);\n            });\n        };\n    }\n    function settle(resolve, reject, d, v) {\n        Promise.resolve(v).then(function(v) {\n            resolve({\n                value: v,\n                done: d\n            });\n        }, reject);\n    }\n}\ntypeof SuppressedError === \"function\" ? SuppressedError : function(error, suppressed, message) {\n    var e = new Error(message);\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\nvar events = {\n    exports: {}\n};\nvar R = typeof Reflect === 'object' ? Reflect : null;\nvar ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n};\nvar ReflectOwnKeys;\nif (R && typeof R.ownKeys === 'function') {\n    ReflectOwnKeys = R.ownKeys;\n} else if (Object.getOwnPropertySymbols) {\n    ReflectOwnKeys = function ReflectOwnKeys(target) {\n        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));\n    };\n} else {\n    ReflectOwnKeys = function ReflectOwnKeys(target) {\n        return Object.getOwnPropertyNames(target);\n    };\n}\nfunction ProcessEmitWarning(warning) {\n    if (console && console.warn) console.warn(warning);\n}\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n    return value !== value;\n};\nfunction EventEmitter() {\n    EventEmitter.init.call(this);\n}\nevents.exports = EventEmitter;\nevents.exports.once = once;\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\nfunction checkListener(listener) {\n    if (typeof listener !== 'function') {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n    }\n}\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n    enumerable: true,\n    get: function() {\n        return defaultMaxListeners;\n    },\n    set: function(arg) {\n        if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n            throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n        }\n        defaultMaxListeners = arg;\n    }\n});\nEventEmitter.init = function() {\n    if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n    }\n    this._maxListeners = this._maxListeners || undefined;\n};\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n    if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n        throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n    }\n    this._maxListeners = n;\n    return this;\n};\nfunction _getMaxListeners(that) {\n    if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;\n    return that._maxListeners;\n}\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n    return _getMaxListeners(this);\n};\nEventEmitter.prototype.emit = function emit(type) {\n    var args = [];\n    for(var i = 1; i < arguments.length; i++)args.push(arguments[i]);\n    var doError = type === 'error';\n    var events = this._events;\n    if (events !== undefined) doError = doError && events.error === undefined;\n    else if (!doError) return false;\n    // If there is no 'error' event listener then throw.\n    if (doError) {\n        var er;\n        if (args.length > 0) er = args[0];\n        if (er instanceof Error) {\n            // Note: The comments on the `throw` lines are intentional, they show\n            // up in Node's output if this results in an unhandled exception.\n            throw er; // Unhandled 'error' event\n        }\n        // At least give some kind of context to the user\n        var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n        err.context = er;\n        throw err; // Unhandled 'error' event\n    }\n    var handler = events[type];\n    if (handler === undefined) return false;\n    if (typeof handler === 'function') {\n        ReflectApply(handler, this, args);\n    } else {\n        var len = handler.length;\n        var listeners = arrayClone(handler, len);\n        for(var i = 0; i < len; ++i)ReflectApply(listeners[i], this, args);\n    }\n    return true;\n};\nfunction _addListener(target, type, listener, prepend) {\n    var m;\n    var events;\n    var existing;\n    checkListener(listener);\n    events = target._events;\n    if (events === undefined) {\n        events = target._events = Object.create(null);\n        target._eventsCount = 0;\n    } else {\n        // To avoid recursion in the case that type === \"newListener\"! Before\n        // adding it to the listeners, first emit \"newListener\".\n        if (events.newListener !== undefined) {\n            target.emit('newListener', type, listener.listener ? listener.listener : listener);\n            // Re-assign `events` because a newListener handler could have caused the\n            // this._events to be assigned to a new object\n            events = target._events;\n        }\n        existing = events[type];\n    }\n    if (existing === undefined) {\n        // Optimize the case of one listener. Don't need the extra array object.\n        existing = events[type] = listener;\n        ++target._eventsCount;\n    } else {\n        if (typeof existing === 'function') {\n            // Adding the second element, need to change to array.\n            existing = events[type] = prepend ? [\n                listener,\n                existing\n            ] : [\n                existing,\n                listener\n            ];\n        // If we've already got an array, just append.\n        } else if (prepend) {\n            existing.unshift(listener);\n        } else {\n            existing.push(listener);\n        }\n        // Check for listener leak\n        m = _getMaxListeners(target);\n        if (m > 0 && existing.length > m && !existing.warned) {\n            existing.warned = true;\n            // No error code for this since it is a Warning\n            // eslint-disable-next-line no-restricted-syntax\n            var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');\n            w.name = 'MaxListenersExceededWarning';\n            w.emitter = target;\n            w.type = type;\n            w.count = existing.length;\n            ProcessEmitWarning(w);\n        }\n    }\n    return target;\n}\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n    return _addListener(this, type, listener, false);\n};\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\nEventEmitter.prototype.prependListener = function prependListener(type, listener) {\n    return _addListener(this, type, listener, true);\n};\nfunction onceWrapper() {\n    if (!this.fired) {\n        this.target.removeListener(this.type, this.wrapFn);\n        this.fired = true;\n        if (arguments.length === 0) return this.listener.call(this.target);\n        return this.listener.apply(this.target, arguments);\n    }\n}\nfunction _onceWrap(target, type, listener) {\n    var state = {\n        fired: false,\n        wrapFn: undefined,\n        target: target,\n        type: type,\n        listener: listener\n    };\n    var wrapped = onceWrapper.bind(state);\n    wrapped.listener = listener;\n    state.wrapFn = wrapped;\n    return wrapped;\n}\nEventEmitter.prototype.once = function once(type, listener) {\n    checkListener(listener);\n    this.on(type, _onceWrap(this, type, listener));\n    return this;\n};\nEventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {\n    checkListener(listener);\n    this.prependListener(type, _onceWrap(this, type, listener));\n    return this;\n};\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener = function removeListener(type, listener) {\n    var list, events, position, i, originalListener;\n    checkListener(listener);\n    events = this._events;\n    if (events === undefined) return this;\n    list = events[type];\n    if (list === undefined) return this;\n    if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0) this._events = Object.create(null);\n        else {\n            delete events[type];\n            if (events.removeListener) this.emit('removeListener', type, list.listener || listener);\n        }\n    } else if (typeof list !== 'function') {\n        position = -1;\n        for(i = list.length - 1; i >= 0; i--){\n            if (list[i] === listener || list[i].listener === listener) {\n                originalListener = list[i].listener;\n                position = i;\n                break;\n            }\n        }\n        if (position < 0) return this;\n        if (position === 0) list.shift();\n        else {\n            spliceOne(list, position);\n        }\n        if (list.length === 1) events[type] = list[0];\n        if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);\n    }\n    return this;\n};\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {\n    var listeners, events, i;\n    events = this._events;\n    if (events === undefined) return this;\n    // not listening for removeListener, no need to emit\n    if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n            this._events = Object.create(null);\n            this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n            if (--this._eventsCount === 0) this._events = Object.create(null);\n            else delete events[type];\n        }\n        return this;\n    }\n    // emit removeListener for all listeners on all events\n    if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for(i = 0; i < keys.length; ++i){\n            key = keys[i];\n            if (key === 'removeListener') continue;\n            this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n    }\n    listeners = events[type];\n    if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n    } else if (listeners !== undefined) {\n        // LIFO order\n        for(i = listeners.length - 1; i >= 0; i--){\n            this.removeListener(type, listeners[i]);\n        }\n    }\n    return this;\n};\nfunction _listeners(target, type, unwrap) {\n    var events = target._events;\n    if (events === undefined) return [];\n    var evlistener = events[type];\n    if (evlistener === undefined) return [];\n    if (typeof evlistener === 'function') return unwrap ? [\n        evlistener.listener || evlistener\n    ] : [\n        evlistener\n    ];\n    return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\nEventEmitter.prototype.listeners = function listeners(type) {\n    return _listeners(this, type, true);\n};\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n    return _listeners(this, type, false);\n};\nEventEmitter.listenerCount = function(emitter, type) {\n    if (typeof emitter.listenerCount === 'function') {\n        return emitter.listenerCount(type);\n    } else {\n        return listenerCount.call(emitter, type);\n    }\n};\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n    var events = this._events;\n    if (events !== undefined) {\n        var evlistener = events[type];\n        if (typeof evlistener === 'function') {\n            return 1;\n        } else if (evlistener !== undefined) {\n            return evlistener.length;\n        }\n    }\n    return 0;\n}\nEventEmitter.prototype.eventNames = function eventNames() {\n    return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\nfunction arrayClone(arr, n) {\n    var copy = new Array(n);\n    for(var i = 0; i < n; ++i)copy[i] = arr[i];\n    return copy;\n}\nfunction spliceOne(list, index) {\n    for(; index + 1 < list.length; index++)list[index] = list[index + 1];\n    list.pop();\n}\nfunction unwrapListeners(arr) {\n    var ret = new Array(arr.length);\n    for(var i = 0; i < ret.length; ++i){\n        ret[i] = arr[i].listener || arr[i];\n    }\n    return ret;\n}\nfunction once(emitter, name) {\n    return new Promise(function(resolve, reject) {\n        function errorListener(err) {\n            emitter.removeListener(name, resolver);\n            reject(err);\n        }\n        function resolver() {\n            if (typeof emitter.removeListener === 'function') {\n                emitter.removeListener('error', errorListener);\n            }\n            resolve([].slice.call(arguments));\n        }\n        eventTargetAgnosticAddListener(emitter, name, resolver, {\n            once: true\n        });\n        if (name !== 'error') {\n            addErrorHandlerIfEventEmitter(emitter, errorListener, {\n                once: true\n            });\n        }\n    });\n}\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n    if (typeof emitter.on === 'function') {\n        eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n    }\n}\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n    if (typeof emitter.on === 'function') {\n        if (flags.once) {\n            emitter.once(name, listener);\n        } else {\n            emitter.on(name, listener);\n        }\n    } else if (typeof emitter.addEventListener === 'function') {\n        // EventTarget does not have `error` event semantics like Node\n        // EventEmitters, we do not listen for `error` events here.\n        emitter.addEventListener(name, function wrapListener(arg) {\n            // IE does not have builtin `{ once: true }` support so we\n            // have to do it manually.\n            if (flags.once) {\n                emitter.removeEventListener(name, wrapListener);\n            }\n            listener(arg);\n        });\n    } else {\n        throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n    }\n}\nvar eventsExports = events.exports;\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ let logDisabled_ = true;\nlet deprecationWarnings_ = true;\n/**\n * Extract browser version out of the provided user agent string.\n *\n * @param {!string} uastring userAgent string.\n * @param {!string} expr Regular expression used as match criteria.\n * @param {!number} pos position in the version string to be returned.\n * @return {!number} browser version.\n */ function extractVersion(uastring, expr, pos) {\n    const match = uastring.match(expr);\n    return match && match.length >= pos && parseInt(match[pos], 10);\n}\n// Wraps the peerconnection event eventNameToWrap in a function\n// which returns the modified event object (or false to prevent\n// the event).\nfunction wrapPeerConnectionEvent(window1, eventNameToWrap, wrapper) {\n    if (!window1.RTCPeerConnection) {\n        return;\n    }\n    const proto = window1.RTCPeerConnection.prototype;\n    const nativeAddEventListener = proto.addEventListener;\n    proto.addEventListener = function(nativeEventName, cb) {\n        if (nativeEventName !== eventNameToWrap) {\n            return nativeAddEventListener.apply(this, arguments);\n        }\n        const wrappedCallback = (e)=>{\n            const modifiedEvent = wrapper(e);\n            if (modifiedEvent) {\n                if (cb.handleEvent) {\n                    cb.handleEvent(modifiedEvent);\n                } else {\n                    cb(modifiedEvent);\n                }\n            }\n        };\n        this._eventMap = this._eventMap || {};\n        if (!this._eventMap[eventNameToWrap]) {\n            this._eventMap[eventNameToWrap] = new Map();\n        }\n        this._eventMap[eventNameToWrap].set(cb, wrappedCallback);\n        return nativeAddEventListener.apply(this, [\n            nativeEventName,\n            wrappedCallback\n        ]);\n    };\n    const nativeRemoveEventListener = proto.removeEventListener;\n    proto.removeEventListener = function(nativeEventName, cb) {\n        if (nativeEventName !== eventNameToWrap || !this._eventMap || !this._eventMap[eventNameToWrap]) {\n            return nativeRemoveEventListener.apply(this, arguments);\n        }\n        if (!this._eventMap[eventNameToWrap].has(cb)) {\n            return nativeRemoveEventListener.apply(this, arguments);\n        }\n        const unwrappedCb = this._eventMap[eventNameToWrap].get(cb);\n        this._eventMap[eventNameToWrap].delete(cb);\n        if (this._eventMap[eventNameToWrap].size === 0) {\n            delete this._eventMap[eventNameToWrap];\n        }\n        if (Object.keys(this._eventMap).length === 0) {\n            delete this._eventMap;\n        }\n        return nativeRemoveEventListener.apply(this, [\n            nativeEventName,\n            unwrappedCb\n        ]);\n    };\n    Object.defineProperty(proto, 'on' + eventNameToWrap, {\n        get () {\n            return this['_on' + eventNameToWrap];\n        },\n        set (cb) {\n            if (this['_on' + eventNameToWrap]) {\n                this.removeEventListener(eventNameToWrap, this['_on' + eventNameToWrap]);\n                delete this['_on' + eventNameToWrap];\n            }\n            if (cb) {\n                this.addEventListener(eventNameToWrap, this['_on' + eventNameToWrap] = cb);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n}\nfunction disableLog(bool) {\n    if (typeof bool !== 'boolean') {\n        return new Error('Argument type: ' + typeof bool + '. Please use a boolean.');\n    }\n    logDisabled_ = bool;\n    return bool ? 'adapter.js logging disabled' : 'adapter.js logging enabled';\n}\n/**\n * Disable or enable deprecation warnings\n * @param {!boolean} bool set to true to disable warnings.\n */ function disableWarnings(bool) {\n    if (typeof bool !== 'boolean') {\n        return new Error('Argument type: ' + typeof bool + '. Please use a boolean.');\n    }\n    deprecationWarnings_ = !bool;\n    return 'adapter.js deprecation warnings ' + (bool ? 'disabled' : 'enabled');\n}\nfunction log() {\n    if (false) {}\n}\n/**\n * Shows a deprecation warning suggesting the modern and spec-compatible API.\n */ function deprecated(oldMethod, newMethod) {\n    if (!deprecationWarnings_) {\n        return;\n    }\n    console.warn(oldMethod + ' is deprecated, please use ' + newMethod + ' instead.');\n}\n/**\n * Browser detector.\n *\n * @return {object} result containing browser and version\n *     properties.\n */ function detectBrowser(window1) {\n    // Returned result object.\n    const result = {\n        browser: null,\n        version: null\n    };\n    // Fail early if it's not a browser\n    if (typeof window1 === 'undefined' || !window1.navigator || !window1.navigator.userAgent) {\n        result.browser = 'Not a browser.';\n        return result;\n    }\n    const { navigator: navigator1 } = window1;\n    if (navigator1.mozGetUserMedia) {\n        // Firefox.\n        result.browser = 'firefox';\n        result.version = extractVersion(navigator1.userAgent, /Firefox\\/(\\d+)\\./, 1);\n    } else if (navigator1.webkitGetUserMedia || window1.isSecureContext === false && window1.webkitRTCPeerConnection) {\n        // Chrome, Chromium, Webview, Opera.\n        // Version matches Chrome/WebRTC version.\n        // Chrome 74 removed webkitGetUserMedia on http as well so we need the\n        // more complicated fallback to webkitRTCPeerConnection.\n        result.browser = 'chrome';\n        result.version = extractVersion(navigator1.userAgent, /Chrom(e|ium)\\/(\\d+)\\./, 2);\n    } else if (window1.RTCPeerConnection && navigator1.userAgent.match(/AppleWebKit\\/(\\d+)\\./)) {\n        // Safari.\n        result.browser = 'safari';\n        result.version = extractVersion(navigator1.userAgent, /AppleWebKit\\/(\\d+)\\./, 1);\n        result.supportsUnifiedPlan = window1.RTCRtpTransceiver && 'currentDirection' in window1.RTCRtpTransceiver.prototype;\n    } else {\n        // Default fallthrough: not supported.\n        result.browser = 'Not a supported browser.';\n        return result;\n    }\n    return result;\n}\n/**\n * Checks if something is an object.\n *\n * @param {*} val The something you want to check.\n * @return true if val is an object, false otherwise.\n */ function isObject(val) {\n    return Object.prototype.toString.call(val) === '[object Object]';\n}\n/**\n * Remove all empty objects and undefined values\n * from a nested object -- an enhanced and vanilla version\n * of Lodash's `compact`.\n */ function compactObject(data) {\n    if (!isObject(data)) {\n        return data;\n    }\n    return Object.keys(data).reduce(function(accumulator, key) {\n        const isObj = isObject(data[key]);\n        const value = isObj ? compactObject(data[key]) : data[key];\n        const isEmptyObject = isObj && !Object.keys(value).length;\n        if (value === undefined || isEmptyObject) {\n            return accumulator;\n        }\n        return Object.assign(accumulator, {\n            [key]: value\n        });\n    }, {});\n}\n/* iterates the stats graph recursively. */ function walkStats(stats, base, resultSet) {\n    if (!base || resultSet.has(base.id)) {\n        return;\n    }\n    resultSet.set(base.id, base);\n    Object.keys(base).forEach((name)=>{\n        if (name.endsWith('Id')) {\n            walkStats(stats, stats.get(base[name]), resultSet);\n        } else if (name.endsWith('Ids')) {\n            base[name].forEach((id)=>{\n                walkStats(stats, stats.get(id), resultSet);\n            });\n        }\n    });\n}\n/* filter getStats for a sender/receiver track. */ function filterStats(result, track, outbound) {\n    const streamStatsType = outbound ? 'outbound-rtp' : 'inbound-rtp';\n    const filteredResult = new Map();\n    if (track === null) {\n        return filteredResult;\n    }\n    const trackStats = [];\n    result.forEach((value)=>{\n        if (value.type === 'track' && value.trackIdentifier === track.id) {\n            trackStats.push(value);\n        }\n    });\n    trackStats.forEach((trackStat)=>{\n        result.forEach((stats)=>{\n            if (stats.type === streamStatsType && stats.trackId === trackStat.id) {\n                walkStats(result, stats, filteredResult);\n            }\n        });\n    });\n    return filteredResult;\n}\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ const logging = log;\nfunction shimGetUserMedia$2(window1, browserDetails) {\n    const navigator1 = window1 && window1.navigator;\n    if (!navigator1.mediaDevices) {\n        return;\n    }\n    const constraintsToChrome_ = function(c) {\n        if (typeof c !== 'object' || c.mandatory || c.optional) {\n            return c;\n        }\n        const cc = {};\n        Object.keys(c).forEach((key)=>{\n            if (key === 'require' || key === 'advanced' || key === 'mediaSource') {\n                return;\n            }\n            const r = typeof c[key] === 'object' ? c[key] : {\n                ideal: c[key]\n            };\n            if (r.exact !== undefined && typeof r.exact === 'number') {\n                r.min = r.max = r.exact;\n            }\n            const oldname_ = function(prefix, name) {\n                if (prefix) {\n                    return prefix + name.charAt(0).toUpperCase() + name.slice(1);\n                }\n                return name === 'deviceId' ? 'sourceId' : name;\n            };\n            if (r.ideal !== undefined) {\n                cc.optional = cc.optional || [];\n                let oc = {};\n                if (typeof r.ideal === 'number') {\n                    oc[oldname_('min', key)] = r.ideal;\n                    cc.optional.push(oc);\n                    oc = {};\n                    oc[oldname_('max', key)] = r.ideal;\n                    cc.optional.push(oc);\n                } else {\n                    oc[oldname_('', key)] = r.ideal;\n                    cc.optional.push(oc);\n                }\n            }\n            if (r.exact !== undefined && typeof r.exact !== 'number') {\n                cc.mandatory = cc.mandatory || {};\n                cc.mandatory[oldname_('', key)] = r.exact;\n            } else {\n                [\n                    'min',\n                    'max'\n                ].forEach((mix)=>{\n                    if (r[mix] !== undefined) {\n                        cc.mandatory = cc.mandatory || {};\n                        cc.mandatory[oldname_(mix, key)] = r[mix];\n                    }\n                });\n            }\n        });\n        if (c.advanced) {\n            cc.optional = (cc.optional || []).concat(c.advanced);\n        }\n        return cc;\n    };\n    const shimConstraints_ = function(constraints, func) {\n        if (browserDetails.version >= 61) {\n            return func(constraints);\n        }\n        constraints = JSON.parse(JSON.stringify(constraints));\n        if (constraints && typeof constraints.audio === 'object') {\n            const remap = function(obj, a, b) {\n                if (a in obj && !(b in obj)) {\n                    obj[b] = obj[a];\n                    delete obj[a];\n                }\n            };\n            constraints = JSON.parse(JSON.stringify(constraints));\n            remap(constraints.audio, 'autoGainControl', 'googAutoGainControl');\n            remap(constraints.audio, 'noiseSuppression', 'googNoiseSuppression');\n            constraints.audio = constraintsToChrome_(constraints.audio);\n        }\n        if (constraints && typeof constraints.video === 'object') {\n            // Shim facingMode for mobile & surface pro.\n            let face = constraints.video.facingMode;\n            face = face && (typeof face === 'object' ? face : {\n                ideal: face\n            });\n            const getSupportedFacingModeLies = browserDetails.version < 66;\n            if (face && (face.exact === 'user' || face.exact === 'environment' || face.ideal === 'user' || face.ideal === 'environment') && !(navigator1.mediaDevices.getSupportedConstraints && navigator1.mediaDevices.getSupportedConstraints().facingMode && !getSupportedFacingModeLies)) {\n                delete constraints.video.facingMode;\n                let matches;\n                if (face.exact === 'environment' || face.ideal === 'environment') {\n                    matches = [\n                        'back',\n                        'rear'\n                    ];\n                } else if (face.exact === 'user' || face.ideal === 'user') {\n                    matches = [\n                        'front'\n                    ];\n                }\n                if (matches) {\n                    // Look for matches in label, or use last cam for back (typical).\n                    return navigator1.mediaDevices.enumerateDevices().then((devices)=>{\n                        devices = devices.filter((d)=>d.kind === 'videoinput');\n                        let dev = devices.find((d)=>matches.some((match)=>d.label.toLowerCase().includes(match)));\n                        if (!dev && devices.length && matches.includes('back')) {\n                            dev = devices[devices.length - 1]; // more likely the back cam\n                        }\n                        if (dev) {\n                            constraints.video.deviceId = face.exact ? {\n                                exact: dev.deviceId\n                            } : {\n                                ideal: dev.deviceId\n                            };\n                        }\n                        constraints.video = constraintsToChrome_(constraints.video);\n                        logging('chrome: ' + JSON.stringify(constraints));\n                        return func(constraints);\n                    });\n                }\n            }\n            constraints.video = constraintsToChrome_(constraints.video);\n        }\n        logging('chrome: ' + JSON.stringify(constraints));\n        return func(constraints);\n    };\n    const shimError_ = function(e) {\n        if (browserDetails.version >= 64) {\n            return e;\n        }\n        return {\n            name: ({\n                PermissionDeniedError: 'NotAllowedError',\n                PermissionDismissedError: 'NotAllowedError',\n                InvalidStateError: 'NotAllowedError',\n                DevicesNotFoundError: 'NotFoundError',\n                ConstraintNotSatisfiedError: 'OverconstrainedError',\n                TrackStartError: 'NotReadableError',\n                MediaDeviceFailedDueToShutdown: 'NotAllowedError',\n                MediaDeviceKillSwitchOn: 'NotAllowedError',\n                TabCaptureError: 'AbortError',\n                ScreenCaptureError: 'AbortError',\n                DeviceCaptureError: 'AbortError'\n            })[e.name] || e.name,\n            message: e.message,\n            constraint: e.constraint || e.constraintName,\n            toString () {\n                return this.name + (this.message && ': ') + this.message;\n            }\n        };\n    };\n    const getUserMedia_ = function(constraints, onSuccess, onError) {\n        shimConstraints_(constraints, (c)=>{\n            navigator1.webkitGetUserMedia(c, onSuccess, (e)=>{\n                if (onError) {\n                    onError(shimError_(e));\n                }\n            });\n        });\n    };\n    navigator1.getUserMedia = getUserMedia_.bind(navigator1);\n    // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia\n    // function which returns a Promise, it does not accept spec-style\n    // constraints.\n    if (navigator1.mediaDevices.getUserMedia) {\n        const origGetUserMedia = navigator1.mediaDevices.getUserMedia.bind(navigator1.mediaDevices);\n        navigator1.mediaDevices.getUserMedia = function(cs) {\n            return shimConstraints_(cs, (c)=>origGetUserMedia(c).then((stream)=>{\n                    if (c.audio && !stream.getAudioTracks().length || c.video && !stream.getVideoTracks().length) {\n                        stream.getTracks().forEach((track)=>{\n                            track.stop();\n                        });\n                        throw new DOMException('', 'NotFoundError');\n                    }\n                    return stream;\n                }, (e)=>Promise.reject(shimError_(e))));\n        };\n    }\n}\n/*\n *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ function shimGetDisplayMedia$1(window1, getSourceId) {\n    if (window1.navigator.mediaDevices && 'getDisplayMedia' in window1.navigator.mediaDevices) {\n        return;\n    }\n    if (!window1.navigator.mediaDevices) {\n        return;\n    }\n    // getSourceId is a function that returns a promise resolving with\n    // the sourceId of the screen/window/tab to be shared.\n    if (typeof getSourceId !== 'function') {\n        console.error('shimGetDisplayMedia: getSourceId argument is not ' + 'a function');\n        return;\n    }\n    window1.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {\n        return getSourceId(constraints).then((sourceId)=>{\n            const widthSpecified = constraints.video && constraints.video.width;\n            const heightSpecified = constraints.video && constraints.video.height;\n            const frameRateSpecified = constraints.video && constraints.video.frameRate;\n            constraints.video = {\n                mandatory: {\n                    chromeMediaSource: 'desktop',\n                    chromeMediaSourceId: sourceId,\n                    maxFrameRate: frameRateSpecified || 3\n                }\n            };\n            if (widthSpecified) {\n                constraints.video.mandatory.maxWidth = widthSpecified;\n            }\n            if (heightSpecified) {\n                constraints.video.mandatory.maxHeight = heightSpecified;\n            }\n            return window1.navigator.mediaDevices.getUserMedia(constraints);\n        });\n    };\n}\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ function shimMediaStream(window1) {\n    window1.MediaStream = window1.MediaStream || window1.webkitMediaStream;\n}\nfunction shimOnTrack$1(window1) {\n    if (typeof window1 === 'object' && window1.RTCPeerConnection && !('ontrack' in window1.RTCPeerConnection.prototype)) {\n        Object.defineProperty(window1.RTCPeerConnection.prototype, 'ontrack', {\n            get () {\n                return this._ontrack;\n            },\n            set (f) {\n                if (this._ontrack) {\n                    this.removeEventListener('track', this._ontrack);\n                }\n                this.addEventListener('track', this._ontrack = f);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        const origSetRemoteDescription = window1.RTCPeerConnection.prototype.setRemoteDescription;\n        window1.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n            if (!this._ontrackpoly) {\n                this._ontrackpoly = (e)=>{\n                    // onaddstream does not fire when a track is added to an existing\n                    // stream. But stream.onaddtrack is implemented so we use that.\n                    e.stream.addEventListener('addtrack', (te)=>{\n                        let receiver;\n                        if (window1.RTCPeerConnection.prototype.getReceivers) {\n                            receiver = this.getReceivers().find((r)=>r.track && r.track.id === te.track.id);\n                        } else {\n                            receiver = {\n                                track: te.track\n                            };\n                        }\n                        const event = new Event('track');\n                        event.track = te.track;\n                        event.receiver = receiver;\n                        event.transceiver = {\n                            receiver\n                        };\n                        event.streams = [\n                            e.stream\n                        ];\n                        this.dispatchEvent(event);\n                    });\n                    e.stream.getTracks().forEach((track)=>{\n                        let receiver;\n                        if (window1.RTCPeerConnection.prototype.getReceivers) {\n                            receiver = this.getReceivers().find((r)=>r.track && r.track.id === track.id);\n                        } else {\n                            receiver = {\n                                track\n                            };\n                        }\n                        const event = new Event('track');\n                        event.track = track;\n                        event.receiver = receiver;\n                        event.transceiver = {\n                            receiver\n                        };\n                        event.streams = [\n                            e.stream\n                        ];\n                        this.dispatchEvent(event);\n                    });\n                };\n                this.addEventListener('addstream', this._ontrackpoly);\n            }\n            return origSetRemoteDescription.apply(this, arguments);\n        };\n    } else {\n        // even if RTCRtpTransceiver is in window, it is only used and\n        // emitted in unified-plan. Unfortunately this means we need\n        // to unconditionally wrap the event.\n        wrapPeerConnectionEvent(window1, 'track', (e)=>{\n            if (!e.transceiver) {\n                Object.defineProperty(e, 'transceiver', {\n                    value: {\n                        receiver: e.receiver\n                    }\n                });\n            }\n            return e;\n        });\n    }\n}\nfunction shimGetSendersWithDtmf(window1) {\n    // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.\n    if (typeof window1 === 'object' && window1.RTCPeerConnection && !('getSenders' in window1.RTCPeerConnection.prototype) && 'createDTMFSender' in window1.RTCPeerConnection.prototype) {\n        const shimSenderWithDtmf = function(pc, track) {\n            return {\n                track,\n                get dtmf () {\n                    if (this._dtmf === undefined) {\n                        if (track.kind === 'audio') {\n                            this._dtmf = pc.createDTMFSender(track);\n                        } else {\n                            this._dtmf = null;\n                        }\n                    }\n                    return this._dtmf;\n                },\n                _pc: pc\n            };\n        };\n        // augment addTrack when getSenders is not available.\n        if (!window1.RTCPeerConnection.prototype.getSenders) {\n            window1.RTCPeerConnection.prototype.getSenders = function getSenders() {\n                this._senders = this._senders || [];\n                return this._senders.slice(); // return a copy of the internal state.\n            };\n            const origAddTrack = window1.RTCPeerConnection.prototype.addTrack;\n            window1.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\n                let sender = origAddTrack.apply(this, arguments);\n                if (!sender) {\n                    sender = shimSenderWithDtmf(this, track);\n                    this._senders.push(sender);\n                }\n                return sender;\n            };\n            const origRemoveTrack = window1.RTCPeerConnection.prototype.removeTrack;\n            window1.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n                origRemoveTrack.apply(this, arguments);\n                const idx = this._senders.indexOf(sender);\n                if (idx !== -1) {\n                    this._senders.splice(idx, 1);\n                }\n            };\n        }\n        const origAddStream = window1.RTCPeerConnection.prototype.addStream;\n        window1.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n            this._senders = this._senders || [];\n            origAddStream.apply(this, [\n                stream\n            ]);\n            stream.getTracks().forEach((track)=>{\n                this._senders.push(shimSenderWithDtmf(this, track));\n            });\n        };\n        const origRemoveStream = window1.RTCPeerConnection.prototype.removeStream;\n        window1.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n            this._senders = this._senders || [];\n            origRemoveStream.apply(this, [\n                stream\n            ]);\n            stream.getTracks().forEach((track)=>{\n                const sender = this._senders.find((s)=>s.track === track);\n                if (sender) {\n                    // remove sender\n                    this._senders.splice(this._senders.indexOf(sender), 1);\n                }\n            });\n        };\n    } else if (typeof window1 === 'object' && window1.RTCPeerConnection && 'getSenders' in window1.RTCPeerConnection.prototype && 'createDTMFSender' in window1.RTCPeerConnection.prototype && window1.RTCRtpSender && !('dtmf' in window1.RTCRtpSender.prototype)) {\n        const origGetSenders = window1.RTCPeerConnection.prototype.getSenders;\n        window1.RTCPeerConnection.prototype.getSenders = function getSenders() {\n            const senders = origGetSenders.apply(this, []);\n            senders.forEach((sender)=>sender._pc = this);\n            return senders;\n        };\n        Object.defineProperty(window1.RTCRtpSender.prototype, 'dtmf', {\n            get () {\n                if (this._dtmf === undefined) {\n                    if (this.track.kind === 'audio') {\n                        this._dtmf = this._pc.createDTMFSender(this.track);\n                    } else {\n                        this._dtmf = null;\n                    }\n                }\n                return this._dtmf;\n            }\n        });\n    }\n}\nfunction shimGetStats(window1) {\n    if (!window1.RTCPeerConnection) {\n        return;\n    }\n    const origGetStats = window1.RTCPeerConnection.prototype.getStats;\n    window1.RTCPeerConnection.prototype.getStats = function getStats() {\n        const [selector, onSucc, onErr] = arguments;\n        // If selector is a function then we are in the old style stats so just\n        // pass back the original getStats format to avoid breaking old users.\n        if (arguments.length > 0 && typeof selector === 'function') {\n            return origGetStats.apply(this, arguments);\n        }\n        // When spec-style getStats is supported, return those when called with\n        // either no arguments or the selector argument is null.\n        if (origGetStats.length === 0 && (arguments.length === 0 || typeof selector !== 'function')) {\n            return origGetStats.apply(this, []);\n        }\n        const fixChromeStats_ = function(response) {\n            const standardReport = {};\n            const reports = response.result();\n            reports.forEach((report)=>{\n                const standardStats = {\n                    id: report.id,\n                    timestamp: report.timestamp,\n                    type: {\n                        localcandidate: 'local-candidate',\n                        remotecandidate: 'remote-candidate'\n                    }[report.type] || report.type\n                };\n                report.names().forEach((name)=>{\n                    standardStats[name] = report.stat(name);\n                });\n                standardReport[standardStats.id] = standardStats;\n            });\n            return standardReport;\n        };\n        // shim getStats with maplike support\n        const makeMapStats = function(stats) {\n            return new Map(Object.keys(stats).map((key)=>[\n                    key,\n                    stats[key]\n                ]));\n        };\n        if (arguments.length >= 2) {\n            const successCallbackWrapper_ = function(response) {\n                onSucc(makeMapStats(fixChromeStats_(response)));\n            };\n            return origGetStats.apply(this, [\n                successCallbackWrapper_,\n                selector\n            ]);\n        }\n        // promise-support\n        return new Promise((resolve, reject)=>{\n            origGetStats.apply(this, [\n                function(response) {\n                    resolve(makeMapStats(fixChromeStats_(response)));\n                },\n                reject\n            ]);\n        }).then(onSucc, onErr);\n    };\n}\nfunction shimSenderReceiverGetStats(window1) {\n    if (!(typeof window1 === 'object' && window1.RTCPeerConnection && window1.RTCRtpSender && window1.RTCRtpReceiver)) {\n        return;\n    }\n    // shim sender stats.\n    if (!('getStats' in window1.RTCRtpSender.prototype)) {\n        const origGetSenders = window1.RTCPeerConnection.prototype.getSenders;\n        if (origGetSenders) {\n            window1.RTCPeerConnection.prototype.getSenders = function getSenders() {\n                const senders = origGetSenders.apply(this, []);\n                senders.forEach((sender)=>sender._pc = this);\n                return senders;\n            };\n        }\n        const origAddTrack = window1.RTCPeerConnection.prototype.addTrack;\n        if (origAddTrack) {\n            window1.RTCPeerConnection.prototype.addTrack = function addTrack() {\n                const sender = origAddTrack.apply(this, arguments);\n                sender._pc = this;\n                return sender;\n            };\n        }\n        window1.RTCRtpSender.prototype.getStats = function getStats() {\n            const sender = this;\n            return this._pc.getStats().then((result)=>/* Note: this will include stats of all senders that\n       *   send a track with the same id as sender.track as\n       *   it is not possible to identify the RTCRtpSender.\n       */ filterStats(result, sender.track, true));\n        };\n    }\n    // shim receiver stats.\n    if (!('getStats' in window1.RTCRtpReceiver.prototype)) {\n        const origGetReceivers = window1.RTCPeerConnection.prototype.getReceivers;\n        if (origGetReceivers) {\n            window1.RTCPeerConnection.prototype.getReceivers = function getReceivers() {\n                const receivers = origGetReceivers.apply(this, []);\n                receivers.forEach((receiver)=>receiver._pc = this);\n                return receivers;\n            };\n        }\n        wrapPeerConnectionEvent(window1, 'track', (e)=>{\n            e.receiver._pc = e.srcElement;\n            return e;\n        });\n        window1.RTCRtpReceiver.prototype.getStats = function getStats() {\n            const receiver = this;\n            return this._pc.getStats().then((result)=>filterStats(result, receiver.track, false));\n        };\n    }\n    if (!('getStats' in window1.RTCRtpSender.prototype && 'getStats' in window1.RTCRtpReceiver.prototype)) {\n        return;\n    }\n    // shim RTCPeerConnection.getStats(track).\n    const origGetStats = window1.RTCPeerConnection.prototype.getStats;\n    window1.RTCPeerConnection.prototype.getStats = function getStats() {\n        if (arguments.length > 0 && arguments[0] instanceof window1.MediaStreamTrack) {\n            const track = arguments[0];\n            let sender;\n            let receiver;\n            let err;\n            this.getSenders().forEach((s)=>{\n                if (s.track === track) {\n                    if (sender) {\n                        err = true;\n                    } else {\n                        sender = s;\n                    }\n                }\n            });\n            this.getReceivers().forEach((r)=>{\n                if (r.track === track) {\n                    if (receiver) {\n                        err = true;\n                    } else {\n                        receiver = r;\n                    }\n                }\n                return r.track === track;\n            });\n            if (err || sender && receiver) {\n                return Promise.reject(new DOMException('There are more than one sender or receiver for the track.', 'InvalidAccessError'));\n            } else if (sender) {\n                return sender.getStats();\n            } else if (receiver) {\n                return receiver.getStats();\n            }\n            return Promise.reject(new DOMException('There is no sender or receiver for the track.', 'InvalidAccessError'));\n        }\n        return origGetStats.apply(this, arguments);\n    };\n}\nfunction shimAddTrackRemoveTrackWithNative(window1) {\n    // shim addTrack/removeTrack with native variants in order to make\n    // the interactions with legacy getLocalStreams behave as in other browsers.\n    // Keeps a mapping stream.id => [stream, rtpsenders...]\n    window1.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\n        this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n        return Object.keys(this._shimmedLocalStreams).map((streamId)=>this._shimmedLocalStreams[streamId][0]);\n    };\n    const origAddTrack = window1.RTCPeerConnection.prototype.addTrack;\n    window1.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\n        if (!stream) {\n            return origAddTrack.apply(this, arguments);\n        }\n        this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n        const sender = origAddTrack.apply(this, arguments);\n        if (!this._shimmedLocalStreams[stream.id]) {\n            this._shimmedLocalStreams[stream.id] = [\n                stream,\n                sender\n            ];\n        } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {\n            this._shimmedLocalStreams[stream.id].push(sender);\n        }\n        return sender;\n    };\n    const origAddStream = window1.RTCPeerConnection.prototype.addStream;\n    window1.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n        this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n        stream.getTracks().forEach((track)=>{\n            const alreadyExists = this.getSenders().find((s)=>s.track === track);\n            if (alreadyExists) {\n                throw new DOMException('Track already exists.', 'InvalidAccessError');\n            }\n        });\n        const existingSenders = this.getSenders();\n        origAddStream.apply(this, arguments);\n        const newSenders = this.getSenders().filter((newSender)=>existingSenders.indexOf(newSender) === -1);\n        this._shimmedLocalStreams[stream.id] = [\n            stream\n        ].concat(newSenders);\n    };\n    const origRemoveStream = window1.RTCPeerConnection.prototype.removeStream;\n    window1.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n        this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n        delete this._shimmedLocalStreams[stream.id];\n        return origRemoveStream.apply(this, arguments);\n    };\n    const origRemoveTrack = window1.RTCPeerConnection.prototype.removeTrack;\n    window1.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n        this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n        if (sender) {\n            Object.keys(this._shimmedLocalStreams).forEach((streamId)=>{\n                const idx = this._shimmedLocalStreams[streamId].indexOf(sender);\n                if (idx !== -1) {\n                    this._shimmedLocalStreams[streamId].splice(idx, 1);\n                }\n                if (this._shimmedLocalStreams[streamId].length === 1) {\n                    delete this._shimmedLocalStreams[streamId];\n                }\n            });\n        }\n        return origRemoveTrack.apply(this, arguments);\n    };\n}\nfunction shimAddTrackRemoveTrack(window1, browserDetails) {\n    if (!window1.RTCPeerConnection) {\n        return;\n    }\n    // shim addTrack and removeTrack.\n    if (window1.RTCPeerConnection.prototype.addTrack && browserDetails.version >= 65) {\n        return shimAddTrackRemoveTrackWithNative(window1);\n    }\n    // also shim pc.getLocalStreams when addTrack is shimmed\n    // to return the original streams.\n    const origGetLocalStreams = window1.RTCPeerConnection.prototype.getLocalStreams;\n    window1.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\n        const nativeStreams = origGetLocalStreams.apply(this);\n        this._reverseStreams = this._reverseStreams || {};\n        return nativeStreams.map((stream)=>this._reverseStreams[stream.id]);\n    };\n    const origAddStream = window1.RTCPeerConnection.prototype.addStream;\n    window1.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n        this._streams = this._streams || {};\n        this._reverseStreams = this._reverseStreams || {};\n        stream.getTracks().forEach((track)=>{\n            const alreadyExists = this.getSenders().find((s)=>s.track === track);\n            if (alreadyExists) {\n                throw new DOMException('Track already exists.', 'InvalidAccessError');\n            }\n        });\n        // Add identity mapping for consistency with addTrack.\n        // Unless this is being used with a stream from addTrack.\n        if (!this._reverseStreams[stream.id]) {\n            const newStream = new window1.MediaStream(stream.getTracks());\n            this._streams[stream.id] = newStream;\n            this._reverseStreams[newStream.id] = stream;\n            stream = newStream;\n        }\n        origAddStream.apply(this, [\n            stream\n        ]);\n    };\n    const origRemoveStream = window1.RTCPeerConnection.prototype.removeStream;\n    window1.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n        this._streams = this._streams || {};\n        this._reverseStreams = this._reverseStreams || {};\n        origRemoveStream.apply(this, [\n            this._streams[stream.id] || stream\n        ]);\n        delete this._reverseStreams[this._streams[stream.id] ? this._streams[stream.id].id : stream.id];\n        delete this._streams[stream.id];\n    };\n    window1.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\n        if (this.signalingState === 'closed') {\n            throw new DOMException('The RTCPeerConnection\\'s signalingState is \\'closed\\'.', 'InvalidStateError');\n        }\n        const streams = [].slice.call(arguments, 1);\n        if (streams.length !== 1 || !streams[0].getTracks().find((t)=>t === track)) {\n            // this is not fully correct but all we can manage without\n            // [[associated MediaStreams]] internal slot.\n            throw new DOMException('The adapter.js addTrack polyfill only supports a single ' + ' stream which is associated with the specified track.', 'NotSupportedError');\n        }\n        const alreadyExists = this.getSenders().find((s)=>s.track === track);\n        if (alreadyExists) {\n            throw new DOMException('Track already exists.', 'InvalidAccessError');\n        }\n        this._streams = this._streams || {};\n        this._reverseStreams = this._reverseStreams || {};\n        const oldStream = this._streams[stream.id];\n        if (oldStream) {\n            // this is using odd Chrome behaviour, use with caution:\n            // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815\n            // Note: we rely on the high-level addTrack/dtmf shim to\n            // create the sender with a dtmf sender.\n            oldStream.addTrack(track);\n            // Trigger ONN async.\n            Promise.resolve().then(()=>{\n                this.dispatchEvent(new Event('negotiationneeded'));\n            });\n        } else {\n            const newStream = new window1.MediaStream([\n                track\n            ]);\n            this._streams[stream.id] = newStream;\n            this._reverseStreams[newStream.id] = stream;\n            this.addStream(newStream);\n        }\n        return this.getSenders().find((s)=>s.track === track);\n    };\n    // replace the internal stream id with the external one and\n    // vice versa.\n    function replaceInternalStreamId(pc, description) {\n        let sdp = description.sdp;\n        Object.keys(pc._reverseStreams || []).forEach((internalId)=>{\n            const externalStream = pc._reverseStreams[internalId];\n            const internalStream = pc._streams[externalStream.id];\n            sdp = sdp.replace(new RegExp(internalStream.id, 'g'), externalStream.id);\n        });\n        return new RTCSessionDescription({\n            type: description.type,\n            sdp\n        });\n    }\n    function replaceExternalStreamId(pc, description) {\n        let sdp = description.sdp;\n        Object.keys(pc._reverseStreams || []).forEach((internalId)=>{\n            const externalStream = pc._reverseStreams[internalId];\n            const internalStream = pc._streams[externalStream.id];\n            sdp = sdp.replace(new RegExp(externalStream.id, 'g'), internalStream.id);\n        });\n        return new RTCSessionDescription({\n            type: description.type,\n            sdp\n        });\n    }\n    [\n        'createOffer',\n        'createAnswer'\n    ].forEach(function(method) {\n        const nativeMethod = window1.RTCPeerConnection.prototype[method];\n        const methodObj = {\n            [method] () {\n                const args = arguments;\n                const isLegacyCall = arguments.length && typeof arguments[0] === 'function';\n                if (isLegacyCall) {\n                    return nativeMethod.apply(this, [\n                        (description)=>{\n                            const desc = replaceInternalStreamId(this, description);\n                            args[0].apply(null, [\n                                desc\n                            ]);\n                        },\n                        (err)=>{\n                            if (args[1]) {\n                                args[1].apply(null, err);\n                            }\n                        },\n                        arguments[2]\n                    ]);\n                }\n                return nativeMethod.apply(this, arguments).then((description)=>replaceInternalStreamId(this, description));\n            }\n        };\n        window1.RTCPeerConnection.prototype[method] = methodObj[method];\n    });\n    const origSetLocalDescription = window1.RTCPeerConnection.prototype.setLocalDescription;\n    window1.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {\n        if (!arguments.length || !arguments[0].type) {\n            return origSetLocalDescription.apply(this, arguments);\n        }\n        arguments[0] = replaceExternalStreamId(this, arguments[0]);\n        return origSetLocalDescription.apply(this, arguments);\n    };\n    // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier\n    const origLocalDescription = Object.getOwnPropertyDescriptor(window1.RTCPeerConnection.prototype, 'localDescription');\n    Object.defineProperty(window1.RTCPeerConnection.prototype, 'localDescription', {\n        get () {\n            const description = origLocalDescription.get.apply(this);\n            if (description.type === '') {\n                return description;\n            }\n            return replaceInternalStreamId(this, description);\n        }\n    });\n    window1.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n        if (this.signalingState === 'closed') {\n            throw new DOMException('The RTCPeerConnection\\'s signalingState is \\'closed\\'.', 'InvalidStateError');\n        }\n        // We can not yet check for sender instanceof RTCRtpSender\n        // since we shim RTPSender. So we check if sender._pc is set.\n        if (!sender._pc) {\n            throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' + 'does not implement interface RTCRtpSender.', 'TypeError');\n        }\n        const isLocal = sender._pc === this;\n        if (!isLocal) {\n            throw new DOMException('Sender was not created by this connection.', 'InvalidAccessError');\n        }\n        // Search for the native stream the senders track belongs to.\n        this._streams = this._streams || {};\n        let stream;\n        Object.keys(this._streams).forEach((streamid)=>{\n            const hasTrack = this._streams[streamid].getTracks().find((track)=>sender.track === track);\n            if (hasTrack) {\n                stream = this._streams[streamid];\n            }\n        });\n        if (stream) {\n            if (stream.getTracks().length === 1) {\n                // if this is the last track of the stream, remove the stream. This\n                // takes care of any shimmed _senders.\n                this.removeStream(this._reverseStreams[stream.id]);\n            } else {\n                // relying on the same odd chrome behaviour as above.\n                stream.removeTrack(sender.track);\n            }\n            this.dispatchEvent(new Event('negotiationneeded'));\n        }\n    };\n}\nfunction shimPeerConnection$1(window1, browserDetails) {\n    if (!window1.RTCPeerConnection && window1.webkitRTCPeerConnection) {\n        // very basic support for old versions.\n        window1.RTCPeerConnection = window1.webkitRTCPeerConnection;\n    }\n    if (!window1.RTCPeerConnection) {\n        return;\n    }\n    // shim implicit creation of RTCSessionDescription/RTCIceCandidate\n    if (browserDetails.version < 53) {\n        [\n            'setLocalDescription',\n            'setRemoteDescription',\n            'addIceCandidate'\n        ].forEach(function(method) {\n            const nativeMethod = window1.RTCPeerConnection.prototype[method];\n            const methodObj = {\n                [method] () {\n                    arguments[0] = new (method === 'addIceCandidate' ? window1.RTCIceCandidate : window1.RTCSessionDescription)(arguments[0]);\n                    return nativeMethod.apply(this, arguments);\n                }\n            };\n            window1.RTCPeerConnection.prototype[method] = methodObj[method];\n        });\n    }\n}\n// Attempt to fix ONN in plan-b mode.\nfunction fixNegotiationNeeded(window1, browserDetails) {\n    wrapPeerConnectionEvent(window1, 'negotiationneeded', (e)=>{\n        const pc = e.target;\n        if (browserDetails.version < 72 || pc.getConfiguration && pc.getConfiguration().sdpSemantics === 'plan-b') {\n            if (pc.signalingState !== 'stable') {\n                return;\n            }\n        }\n        return e;\n    });\n}\nvar chromeShim = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    fixNegotiationNeeded: fixNegotiationNeeded,\n    shimAddTrackRemoveTrack: shimAddTrackRemoveTrack,\n    shimAddTrackRemoveTrackWithNative: shimAddTrackRemoveTrackWithNative,\n    shimGetDisplayMedia: shimGetDisplayMedia$1,\n    shimGetSendersWithDtmf: shimGetSendersWithDtmf,\n    shimGetStats: shimGetStats,\n    shimGetUserMedia: shimGetUserMedia$2,\n    shimMediaStream: shimMediaStream,\n    shimOnTrack: shimOnTrack$1,\n    shimPeerConnection: shimPeerConnection$1,\n    shimSenderReceiverGetStats: shimSenderReceiverGetStats\n});\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ function shimGetUserMedia$1(window1, browserDetails) {\n    const navigator1 = window1 && window1.navigator;\n    const MediaStreamTrack1 = window1 && window1.MediaStreamTrack;\n    navigator1.getUserMedia = function(constraints, onSuccess, onError) {\n        // Replace Firefox 44+'s deprecation warning with unprefixed version.\n        deprecated('navigator.getUserMedia', 'navigator.mediaDevices.getUserMedia');\n        navigator1.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);\n    };\n    if (!(browserDetails.version > 55 && 'autoGainControl' in navigator1.mediaDevices.getSupportedConstraints())) {\n        const remap = function(obj, a, b) {\n            if (a in obj && !(b in obj)) {\n                obj[b] = obj[a];\n                delete obj[a];\n            }\n        };\n        const nativeGetUserMedia = navigator1.mediaDevices.getUserMedia.bind(navigator1.mediaDevices);\n        navigator1.mediaDevices.getUserMedia = function(c) {\n            if (typeof c === 'object' && typeof c.audio === 'object') {\n                c = JSON.parse(JSON.stringify(c));\n                remap(c.audio, 'autoGainControl', 'mozAutoGainControl');\n                remap(c.audio, 'noiseSuppression', 'mozNoiseSuppression');\n            }\n            return nativeGetUserMedia(c);\n        };\n        if (MediaStreamTrack1 && MediaStreamTrack1.prototype.getSettings) {\n            const nativeGetSettings = MediaStreamTrack1.prototype.getSettings;\n            MediaStreamTrack1.prototype.getSettings = function() {\n                const obj = nativeGetSettings.apply(this, arguments);\n                remap(obj, 'mozAutoGainControl', 'autoGainControl');\n                remap(obj, 'mozNoiseSuppression', 'noiseSuppression');\n                return obj;\n            };\n        }\n        if (MediaStreamTrack1 && MediaStreamTrack1.prototype.applyConstraints) {\n            const nativeApplyConstraints = MediaStreamTrack1.prototype.applyConstraints;\n            MediaStreamTrack1.prototype.applyConstraints = function(c) {\n                if (this.kind === 'audio' && typeof c === 'object') {\n                    c = JSON.parse(JSON.stringify(c));\n                    remap(c, 'autoGainControl', 'mozAutoGainControl');\n                    remap(c, 'noiseSuppression', 'mozNoiseSuppression');\n                }\n                return nativeApplyConstraints.apply(this, [\n                    c\n                ]);\n            };\n        }\n    }\n}\n/*\n *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ function shimGetDisplayMedia(window1, preferredMediaSource) {\n    if (window1.navigator.mediaDevices && 'getDisplayMedia' in window1.navigator.mediaDevices) {\n        return;\n    }\n    if (!window1.navigator.mediaDevices) {\n        return;\n    }\n    window1.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {\n        if (!(constraints && constraints.video)) {\n            const err = new DOMException('getDisplayMedia without video ' + 'constraints is undefined');\n            err.name = 'NotFoundError';\n            // from https://heycam.github.io/webidl/#idl-DOMException-error-names\n            err.code = 8;\n            return Promise.reject(err);\n        }\n        if (constraints.video === true) {\n            constraints.video = {\n                mediaSource: preferredMediaSource\n            };\n        } else {\n            constraints.video.mediaSource = preferredMediaSource;\n        }\n        return window1.navigator.mediaDevices.getUserMedia(constraints);\n    };\n}\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ function shimOnTrack(window1) {\n    if (typeof window1 === 'object' && window1.RTCTrackEvent && 'receiver' in window1.RTCTrackEvent.prototype && !('transceiver' in window1.RTCTrackEvent.prototype)) {\n        Object.defineProperty(window1.RTCTrackEvent.prototype, 'transceiver', {\n            get () {\n                return {\n                    receiver: this.receiver\n                };\n            }\n        });\n    }\n}\nfunction shimPeerConnection(window1, browserDetails) {\n    if (typeof window1 !== 'object' || !(window1.RTCPeerConnection || window1.mozRTCPeerConnection)) {\n        return; // probably media.peerconnection.enabled=false in about:config\n    }\n    if (!window1.RTCPeerConnection && window1.mozRTCPeerConnection) {\n        // very basic support for old versions.\n        window1.RTCPeerConnection = window1.mozRTCPeerConnection;\n    }\n    if (browserDetails.version < 53) {\n        // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.\n        [\n            'setLocalDescription',\n            'setRemoteDescription',\n            'addIceCandidate'\n        ].forEach(function(method) {\n            const nativeMethod = window1.RTCPeerConnection.prototype[method];\n            const methodObj = {\n                [method] () {\n                    arguments[0] = new (method === 'addIceCandidate' ? window1.RTCIceCandidate : window1.RTCSessionDescription)(arguments[0]);\n                    return nativeMethod.apply(this, arguments);\n                }\n            };\n            window1.RTCPeerConnection.prototype[method] = methodObj[method];\n        });\n    }\n    const modernStatsTypes = {\n        inboundrtp: 'inbound-rtp',\n        outboundrtp: 'outbound-rtp',\n        candidatepair: 'candidate-pair',\n        localcandidate: 'local-candidate',\n        remotecandidate: 'remote-candidate'\n    };\n    const nativeGetStats = window1.RTCPeerConnection.prototype.getStats;\n    window1.RTCPeerConnection.prototype.getStats = function getStats() {\n        const [selector, onSucc, onErr] = arguments;\n        return nativeGetStats.apply(this, [\n            selector || null\n        ]).then((stats)=>{\n            if (browserDetails.version < 53 && !onSucc) {\n                // Shim only promise getStats with spec-hyphens in type names\n                // Leave callback version alone; misc old uses of forEach before Map\n                try {\n                    stats.forEach((stat)=>{\n                        stat.type = modernStatsTypes[stat.type] || stat.type;\n                    });\n                } catch (e) {\n                    if (e.name !== 'TypeError') {\n                        throw e;\n                    }\n                    // Avoid TypeError: \"type\" is read-only, in old versions. 34-43ish\n                    stats.forEach((stat, i)=>{\n                        stats.set(i, Object.assign({}, stat, {\n                            type: modernStatsTypes[stat.type] || stat.type\n                        }));\n                    });\n                }\n            }\n            return stats;\n        }).then(onSucc, onErr);\n    };\n}\nfunction shimSenderGetStats(window1) {\n    if (!(typeof window1 === 'object' && window1.RTCPeerConnection && window1.RTCRtpSender)) {\n        return;\n    }\n    if (window1.RTCRtpSender && 'getStats' in window1.RTCRtpSender.prototype) {\n        return;\n    }\n    const origGetSenders = window1.RTCPeerConnection.prototype.getSenders;\n    if (origGetSenders) {\n        window1.RTCPeerConnection.prototype.getSenders = function getSenders() {\n            const senders = origGetSenders.apply(this, []);\n            senders.forEach((sender)=>sender._pc = this);\n            return senders;\n        };\n    }\n    const origAddTrack = window1.RTCPeerConnection.prototype.addTrack;\n    if (origAddTrack) {\n        window1.RTCPeerConnection.prototype.addTrack = function addTrack() {\n            const sender = origAddTrack.apply(this, arguments);\n            sender._pc = this;\n            return sender;\n        };\n    }\n    window1.RTCRtpSender.prototype.getStats = function getStats() {\n        return this.track ? this._pc.getStats(this.track) : Promise.resolve(new Map());\n    };\n}\nfunction shimReceiverGetStats(window1) {\n    if (!(typeof window1 === 'object' && window1.RTCPeerConnection && window1.RTCRtpSender)) {\n        return;\n    }\n    if (window1.RTCRtpSender && 'getStats' in window1.RTCRtpReceiver.prototype) {\n        return;\n    }\n    const origGetReceivers = window1.RTCPeerConnection.prototype.getReceivers;\n    if (origGetReceivers) {\n        window1.RTCPeerConnection.prototype.getReceivers = function getReceivers() {\n            const receivers = origGetReceivers.apply(this, []);\n            receivers.forEach((receiver)=>receiver._pc = this);\n            return receivers;\n        };\n    }\n    wrapPeerConnectionEvent(window1, 'track', (e)=>{\n        e.receiver._pc = e.srcElement;\n        return e;\n    });\n    window1.RTCRtpReceiver.prototype.getStats = function getStats() {\n        return this._pc.getStats(this.track);\n    };\n}\nfunction shimRemoveStream(window1) {\n    if (!window1.RTCPeerConnection || 'removeStream' in window1.RTCPeerConnection.prototype) {\n        return;\n    }\n    window1.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n        deprecated('removeStream', 'removeTrack');\n        this.getSenders().forEach((sender)=>{\n            if (sender.track && stream.getTracks().includes(sender.track)) {\n                this.removeTrack(sender);\n            }\n        });\n    };\n}\nfunction shimRTCDataChannel(window1) {\n    // rename DataChannel to RTCDataChannel (native fix in FF60):\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1173851\n    if (window1.DataChannel && !window1.RTCDataChannel) {\n        window1.RTCDataChannel = window1.DataChannel;\n    }\n}\nfunction shimAddTransceiver(window1) {\n    // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647\n    // Firefox ignores the init sendEncodings options passed to addTransceiver\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918\n    if (!(typeof window1 === 'object' && window1.RTCPeerConnection)) {\n        return;\n    }\n    const origAddTransceiver = window1.RTCPeerConnection.prototype.addTransceiver;\n    if (origAddTransceiver) {\n        window1.RTCPeerConnection.prototype.addTransceiver = function addTransceiver() {\n            this.setParametersPromises = [];\n            // WebIDL input coercion and validation\n            let sendEncodings = arguments[1] && arguments[1].sendEncodings;\n            if (sendEncodings === undefined) {\n                sendEncodings = [];\n            }\n            sendEncodings = [\n                ...sendEncodings\n            ];\n            const shouldPerformCheck = sendEncodings.length > 0;\n            if (shouldPerformCheck) {\n                // If sendEncodings params are provided, validate grammar\n                sendEncodings.forEach((encodingParam)=>{\n                    if ('rid' in encodingParam) {\n                        const ridRegex = /^[a-z0-9]{0,16}$/i;\n                        if (!ridRegex.test(encodingParam.rid)) {\n                            throw new TypeError('Invalid RID value provided.');\n                        }\n                    }\n                    if ('scaleResolutionDownBy' in encodingParam) {\n                        if (!(parseFloat(encodingParam.scaleResolutionDownBy) >= 1.0)) {\n                            throw new RangeError('scale_resolution_down_by must be >= 1.0');\n                        }\n                    }\n                    if ('maxFramerate' in encodingParam) {\n                        if (!(parseFloat(encodingParam.maxFramerate) >= 0)) {\n                            throw new RangeError('max_framerate must be >= 0.0');\n                        }\n                    }\n                });\n            }\n            const transceiver = origAddTransceiver.apply(this, arguments);\n            if (shouldPerformCheck) {\n                // Check if the init options were applied. If not we do this in an\n                // asynchronous way and save the promise reference in a global object.\n                // This is an ugly hack, but at the same time is way more robust than\n                // checking the sender parameters before and after the createOffer\n                // Also note that after the createoffer we are not 100% sure that\n                // the params were asynchronously applied so we might miss the\n                // opportunity to recreate offer.\n                const { sender } = transceiver;\n                const params = sender.getParameters();\n                if (!('encodings' in params) || // Avoid being fooled by patched getParameters() below.\n                params.encodings.length === 1 && Object.keys(params.encodings[0]).length === 0) {\n                    params.encodings = sendEncodings;\n                    sender.sendEncodings = sendEncodings;\n                    this.setParametersPromises.push(sender.setParameters(params).then(()=>{\n                        delete sender.sendEncodings;\n                    }).catch(()=>{\n                        delete sender.sendEncodings;\n                    }));\n                }\n            }\n            return transceiver;\n        };\n    }\n}\nfunction shimGetParameters(window1) {\n    if (!(typeof window1 === 'object' && window1.RTCRtpSender)) {\n        return;\n    }\n    const origGetParameters = window1.RTCRtpSender.prototype.getParameters;\n    if (origGetParameters) {\n        window1.RTCRtpSender.prototype.getParameters = function getParameters() {\n            const params = origGetParameters.apply(this, arguments);\n            if (!('encodings' in params)) {\n                params.encodings = [].concat(this.sendEncodings || [\n                    {}\n                ]);\n            }\n            return params;\n        };\n    }\n}\nfunction shimCreateOffer(window1) {\n    // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647\n    // Firefox ignores the init sendEncodings options passed to addTransceiver\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918\n    if (!(typeof window1 === 'object' && window1.RTCPeerConnection)) {\n        return;\n    }\n    const origCreateOffer = window1.RTCPeerConnection.prototype.createOffer;\n    window1.RTCPeerConnection.prototype.createOffer = function createOffer() {\n        if (this.setParametersPromises && this.setParametersPromises.length) {\n            return Promise.all(this.setParametersPromises).then(()=>{\n                return origCreateOffer.apply(this, arguments);\n            }).finally(()=>{\n                this.setParametersPromises = [];\n            });\n        }\n        return origCreateOffer.apply(this, arguments);\n    };\n}\nfunction shimCreateAnswer(window1) {\n    // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647\n    // Firefox ignores the init sendEncodings options passed to addTransceiver\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918\n    if (!(typeof window1 === 'object' && window1.RTCPeerConnection)) {\n        return;\n    }\n    const origCreateAnswer = window1.RTCPeerConnection.prototype.createAnswer;\n    window1.RTCPeerConnection.prototype.createAnswer = function createAnswer() {\n        if (this.setParametersPromises && this.setParametersPromises.length) {\n            return Promise.all(this.setParametersPromises).then(()=>{\n                return origCreateAnswer.apply(this, arguments);\n            }).finally(()=>{\n                this.setParametersPromises = [];\n            });\n        }\n        return origCreateAnswer.apply(this, arguments);\n    };\n}\nvar firefoxShim = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    shimAddTransceiver: shimAddTransceiver,\n    shimCreateAnswer: shimCreateAnswer,\n    shimCreateOffer: shimCreateOffer,\n    shimGetDisplayMedia: shimGetDisplayMedia,\n    shimGetParameters: shimGetParameters,\n    shimGetUserMedia: shimGetUserMedia$1,\n    shimOnTrack: shimOnTrack,\n    shimPeerConnection: shimPeerConnection,\n    shimRTCDataChannel: shimRTCDataChannel,\n    shimReceiverGetStats: shimReceiverGetStats,\n    shimRemoveStream: shimRemoveStream,\n    shimSenderGetStats: shimSenderGetStats\n});\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ function shimLocalStreamsAPI(window1) {\n    if (typeof window1 !== 'object' || !window1.RTCPeerConnection) {\n        return;\n    }\n    if (!('getLocalStreams' in window1.RTCPeerConnection.prototype)) {\n        window1.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\n            if (!this._localStreams) {\n                this._localStreams = [];\n            }\n            return this._localStreams;\n        };\n    }\n    if (!('addStream' in window1.RTCPeerConnection.prototype)) {\n        const _addTrack = window1.RTCPeerConnection.prototype.addTrack;\n        window1.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n            if (!this._localStreams) {\n                this._localStreams = [];\n            }\n            if (!this._localStreams.includes(stream)) {\n                this._localStreams.push(stream);\n            }\n            // Try to emulate Chrome's behaviour of adding in audio-video order.\n            // Safari orders by track id.\n            stream.getAudioTracks().forEach((track)=>_addTrack.call(this, track, stream));\n            stream.getVideoTracks().forEach((track)=>_addTrack.call(this, track, stream));\n        };\n        window1.RTCPeerConnection.prototype.addTrack = function addTrack(track) {\n            for(var _len = arguments.length, streams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                streams[_key - 1] = arguments[_key];\n            }\n            if (streams) {\n                streams.forEach((stream)=>{\n                    if (!this._localStreams) {\n                        this._localStreams = [\n                            stream\n                        ];\n                    } else if (!this._localStreams.includes(stream)) {\n                        this._localStreams.push(stream);\n                    }\n                });\n            }\n            return _addTrack.apply(this, arguments);\n        };\n    }\n    if (!('removeStream' in window1.RTCPeerConnection.prototype)) {\n        window1.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n            if (!this._localStreams) {\n                this._localStreams = [];\n            }\n            const index = this._localStreams.indexOf(stream);\n            if (index === -1) {\n                return;\n            }\n            this._localStreams.splice(index, 1);\n            const tracks = stream.getTracks();\n            this.getSenders().forEach((sender)=>{\n                if (tracks.includes(sender.track)) {\n                    this.removeTrack(sender);\n                }\n            });\n        };\n    }\n}\nfunction shimRemoteStreamsAPI(window1) {\n    if (typeof window1 !== 'object' || !window1.RTCPeerConnection) {\n        return;\n    }\n    if (!('getRemoteStreams' in window1.RTCPeerConnection.prototype)) {\n        window1.RTCPeerConnection.prototype.getRemoteStreams = function getRemoteStreams() {\n            return this._remoteStreams ? this._remoteStreams : [];\n        };\n    }\n    if (!('onaddstream' in window1.RTCPeerConnection.prototype)) {\n        Object.defineProperty(window1.RTCPeerConnection.prototype, 'onaddstream', {\n            get () {\n                return this._onaddstream;\n            },\n            set (f) {\n                if (this._onaddstream) {\n                    this.removeEventListener('addstream', this._onaddstream);\n                    this.removeEventListener('track', this._onaddstreampoly);\n                }\n                this.addEventListener('addstream', this._onaddstream = f);\n                this.addEventListener('track', this._onaddstreampoly = (e)=>{\n                    e.streams.forEach((stream)=>{\n                        if (!this._remoteStreams) {\n                            this._remoteStreams = [];\n                        }\n                        if (this._remoteStreams.includes(stream)) {\n                            return;\n                        }\n                        this._remoteStreams.push(stream);\n                        const event = new Event('addstream');\n                        event.stream = stream;\n                        this.dispatchEvent(event);\n                    });\n                });\n            }\n        });\n        const origSetRemoteDescription = window1.RTCPeerConnection.prototype.setRemoteDescription;\n        window1.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n            const pc = this;\n            if (!this._onaddstreampoly) {\n                this.addEventListener('track', this._onaddstreampoly = function(e) {\n                    e.streams.forEach((stream)=>{\n                        if (!pc._remoteStreams) {\n                            pc._remoteStreams = [];\n                        }\n                        if (pc._remoteStreams.indexOf(stream) >= 0) {\n                            return;\n                        }\n                        pc._remoteStreams.push(stream);\n                        const event = new Event('addstream');\n                        event.stream = stream;\n                        pc.dispatchEvent(event);\n                    });\n                });\n            }\n            return origSetRemoteDescription.apply(pc, arguments);\n        };\n    }\n}\nfunction shimCallbacksAPI(window1) {\n    if (typeof window1 !== 'object' || !window1.RTCPeerConnection) {\n        return;\n    }\n    const prototype = window1.RTCPeerConnection.prototype;\n    const origCreateOffer = prototype.createOffer;\n    const origCreateAnswer = prototype.createAnswer;\n    const setLocalDescription = prototype.setLocalDescription;\n    const setRemoteDescription = prototype.setRemoteDescription;\n    const addIceCandidate = prototype.addIceCandidate;\n    prototype.createOffer = function createOffer(successCallback, failureCallback) {\n        const options = arguments.length >= 2 ? arguments[2] : arguments[0];\n        const promise = origCreateOffer.apply(this, [\n            options\n        ]);\n        if (!failureCallback) {\n            return promise;\n        }\n        promise.then(successCallback, failureCallback);\n        return Promise.resolve();\n    };\n    prototype.createAnswer = function createAnswer(successCallback, failureCallback) {\n        const options = arguments.length >= 2 ? arguments[2] : arguments[0];\n        const promise = origCreateAnswer.apply(this, [\n            options\n        ]);\n        if (!failureCallback) {\n            return promise;\n        }\n        promise.then(successCallback, failureCallback);\n        return Promise.resolve();\n    };\n    let withCallback = function(description, successCallback, failureCallback) {\n        const promise = setLocalDescription.apply(this, [\n            description\n        ]);\n        if (!failureCallback) {\n            return promise;\n        }\n        promise.then(successCallback, failureCallback);\n        return Promise.resolve();\n    };\n    prototype.setLocalDescription = withCallback;\n    withCallback = function(description, successCallback, failureCallback) {\n        const promise = setRemoteDescription.apply(this, [\n            description\n        ]);\n        if (!failureCallback) {\n            return promise;\n        }\n        promise.then(successCallback, failureCallback);\n        return Promise.resolve();\n    };\n    prototype.setRemoteDescription = withCallback;\n    withCallback = function(candidate, successCallback, failureCallback) {\n        const promise = addIceCandidate.apply(this, [\n            candidate\n        ]);\n        if (!failureCallback) {\n            return promise;\n        }\n        promise.then(successCallback, failureCallback);\n        return Promise.resolve();\n    };\n    prototype.addIceCandidate = withCallback;\n}\nfunction shimGetUserMedia(window1) {\n    const navigator1 = window1 && window1.navigator;\n    if (navigator1.mediaDevices && navigator1.mediaDevices.getUserMedia) {\n        // shim not needed in Safari 12.1\n        const mediaDevices = navigator1.mediaDevices;\n        const _getUserMedia = mediaDevices.getUserMedia.bind(mediaDevices);\n        navigator1.mediaDevices.getUserMedia = (constraints)=>{\n            return _getUserMedia(shimConstraints(constraints));\n        };\n    }\n    if (!navigator1.getUserMedia && navigator1.mediaDevices && navigator1.mediaDevices.getUserMedia) {\n        navigator1.getUserMedia = (function getUserMedia(constraints, cb, errcb) {\n            navigator1.mediaDevices.getUserMedia(constraints).then(cb, errcb);\n        }).bind(navigator1);\n    }\n}\nfunction shimConstraints(constraints) {\n    if (constraints && constraints.video !== undefined) {\n        return Object.assign({}, constraints, {\n            video: compactObject(constraints.video)\n        });\n    }\n    return constraints;\n}\nfunction shimRTCIceServerUrls(window1) {\n    if (!window1.RTCPeerConnection) {\n        return;\n    }\n    // migrate from non-spec RTCIceServer.url to RTCIceServer.urls\n    const OrigPeerConnection = window1.RTCPeerConnection;\n    window1.RTCPeerConnection = function RTCPeerConnection1(pcConfig, pcConstraints) {\n        if (pcConfig && pcConfig.iceServers) {\n            const newIceServers = [];\n            for(let i = 0; i < pcConfig.iceServers.length; i++){\n                let server = pcConfig.iceServers[i];\n                if (server.urls === undefined && server.url) {\n                    deprecated('RTCIceServer.url', 'RTCIceServer.urls');\n                    server = JSON.parse(JSON.stringify(server));\n                    server.urls = server.url;\n                    delete server.url;\n                    newIceServers.push(server);\n                } else {\n                    newIceServers.push(pcConfig.iceServers[i]);\n                }\n            }\n            pcConfig.iceServers = newIceServers;\n        }\n        return new OrigPeerConnection(pcConfig, pcConstraints);\n    };\n    window1.RTCPeerConnection.prototype = OrigPeerConnection.prototype;\n    // wrap static methods. Currently just generateCertificate.\n    if ('generateCertificate' in OrigPeerConnection) {\n        Object.defineProperty(window1.RTCPeerConnection, 'generateCertificate', {\n            get () {\n                return OrigPeerConnection.generateCertificate;\n            }\n        });\n    }\n}\nfunction shimTrackEventTransceiver(window1) {\n    // Add event.transceiver member over deprecated event.receiver\n    if (typeof window1 === 'object' && window1.RTCTrackEvent && 'receiver' in window1.RTCTrackEvent.prototype && !('transceiver' in window1.RTCTrackEvent.prototype)) {\n        Object.defineProperty(window1.RTCTrackEvent.prototype, 'transceiver', {\n            get () {\n                return {\n                    receiver: this.receiver\n                };\n            }\n        });\n    }\n}\nfunction shimCreateOfferLegacy(window1) {\n    const origCreateOffer = window1.RTCPeerConnection.prototype.createOffer;\n    window1.RTCPeerConnection.prototype.createOffer = function createOffer(offerOptions) {\n        if (offerOptions) {\n            if (typeof offerOptions.offerToReceiveAudio !== 'undefined') {\n                // support bit values\n                offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio;\n            }\n            const audioTransceiver = this.getTransceivers().find((transceiver)=>transceiver.receiver.track.kind === 'audio');\n            if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {\n                if (audioTransceiver.direction === 'sendrecv') {\n                    if (audioTransceiver.setDirection) {\n                        audioTransceiver.setDirection('sendonly');\n                    } else {\n                        audioTransceiver.direction = 'sendonly';\n                    }\n                } else if (audioTransceiver.direction === 'recvonly') {\n                    if (audioTransceiver.setDirection) {\n                        audioTransceiver.setDirection('inactive');\n                    } else {\n                        audioTransceiver.direction = 'inactive';\n                    }\n                }\n            } else if (offerOptions.offerToReceiveAudio === true && !audioTransceiver) {\n                this.addTransceiver('audio', {\n                    direction: 'recvonly'\n                });\n            }\n            if (typeof offerOptions.offerToReceiveVideo !== 'undefined') {\n                // support bit values\n                offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo;\n            }\n            const videoTransceiver = this.getTransceivers().find((transceiver)=>transceiver.receiver.track.kind === 'video');\n            if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {\n                if (videoTransceiver.direction === 'sendrecv') {\n                    if (videoTransceiver.setDirection) {\n                        videoTransceiver.setDirection('sendonly');\n                    } else {\n                        videoTransceiver.direction = 'sendonly';\n                    }\n                } else if (videoTransceiver.direction === 'recvonly') {\n                    if (videoTransceiver.setDirection) {\n                        videoTransceiver.setDirection('inactive');\n                    } else {\n                        videoTransceiver.direction = 'inactive';\n                    }\n                }\n            } else if (offerOptions.offerToReceiveVideo === true && !videoTransceiver) {\n                this.addTransceiver('video', {\n                    direction: 'recvonly'\n                });\n            }\n        }\n        return origCreateOffer.apply(this, arguments);\n    };\n}\nfunction shimAudioContext(window1) {\n    if (typeof window1 !== 'object' || window1.AudioContext) {\n        return;\n    }\n    window1.AudioContext = window1.webkitAudioContext;\n}\nvar safariShim = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    shimAudioContext: shimAudioContext,\n    shimCallbacksAPI: shimCallbacksAPI,\n    shimConstraints: shimConstraints,\n    shimCreateOfferLegacy: shimCreateOfferLegacy,\n    shimGetUserMedia: shimGetUserMedia,\n    shimLocalStreamsAPI: shimLocalStreamsAPI,\n    shimRTCIceServerUrls: shimRTCIceServerUrls,\n    shimRemoteStreamsAPI: shimRemoteStreamsAPI,\n    shimTrackEventTransceiver: shimTrackEventTransceiver\n});\nvar sdp$1 = {\n    exports: {}\n};\n/* eslint-env node */ (function(module) {\n    // SDP helpers.\n    const SDPUtils = {};\n    // Generate an alphanumeric identifier for cname or mids.\n    // TODO: use UUIDs instead? https://gist.github.com/jed/982883\n    SDPUtils.generateIdentifier = function() {\n        return Math.random().toString(36).substring(2, 12);\n    };\n    // The RTCP CNAME used by all peerconnections from the same JS.\n    SDPUtils.localCName = SDPUtils.generateIdentifier();\n    // Splits SDP into lines, dealing with both CRLF and LF.\n    SDPUtils.splitLines = function(blob) {\n        return blob.trim().split('\\n').map((line)=>line.trim());\n    };\n    // Splits SDP into sessionpart and mediasections. Ensures CRLF.\n    SDPUtils.splitSections = function(blob) {\n        const parts = blob.split('\\nm=');\n        return parts.map((part, index)=>(index > 0 ? 'm=' + part : part).trim() + '\\r\\n');\n    };\n    // Returns the session description.\n    SDPUtils.getDescription = function(blob) {\n        const sections = SDPUtils.splitSections(blob);\n        return sections && sections[0];\n    };\n    // Returns the individual media sections.\n    SDPUtils.getMediaSections = function(blob) {\n        const sections = SDPUtils.splitSections(blob);\n        sections.shift();\n        return sections;\n    };\n    // Returns lines that start with a certain prefix.\n    SDPUtils.matchPrefix = function(blob, prefix) {\n        return SDPUtils.splitLines(blob).filter((line)=>line.indexOf(prefix) === 0);\n    };\n    // Parses an ICE candidate line. Sample input:\n    // candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8\n    // rport 55996\"\n    // Input can be prefixed with a=.\n    SDPUtils.parseCandidate = function(line) {\n        let parts;\n        // Parse both variants.\n        if (line.indexOf('a=candidate:') === 0) {\n            parts = line.substring(12).split(' ');\n        } else {\n            parts = line.substring(10).split(' ');\n        }\n        const candidate = {\n            foundation: parts[0],\n            component: {\n                1: 'rtp',\n                2: 'rtcp'\n            }[parts[1]] || parts[1],\n            protocol: parts[2].toLowerCase(),\n            priority: parseInt(parts[3], 10),\n            ip: parts[4],\n            address: parts[4],\n            // address is an alias for ip.\n            port: parseInt(parts[5], 10),\n            // skip parts[6] == 'typ'\n            type: parts[7]\n        };\n        for(let i = 8; i < parts.length; i += 2){\n            switch(parts[i]){\n                case 'raddr':\n                    candidate.relatedAddress = parts[i + 1];\n                    break;\n                case 'rport':\n                    candidate.relatedPort = parseInt(parts[i + 1], 10);\n                    break;\n                case 'tcptype':\n                    candidate.tcpType = parts[i + 1];\n                    break;\n                case 'ufrag':\n                    candidate.ufrag = parts[i + 1]; // for backward compatibility.\n                    candidate.usernameFragment = parts[i + 1];\n                    break;\n                default:\n                    // extension handling, in particular ufrag. Don't overwrite.\n                    if (candidate[parts[i]] === undefined) {\n                        candidate[parts[i]] = parts[i + 1];\n                    }\n                    break;\n            }\n        }\n        return candidate;\n    };\n    // Translates a candidate object into SDP candidate attribute.\n    // This does not include the a= prefix!\n    SDPUtils.writeCandidate = function(candidate) {\n        const sdp = [];\n        sdp.push(candidate.foundation);\n        const component = candidate.component;\n        if (component === 'rtp') {\n            sdp.push(1);\n        } else if (component === 'rtcp') {\n            sdp.push(2);\n        } else {\n            sdp.push(component);\n        }\n        sdp.push(candidate.protocol.toUpperCase());\n        sdp.push(candidate.priority);\n        sdp.push(candidate.address || candidate.ip);\n        sdp.push(candidate.port);\n        const type = candidate.type;\n        sdp.push('typ');\n        sdp.push(type);\n        if (type !== 'host' && candidate.relatedAddress && candidate.relatedPort) {\n            sdp.push('raddr');\n            sdp.push(candidate.relatedAddress);\n            sdp.push('rport');\n            sdp.push(candidate.relatedPort);\n        }\n        if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {\n            sdp.push('tcptype');\n            sdp.push(candidate.tcpType);\n        }\n        if (candidate.usernameFragment || candidate.ufrag) {\n            sdp.push('ufrag');\n            sdp.push(candidate.usernameFragment || candidate.ufrag);\n        }\n        return 'candidate:' + sdp.join(' ');\n    };\n    // Parses an ice-options line, returns an array of option tags.\n    // Sample input:\n    // a=ice-options:foo bar\n    SDPUtils.parseIceOptions = function(line) {\n        return line.substring(14).split(' ');\n    };\n    // Parses a rtpmap line, returns RTCRtpCoddecParameters. Sample input:\n    // a=rtpmap:111 opus/48000/2\n    SDPUtils.parseRtpMap = function(line) {\n        let parts = line.substring(9).split(' ');\n        const parsed = {\n            payloadType: parseInt(parts.shift(), 10) // was: id\n        };\n        parts = parts[0].split('/');\n        parsed.name = parts[0];\n        parsed.clockRate = parseInt(parts[1], 10); // was: clockrate\n        parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;\n        // legacy alias, got renamed back to channels in ORTC.\n        parsed.numChannels = parsed.channels;\n        return parsed;\n    };\n    // Generates a rtpmap line from RTCRtpCodecCapability or\n    // RTCRtpCodecParameters.\n    SDPUtils.writeRtpMap = function(codec) {\n        let pt = codec.payloadType;\n        if (codec.preferredPayloadType !== undefined) {\n            pt = codec.preferredPayloadType;\n        }\n        const channels = codec.channels || codec.numChannels || 1;\n        return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate + (channels !== 1 ? '/' + channels : '') + '\\r\\n';\n    };\n    // Parses a extmap line (headerextension from RFC 5285). Sample input:\n    // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n    // a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset\n    SDPUtils.parseExtmap = function(line) {\n        const parts = line.substring(9).split(' ');\n        return {\n            id: parseInt(parts[0], 10),\n            direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',\n            uri: parts[1],\n            attributes: parts.slice(2).join(' ')\n        };\n    };\n    // Generates an extmap line from RTCRtpHeaderExtensionParameters or\n    // RTCRtpHeaderExtension.\n    SDPUtils.writeExtmap = function(headerExtension) {\n        return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) + (headerExtension.direction && headerExtension.direction !== 'sendrecv' ? '/' + headerExtension.direction : '') + ' ' + headerExtension.uri + (headerExtension.attributes ? ' ' + headerExtension.attributes : '') + '\\r\\n';\n    };\n    // Parses a fmtp line, returns dictionary. Sample input:\n    // a=fmtp:96 vbr=on;cng=on\n    // Also deals with vbr=on; cng=on\n    SDPUtils.parseFmtp = function(line) {\n        const parsed = {};\n        let kv;\n        const parts = line.substring(line.indexOf(' ') + 1).split(';');\n        for(let j = 0; j < parts.length; j++){\n            kv = parts[j].trim().split('=');\n            parsed[kv[0].trim()] = kv[1];\n        }\n        return parsed;\n    };\n    // Generates a fmtp line from RTCRtpCodecCapability or RTCRtpCodecParameters.\n    SDPUtils.writeFmtp = function(codec) {\n        let line = '';\n        let pt = codec.payloadType;\n        if (codec.preferredPayloadType !== undefined) {\n            pt = codec.preferredPayloadType;\n        }\n        if (codec.parameters && Object.keys(codec.parameters).length) {\n            const params = [];\n            Object.keys(codec.parameters).forEach((param)=>{\n                if (codec.parameters[param] !== undefined) {\n                    params.push(param + '=' + codec.parameters[param]);\n                } else {\n                    params.push(param);\n                }\n            });\n            line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\\r\\n';\n        }\n        return line;\n    };\n    // Parses a rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:\n    // a=rtcp-fb:98 nack rpsi\n    SDPUtils.parseRtcpFb = function(line) {\n        const parts = line.substring(line.indexOf(' ') + 1).split(' ');\n        return {\n            type: parts.shift(),\n            parameter: parts.join(' ')\n        };\n    };\n    // Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.\n    SDPUtils.writeRtcpFb = function(codec) {\n        let lines = '';\n        let pt = codec.payloadType;\n        if (codec.preferredPayloadType !== undefined) {\n            pt = codec.preferredPayloadType;\n        }\n        if (codec.rtcpFeedback && codec.rtcpFeedback.length) {\n            // FIXME: special handling for trr-int?\n            codec.rtcpFeedback.forEach((fb)=>{\n                lines += 'a=rtcp-fb:' + pt + ' ' + fb.type + (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') + '\\r\\n';\n            });\n        }\n        return lines;\n    };\n    // Parses a RFC 5576 ssrc media attribute. Sample input:\n    // a=ssrc:3735928559 cname:something\n    SDPUtils.parseSsrcMedia = function(line) {\n        const sp = line.indexOf(' ');\n        const parts = {\n            ssrc: parseInt(line.substring(7, sp), 10)\n        };\n        const colon = line.indexOf(':', sp);\n        if (colon > -1) {\n            parts.attribute = line.substring(sp + 1, colon);\n            parts.value = line.substring(colon + 1);\n        } else {\n            parts.attribute = line.substring(sp + 1);\n        }\n        return parts;\n    };\n    // Parse a ssrc-group line (see RFC 5576). Sample input:\n    // a=ssrc-group:semantics 12 34\n    SDPUtils.parseSsrcGroup = function(line) {\n        const parts = line.substring(13).split(' ');\n        return {\n            semantics: parts.shift(),\n            ssrcs: parts.map((ssrc)=>parseInt(ssrc, 10))\n        };\n    };\n    // Extracts the MID (RFC 5888) from a media section.\n    // Returns the MID or undefined if no mid line was found.\n    SDPUtils.getMid = function(mediaSection) {\n        const mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];\n        if (mid) {\n            return mid.substring(6);\n        }\n    };\n    // Parses a fingerprint line for DTLS-SRTP.\n    SDPUtils.parseFingerprint = function(line) {\n        const parts = line.substring(14).split(' ');\n        return {\n            algorithm: parts[0].toLowerCase(),\n            // algorithm is case-sensitive in Edge.\n            value: parts[1].toUpperCase() // the definition is upper-case in RFC 4572.\n        };\n    };\n    // Extracts DTLS parameters from SDP media section or sessionpart.\n    // FIXME: for consistency with other functions this should only\n    //   get the fingerprint line as input. See also getIceParameters.\n    SDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {\n        const lines = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=fingerprint:');\n        // Note: a=setup line is ignored since we use the 'auto' role in Edge.\n        return {\n            role: 'auto',\n            fingerprints: lines.map(SDPUtils.parseFingerprint)\n        };\n    };\n    // Serializes DTLS parameters to SDP.\n    SDPUtils.writeDtlsParameters = function(params, setupType) {\n        let sdp = 'a=setup:' + setupType + '\\r\\n';\n        params.fingerprints.forEach((fp)=>{\n            sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\\r\\n';\n        });\n        return sdp;\n    };\n    // Parses a=crypto lines into\n    //   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#dictionary-rtcsrtpsdesparameters-members\n    SDPUtils.parseCryptoLine = function(line) {\n        const parts = line.substring(9).split(' ');\n        return {\n            tag: parseInt(parts[0], 10),\n            cryptoSuite: parts[1],\n            keyParams: parts[2],\n            sessionParams: parts.slice(3)\n        };\n    };\n    SDPUtils.writeCryptoLine = function(parameters) {\n        return 'a=crypto:' + parameters.tag + ' ' + parameters.cryptoSuite + ' ' + (typeof parameters.keyParams === 'object' ? SDPUtils.writeCryptoKeyParams(parameters.keyParams) : parameters.keyParams) + (parameters.sessionParams ? ' ' + parameters.sessionParams.join(' ') : '') + '\\r\\n';\n    };\n    // Parses the crypto key parameters into\n    //   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#rtcsrtpkeyparam*\n    SDPUtils.parseCryptoKeyParams = function(keyParams) {\n        if (keyParams.indexOf('inline:') !== 0) {\n            return null;\n        }\n        const parts = keyParams.substring(7).split('|');\n        return {\n            keyMethod: 'inline',\n            keySalt: parts[0],\n            lifeTime: parts[1],\n            mkiValue: parts[2] ? parts[2].split(':')[0] : undefined,\n            mkiLength: parts[2] ? parts[2].split(':')[1] : undefined\n        };\n    };\n    SDPUtils.writeCryptoKeyParams = function(keyParams) {\n        return keyParams.keyMethod + ':' + keyParams.keySalt + (keyParams.lifeTime ? '|' + keyParams.lifeTime : '') + (keyParams.mkiValue && keyParams.mkiLength ? '|' + keyParams.mkiValue + ':' + keyParams.mkiLength : '');\n    };\n    // Extracts all SDES parameters.\n    SDPUtils.getCryptoParameters = function(mediaSection, sessionpart) {\n        const lines = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=crypto:');\n        return lines.map(SDPUtils.parseCryptoLine);\n    };\n    // Parses ICE information from SDP media section or sessionpart.\n    // FIXME: for consistency with other functions this should only\n    //   get the ice-ufrag and ice-pwd lines as input.\n    SDPUtils.getIceParameters = function(mediaSection, sessionpart) {\n        const ufrag = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=ice-ufrag:')[0];\n        const pwd = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=ice-pwd:')[0];\n        if (!(ufrag && pwd)) {\n            return null;\n        }\n        return {\n            usernameFragment: ufrag.substring(12),\n            password: pwd.substring(10)\n        };\n    };\n    // Serializes ICE parameters to SDP.\n    SDPUtils.writeIceParameters = function(params) {\n        let sdp = 'a=ice-ufrag:' + params.usernameFragment + '\\r\\n' + 'a=ice-pwd:' + params.password + '\\r\\n';\n        if (params.iceLite) {\n            sdp += 'a=ice-lite\\r\\n';\n        }\n        return sdp;\n    };\n    // Parses the SDP media section and returns RTCRtpParameters.\n    SDPUtils.parseRtpParameters = function(mediaSection) {\n        const description = {\n            codecs: [],\n            headerExtensions: [],\n            fecMechanisms: [],\n            rtcp: []\n        };\n        const lines = SDPUtils.splitLines(mediaSection);\n        const mline = lines[0].split(' ');\n        description.profile = mline[2];\n        for(let i = 3; i < mline.length; i++){\n            // find all codecs from mline[3..]\n            const pt = mline[i];\n            const rtpmapline = SDPUtils.matchPrefix(mediaSection, 'a=rtpmap:' + pt + ' ')[0];\n            if (rtpmapline) {\n                const codec = SDPUtils.parseRtpMap(rtpmapline);\n                const fmtps = SDPUtils.matchPrefix(mediaSection, 'a=fmtp:' + pt + ' ');\n                // Only the first a=fmtp:<pt> is considered.\n                codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};\n                codec.rtcpFeedback = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-fb:' + pt + ' ').map(SDPUtils.parseRtcpFb);\n                description.codecs.push(codec);\n                // parse FEC mechanisms from rtpmap lines.\n                switch(codec.name.toUpperCase()){\n                    case 'RED':\n                    case 'ULPFEC':\n                        description.fecMechanisms.push(codec.name.toUpperCase());\n                        break;\n                }\n            }\n        }\n        SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach((line)=>{\n            description.headerExtensions.push(SDPUtils.parseExtmap(line));\n        });\n        const wildcardRtcpFb = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-fb:* ').map(SDPUtils.parseRtcpFb);\n        description.codecs.forEach((codec)=>{\n            wildcardRtcpFb.forEach((fb)=>{\n                const duplicate = codec.rtcpFeedback.find((existingFeedback)=>{\n                    return existingFeedback.type === fb.type && existingFeedback.parameter === fb.parameter;\n                });\n                if (!duplicate) {\n                    codec.rtcpFeedback.push(fb);\n                }\n            });\n        });\n        // FIXME: parse rtcp.\n        return description;\n    };\n    // Generates parts of the SDP media section describing the capabilities /\n    // parameters.\n    SDPUtils.writeRtpDescription = function(kind, caps) {\n        let sdp = '';\n        // Build the mline.\n        sdp += 'm=' + kind + ' ';\n        sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.\n        sdp += ' ' + (caps.profile || 'UDP/TLS/RTP/SAVPF') + ' ';\n        sdp += caps.codecs.map((codec)=>{\n            if (codec.preferredPayloadType !== undefined) {\n                return codec.preferredPayloadType;\n            }\n            return codec.payloadType;\n        }).join(' ') + '\\r\\n';\n        sdp += 'c=IN IP4 0.0.0.0\\r\\n';\n        sdp += 'a=rtcp:9 IN IP4 0.0.0.0\\r\\n';\n        // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.\n        caps.codecs.forEach((codec)=>{\n            sdp += SDPUtils.writeRtpMap(codec);\n            sdp += SDPUtils.writeFmtp(codec);\n            sdp += SDPUtils.writeRtcpFb(codec);\n        });\n        let maxptime = 0;\n        caps.codecs.forEach((codec)=>{\n            if (codec.maxptime > maxptime) {\n                maxptime = codec.maxptime;\n            }\n        });\n        if (maxptime > 0) {\n            sdp += 'a=maxptime:' + maxptime + '\\r\\n';\n        }\n        if (caps.headerExtensions) {\n            caps.headerExtensions.forEach((extension)=>{\n                sdp += SDPUtils.writeExtmap(extension);\n            });\n        }\n        // FIXME: write fecMechanisms.\n        return sdp;\n    };\n    // Parses the SDP media section and returns an array of\n    // RTCRtpEncodingParameters.\n    SDPUtils.parseRtpEncodingParameters = function(mediaSection) {\n        const encodingParameters = [];\n        const description = SDPUtils.parseRtpParameters(mediaSection);\n        const hasRed = description.fecMechanisms.indexOf('RED') !== -1;\n        const hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;\n        // filter a=ssrc:... cname:, ignore PlanB-msid\n        const ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:').map((line)=>SDPUtils.parseSsrcMedia(line)).filter((parts)=>parts.attribute === 'cname');\n        const primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;\n        let secondarySsrc;\n        const flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID').map((line)=>{\n            const parts = line.substring(17).split(' ');\n            return parts.map((part)=>parseInt(part, 10));\n        });\n        if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {\n            secondarySsrc = flows[0][1];\n        }\n        description.codecs.forEach((codec)=>{\n            if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {\n                let encParam = {\n                    ssrc: primarySsrc,\n                    codecPayloadType: parseInt(codec.parameters.apt, 10)\n                };\n                if (primarySsrc && secondarySsrc) {\n                    encParam.rtx = {\n                        ssrc: secondarySsrc\n                    };\n                }\n                encodingParameters.push(encParam);\n                if (hasRed) {\n                    encParam = JSON.parse(JSON.stringify(encParam));\n                    encParam.fec = {\n                        ssrc: primarySsrc,\n                        mechanism: hasUlpfec ? 'red+ulpfec' : 'red'\n                    };\n                    encodingParameters.push(encParam);\n                }\n            }\n        });\n        if (encodingParameters.length === 0 && primarySsrc) {\n            encodingParameters.push({\n                ssrc: primarySsrc\n            });\n        }\n        // we support both b=AS and b=TIAS but interpret AS as TIAS.\n        let bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');\n        if (bandwidth.length) {\n            if (bandwidth[0].indexOf('b=TIAS:') === 0) {\n                bandwidth = parseInt(bandwidth[0].substring(7), 10);\n            } else if (bandwidth[0].indexOf('b=AS:') === 0) {\n                // use formula from JSEP to convert b=AS to TIAS value.\n                bandwidth = parseInt(bandwidth[0].substring(5), 10) * 1000 * 0.95 - 50 * 40 * 8;\n            } else {\n                bandwidth = undefined;\n            }\n            encodingParameters.forEach((params)=>{\n                params.maxBitrate = bandwidth;\n            });\n        }\n        return encodingParameters;\n    };\n    // parses http://draft.ortc.org/#rtcrtcpparameters*\n    SDPUtils.parseRtcpParameters = function(mediaSection) {\n        const rtcpParameters = {};\n        // Gets the first SSRC. Note that with RTX there might be multiple\n        // SSRCs.\n        const remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:').map((line)=>SDPUtils.parseSsrcMedia(line)).filter((obj)=>obj.attribute === 'cname')[0];\n        if (remoteSsrc) {\n            rtcpParameters.cname = remoteSsrc.value;\n            rtcpParameters.ssrc = remoteSsrc.ssrc;\n        }\n        // Edge uses the compound attribute instead of reducedSize\n        // compound is !reducedSize\n        const rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');\n        rtcpParameters.reducedSize = rsize.length > 0;\n        rtcpParameters.compound = rsize.length === 0;\n        // parses the rtcp-mux attrbute.\n        // Note that Edge does not support unmuxed RTCP.\n        const mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');\n        rtcpParameters.mux = mux.length > 0;\n        return rtcpParameters;\n    };\n    SDPUtils.writeRtcpParameters = function(rtcpParameters) {\n        let sdp = '';\n        if (rtcpParameters.reducedSize) {\n            sdp += 'a=rtcp-rsize\\r\\n';\n        }\n        if (rtcpParameters.mux) {\n            sdp += 'a=rtcp-mux\\r\\n';\n        }\n        if (rtcpParameters.ssrc !== undefined && rtcpParameters.cname) {\n            sdp += 'a=ssrc:' + rtcpParameters.ssrc + ' cname:' + rtcpParameters.cname + '\\r\\n';\n        }\n        return sdp;\n    };\n    // parses either a=msid: or a=ssrc:... msid lines and returns\n    // the id of the MediaStream and MediaStreamTrack.\n    SDPUtils.parseMsid = function(mediaSection) {\n        let parts;\n        const spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');\n        if (spec.length === 1) {\n            parts = spec[0].substring(7).split(' ');\n            return {\n                stream: parts[0],\n                track: parts[1]\n            };\n        }\n        const planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:').map((line)=>SDPUtils.parseSsrcMedia(line)).filter((msidParts)=>msidParts.attribute === 'msid');\n        if (planB.length > 0) {\n            parts = planB[0].value.split(' ');\n            return {\n                stream: parts[0],\n                track: parts[1]\n            };\n        }\n    };\n    // SCTP\n    // parses draft-ietf-mmusic-sctp-sdp-26 first and falls back\n    // to draft-ietf-mmusic-sctp-sdp-05\n    SDPUtils.parseSctpDescription = function(mediaSection) {\n        const mline = SDPUtils.parseMLine(mediaSection);\n        const maxSizeLine = SDPUtils.matchPrefix(mediaSection, 'a=max-message-size:');\n        let maxMessageSize;\n        if (maxSizeLine.length > 0) {\n            maxMessageSize = parseInt(maxSizeLine[0].substring(19), 10);\n        }\n        if (isNaN(maxMessageSize)) {\n            maxMessageSize = 65536;\n        }\n        const sctpPort = SDPUtils.matchPrefix(mediaSection, 'a=sctp-port:');\n        if (sctpPort.length > 0) {\n            return {\n                port: parseInt(sctpPort[0].substring(12), 10),\n                protocol: mline.fmt,\n                maxMessageSize\n            };\n        }\n        const sctpMapLines = SDPUtils.matchPrefix(mediaSection, 'a=sctpmap:');\n        if (sctpMapLines.length > 0) {\n            const parts = sctpMapLines[0].substring(10).split(' ');\n            return {\n                port: parseInt(parts[0], 10),\n                protocol: parts[1],\n                maxMessageSize\n            };\n        }\n    };\n    // SCTP\n    // outputs the draft-ietf-mmusic-sctp-sdp-26 version that all browsers\n    // support by now receiving in this format, unless we originally parsed\n    // as the draft-ietf-mmusic-sctp-sdp-05 format (indicated by the m-line\n    // protocol of DTLS/SCTP -- without UDP/ or TCP/)\n    SDPUtils.writeSctpDescription = function(media, sctp) {\n        let output = [];\n        if (media.protocol !== 'DTLS/SCTP') {\n            output = [\n                'm=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.protocol + '\\r\\n',\n                'c=IN IP4 0.0.0.0\\r\\n',\n                'a=sctp-port:' + sctp.port + '\\r\\n'\n            ];\n        } else {\n            output = [\n                'm=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.port + '\\r\\n',\n                'c=IN IP4 0.0.0.0\\r\\n',\n                'a=sctpmap:' + sctp.port + ' ' + sctp.protocol + ' 65535\\r\\n'\n            ];\n        }\n        if (sctp.maxMessageSize !== undefined) {\n            output.push('a=max-message-size:' + sctp.maxMessageSize + '\\r\\n');\n        }\n        return output.join('');\n    };\n    // Generate a session ID for SDP.\n    // https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1\n    // recommends using a cryptographically random +ve 64-bit value\n    // but right now this should be acceptable and within the right range\n    SDPUtils.generateSessionId = function() {\n        return Math.random().toString().substr(2, 22);\n    };\n    // Write boiler plate for start of SDP\n    // sessId argument is optional - if not supplied it will\n    // be generated randomly\n    // sessVersion is optional and defaults to 2\n    // sessUser is optional and defaults to 'thisisadapterortc'\n    SDPUtils.writeSessionBoilerplate = function(sessId, sessVer, sessUser) {\n        let sessionId;\n        const version = sessVer !== undefined ? sessVer : 2;\n        if (sessId) {\n            sessionId = sessId;\n        } else {\n            sessionId = SDPUtils.generateSessionId();\n        }\n        const user = sessUser || 'thisisadapterortc';\n        // FIXME: sess-id should be an NTP timestamp.\n        return 'v=0\\r\\n' + 'o=' + user + ' ' + sessionId + ' ' + version + ' IN IP4 127.0.0.1\\r\\n' + 's=-\\r\\n' + 't=0 0\\r\\n';\n    };\n    // Gets the direction from the mediaSection or the sessionpart.\n    SDPUtils.getDirection = function(mediaSection, sessionpart) {\n        // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.\n        const lines = SDPUtils.splitLines(mediaSection);\n        for(let i = 0; i < lines.length; i++){\n            switch(lines[i]){\n                case 'a=sendrecv':\n                case 'a=sendonly':\n                case 'a=recvonly':\n                case 'a=inactive':\n                    return lines[i].substring(2);\n            }\n        }\n        if (sessionpart) {\n            return SDPUtils.getDirection(sessionpart);\n        }\n        return 'sendrecv';\n    };\n    SDPUtils.getKind = function(mediaSection) {\n        const lines = SDPUtils.splitLines(mediaSection);\n        const mline = lines[0].split(' ');\n        return mline[0].substring(2);\n    };\n    SDPUtils.isRejected = function(mediaSection) {\n        return mediaSection.split(' ', 2)[1] === '0';\n    };\n    SDPUtils.parseMLine = function(mediaSection) {\n        const lines = SDPUtils.splitLines(mediaSection);\n        const parts = lines[0].substring(2).split(' ');\n        return {\n            kind: parts[0],\n            port: parseInt(parts[1], 10),\n            protocol: parts[2],\n            fmt: parts.slice(3).join(' ')\n        };\n    };\n    SDPUtils.parseOLine = function(mediaSection) {\n        const line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];\n        const parts = line.substring(2).split(' ');\n        return {\n            username: parts[0],\n            sessionId: parts[1],\n            sessionVersion: parseInt(parts[2], 10),\n            netType: parts[3],\n            addressType: parts[4],\n            address: parts[5]\n        };\n    };\n    // a very naive interpretation of a valid SDP.\n    SDPUtils.isValidSDP = function(blob) {\n        if (typeof blob !== 'string' || blob.length === 0) {\n            return false;\n        }\n        const lines = SDPUtils.splitLines(blob);\n        for(let i = 0; i < lines.length; i++){\n            if (lines[i].length < 2 || lines[i].charAt(1) !== '=') {\n                return false;\n            }\n        // TODO: check the modifier a bit more.\n        }\n        return true;\n    };\n    // Expose public methods.\n    {\n        module.exports = SDPUtils;\n    }\n})(sdp$1);\nvar sdpExports = sdp$1.exports;\nvar SDPUtils = /*@__PURE__*/ getDefaultExportFromCjs(sdpExports);\nvar sdp = /*#__PURE__*/ _mergeNamespaces({\n    __proto__: null,\n    default: SDPUtils\n}, [\n    sdpExports\n]);\n/*\n *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ function shimRTCIceCandidate(window1) {\n    // foundation is arbitrarily chosen as an indicator for full support for\n    // https://w3c.github.io/webrtc-pc/#rtcicecandidate-interface\n    if (!window1.RTCIceCandidate || window1.RTCIceCandidate && 'foundation' in window1.RTCIceCandidate.prototype) {\n        return;\n    }\n    const NativeRTCIceCandidate = window1.RTCIceCandidate;\n    window1.RTCIceCandidate = function RTCIceCandidate1(args) {\n        // Remove the a= which shouldn't be part of the candidate string.\n        if (typeof args === 'object' && args.candidate && args.candidate.indexOf('a=') === 0) {\n            args = JSON.parse(JSON.stringify(args));\n            args.candidate = args.candidate.substring(2);\n        }\n        if (args.candidate && args.candidate.length) {\n            // Augment the native candidate with the parsed fields.\n            const nativeCandidate = new NativeRTCIceCandidate(args);\n            const parsedCandidate = SDPUtils.parseCandidate(args.candidate);\n            for(const key in parsedCandidate){\n                if (!(key in nativeCandidate)) {\n                    Object.defineProperty(nativeCandidate, key, {\n                        value: parsedCandidate[key]\n                    });\n                }\n            }\n            // Override serializer to not serialize the extra attributes.\n            nativeCandidate.toJSON = function toJSON() {\n                return {\n                    candidate: nativeCandidate.candidate,\n                    sdpMid: nativeCandidate.sdpMid,\n                    sdpMLineIndex: nativeCandidate.sdpMLineIndex,\n                    usernameFragment: nativeCandidate.usernameFragment\n                };\n            };\n            return nativeCandidate;\n        }\n        return new NativeRTCIceCandidate(args);\n    };\n    window1.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;\n    // Hook up the augmented candidate in onicecandidate and\n    // addEventListener('icecandidate', ...)\n    wrapPeerConnectionEvent(window1, 'icecandidate', (e)=>{\n        if (e.candidate) {\n            Object.defineProperty(e, 'candidate', {\n                value: new window1.RTCIceCandidate(e.candidate),\n                writable: 'false'\n            });\n        }\n        return e;\n    });\n}\nfunction shimRTCIceCandidateRelayProtocol(window1) {\n    if (!window1.RTCIceCandidate || window1.RTCIceCandidate && 'relayProtocol' in window1.RTCIceCandidate.prototype) {\n        return;\n    }\n    // Hook up the augmented candidate in onicecandidate and\n    // addEventListener('icecandidate', ...)\n    wrapPeerConnectionEvent(window1, 'icecandidate', (e)=>{\n        if (e.candidate) {\n            const parsedCandidate = SDPUtils.parseCandidate(e.candidate.candidate);\n            if (parsedCandidate.type === 'relay') {\n                // This is a libwebrtc-specific mapping of local type preference\n                // to relayProtocol.\n                e.candidate.relayProtocol = ({\n                    0: 'tls',\n                    1: 'tcp',\n                    2: 'udp'\n                })[parsedCandidate.priority >> 24];\n            }\n        }\n        return e;\n    });\n}\nfunction shimMaxMessageSize(window1, browserDetails) {\n    if (!window1.RTCPeerConnection) {\n        return;\n    }\n    if (!('sctp' in window1.RTCPeerConnection.prototype)) {\n        Object.defineProperty(window1.RTCPeerConnection.prototype, 'sctp', {\n            get () {\n                return typeof this._sctp === 'undefined' ? null : this._sctp;\n            }\n        });\n    }\n    const sctpInDescription = function(description) {\n        if (!description || !description.sdp) {\n            return false;\n        }\n        const sections = SDPUtils.splitSections(description.sdp);\n        sections.shift();\n        return sections.some((mediaSection)=>{\n            const mLine = SDPUtils.parseMLine(mediaSection);\n            return mLine && mLine.kind === 'application' && mLine.protocol.indexOf('SCTP') !== -1;\n        });\n    };\n    const getRemoteFirefoxVersion = function(description) {\n        // TODO: Is there a better solution for detecting Firefox?\n        const match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\\d+)/);\n        if (match === null || match.length < 2) {\n            return -1;\n        }\n        const version = parseInt(match[1], 10);\n        // Test for NaN (yes, this is ugly)\n        return version !== version ? -1 : version;\n    };\n    const getCanSendMaxMessageSize = function(remoteIsFirefox) {\n        // Every implementation we know can send at least 64 KiB.\n        // Note: Although Chrome is technically able to send up to 256 KiB, the\n        //       data does not reach the other peer reliably.\n        //       See: https://bugs.chromium.org/p/webrtc/issues/detail?id=8419\n        let canSendMaxMessageSize = 65536;\n        if (browserDetails.browser === 'firefox') {\n            if (browserDetails.version < 57) {\n                if (remoteIsFirefox === -1) {\n                    // FF < 57 will send in 16 KiB chunks using the deprecated PPID\n                    // fragmentation.\n                    canSendMaxMessageSize = 16384;\n                } else {\n                    // However, other FF (and RAWRTC) can reassemble PPID-fragmented\n                    // messages. Thus, supporting ~2 GiB when sending.\n                    canSendMaxMessageSize = 2147483637;\n                }\n            } else if (browserDetails.version < 60) {\n                // Currently, all FF >= 57 will reset the remote maximum message size\n                // to the default value when a data channel is created at a later\n                // stage. :(\n                // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831\n                canSendMaxMessageSize = browserDetails.version === 57 ? 65535 : 65536;\n            } else {\n                // FF >= 60 supports sending ~2 GiB\n                canSendMaxMessageSize = 2147483637;\n            }\n        }\n        return canSendMaxMessageSize;\n    };\n    const getMaxMessageSize = function(description, remoteIsFirefox) {\n        // Note: 65536 bytes is the default value from the SDP spec. Also,\n        //       every implementation we know supports receiving 65536 bytes.\n        let maxMessageSize = 65536;\n        // FF 57 has a slightly incorrect default remote max message size, so\n        // we need to adjust it here to avoid a failure when sending.\n        // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1425697\n        if (browserDetails.browser === 'firefox' && browserDetails.version === 57) {\n            maxMessageSize = 65535;\n        }\n        const match = SDPUtils.matchPrefix(description.sdp, 'a=max-message-size:');\n        if (match.length > 0) {\n            maxMessageSize = parseInt(match[0].substring(19), 10);\n        } else if (browserDetails.browser === 'firefox' && remoteIsFirefox !== -1) {\n            // If the maximum message size is not present in the remote SDP and\n            // both local and remote are Firefox, the remote peer can receive\n            // ~2 GiB.\n            maxMessageSize = 2147483637;\n        }\n        return maxMessageSize;\n    };\n    const origSetRemoteDescription = window1.RTCPeerConnection.prototype.setRemoteDescription;\n    window1.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n        this._sctp = null;\n        // Chrome decided to not expose .sctp in plan-b mode.\n        // As usual, adapter.js has to do an 'ugly worakaround'\n        // to cover up the mess.\n        if (browserDetails.browser === 'chrome' && browserDetails.version >= 76) {\n            const { sdpSemantics } = this.getConfiguration();\n            if (sdpSemantics === 'plan-b') {\n                Object.defineProperty(this, 'sctp', {\n                    get () {\n                        return typeof this._sctp === 'undefined' ? null : this._sctp;\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n            }\n        }\n        if (sctpInDescription(arguments[0])) {\n            // Check if the remote is FF.\n            const isFirefox = getRemoteFirefoxVersion(arguments[0]);\n            // Get the maximum message size the local peer is capable of sending\n            const canSendMMS = getCanSendMaxMessageSize(isFirefox);\n            // Get the maximum message size of the remote peer.\n            const remoteMMS = getMaxMessageSize(arguments[0], isFirefox);\n            // Determine final maximum message size\n            let maxMessageSize;\n            if (canSendMMS === 0 && remoteMMS === 0) {\n                maxMessageSize = Number.POSITIVE_INFINITY;\n            } else if (canSendMMS === 0 || remoteMMS === 0) {\n                maxMessageSize = Math.max(canSendMMS, remoteMMS);\n            } else {\n                maxMessageSize = Math.min(canSendMMS, remoteMMS);\n            }\n            // Create a dummy RTCSctpTransport object and the 'maxMessageSize'\n            // attribute.\n            const sctp = {};\n            Object.defineProperty(sctp, 'maxMessageSize', {\n                get () {\n                    return maxMessageSize;\n                }\n            });\n            this._sctp = sctp;\n        }\n        return origSetRemoteDescription.apply(this, arguments);\n    };\n}\nfunction shimSendThrowTypeError(window1) {\n    if (!(window1.RTCPeerConnection && 'createDataChannel' in window1.RTCPeerConnection.prototype)) {\n        return;\n    }\n    // Note: Although Firefox >= 57 has a native implementation, the maximum\n    //       message size can be reset for all data channels at a later stage.\n    //       See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831\n    function wrapDcSend(dc, pc) {\n        const origDataChannelSend = dc.send;\n        dc.send = function send() {\n            const data = arguments[0];\n            const length = data.length || data.size || data.byteLength;\n            if (dc.readyState === 'open' && pc.sctp && length > pc.sctp.maxMessageSize) {\n                throw new TypeError('Message too large (can send a maximum of ' + pc.sctp.maxMessageSize + ' bytes)');\n            }\n            return origDataChannelSend.apply(dc, arguments);\n        };\n    }\n    const origCreateDataChannel = window1.RTCPeerConnection.prototype.createDataChannel;\n    window1.RTCPeerConnection.prototype.createDataChannel = function createDataChannel() {\n        const dataChannel = origCreateDataChannel.apply(this, arguments);\n        wrapDcSend(dataChannel, this);\n        return dataChannel;\n    };\n    wrapPeerConnectionEvent(window1, 'datachannel', (e)=>{\n        wrapDcSend(e.channel, e.target);\n        return e;\n    });\n}\n/* shims RTCConnectionState by pretending it is the same as iceConnectionState.\n * See https://bugs.chromium.org/p/webrtc/issues/detail?id=6145#c12\n * for why this is a valid hack in Chrome. In Firefox it is slightly incorrect\n * since DTLS failures would be hidden. See\n * https://bugzilla.mozilla.org/show_bug.cgi?id=1265827\n * for the Firefox tracking bug.\n */ function shimConnectionState(window1) {\n    if (!window1.RTCPeerConnection || 'connectionState' in window1.RTCPeerConnection.prototype) {\n        return;\n    }\n    const proto = window1.RTCPeerConnection.prototype;\n    Object.defineProperty(proto, 'connectionState', {\n        get () {\n            return ({\n                completed: 'connected',\n                checking: 'connecting'\n            })[this.iceConnectionState] || this.iceConnectionState;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(proto, 'onconnectionstatechange', {\n        get () {\n            return this._onconnectionstatechange || null;\n        },\n        set (cb) {\n            if (this._onconnectionstatechange) {\n                this.removeEventListener('connectionstatechange', this._onconnectionstatechange);\n                delete this._onconnectionstatechange;\n            }\n            if (cb) {\n                this.addEventListener('connectionstatechange', this._onconnectionstatechange = cb);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    [\n        'setLocalDescription',\n        'setRemoteDescription'\n    ].forEach((method)=>{\n        const origMethod = proto[method];\n        proto[method] = function() {\n            if (!this._connectionstatechangepoly) {\n                this._connectionstatechangepoly = (e)=>{\n                    const pc = e.target;\n                    if (pc._lastConnectionState !== pc.connectionState) {\n                        pc._lastConnectionState = pc.connectionState;\n                        const newEvent = new Event('connectionstatechange', e);\n                        pc.dispatchEvent(newEvent);\n                    }\n                    return e;\n                };\n                this.addEventListener('iceconnectionstatechange', this._connectionstatechangepoly);\n            }\n            return origMethod.apply(this, arguments);\n        };\n    });\n}\nfunction removeExtmapAllowMixed(window1, browserDetails) {\n    /* remove a=extmap-allow-mixed for webrtc.org < M71 */ if (!window1.RTCPeerConnection) {\n        return;\n    }\n    if (browserDetails.browser === 'chrome' && browserDetails.version >= 71) {\n        return;\n    }\n    if (browserDetails.browser === 'safari' && browserDetails.version >= 605) {\n        return;\n    }\n    const nativeSRD = window1.RTCPeerConnection.prototype.setRemoteDescription;\n    window1.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription(desc) {\n        if (desc && desc.sdp && desc.sdp.indexOf('\\na=extmap-allow-mixed') !== -1) {\n            const sdp = desc.sdp.split('\\n').filter((line)=>{\n                return line.trim() !== 'a=extmap-allow-mixed';\n            }).join('\\n');\n            // Safari enforces read-only-ness of RTCSessionDescription fields.\n            if (window1.RTCSessionDescription && desc instanceof window1.RTCSessionDescription) {\n                arguments[0] = new window1.RTCSessionDescription({\n                    type: desc.type,\n                    sdp\n                });\n            } else {\n                desc.sdp = sdp;\n            }\n        }\n        return nativeSRD.apply(this, arguments);\n    };\n}\nfunction shimAddIceCandidateNullOrEmpty(window1, browserDetails) {\n    // Support for addIceCandidate(null or undefined)\n    // as well as addIceCandidate({candidate: \"\", ...})\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=978582\n    // Note: must be called before other polyfills which change the signature.\n    if (!(window1.RTCPeerConnection && window1.RTCPeerConnection.prototype)) {\n        return;\n    }\n    const nativeAddIceCandidate = window1.RTCPeerConnection.prototype.addIceCandidate;\n    if (!nativeAddIceCandidate || nativeAddIceCandidate.length === 0) {\n        return;\n    }\n    window1.RTCPeerConnection.prototype.addIceCandidate = function addIceCandidate() {\n        if (!arguments[0]) {\n            if (arguments[1]) {\n                arguments[1].apply(null);\n            }\n            return Promise.resolve();\n        }\n        // Firefox 68+ emits and processes {candidate: \"\", ...}, ignore\n        // in older versions.\n        // Native support for ignoring exists for Chrome M77+.\n        // Safari ignores as well, exact version unknown but works in the same\n        // version that also ignores addIceCandidate(null).\n        if ((browserDetails.browser === 'chrome' && browserDetails.version < 78 || browserDetails.browser === 'firefox' && browserDetails.version < 68 || browserDetails.browser === 'safari') && arguments[0] && arguments[0].candidate === '') {\n            return Promise.resolve();\n        }\n        return nativeAddIceCandidate.apply(this, arguments);\n    };\n}\n// Note: Make sure to call this ahead of APIs that modify\n// setLocalDescription.length\nfunction shimParameterlessSetLocalDescription(window1, browserDetails) {\n    if (!(window1.RTCPeerConnection && window1.RTCPeerConnection.prototype)) {\n        return;\n    }\n    const nativeSetLocalDescription = window1.RTCPeerConnection.prototype.setLocalDescription;\n    if (!nativeSetLocalDescription || nativeSetLocalDescription.length === 0) {\n        return;\n    }\n    window1.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {\n        let desc = arguments[0] || {};\n        if (typeof desc !== 'object' || desc.type && desc.sdp) {\n            return nativeSetLocalDescription.apply(this, arguments);\n        }\n        // The remaining steps should technically happen when SLD comes off the\n        // RTCPeerConnection's operations chain (not ahead of going on it), but\n        // this is too difficult to shim. Instead, this shim only covers the\n        // common case where the operations chain is empty. This is imperfect, but\n        // should cover many cases. Rationale: Even if we can't reduce the glare\n        // window to zero on imperfect implementations, there's value in tapping\n        // into the perfect negotiation pattern that several browsers support.\n        desc = {\n            type: desc.type,\n            sdp: desc.sdp\n        };\n        if (!desc.type) {\n            switch(this.signalingState){\n                case 'stable':\n                case 'have-local-offer':\n                case 'have-remote-pranswer':\n                    desc.type = 'offer';\n                    break;\n                default:\n                    desc.type = 'answer';\n                    break;\n            }\n        }\n        if (desc.sdp || desc.type !== 'offer' && desc.type !== 'answer') {\n            return nativeSetLocalDescription.apply(this, [\n                desc\n            ]);\n        }\n        const func = desc.type === 'offer' ? this.createOffer : this.createAnswer;\n        return func.apply(this).then((d)=>nativeSetLocalDescription.apply(this, [\n                d\n            ]));\n    };\n}\nvar commonShim = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    removeExtmapAllowMixed: removeExtmapAllowMixed,\n    shimAddIceCandidateNullOrEmpty: shimAddIceCandidateNullOrEmpty,\n    shimConnectionState: shimConnectionState,\n    shimMaxMessageSize: shimMaxMessageSize,\n    shimParameterlessSetLocalDescription: shimParameterlessSetLocalDescription,\n    shimRTCIceCandidate: shimRTCIceCandidate,\n    shimRTCIceCandidateRelayProtocol: shimRTCIceCandidateRelayProtocol,\n    shimSendThrowTypeError: shimSendThrowTypeError\n});\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ // Shimming starts here.\nfunction adapterFactory() {\n    let { window: window1 } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        shimChrome: true,\n        shimFirefox: true,\n        shimSafari: true\n    };\n    // Utils.\n    const logging = log;\n    const browserDetails = detectBrowser(window1);\n    const adapter = {\n        browserDetails,\n        commonShim,\n        extractVersion: extractVersion,\n        disableLog: disableLog,\n        disableWarnings: disableWarnings,\n        // Expose sdp as a convenience. For production apps include directly.\n        sdp\n    };\n    // Shim browser if found.\n    switch(browserDetails.browser){\n        case 'chrome':\n            if (!chromeShim || !shimPeerConnection$1 || !options.shimChrome) {\n                logging('Chrome shim is not included in this adapter release.');\n                return adapter;\n            }\n            if (browserDetails.version === null) {\n                logging('Chrome shim can not determine version, not shimming.');\n                return adapter;\n            }\n            logging('adapter.js shimming chrome.');\n            // Export to the adapter global object visible in the browser.\n            adapter.browserShim = chromeShim;\n            // Must be called before shimPeerConnection.\n            shimAddIceCandidateNullOrEmpty(window1, browserDetails);\n            shimParameterlessSetLocalDescription(window1);\n            shimGetUserMedia$2(window1, browserDetails);\n            shimMediaStream(window1);\n            shimPeerConnection$1(window1, browserDetails);\n            shimOnTrack$1(window1);\n            shimAddTrackRemoveTrack(window1, browserDetails);\n            shimGetSendersWithDtmf(window1);\n            shimGetStats(window1);\n            shimSenderReceiverGetStats(window1);\n            fixNegotiationNeeded(window1, browserDetails);\n            shimRTCIceCandidate(window1);\n            shimRTCIceCandidateRelayProtocol(window1);\n            shimConnectionState(window1);\n            shimMaxMessageSize(window1, browserDetails);\n            shimSendThrowTypeError(window1);\n            removeExtmapAllowMixed(window1, browserDetails);\n            break;\n        case 'firefox':\n            if (!firefoxShim || !shimPeerConnection || !options.shimFirefox) {\n                logging('Firefox shim is not included in this adapter release.');\n                return adapter;\n            }\n            logging('adapter.js shimming firefox.');\n            // Export to the adapter global object visible in the browser.\n            adapter.browserShim = firefoxShim;\n            // Must be called before shimPeerConnection.\n            shimAddIceCandidateNullOrEmpty(window1, browserDetails);\n            shimParameterlessSetLocalDescription(window1);\n            shimGetUserMedia$1(window1, browserDetails);\n            shimPeerConnection(window1, browserDetails);\n            shimOnTrack(window1);\n            shimRemoveStream(window1);\n            shimSenderGetStats(window1);\n            shimReceiverGetStats(window1);\n            shimRTCDataChannel(window1);\n            shimAddTransceiver(window1);\n            shimGetParameters(window1);\n            shimCreateOffer(window1);\n            shimCreateAnswer(window1);\n            shimRTCIceCandidate(window1);\n            shimConnectionState(window1);\n            shimMaxMessageSize(window1, browserDetails);\n            shimSendThrowTypeError(window1);\n            break;\n        case 'safari':\n            if (!safariShim || !options.shimSafari) {\n                logging('Safari shim is not included in this adapter release.');\n                return adapter;\n            }\n            logging('adapter.js shimming safari.');\n            // Export to the adapter global object visible in the browser.\n            adapter.browserShim = safariShim;\n            // Must be called before shimCallbackAPI.\n            shimAddIceCandidateNullOrEmpty(window1, browserDetails);\n            shimParameterlessSetLocalDescription(window1);\n            shimRTCIceServerUrls(window1);\n            shimCreateOfferLegacy(window1);\n            shimCallbacksAPI(window1);\n            shimLocalStreamsAPI(window1);\n            shimRemoteStreamsAPI(window1);\n            shimTrackEventTransceiver(window1);\n            shimGetUserMedia(window1);\n            shimAudioContext(window1);\n            shimRTCIceCandidate(window1);\n            shimRTCIceCandidateRelayProtocol(window1);\n            shimMaxMessageSize(window1, browserDetails);\n            shimSendThrowTypeError(window1);\n            removeExtmapAllowMixed(window1, browserDetails);\n            break;\n        default:\n            logging('Unsupported browser!');\n            break;\n    }\n    return adapter;\n}\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ adapterFactory({\n    window:  true ? undefined : 0\n});\nconst ENCRYPTION_ALGORITHM = 'AES-GCM';\n// How many consecutive frames can fail decrypting before a particular key gets marked as invalid\nconst DECRYPTION_FAILURE_TOLERANCE = 10;\n// flag set to indicate that e2ee has been setup for sender/receiver;\nconst E2EE_FLAG = 'lk_e2ee';\nconst SALT = 'LKFrameEncryptionKey';\nconst KEY_PROVIDER_DEFAULTS = {\n    sharedKey: false,\n    ratchetSalt: SALT,\n    ratchetWindowSize: 8,\n    failureTolerance: DECRYPTION_FAILURE_TOLERANCE\n};\nvar KeyProviderEvent;\n(function(KeyProviderEvent) {\n    KeyProviderEvent[\"SetKey\"] = \"setKey\";\n    KeyProviderEvent[\"RatchetRequest\"] = \"ratchetRequest\";\n    KeyProviderEvent[\"KeyRatcheted\"] = \"keyRatcheted\";\n})(KeyProviderEvent || (KeyProviderEvent = {}));\nvar KeyHandlerEvent;\n(function(KeyHandlerEvent) {\n    KeyHandlerEvent[\"KeyRatcheted\"] = \"keyRatcheted\";\n})(KeyHandlerEvent || (KeyHandlerEvent = {}));\nvar EncryptionEvent;\n(function(EncryptionEvent) {\n    EncryptionEvent[\"ParticipantEncryptionStatusChanged\"] = \"participantEncryptionStatusChanged\";\n    EncryptionEvent[\"EncryptionError\"] = \"encryptionError\";\n})(EncryptionEvent || (EncryptionEvent = {}));\nvar CryptorEvent;\n(function(CryptorEvent) {\n    CryptorEvent[\"Error\"] = \"cryptorError\";\n})(CryptorEvent || (CryptorEvent = {}));\nfunction isE2EESupported() {\n    return isInsertableStreamSupported() || isScriptTransformSupported();\n}\nfunction isScriptTransformSupported() {\n    // @ts-ignore\n    return typeof window.RTCRtpScriptTransform !== 'undefined';\n}\nfunction isInsertableStreamSupported() {\n    return typeof window.RTCRtpSender !== 'undefined' && // @ts-ignore\n    typeof window.RTCRtpSender.prototype.createEncodedStreams !== 'undefined';\n}\nfunction isVideoFrame(frame) {\n    return 'type' in frame;\n}\nfunction importKey(keyBytes) {\n    let algorithm = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        name: ENCRYPTION_ALGORITHM\n    };\n    let usage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'encrypt';\n    return __awaiter(this, void 0, void 0, function*() {\n        // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey\n        return crypto.subtle.importKey('raw', keyBytes, algorithm, false, usage === 'derive' ? [\n            'deriveBits',\n            'deriveKey'\n        ] : [\n            'encrypt',\n            'decrypt'\n        ]);\n    });\n}\nfunction createKeyMaterialFromString(password) {\n    return __awaiter(this, void 0, void 0, function*() {\n        let enc = new TextEncoder();\n        const keyMaterial = yield crypto.subtle.importKey('raw', enc.encode(password), {\n            name: 'PBKDF2'\n        }, false, [\n            'deriveBits',\n            'deriveKey'\n        ]);\n        return keyMaterial;\n    });\n}\nfunction createKeyMaterialFromBuffer(cryptoBuffer) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const keyMaterial = yield crypto.subtle.importKey('raw', cryptoBuffer, 'HKDF', false, [\n            'deriveBits',\n            'deriveKey'\n        ]);\n        return keyMaterial;\n    });\n}\nfunction getAlgoOptions(algorithmName, salt) {\n    const textEncoder = new TextEncoder();\n    const encodedSalt = textEncoder.encode(salt);\n    switch(algorithmName){\n        case 'HKDF':\n            return {\n                name: 'HKDF',\n                salt: encodedSalt,\n                hash: 'SHA-256',\n                info: new ArrayBuffer(128)\n            };\n        case 'PBKDF2':\n            {\n                return {\n                    name: 'PBKDF2',\n                    salt: encodedSalt,\n                    hash: 'SHA-256',\n                    iterations: 100000\n                };\n            }\n        default:\n            throw new Error(\"algorithm \".concat(algorithmName, \" is currently unsupported\"));\n    }\n}\n/**\n * Derives a set of keys from the master key.\n * See https://tools.ietf.org/html/draft-omara-sframe-00#section-4.3.1\n */ function deriveKeys(material, salt) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const algorithmOptions = getAlgoOptions(material.algorithm.name, salt);\n        // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/deriveKey#HKDF\n        // https://developer.mozilla.org/en-US/docs/Web/API/HkdfParams\n        const encryptionKey = yield crypto.subtle.deriveKey(algorithmOptions, material, {\n            name: ENCRYPTION_ALGORITHM,\n            length: 128\n        }, false, [\n            'encrypt',\n            'decrypt'\n        ]);\n        return {\n            material,\n            encryptionKey\n        };\n    });\n}\nfunction createE2EEKey() {\n    return window.crypto.getRandomValues(new Uint8Array(32));\n}\n/**\n * Ratchets a key. See\n * https://tools.ietf.org/html/draft-omara-sframe-00#section-4.3.5.1\n */ function ratchet(material, salt) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const algorithmOptions = getAlgoOptions(material.algorithm.name, salt);\n        // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/deriveBits\n        return crypto.subtle.deriveBits(algorithmOptions, material, 256);\n    });\n}\nfunction needsRbspUnescaping(frameData) {\n    for(var i = 0; i < frameData.length - 3; i++){\n        if (frameData[i] == 0 && frameData[i + 1] == 0 && frameData[i + 2] == 3) return true;\n    }\n    return false;\n}\nfunction parseRbsp(stream) {\n    const dataOut = [];\n    var length = stream.length;\n    for(var i = 0; i < stream.length;){\n        // Be careful about over/underflow here. byte_length_ - 3 can underflow, and\n        // i + 3 can overflow, but byte_length_ - i can't, because i < byte_length_\n        // above, and that expression will produce the number of bytes left in\n        // the stream including the byte at i.\n        if (length - i >= 3 && !stream[i] && !stream[i + 1] && stream[i + 2] == 3) {\n            // Two rbsp bytes.\n            dataOut.push(stream[i++]);\n            dataOut.push(stream[i++]);\n            // Skip the emulation byte.\n            i++;\n        } else {\n            // Single rbsp byte.\n            dataOut.push(stream[i++]);\n        }\n    }\n    return new Uint8Array(dataOut);\n}\nconst kZerosInStartSequence = 2;\nconst kEmulationByte = 3;\nfunction writeRbsp(data_in) {\n    const dataOut = [];\n    var numConsecutiveZeros = 0;\n    for(var i = 0; i < data_in.length; ++i){\n        var byte = data_in[i];\n        if (byte <= kEmulationByte && numConsecutiveZeros >= kZerosInStartSequence) {\n            // Need to escape.\n            dataOut.push(kEmulationByte);\n            numConsecutiveZeros = 0;\n        }\n        dataOut.push(byte);\n        if (byte == 0) {\n            ++numConsecutiveZeros;\n        } else {\n            numConsecutiveZeros = 0;\n        }\n    }\n    return new Uint8Array(dataOut);\n}\n/**\n * @experimental\n */ class BaseKeyProvider extends eventsExports.EventEmitter {\n    constructor(){\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        super();\n        /**\n     * callback being invoked after a ratchet request has been performed on a participant\n     * that surfaces the new key material.\n     * @param material\n     * @param keyIndex\n     */ this.onKeyRatcheted = (material, keyIndex)=>{\n            livekitLogger.debug('key ratcheted event received', {\n                material,\n                keyIndex\n            });\n        };\n        this.keyInfoMap = new Map();\n        this.options = Object.assign(Object.assign({}, KEY_PROVIDER_DEFAULTS), options);\n        this.on(KeyProviderEvent.KeyRatcheted, this.onKeyRatcheted);\n    }\n    /**\n   * callback to invoke once a key has been set for a participant\n   * @param key\n   * @param participantIdentity\n   * @param keyIndex\n   */ onSetEncryptionKey(key, participantIdentity, keyIndex) {\n        const keyInfo = {\n            key,\n            participantIdentity,\n            keyIndex\n        };\n        this.keyInfoMap.set(\"\".concat(participantIdentity !== null && participantIdentity !== void 0 ? participantIdentity : 'shared', \"-\").concat(keyIndex !== null && keyIndex !== void 0 ? keyIndex : 0), keyInfo);\n        this.emit(KeyProviderEvent.SetKey, keyInfo);\n    }\n    getKeys() {\n        return Array.from(this.keyInfoMap.values());\n    }\n    getOptions() {\n        return this.options;\n    }\n    ratchetKey(participantIdentity, keyIndex) {\n        this.emit(KeyProviderEvent.RatchetRequest, participantIdentity, keyIndex);\n    }\n}\n/**\n * A basic KeyProvider implementation intended for a single shared\n * passphrase between all participants\n * @experimental\n */ class ExternalE2EEKeyProvider extends BaseKeyProvider {\n    constructor(){\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        const opts = Object.assign(Object.assign({}, options), {\n            sharedKey: true,\n            // for a shared key provider failing to decrypt for a specific participant\n            // should not mark the key as invalid, so we accept wrong keys forever\n            // and won't try to auto-ratchet\n            ratchetWindowSize: 0,\n            failureTolerance: -1\n        });\n        super(opts);\n    }\n    /**\n   * Accepts a passphrase that's used to create the crypto keys.\n   * When passing in a string, PBKDF2 is used.\n   * When passing in an Array buffer of cryptographically random numbers, HKDF is being used. (recommended)\n   * @param key\n   */ setKey(key) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const derivedKey = typeof key === 'string' ? yield createKeyMaterialFromString(key) : yield createKeyMaterialFromBuffer(key);\n            this.onSetEncryptionKey(derivedKey);\n        });\n    }\n}\nclass LivekitError extends Error {\n    constructor(code, message){\n        super(message || 'an error has occured');\n        this.code = code;\n    }\n}\nclass ConnectionError extends LivekitError {\n    constructor(message, reason, status){\n        super(1, message);\n        this.status = status;\n        this.reason = reason;\n    }\n}\nclass DeviceUnsupportedError extends LivekitError {\n    constructor(message){\n        super(21, message !== null && message !== void 0 ? message : 'device is unsupported');\n    }\n}\nclass TrackInvalidError extends LivekitError {\n    constructor(message){\n        super(20, message !== null && message !== void 0 ? message : 'track is invalid');\n    }\n}\nclass UnsupportedServer extends LivekitError {\n    constructor(message){\n        super(10, message !== null && message !== void 0 ? message : 'unsupported server');\n    }\n}\nclass UnexpectedConnectionState extends LivekitError {\n    constructor(message){\n        super(12, message !== null && message !== void 0 ? message : 'unexpected connection state');\n    }\n}\nclass NegotiationError extends LivekitError {\n    constructor(message){\n        super(13, message !== null && message !== void 0 ? message : 'unable to negotiate');\n    }\n}\nclass PublishDataError extends LivekitError {\n    constructor(message){\n        super(13, message !== null && message !== void 0 ? message : 'unable to publish data');\n    }\n}\nvar MediaDeviceFailure;\n(function(MediaDeviceFailure) {\n    // user rejected permissions\n    MediaDeviceFailure[\"PermissionDenied\"] = \"PermissionDenied\";\n    // device is not available\n    MediaDeviceFailure[\"NotFound\"] = \"NotFound\";\n    // device is in use. On Windows, only a single tab may get access to a device at a time.\n    MediaDeviceFailure[\"DeviceInUse\"] = \"DeviceInUse\";\n    MediaDeviceFailure[\"Other\"] = \"Other\";\n})(MediaDeviceFailure || (MediaDeviceFailure = {}));\n(function(MediaDeviceFailure) {\n    function getFailure(error) {\n        if (error && 'name' in error) {\n            if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {\n                return MediaDeviceFailure.NotFound;\n            }\n            if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {\n                return MediaDeviceFailure.PermissionDenied;\n            }\n            if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {\n                return MediaDeviceFailure.DeviceInUse;\n            }\n            return MediaDeviceFailure.Other;\n        }\n    }\n    MediaDeviceFailure.getFailure = getFailure;\n})(MediaDeviceFailure || (MediaDeviceFailure = {}));\n/**\n * Events are the primary way LiveKit notifies your application of changes.\n *\n * The following are events emitted by [[Room]], listen to room events like\n *\n * ```typescript\n * room.on(RoomEvent.TrackPublished, (track, publication, participant) => {})\n * ```\n */ var RoomEvent;\n(function(RoomEvent) {\n    /**\n   * When the connection to the server has been established\n   */ RoomEvent[\"Connected\"] = \"connected\";\n    /**\n   * When the connection to the server has been interrupted and it's attempting\n   * to reconnect.\n   */ RoomEvent[\"Reconnecting\"] = \"reconnecting\";\n    /**\n   * Fires when a reconnection has been successful.\n   */ RoomEvent[\"Reconnected\"] = \"reconnected\";\n    /**\n   * When disconnected from room. This fires when room.disconnect() is called or\n   * when an unrecoverable connection issue had occured\n   */ RoomEvent[\"Disconnected\"] = \"disconnected\";\n    /**\n   * Whenever the connection state of the room changes\n   *\n   * args: ([[ConnectionState]])\n   */ RoomEvent[\"ConnectionStateChanged\"] = \"connectionStateChanged\";\n    /**\n   * @deprecated StateChanged has been renamed to ConnectionStateChanged\n   */ RoomEvent[\"StateChanged\"] = \"connectionStateChanged\";\n    /**\n   * When input or output devices on the machine have changed.\n   */ RoomEvent[\"MediaDevicesChanged\"] = \"mediaDevicesChanged\";\n    /**\n   * When a [[RemoteParticipant]] joins *after* the local\n   * participant. It will not emit events for participants that are already\n   * in the room\n   *\n   * args: ([[RemoteParticipant]])\n   */ RoomEvent[\"ParticipantConnected\"] = \"participantConnected\";\n    /**\n   * When a [[RemoteParticipant]] leaves *after* the local\n   * participant has joined.\n   *\n   * args: ([[RemoteParticipant]])\n   */ RoomEvent[\"ParticipantDisconnected\"] = \"participantDisconnected\";\n    /**\n   * When a new track is published to room *after* the local\n   * participant has joined. It will not fire for tracks that are already published.\n   *\n   * A track published doesn't mean the participant has subscribed to it. It's\n   * simply reflecting the state of the room.\n   *\n   * args: ([[RemoteTrackPublication]], [[RemoteParticipant]])\n   */ RoomEvent[\"TrackPublished\"] = \"trackPublished\";\n    /**\n   * The [[LocalParticipant]] has subscribed to a new track. This event will **always**\n   * fire as long as new tracks are ready for use.\n   *\n   * args: ([[RemoteTrack]], [[RemoteTrackPublication]], [[RemoteParticipant]])\n   */ RoomEvent[\"TrackSubscribed\"] = \"trackSubscribed\";\n    /**\n   * Could not subscribe to a track\n   *\n   * args: (track sid, [[RemoteParticipant]])\n   */ RoomEvent[\"TrackSubscriptionFailed\"] = \"trackSubscriptionFailed\";\n    /**\n   * A [[RemoteParticipant]] has unpublished a track\n   *\n   * args: ([[RemoteTrackPublication]], [[RemoteParticipant]])\n   */ RoomEvent[\"TrackUnpublished\"] = \"trackUnpublished\";\n    /**\n   * A subscribed track is no longer available. Clients should listen to this\n   * event and ensure they detach tracks.\n   *\n   * args: ([[Track]], [[RemoteTrackPublication]], [[RemoteParticipant]])\n   */ RoomEvent[\"TrackUnsubscribed\"] = \"trackUnsubscribed\";\n    /**\n   * A track that was muted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]\n   *\n   * args: ([[TrackPublication]], [[Participant]])\n   */ RoomEvent[\"TrackMuted\"] = \"trackMuted\";\n    /**\n   * A track that was unmuted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]\n   *\n   * args: ([[TrackPublication]], [[Participant]])\n   */ RoomEvent[\"TrackUnmuted\"] = \"trackUnmuted\";\n    /**\n   * A local track was published successfully. This event is helpful to know\n   * when to update your local UI with the newly published track.\n   *\n   * args: ([[LocalTrackPublication]], [[LocalParticipant]])\n   */ RoomEvent[\"LocalTrackPublished\"] = \"localTrackPublished\";\n    /**\n   * A local track was unpublished. This event is helpful to know when to remove\n   * the local track from your UI.\n   *\n   * When a user stops sharing their screen by pressing \"End\" on the browser UI,\n   * this event will also fire.\n   *\n   * args: ([[LocalTrackPublication]], [[LocalParticipant]])\n   */ RoomEvent[\"LocalTrackUnpublished\"] = \"localTrackUnpublished\";\n    /**\n   * When a local audio track is published the SDK checks whether there is complete silence\n   * on that track and emits the LocalAudioSilenceDetected event in that case.\n   * This allows for applications to show UI informing users that they might have to\n   * reset their audio hardware or check for proper device connectivity.\n   */ RoomEvent[\"LocalAudioSilenceDetected\"] = \"localAudioSilenceDetected\";\n    /**\n   * Active speakers changed. List of speakers are ordered by their audio level.\n   * loudest speakers first. This will include the LocalParticipant too.\n   *\n   * Speaker updates are sent only to the publishing participant and their subscribers.\n   *\n   * args: (Array<[[Participant]]>)\n   */ RoomEvent[\"ActiveSpeakersChanged\"] = \"activeSpeakersChanged\";\n    /**\n   * Participant metadata is a simple way for app-specific state to be pushed to\n   * all users.\n   * When RoomService.UpdateParticipantMetadata is called to change a participant's\n   * state, *all*  participants in the room will fire this event.\n   *\n   * args: (prevMetadata: string, [[Participant]])\n   *\n   */ RoomEvent[\"ParticipantMetadataChanged\"] = \"participantMetadataChanged\";\n    /**\n   * Participant's display name changed\n   *\n   * args: (name: string, [[Participant]])\n   *\n   */ RoomEvent[\"ParticipantNameChanged\"] = \"participantNameChanged\";\n    /**\n   * Room metadata is a simple way for app-specific state to be pushed to\n   * all users.\n   * When RoomService.UpdateRoomMetadata is called to change a room's state,\n   * *all*  participants in the room will fire this event.\n   *\n   * args: (string)\n   */ RoomEvent[\"RoomMetadataChanged\"] = \"roomMetadataChanged\";\n    /**\n   * Data received from another participant.\n   * Data packets provides the ability to use LiveKit to send/receive arbitrary payloads.\n   * All participants in the room will receive the messages sent to the room.\n   *\n   * args: (payload: Uint8Array, participant: [[Participant]], kind: [[DataPacket_Kind]], topic?: string)\n   */ RoomEvent[\"DataReceived\"] = \"dataReceived\";\n    /**\n   * Connection quality was changed for a Participant. It'll receive updates\n   * from the local participant, as well as any [[RemoteParticipant]]s that we are\n   * subscribed to.\n   *\n   * args: (connectionQuality: [[ConnectionQuality]], participant: [[Participant]])\n   */ RoomEvent[\"ConnectionQualityChanged\"] = \"connectionQualityChanged\";\n    /**\n   * StreamState indicates if a subscribed (remote) track has been paused by the SFU\n   * (typically this happens because of subscriber's bandwidth constraints)\n   *\n   * When bandwidth conditions allow, the track will be resumed automatically.\n   * TrackStreamStateChanged will also be emitted when that happens.\n   *\n   * args: (pub: [[RemoteTrackPublication]], streamState: [[Track.StreamState]],\n   *        participant: [[RemoteParticipant]])\n   */ RoomEvent[\"TrackStreamStateChanged\"] = \"trackStreamStateChanged\";\n    /**\n   * One of subscribed tracks have changed its permissions for the current\n   * participant. If permission was revoked, then the track will no longer\n   * be subscribed. If permission was granted, a TrackSubscribed event will\n   * be emitted.\n   *\n   * args: (pub: [[RemoteTrackPublication]],\n   *        status: [[TrackPublication.PermissionStatus]],\n   *        participant: [[RemoteParticipant]])\n   */ RoomEvent[\"TrackSubscriptionPermissionChanged\"] = \"trackSubscriptionPermissionChanged\";\n    /**\n   * One of subscribed tracks have changed its status for the current\n   * participant.\n   *\n   * args: (pub: [[RemoteTrackPublication]],\n   *        status: [[TrackPublication.SubscriptionStatus]],\n   *        participant: [[RemoteParticipant]])\n   */ RoomEvent[\"TrackSubscriptionStatusChanged\"] = \"trackSubscriptionStatusChanged\";\n    /**\n   * LiveKit will attempt to autoplay all audio tracks when you attach them to\n   * audio elements. However, if that fails, we'll notify you via AudioPlaybackStatusChanged.\n   * `Room.canPlaybackAudio` will indicate if audio playback is permitted.\n   */ RoomEvent[\"AudioPlaybackStatusChanged\"] = \"audioPlaybackChanged\";\n    /**\n   * LiveKit will attempt to autoplay all video tracks when you attach them to\n   * a video element. However, if that fails, we'll notify you via VideoPlaybackStatusChanged.\n   * Calling `room.startVideo()` in a user gesture event handler will resume the video playback.\n   */ RoomEvent[\"VideoPlaybackStatusChanged\"] = \"videoPlaybackChanged\";\n    /**\n   * When we have encountered an error while attempting to create a track.\n   * The errors take place in getUserMedia().\n   * Use MediaDeviceFailure.getFailure(error) to get the reason of failure.\n   * [[LocalParticipant.lastCameraError]] and [[LocalParticipant.lastMicrophoneError]]\n   * will indicate if it had an error while creating the audio or video track respectively.\n   *\n   * args: (error: Error)\n   */ RoomEvent[\"MediaDevicesError\"] = \"mediaDevicesError\";\n    /**\n   * A participant's permission has changed. Currently only fired on LocalParticipant.\n   * args: (prevPermissions: [[ParticipantPermission]], participant: [[Participant]])\n   */ RoomEvent[\"ParticipantPermissionsChanged\"] = \"participantPermissionsChanged\";\n    /**\n   * Signal connected, can publish tracks.\n   */ RoomEvent[\"SignalConnected\"] = \"signalConnected\";\n    /**\n   * Recording of a room has started/stopped. Room.isRecording will be updated too.\n   * args: (isRecording: boolean)\n   */ RoomEvent[\"RecordingStatusChanged\"] = \"recordingStatusChanged\";\n    RoomEvent[\"ParticipantEncryptionStatusChanged\"] = \"participantEncryptionStatusChanged\";\n    RoomEvent[\"EncryptionError\"] = \"encryptionError\";\n    /**\n   * Emits whenever the current buffer status of a data channel changes\n   * args: (isLow: boolean, kind: [[DataPacket_Kind]])\n   */ RoomEvent[\"DCBufferStatusChanged\"] = \"dcBufferStatusChanged\";\n    /**\n   * Triggered by a call to room.switchActiveDevice\n   * args: (kind: MediaDeviceKind, deviceId: string)\n   */ RoomEvent[\"ActiveDeviceChanged\"] = \"activeDeviceChanged\";\n})(RoomEvent || (RoomEvent = {}));\nvar ParticipantEvent;\n(function(ParticipantEvent) {\n    /**\n   * When a new track is published to room *after* the local\n   * participant has joined. It will not fire for tracks that are already published.\n   *\n   * A track published doesn't mean the participant has subscribed to it. It's\n   * simply reflecting the state of the room.\n   *\n   * args: ([[RemoteTrackPublication]])\n   */ ParticipantEvent[\"TrackPublished\"] = \"trackPublished\";\n    /**\n   * Successfully subscribed to the [[RemoteParticipant]]'s track.\n   * This event will **always** fire as long as new tracks are ready for use.\n   *\n   * args: ([[RemoteTrack]], [[RemoteTrackPublication]])\n   */ ParticipantEvent[\"TrackSubscribed\"] = \"trackSubscribed\";\n    /**\n   * Could not subscribe to a track\n   *\n   * args: (track sid)\n   */ ParticipantEvent[\"TrackSubscriptionFailed\"] = \"trackSubscriptionFailed\";\n    /**\n   * A [[RemoteParticipant]] has unpublished a track\n   *\n   * args: ([[RemoteTrackPublication]])\n   */ ParticipantEvent[\"TrackUnpublished\"] = \"trackUnpublished\";\n    /**\n   * A subscribed track is no longer available. Clients should listen to this\n   * event and ensure they detach tracks.\n   *\n   * args: ([[RemoteTrack]], [[RemoteTrackPublication]])\n   */ ParticipantEvent[\"TrackUnsubscribed\"] = \"trackUnsubscribed\";\n    /**\n   * A track that was muted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]\n   *\n   * args: ([[TrackPublication]])\n   */ ParticipantEvent[\"TrackMuted\"] = \"trackMuted\";\n    /**\n   * A track that was unmuted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]\n   *\n   * args: ([[TrackPublication]])\n   */ ParticipantEvent[\"TrackUnmuted\"] = \"trackUnmuted\";\n    /**\n   * A local track was published successfully. This event is helpful to know\n   * when to update your local UI with the newly published track.\n   *\n   * args: ([[LocalTrackPublication]])\n   */ ParticipantEvent[\"LocalTrackPublished\"] = \"localTrackPublished\";\n    /**\n   * A local track was unpublished. This event is helpful to know when to remove\n   * the local track from your UI.\n   *\n   * When a user stops sharing their screen by pressing \"End\" on the browser UI,\n   * this event will also fire.\n   *\n   * args: ([[LocalTrackPublication]])\n   */ ParticipantEvent[\"LocalTrackUnpublished\"] = \"localTrackUnpublished\";\n    /**\n   * Participant metadata is a simple way for app-specific state to be pushed to\n   * all users.\n   * When RoomService.UpdateParticipantMetadata is called to change a participant's\n   * state, *all*  participants in the room will fire this event.\n   * To access the current metadata, see [[Participant.metadata]].\n   *\n   * args: (prevMetadata: string)\n   *\n   */ ParticipantEvent[\"ParticipantMetadataChanged\"] = \"participantMetadataChanged\";\n    /**\n   * Participant's display name changed\n   *\n   * args: (name: string, [[Participant]])\n   *\n   */ ParticipantEvent[\"ParticipantNameChanged\"] = \"participantNameChanged\";\n    /**\n   * Data received from this participant as sender.\n   * Data packets provides the ability to use LiveKit to send/receive arbitrary payloads.\n   * All participants in the room will receive the messages sent to the room.\n   *\n   * args: (payload: Uint8Array, kind: [[DataPacket_Kind]])\n   */ ParticipantEvent[\"DataReceived\"] = \"dataReceived\";\n    /**\n   * Has speaking status changed for the current participant\n   *\n   * args: (speaking: boolean)\n   */ ParticipantEvent[\"IsSpeakingChanged\"] = \"isSpeakingChanged\";\n    /**\n   * Connection quality was changed for a Participant. It'll receive updates\n   * from the local participant, as well as any [[RemoteParticipant]]s that we are\n   * subscribed to.\n   *\n   * args: (connectionQuality: [[ConnectionQuality]])\n   */ ParticipantEvent[\"ConnectionQualityChanged\"] = \"connectionQualityChanged\";\n    /**\n   * StreamState indicates if a subscribed track has been paused by the SFU\n   * (typically this happens because of subscriber's bandwidth constraints)\n   *\n   * When bandwidth conditions allow, the track will be resumed automatically.\n   * TrackStreamStateChanged will also be emitted when that happens.\n   *\n   * args: (pub: [[RemoteTrackPublication]], streamState: [[Track.StreamState]])\n   */ ParticipantEvent[\"TrackStreamStateChanged\"] = \"trackStreamStateChanged\";\n    /**\n   * One of subscribed tracks have changed its permissions for the current\n   * participant. If permission was revoked, then the track will no longer\n   * be subscribed. If permission was granted, a TrackSubscribed event will\n   * be emitted.\n   *\n   * args: (pub: [[RemoteTrackPublication]],\n   *        status: [[TrackPublication.SubscriptionStatus]])\n   */ ParticipantEvent[\"TrackSubscriptionPermissionChanged\"] = \"trackSubscriptionPermissionChanged\";\n    /**\n   * One of the remote participants publications has changed its subscription status.\n   *\n   */ ParticipantEvent[\"TrackSubscriptionStatusChanged\"] = \"trackSubscriptionStatusChanged\";\n    // fired only on LocalParticipant\n    /** @internal */ ParticipantEvent[\"MediaDevicesError\"] = \"mediaDevicesError\";\n    // fired only on LocalParticipant\n    /** @internal */ ParticipantEvent[\"AudioStreamAcquired\"] = \"audioStreamAcquired\";\n    /**\n   * A participant's permission has changed. Currently only fired on LocalParticipant.\n   * args: (prevPermissions: [[ParticipantPermission]])\n   */ ParticipantEvent[\"ParticipantPermissionsChanged\"] = \"participantPermissionsChanged\";\n    /** @internal */ ParticipantEvent[\"PCTrackAdded\"] = \"pcTrackAdded\";\n})(ParticipantEvent || (ParticipantEvent = {}));\n/** @internal */ var EngineEvent;\n(function(EngineEvent) {\n    EngineEvent[\"TransportsCreated\"] = \"transportsCreated\";\n    EngineEvent[\"Connected\"] = \"connected\";\n    EngineEvent[\"Disconnected\"] = \"disconnected\";\n    EngineEvent[\"Resuming\"] = \"resuming\";\n    EngineEvent[\"Resumed\"] = \"resumed\";\n    EngineEvent[\"Restarting\"] = \"restarting\";\n    EngineEvent[\"Restarted\"] = \"restarted\";\n    EngineEvent[\"SignalResumed\"] = \"signalResumed\";\n    EngineEvent[\"SignalRestarted\"] = \"signalRestarted\";\n    EngineEvent[\"Closing\"] = \"closing\";\n    EngineEvent[\"MediaTrackAdded\"] = \"mediaTrackAdded\";\n    EngineEvent[\"ActiveSpeakersUpdate\"] = \"activeSpeakersUpdate\";\n    EngineEvent[\"DataPacketReceived\"] = \"dataPacketReceived\";\n    EngineEvent[\"RTPVideoMapUpdate\"] = \"rtpVideoMapUpdate\";\n    EngineEvent[\"DCBufferStatusChanged\"] = \"dcBufferStatusChanged\";\n    EngineEvent[\"ParticipantUpdate\"] = \"participantUpdate\";\n    EngineEvent[\"RoomUpdate\"] = \"roomUpdate\";\n    EngineEvent[\"SpeakersChanged\"] = \"speakersChanged\";\n    EngineEvent[\"StreamStateChanged\"] = \"streamStateChanged\";\n    EngineEvent[\"ConnectionQualityUpdate\"] = \"connectionQualityUpdate\";\n    EngineEvent[\"SubscriptionError\"] = \"subscriptionError\";\n    EngineEvent[\"SubscriptionPermissionUpdate\"] = \"subscriptionPermissionUpdate\";\n    EngineEvent[\"RemoteMute\"] = \"remoteMute\";\n    EngineEvent[\"SubscribedQualityUpdate\"] = \"subscribedQualityUpdate\";\n    EngineEvent[\"LocalTrackUnpublished\"] = \"localTrackUnpublished\";\n})(EngineEvent || (EngineEvent = {}));\nvar TrackEvent;\n(function(TrackEvent) {\n    TrackEvent[\"Message\"] = \"message\";\n    TrackEvent[\"Muted\"] = \"muted\";\n    TrackEvent[\"Unmuted\"] = \"unmuted\";\n    /**\n   * Only fires on LocalTracks\n   */ TrackEvent[\"Restarted\"] = \"restarted\";\n    TrackEvent[\"Ended\"] = \"ended\";\n    TrackEvent[\"Subscribed\"] = \"subscribed\";\n    TrackEvent[\"Unsubscribed\"] = \"unsubscribed\";\n    /** @internal */ TrackEvent[\"UpdateSettings\"] = \"updateSettings\";\n    /** @internal */ TrackEvent[\"UpdateSubscription\"] = \"updateSubscription\";\n    /** @internal */ TrackEvent[\"AudioPlaybackStarted\"] = \"audioPlaybackStarted\";\n    /** @internal */ TrackEvent[\"AudioPlaybackFailed\"] = \"audioPlaybackFailed\";\n    /**\n   * @internal\n   * Only fires on LocalAudioTrack instances\n   */ TrackEvent[\"AudioSilenceDetected\"] = \"audioSilenceDetected\";\n    /** @internal */ TrackEvent[\"VisibilityChanged\"] = \"visibilityChanged\";\n    /** @internal */ TrackEvent[\"VideoDimensionsChanged\"] = \"videoDimensionsChanged\";\n    /** @internal */ TrackEvent[\"VideoPlaybackStarted\"] = \"videoPlaybackStarted\";\n    /** @internal */ TrackEvent[\"VideoPlaybackFailed\"] = \"videoPlaybackFailed\";\n    /** @internal */ TrackEvent[\"ElementAttached\"] = \"elementAttached\";\n    /** @internal */ TrackEvent[\"ElementDetached\"] = \"elementDetached\";\n    /**\n   * @internal\n   * Only fires on LocalTracks\n   */ TrackEvent[\"UpstreamPaused\"] = \"upstreamPaused\";\n    /**\n   * @internal\n   * Only fires on LocalTracks\n   */ TrackEvent[\"UpstreamResumed\"] = \"upstreamResumed\";\n    /**\n   * @internal\n   * Fires on RemoteTrackPublication\n   */ TrackEvent[\"SubscriptionPermissionChanged\"] = \"subscriptionPermissionChanged\";\n    /**\n   * Fires on RemoteTrackPublication\n   */ TrackEvent[\"SubscriptionStatusChanged\"] = \"subscriptionStatusChanged\";\n    /**\n   * Fires on RemoteTrackPublication\n   */ TrackEvent[\"SubscriptionFailed\"] = \"subscriptionFailed\";\n})(TrackEvent || (TrackEvent = {}));\nfunction r(r, e, n) {\n    var i, t, o;\n    void 0 === e && (e = 50), void 0 === n && (n = {});\n    var a = null != (i = n.isImmediate) && i, u = null != (t = n.callback) && t, c = n.maxWait, v = Date.now(), l = [];\n    function f() {\n        if (void 0 !== c) {\n            var r = Date.now() - v;\n            if (r + e >= c) return c - r;\n        }\n        return e;\n    }\n    var d = function() {\n        var e = [].slice.call(arguments), n = this;\n        return new Promise(function(i, t) {\n            var c = a && void 0 === o;\n            if (void 0 !== o && clearTimeout(o), o = setTimeout(function() {\n                if (o = void 0, v = Date.now(), !a) {\n                    var i = r.apply(n, e);\n                    u && u(i), l.forEach(function(r) {\n                        return (0, r.resolve)(i);\n                    }), l = [];\n                }\n            }, f()), c) {\n                var d = r.apply(n, e);\n                return u && u(d), i(d);\n            }\n            l.push({\n                resolve: i,\n                reject: t\n            });\n        });\n    };\n    return d.cancel = function(r) {\n        void 0 !== o && clearTimeout(o), l.forEach(function(e) {\n            return (0, e.reject)(r);\n        }), l = [];\n    }, d;\n}\n// tiny, simplified version of https://github.com/lancedikson/bowser/blob/master/src/parser-browsers.js\n// reduced to only differentiate Chrome(ium) based browsers / Firefox / Safari\nconst commonVersionIdentifier = /version\\/(\\d+(\\.?_?\\d+)+)/i;\nlet browserDetails;\n/**\n * @internal\n */ function getBrowser(userAgent) {\n    let force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    if (typeof userAgent === 'undefined' && typeof navigator === 'undefined') {\n        return;\n    }\n    const ua = (userAgent !== null && userAgent !== void 0 ? userAgent : navigator.userAgent).toLowerCase();\n    if (browserDetails === undefined || force) {\n        const browser = browsersList.find((_ref)=>{\n            let { test } = _ref;\n            return test.test(ua);\n        });\n        browserDetails = browser === null || browser === void 0 ? void 0 : browser.describe(ua);\n    }\n    return browserDetails;\n}\nconst browsersList = [\n    {\n        test: /firefox|iceweasel|fxios/i,\n        describe (ua) {\n            const browser = {\n                name: 'Firefox',\n                version: getMatch(/(?:firefox|iceweasel|fxios)[\\s/](\\d+(\\.?_?\\d+)+)/i, ua),\n                os: ua.toLowerCase().includes('fxios') ? 'iOS' : undefined\n            };\n            return browser;\n        }\n    },\n    {\n        test: /chrom|crios|crmo/i,\n        describe (ua) {\n            const browser = {\n                name: 'Chrome',\n                version: getMatch(/(?:chrome|chromium|crios|crmo)\\/(\\d+(\\.?_?\\d+)+)/i, ua),\n                os: ua.toLowerCase().includes('crios') ? 'iOS' : undefined\n            };\n            return browser;\n        }\n    },\n    /* Safari */ {\n        test: /safari|applewebkit/i,\n        describe (ua) {\n            const browser = {\n                name: 'Safari',\n                version: getMatch(commonVersionIdentifier, ua),\n                os: ua.includes('mobile/') ? 'iOS' : 'macOS'\n            };\n            return browser;\n        }\n    }\n];\nfunction getMatch(exp, ua) {\n    let id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    const match = ua.match(exp);\n    return match && match.length >= id && match[id] || '';\n}\nvar version$1 = \"1.15.13\";\nconst version = version$1;\nconst protocolVersion = 11;\n/**\n * Timers that can be overridden with platform specific implementations\n * that ensure that they are fired. These should be used when it is critical\n * that the timer fires on time.\n */ class CriticalTimers {\n}\n// eslint-disable-next-line @typescript-eslint/no-implied-eval\nCriticalTimers.setTimeout = function() {\n    return setTimeout(...arguments);\n};\n// eslint-disable-next-line @typescript-eslint/no-implied-eval\nCriticalTimers.setInterval = function() {\n    return setInterval(...arguments);\n};\nCriticalTimers.clearTimeout = function() {\n    return clearTimeout(...arguments);\n};\nCriticalTimers.clearInterval = function() {\n    return clearInterval(...arguments);\n};\nclass VideoPreset {\n    constructor(width, height, maxBitrate, maxFramerate, priority){\n        this.width = width;\n        this.height = height;\n        this.encoding = {\n            maxBitrate,\n            maxFramerate,\n            priority\n        };\n    }\n    get resolution() {\n        return {\n            width: this.width,\n            height: this.height,\n            frameRate: this.encoding.maxFramerate,\n            aspectRatio: this.width / this.height\n        };\n    }\n}\nconst backupCodecs = [\n    'vp8',\n    'h264'\n];\nconst videoCodecs = [\n    'vp8',\n    'h264',\n    'vp9',\n    'av1'\n];\nfunction isBackupCodec(codec) {\n    return !!backupCodecs.find((backup)=>backup === codec);\n}\nvar AudioPresets;\n(function(AudioPresets) {\n    AudioPresets.telephone = {\n        maxBitrate: 12000\n    };\n    AudioPresets.speech = {\n        maxBitrate: 20000\n    };\n    AudioPresets.music = {\n        maxBitrate: 32000\n    };\n    AudioPresets.musicStereo = {\n        maxBitrate: 48000\n    };\n    AudioPresets.musicHighQuality = {\n        maxBitrate: 64000\n    };\n    AudioPresets.musicHighQualityStereo = {\n        maxBitrate: 96000\n    };\n})(AudioPresets || (AudioPresets = {}));\n/**\n * Sane presets for video resolution/encoding\n */ const VideoPresets = {\n    h90: new VideoPreset(160, 90, 90000, 20),\n    h180: new VideoPreset(320, 180, 160000, 20),\n    h216: new VideoPreset(384, 216, 180000, 20),\n    h360: new VideoPreset(640, 360, 450000, 20),\n    h540: new VideoPreset(960, 540, 800000, 25),\n    h720: new VideoPreset(1280, 720, 1700000, 30),\n    h1080: new VideoPreset(1920, 1080, 3000000, 30),\n    h1440: new VideoPreset(2560, 1440, 5000000, 30),\n    h2160: new VideoPreset(3840, 2160, 8000000, 30)\n};\n/**\n * Four by three presets\n */ const VideoPresets43 = {\n    h120: new VideoPreset(160, 120, 70000, 20),\n    h180: new VideoPreset(240, 180, 125000, 20),\n    h240: new VideoPreset(320, 240, 140000, 20),\n    h360: new VideoPreset(480, 360, 330000, 20),\n    h480: new VideoPreset(640, 480, 500000, 20),\n    h540: new VideoPreset(720, 540, 600000, 25),\n    h720: new VideoPreset(960, 720, 1300000, 30),\n    h1080: new VideoPreset(1440, 1080, 2300000, 30),\n    h1440: new VideoPreset(1920, 1440, 3800000, 30)\n};\nconst ScreenSharePresets = {\n    h360fps3: new VideoPreset(640, 360, 200000, 3, 'medium'),\n    h360fps15: new VideoPreset(640, 360, 400000, 15, 'medium'),\n    h720fps5: new VideoPreset(1280, 720, 800000, 5, 'medium'),\n    h720fps15: new VideoPreset(1280, 720, 1500000, 15, 'medium'),\n    h720fps30: new VideoPreset(1280, 720, 2000000, 30, 'medium'),\n    h1080fps15: new VideoPreset(1920, 1080, 2500000, 15, 'medium'),\n    h1080fps30: new VideoPreset(1920, 1080, 5000000, 30, 'medium'),\n    // original resolution, without resizing\n    original: new VideoPreset(0, 0, 7000000, 30, 'medium')\n};\n// Copyright 2023 LiveKit, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * @generated from enum livekit.SignalTarget\n */ var SignalTarget;\n(function(SignalTarget) {\n    /**\n   * @generated from enum value: PUBLISHER = 0;\n   */ SignalTarget[SignalTarget[\"PUBLISHER\"] = 0] = \"PUBLISHER\";\n    /**\n   * @generated from enum value: SUBSCRIBER = 1;\n   */ SignalTarget[SignalTarget[\"SUBSCRIBER\"] = 1] = \"SUBSCRIBER\";\n})(SignalTarget || (SignalTarget = {}));\n// Retrieve enum metadata with: proto3.getEnumType(SignalTarget)\nproto3.util.setEnumType(SignalTarget, \"livekit.SignalTarget\", [\n    {\n        no: 0,\n        name: \"PUBLISHER\"\n    },\n    {\n        no: 1,\n        name: \"SUBSCRIBER\"\n    }\n]);\n/**\n * @generated from enum livekit.StreamState\n */ var StreamState;\n(function(StreamState) {\n    /**\n   * @generated from enum value: ACTIVE = 0;\n   */ StreamState[StreamState[\"ACTIVE\"] = 0] = \"ACTIVE\";\n    /**\n   * @generated from enum value: PAUSED = 1;\n   */ StreamState[StreamState[\"PAUSED\"] = 1] = \"PAUSED\";\n})(StreamState || (StreamState = {}));\n// Retrieve enum metadata with: proto3.getEnumType(StreamState)\nproto3.util.setEnumType(StreamState, \"livekit.StreamState\", [\n    {\n        no: 0,\n        name: \"ACTIVE\"\n    },\n    {\n        no: 1,\n        name: \"PAUSED\"\n    }\n]);\n/**\n * @generated from enum livekit.CandidateProtocol\n */ var CandidateProtocol;\n(function(CandidateProtocol) {\n    /**\n   * @generated from enum value: UDP = 0;\n   */ CandidateProtocol[CandidateProtocol[\"UDP\"] = 0] = \"UDP\";\n    /**\n   * @generated from enum value: TCP = 1;\n   */ CandidateProtocol[CandidateProtocol[\"TCP\"] = 1] = \"TCP\";\n    /**\n   * @generated from enum value: TLS = 2;\n   */ CandidateProtocol[CandidateProtocol[\"TLS\"] = 2] = \"TLS\";\n})(CandidateProtocol || (CandidateProtocol = {}));\n// Retrieve enum metadata with: proto3.getEnumType(CandidateProtocol)\nproto3.util.setEnumType(CandidateProtocol, \"livekit.CandidateProtocol\", [\n    {\n        no: 0,\n        name: \"UDP\"\n    },\n    {\n        no: 1,\n        name: \"TCP\"\n    },\n    {\n        no: 2,\n        name: \"TLS\"\n    }\n]);\n/**\n * @generated from message livekit.SignalRequest\n */ class SignalRequest extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from oneof livekit.SignalRequest.message\n     */ this.message = {\n            case: undefined\n        };\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SignalRequest().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SignalRequest().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SignalRequest().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SignalRequest, a, b);\n    }\n}\nSignalRequest.runtime = proto3;\nSignalRequest.typeName = \"livekit.SignalRequest\";\nSignalRequest.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"offer\",\n            kind: \"message\",\n            T: SessionDescription,\n            oneof: \"message\"\n        },\n        {\n            no: 2,\n            name: \"answer\",\n            kind: \"message\",\n            T: SessionDescription,\n            oneof: \"message\"\n        },\n        {\n            no: 3,\n            name: \"trickle\",\n            kind: \"message\",\n            T: TrickleRequest,\n            oneof: \"message\"\n        },\n        {\n            no: 4,\n            name: \"add_track\",\n            kind: \"message\",\n            T: AddTrackRequest,\n            oneof: \"message\"\n        },\n        {\n            no: 5,\n            name: \"mute\",\n            kind: \"message\",\n            T: MuteTrackRequest,\n            oneof: \"message\"\n        },\n        {\n            no: 6,\n            name: \"subscription\",\n            kind: \"message\",\n            T: UpdateSubscription,\n            oneof: \"message\"\n        },\n        {\n            no: 7,\n            name: \"track_setting\",\n            kind: \"message\",\n            T: UpdateTrackSettings,\n            oneof: \"message\"\n        },\n        {\n            no: 8,\n            name: \"leave\",\n            kind: \"message\",\n            T: LeaveRequest,\n            oneof: \"message\"\n        },\n        {\n            no: 10,\n            name: \"update_layers\",\n            kind: \"message\",\n            T: UpdateVideoLayers,\n            oneof: \"message\"\n        },\n        {\n            no: 11,\n            name: \"subscription_permission\",\n            kind: \"message\",\n            T: SubscriptionPermission,\n            oneof: \"message\"\n        },\n        {\n            no: 12,\n            name: \"sync_state\",\n            kind: \"message\",\n            T: SyncState,\n            oneof: \"message\"\n        },\n        {\n            no: 13,\n            name: \"simulate\",\n            kind: \"message\",\n            T: SimulateScenario,\n            oneof: \"message\"\n        },\n        {\n            no: 14,\n            name: \"ping\",\n            kind: \"scalar\",\n            T: 3 /* ScalarType.INT64 */ ,\n            oneof: \"message\"\n        },\n        {\n            no: 15,\n            name: \"update_metadata\",\n            kind: \"message\",\n            T: UpdateParticipantMetadata,\n            oneof: \"message\"\n        },\n        {\n            no: 16,\n            name: \"ping_req\",\n            kind: \"message\",\n            T: Ping,\n            oneof: \"message\"\n        }\n    ]);\n/**\n * @generated from message livekit.SignalResponse\n */ class SignalResponse extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from oneof livekit.SignalResponse.message\n     */ this.message = {\n            case: undefined\n        };\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SignalResponse().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SignalResponse().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SignalResponse().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SignalResponse, a, b);\n    }\n}\nSignalResponse.runtime = proto3;\nSignalResponse.typeName = \"livekit.SignalResponse\";\nSignalResponse.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"join\",\n            kind: \"message\",\n            T: JoinResponse,\n            oneof: \"message\"\n        },\n        {\n            no: 2,\n            name: \"answer\",\n            kind: \"message\",\n            T: SessionDescription,\n            oneof: \"message\"\n        },\n        {\n            no: 3,\n            name: \"offer\",\n            kind: \"message\",\n            T: SessionDescription,\n            oneof: \"message\"\n        },\n        {\n            no: 4,\n            name: \"trickle\",\n            kind: \"message\",\n            T: TrickleRequest,\n            oneof: \"message\"\n        },\n        {\n            no: 5,\n            name: \"update\",\n            kind: \"message\",\n            T: ParticipantUpdate,\n            oneof: \"message\"\n        },\n        {\n            no: 6,\n            name: \"track_published\",\n            kind: \"message\",\n            T: TrackPublishedResponse,\n            oneof: \"message\"\n        },\n        {\n            no: 8,\n            name: \"leave\",\n            kind: \"message\",\n            T: LeaveRequest,\n            oneof: \"message\"\n        },\n        {\n            no: 9,\n            name: \"mute\",\n            kind: \"message\",\n            T: MuteTrackRequest,\n            oneof: \"message\"\n        },\n        {\n            no: 10,\n            name: \"speakers_changed\",\n            kind: \"message\",\n            T: SpeakersChanged,\n            oneof: \"message\"\n        },\n        {\n            no: 11,\n            name: \"room_update\",\n            kind: \"message\",\n            T: RoomUpdate,\n            oneof: \"message\"\n        },\n        {\n            no: 12,\n            name: \"connection_quality\",\n            kind: \"message\",\n            T: ConnectionQualityUpdate,\n            oneof: \"message\"\n        },\n        {\n            no: 13,\n            name: \"stream_state_update\",\n            kind: \"message\",\n            T: StreamStateUpdate,\n            oneof: \"message\"\n        },\n        {\n            no: 14,\n            name: \"subscribed_quality_update\",\n            kind: \"message\",\n            T: SubscribedQualityUpdate,\n            oneof: \"message\"\n        },\n        {\n            no: 15,\n            name: \"subscription_permission_update\",\n            kind: \"message\",\n            T: SubscriptionPermissionUpdate,\n            oneof: \"message\"\n        },\n        {\n            no: 16,\n            name: \"refresh_token\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ ,\n            oneof: \"message\"\n        },\n        {\n            no: 17,\n            name: \"track_unpublished\",\n            kind: \"message\",\n            T: TrackUnpublishedResponse,\n            oneof: \"message\"\n        },\n        {\n            no: 18,\n            name: \"pong\",\n            kind: \"scalar\",\n            T: 3 /* ScalarType.INT64 */ ,\n            oneof: \"message\"\n        },\n        {\n            no: 19,\n            name: \"reconnect\",\n            kind: \"message\",\n            T: ReconnectResponse,\n            oneof: \"message\"\n        },\n        {\n            no: 20,\n            name: \"pong_resp\",\n            kind: \"message\",\n            T: Pong,\n            oneof: \"message\"\n        },\n        {\n            no: 21,\n            name: \"subscription_response\",\n            kind: \"message\",\n            T: SubscriptionResponse,\n            oneof: \"message\"\n        }\n    ]);\n/**\n * @generated from message livekit.SimulcastCodec\n */ class SimulcastCodec extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string codec = 1;\n     */ this.codec = \"\";\n        /**\n     * @generated from field: string cid = 2;\n     */ this.cid = \"\";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SimulcastCodec().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SimulcastCodec().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SimulcastCodec().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SimulcastCodec, a, b);\n    }\n}\nSimulcastCodec.runtime = proto3;\nSimulcastCodec.typeName = \"livekit.SimulcastCodec\";\nSimulcastCodec.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"codec\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"cid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * @generated from message livekit.AddTrackRequest\n */ class AddTrackRequest extends Message {\n    constructor(data){\n        super();\n        /**\n     * client ID of track, to match it when RTC track is received\n     *\n     * @generated from field: string cid = 1;\n     */ this.cid = \"\";\n        /**\n     * @generated from field: string name = 2;\n     */ this.name = \"\";\n        /**\n     * @generated from field: livekit.TrackType type = 3;\n     */ this.type = TrackType.AUDIO;\n        /**\n     * to be deprecated in favor of layers\n     *\n     * @generated from field: uint32 width = 4;\n     */ this.width = 0;\n        /**\n     * @generated from field: uint32 height = 5;\n     */ this.height = 0;\n        /**\n     * true to add track and initialize to muted\n     *\n     * @generated from field: bool muted = 6;\n     */ this.muted = false;\n        /**\n     * true if DTX (Discontinuous Transmission) is disabled for audio\n     *\n     * @generated from field: bool disable_dtx = 7;\n     */ this.disableDtx = false;\n        /**\n     * @generated from field: livekit.TrackSource source = 8;\n     */ this.source = TrackSource.UNKNOWN;\n        /**\n     * @generated from field: repeated livekit.VideoLayer layers = 9;\n     */ this.layers = [];\n        /**\n     * @generated from field: repeated livekit.SimulcastCodec simulcast_codecs = 10;\n     */ this.simulcastCodecs = [];\n        /**\n     * server ID of track, publish new codec to exist track\n     *\n     * @generated from field: string sid = 11;\n     */ this.sid = \"\";\n        /**\n     * @generated from field: bool stereo = 12;\n     */ this.stereo = false;\n        /**\n     * true if RED (Redundant Encoding) is disabled for audio\n     *\n     * @generated from field: bool disable_red = 13;\n     */ this.disableRed = false;\n        /**\n     * @generated from field: livekit.Encryption.Type encryption = 14;\n     */ this.encryption = Encryption_Type.NONE;\n        /**\n     * which stream the track belongs to, used to group tracks together.\n     * if not specified, server will infer it from track source to bundle camera/microphone, screenshare/audio together\n     *\n     * @generated from field: string stream = 15;\n     */ this.stream = \"\";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new AddTrackRequest().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new AddTrackRequest().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new AddTrackRequest().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(AddTrackRequest, a, b);\n    }\n}\nAddTrackRequest.runtime = proto3;\nAddTrackRequest.typeName = \"livekit.AddTrackRequest\";\nAddTrackRequest.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"cid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"name\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 3,\n            name: \"type\",\n            kind: \"enum\",\n            T: proto3.getEnumType(TrackType)\n        },\n        {\n            no: 4,\n            name: \"width\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 5,\n            name: \"height\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 6,\n            name: \"muted\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 7,\n            name: \"disable_dtx\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 8,\n            name: \"source\",\n            kind: \"enum\",\n            T: proto3.getEnumType(TrackSource)\n        },\n        {\n            no: 9,\n            name: \"layers\",\n            kind: \"message\",\n            T: VideoLayer,\n            repeated: true\n        },\n        {\n            no: 10,\n            name: \"simulcast_codecs\",\n            kind: \"message\",\n            T: SimulcastCodec,\n            repeated: true\n        },\n        {\n            no: 11,\n            name: \"sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 12,\n            name: \"stereo\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 13,\n            name: \"disable_red\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 14,\n            name: \"encryption\",\n            kind: \"enum\",\n            T: proto3.getEnumType(Encryption_Type)\n        },\n        {\n            no: 15,\n            name: \"stream\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * @generated from message livekit.TrickleRequest\n */ class TrickleRequest extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string candidateInit = 1;\n     */ this.candidateInit = \"\";\n        /**\n     * @generated from field: livekit.SignalTarget target = 2;\n     */ this.target = SignalTarget.PUBLISHER;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new TrickleRequest().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new TrickleRequest().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new TrickleRequest().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(TrickleRequest, a, b);\n    }\n}\nTrickleRequest.runtime = proto3;\nTrickleRequest.typeName = \"livekit.TrickleRequest\";\nTrickleRequest.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"candidateInit\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"target\",\n            kind: \"enum\",\n            T: proto3.getEnumType(SignalTarget)\n        }\n    ]);\n/**\n * @generated from message livekit.MuteTrackRequest\n */ class MuteTrackRequest extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string sid = 1;\n     */ this.sid = \"\";\n        /**\n     * @generated from field: bool muted = 2;\n     */ this.muted = false;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new MuteTrackRequest().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new MuteTrackRequest().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new MuteTrackRequest().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(MuteTrackRequest, a, b);\n    }\n}\nMuteTrackRequest.runtime = proto3;\nMuteTrackRequest.typeName = \"livekit.MuteTrackRequest\";\nMuteTrackRequest.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"muted\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        }\n    ]);\n/**\n * @generated from message livekit.JoinResponse\n */ class JoinResponse extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated livekit.ParticipantInfo other_participants = 3;\n     */ this.otherParticipants = [];\n        /**\n     * deprecated. use server_info.version instead.\n     *\n     * @generated from field: string server_version = 4;\n     */ this.serverVersion = \"\";\n        /**\n     * @generated from field: repeated livekit.ICEServer ice_servers = 5;\n     */ this.iceServers = [];\n        /**\n     * use subscriber as the primary PeerConnection\n     *\n     * @generated from field: bool subscriber_primary = 6;\n     */ this.subscriberPrimary = false;\n        /**\n     * when the current server isn't available, return alternate url to retry connection\n     * when this is set, the other fields will be largely empty\n     *\n     * @generated from field: string alternative_url = 7;\n     */ this.alternativeUrl = \"\";\n        /**\n     * deprecated. use server_info.region instead.\n     *\n     * @generated from field: string server_region = 9;\n     */ this.serverRegion = \"\";\n        /**\n     * @generated from field: int32 ping_timeout = 10;\n     */ this.pingTimeout = 0;\n        /**\n     * @generated from field: int32 ping_interval = 11;\n     */ this.pingInterval = 0;\n        /**\n     * Server-Injected-Frame byte trailer, used to identify unencrypted frames when e2ee is enabled\n     *\n     * @generated from field: bytes sif_trailer = 13;\n     */ this.sifTrailer = new Uint8Array(0);\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new JoinResponse().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new JoinResponse().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new JoinResponse().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(JoinResponse, a, b);\n    }\n}\nJoinResponse.runtime = proto3;\nJoinResponse.typeName = \"livekit.JoinResponse\";\nJoinResponse.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"room\",\n            kind: \"message\",\n            T: Room$1\n        },\n        {\n            no: 2,\n            name: \"participant\",\n            kind: \"message\",\n            T: ParticipantInfo\n        },\n        {\n            no: 3,\n            name: \"other_participants\",\n            kind: \"message\",\n            T: ParticipantInfo,\n            repeated: true\n        },\n        {\n            no: 4,\n            name: \"server_version\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 5,\n            name: \"ice_servers\",\n            kind: \"message\",\n            T: ICEServer,\n            repeated: true\n        },\n        {\n            no: 6,\n            name: \"subscriber_primary\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 7,\n            name: \"alternative_url\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 8,\n            name: \"client_configuration\",\n            kind: \"message\",\n            T: ClientConfiguration\n        },\n        {\n            no: 9,\n            name: \"server_region\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 10,\n            name: \"ping_timeout\",\n            kind: \"scalar\",\n            T: 5 /* ScalarType.INT32 */ \n        },\n        {\n            no: 11,\n            name: \"ping_interval\",\n            kind: \"scalar\",\n            T: 5 /* ScalarType.INT32 */ \n        },\n        {\n            no: 12,\n            name: \"server_info\",\n            kind: \"message\",\n            T: ServerInfo\n        },\n        {\n            no: 13,\n            name: \"sif_trailer\",\n            kind: \"scalar\",\n            T: 12 /* ScalarType.BYTES */ \n        }\n    ]);\n/**\n * @generated from message livekit.ReconnectResponse\n */ class ReconnectResponse extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated livekit.ICEServer ice_servers = 1;\n     */ this.iceServers = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ReconnectResponse().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ReconnectResponse().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ReconnectResponse().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ReconnectResponse, a, b);\n    }\n}\nReconnectResponse.runtime = proto3;\nReconnectResponse.typeName = \"livekit.ReconnectResponse\";\nReconnectResponse.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"ice_servers\",\n            kind: \"message\",\n            T: ICEServer,\n            repeated: true\n        },\n        {\n            no: 2,\n            name: \"client_configuration\",\n            kind: \"message\",\n            T: ClientConfiguration\n        }\n    ]);\n/**\n * @generated from message livekit.TrackPublishedResponse\n */ class TrackPublishedResponse extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string cid = 1;\n     */ this.cid = \"\";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new TrackPublishedResponse().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new TrackPublishedResponse().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new TrackPublishedResponse().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(TrackPublishedResponse, a, b);\n    }\n}\nTrackPublishedResponse.runtime = proto3;\nTrackPublishedResponse.typeName = \"livekit.TrackPublishedResponse\";\nTrackPublishedResponse.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"cid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"track\",\n            kind: \"message\",\n            T: TrackInfo\n        }\n    ]);\n/**\n * @generated from message livekit.TrackUnpublishedResponse\n */ class TrackUnpublishedResponse extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string track_sid = 1;\n     */ this.trackSid = \"\";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new TrackUnpublishedResponse().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new TrackUnpublishedResponse().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new TrackUnpublishedResponse().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(TrackUnpublishedResponse, a, b);\n    }\n}\nTrackUnpublishedResponse.runtime = proto3;\nTrackUnpublishedResponse.typeName = \"livekit.TrackUnpublishedResponse\";\nTrackUnpublishedResponse.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * @generated from message livekit.SessionDescription\n */ class SessionDescription extends Message {\n    constructor(data){\n        super();\n        /**\n     * \"answer\" | \"offer\" | \"pranswer\" | \"rollback\"\n     *\n     * @generated from field: string type = 1;\n     */ this.type = \"\";\n        /**\n     * @generated from field: string sdp = 2;\n     */ this.sdp = \"\";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SessionDescription().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SessionDescription().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SessionDescription().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SessionDescription, a, b);\n    }\n}\nSessionDescription.runtime = proto3;\nSessionDescription.typeName = \"livekit.SessionDescription\";\nSessionDescription.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"type\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"sdp\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * @generated from message livekit.ParticipantUpdate\n */ class ParticipantUpdate extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated livekit.ParticipantInfo participants = 1;\n     */ this.participants = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ParticipantUpdate().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ParticipantUpdate().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ParticipantUpdate().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ParticipantUpdate, a, b);\n    }\n}\nParticipantUpdate.runtime = proto3;\nParticipantUpdate.typeName = \"livekit.ParticipantUpdate\";\nParticipantUpdate.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"participants\",\n            kind: \"message\",\n            T: ParticipantInfo,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.UpdateSubscription\n */ class UpdateSubscription extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated string track_sids = 1;\n     */ this.trackSids = [];\n        /**\n     * @generated from field: bool subscribe = 2;\n     */ this.subscribe = false;\n        /**\n     * @generated from field: repeated livekit.ParticipantTracks participant_tracks = 3;\n     */ this.participantTracks = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new UpdateSubscription().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new UpdateSubscription().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new UpdateSubscription().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(UpdateSubscription, a, b);\n    }\n}\nUpdateSubscription.runtime = proto3;\nUpdateSubscription.typeName = \"livekit.UpdateSubscription\";\nUpdateSubscription.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"track_sids\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ ,\n            repeated: true\n        },\n        {\n            no: 2,\n            name: \"subscribe\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 3,\n            name: \"participant_tracks\",\n            kind: \"message\",\n            T: ParticipantTracks,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.UpdateTrackSettings\n */ class UpdateTrackSettings extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated string track_sids = 1;\n     */ this.trackSids = [];\n        /**\n     * when true, the track is placed in a paused state, with no new data returned\n     *\n     * @generated from field: bool disabled = 3;\n     */ this.disabled = false;\n        /**\n     * deprecated in favor of width & height\n     *\n     * @generated from field: livekit.VideoQuality quality = 4;\n     */ this.quality = VideoQuality.LOW;\n        /**\n     * for video, width to receive\n     *\n     * @generated from field: uint32 width = 5;\n     */ this.width = 0;\n        /**\n     * for video, height to receive\n     *\n     * @generated from field: uint32 height = 6;\n     */ this.height = 0;\n        /**\n     * @generated from field: uint32 fps = 7;\n     */ this.fps = 0;\n        /**\n     * subscription priority. 1 being the highest (0 is unset)\n     * when unset, server sill assign priority based on the order of subscription\n     * server will use priority in the following ways:\n     * 1. when subscribed tracks exceed per-participant subscription limit, server will\n     *    pause the lowest priority tracks\n     * 2. when the network is congested, server will assign available bandwidth to\n     *    higher priority tracks first. lowest priority tracks can be paused\n     *\n     * @generated from field: uint32 priority = 8;\n     */ this.priority = 0;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new UpdateTrackSettings().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new UpdateTrackSettings().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new UpdateTrackSettings().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(UpdateTrackSettings, a, b);\n    }\n}\nUpdateTrackSettings.runtime = proto3;\nUpdateTrackSettings.typeName = \"livekit.UpdateTrackSettings\";\nUpdateTrackSettings.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"track_sids\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ ,\n            repeated: true\n        },\n        {\n            no: 3,\n            name: \"disabled\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 4,\n            name: \"quality\",\n            kind: \"enum\",\n            T: proto3.getEnumType(VideoQuality)\n        },\n        {\n            no: 5,\n            name: \"width\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 6,\n            name: \"height\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 7,\n            name: \"fps\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 8,\n            name: \"priority\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        }\n    ]);\n/**\n * @generated from message livekit.LeaveRequest\n */ class LeaveRequest extends Message {\n    constructor(data){\n        super();\n        /**\n     * sent when server initiates the disconnect due to server-restart\n     * indicates clients should attempt full-reconnect sequence\n     *\n     * @generated from field: bool can_reconnect = 1;\n     */ this.canReconnect = false;\n        /**\n     * @generated from field: livekit.DisconnectReason reason = 2;\n     */ this.reason = DisconnectReason.UNKNOWN_REASON;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new LeaveRequest().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new LeaveRequest().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new LeaveRequest().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(LeaveRequest, a, b);\n    }\n}\nLeaveRequest.runtime = proto3;\nLeaveRequest.typeName = \"livekit.LeaveRequest\";\nLeaveRequest.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"can_reconnect\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 2,\n            name: \"reason\",\n            kind: \"enum\",\n            T: proto3.getEnumType(DisconnectReason)\n        }\n    ]);\n/**\n * message to indicate published video track dimensions are changing\n *\n * @generated from message livekit.UpdateVideoLayers\n */ class UpdateVideoLayers extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string track_sid = 1;\n     */ this.trackSid = \"\";\n        /**\n     * @generated from field: repeated livekit.VideoLayer layers = 2;\n     */ this.layers = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new UpdateVideoLayers().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new UpdateVideoLayers().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new UpdateVideoLayers().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(UpdateVideoLayers, a, b);\n    }\n}\nUpdateVideoLayers.runtime = proto3;\nUpdateVideoLayers.typeName = \"livekit.UpdateVideoLayers\";\nUpdateVideoLayers.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"layers\",\n            kind: \"message\",\n            T: VideoLayer,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.UpdateParticipantMetadata\n */ class UpdateParticipantMetadata extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string metadata = 1;\n     */ this.metadata = \"\";\n        /**\n     * @generated from field: string name = 2;\n     */ this.name = \"\";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new UpdateParticipantMetadata().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new UpdateParticipantMetadata().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new UpdateParticipantMetadata().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(UpdateParticipantMetadata, a, b);\n    }\n}\nUpdateParticipantMetadata.runtime = proto3;\nUpdateParticipantMetadata.typeName = \"livekit.UpdateParticipantMetadata\";\nUpdateParticipantMetadata.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"metadata\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"name\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * @generated from message livekit.ICEServer\n */ class ICEServer extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated string urls = 1;\n     */ this.urls = [];\n        /**\n     * @generated from field: string username = 2;\n     */ this.username = \"\";\n        /**\n     * @generated from field: string credential = 3;\n     */ this.credential = \"\";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ICEServer().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ICEServer().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ICEServer().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ICEServer, a, b);\n    }\n}\nICEServer.runtime = proto3;\nICEServer.typeName = \"livekit.ICEServer\";\nICEServer.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"urls\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ ,\n            repeated: true\n        },\n        {\n            no: 2,\n            name: \"username\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 3,\n            name: \"credential\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * @generated from message livekit.SpeakersChanged\n */ class SpeakersChanged extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated livekit.SpeakerInfo speakers = 1;\n     */ this.speakers = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SpeakersChanged().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SpeakersChanged().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SpeakersChanged().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SpeakersChanged, a, b);\n    }\n}\nSpeakersChanged.runtime = proto3;\nSpeakersChanged.typeName = \"livekit.SpeakersChanged\";\nSpeakersChanged.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"speakers\",\n            kind: \"message\",\n            T: SpeakerInfo,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.RoomUpdate\n */ class RoomUpdate extends Message {\n    constructor(data){\n        super();\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new RoomUpdate().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new RoomUpdate().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new RoomUpdate().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(RoomUpdate, a, b);\n    }\n}\nRoomUpdate.runtime = proto3;\nRoomUpdate.typeName = \"livekit.RoomUpdate\";\nRoomUpdate.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"room\",\n            kind: \"message\",\n            T: Room$1\n        }\n    ]);\n/**\n * @generated from message livekit.ConnectionQualityInfo\n */ class ConnectionQualityInfo extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string participant_sid = 1;\n     */ this.participantSid = \"\";\n        /**\n     * @generated from field: livekit.ConnectionQuality quality = 2;\n     */ this.quality = ConnectionQuality$1.POOR;\n        /**\n     * @generated from field: float score = 3;\n     */ this.score = 0;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ConnectionQualityInfo().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ConnectionQualityInfo().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ConnectionQualityInfo().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ConnectionQualityInfo, a, b);\n    }\n}\nConnectionQualityInfo.runtime = proto3;\nConnectionQualityInfo.typeName = \"livekit.ConnectionQualityInfo\";\nConnectionQualityInfo.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"participant_sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"quality\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ConnectionQuality$1)\n        },\n        {\n            no: 3,\n            name: \"score\",\n            kind: \"scalar\",\n            T: 2 /* ScalarType.FLOAT */ \n        }\n    ]);\n/**\n * @generated from message livekit.ConnectionQualityUpdate\n */ class ConnectionQualityUpdate extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated livekit.ConnectionQualityInfo updates = 1;\n     */ this.updates = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ConnectionQualityUpdate().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ConnectionQualityUpdate().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ConnectionQualityUpdate().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ConnectionQualityUpdate, a, b);\n    }\n}\nConnectionQualityUpdate.runtime = proto3;\nConnectionQualityUpdate.typeName = \"livekit.ConnectionQualityUpdate\";\nConnectionQualityUpdate.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"updates\",\n            kind: \"message\",\n            T: ConnectionQualityInfo,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.StreamStateInfo\n */ class StreamStateInfo extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string participant_sid = 1;\n     */ this.participantSid = \"\";\n        /**\n     * @generated from field: string track_sid = 2;\n     */ this.trackSid = \"\";\n        /**\n     * @generated from field: livekit.StreamState state = 3;\n     */ this.state = StreamState.ACTIVE;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new StreamStateInfo().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new StreamStateInfo().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new StreamStateInfo().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(StreamStateInfo, a, b);\n    }\n}\nStreamStateInfo.runtime = proto3;\nStreamStateInfo.typeName = \"livekit.StreamStateInfo\";\nStreamStateInfo.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"participant_sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 3,\n            name: \"state\",\n            kind: \"enum\",\n            T: proto3.getEnumType(StreamState)\n        }\n    ]);\n/**\n * @generated from message livekit.StreamStateUpdate\n */ class StreamStateUpdate extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated livekit.StreamStateInfo stream_states = 1;\n     */ this.streamStates = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new StreamStateUpdate().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new StreamStateUpdate().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new StreamStateUpdate().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(StreamStateUpdate, a, b);\n    }\n}\nStreamStateUpdate.runtime = proto3;\nStreamStateUpdate.typeName = \"livekit.StreamStateUpdate\";\nStreamStateUpdate.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"stream_states\",\n            kind: \"message\",\n            T: StreamStateInfo,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.SubscribedQuality\n */ class SubscribedQuality extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: livekit.VideoQuality quality = 1;\n     */ this.quality = VideoQuality.LOW;\n        /**\n     * @generated from field: bool enabled = 2;\n     */ this.enabled = false;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SubscribedQuality().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SubscribedQuality().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SubscribedQuality().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SubscribedQuality, a, b);\n    }\n}\nSubscribedQuality.runtime = proto3;\nSubscribedQuality.typeName = \"livekit.SubscribedQuality\";\nSubscribedQuality.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"quality\",\n            kind: \"enum\",\n            T: proto3.getEnumType(VideoQuality)\n        },\n        {\n            no: 2,\n            name: \"enabled\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        }\n    ]);\n/**\n * @generated from message livekit.SubscribedCodec\n */ class SubscribedCodec extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string codec = 1;\n     */ this.codec = \"\";\n        /**\n     * @generated from field: repeated livekit.SubscribedQuality qualities = 2;\n     */ this.qualities = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SubscribedCodec().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SubscribedCodec().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SubscribedCodec().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SubscribedCodec, a, b);\n    }\n}\nSubscribedCodec.runtime = proto3;\nSubscribedCodec.typeName = \"livekit.SubscribedCodec\";\nSubscribedCodec.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"codec\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"qualities\",\n            kind: \"message\",\n            T: SubscribedQuality,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.SubscribedQualityUpdate\n */ class SubscribedQualityUpdate extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string track_sid = 1;\n     */ this.trackSid = \"\";\n        /**\n     * @generated from field: repeated livekit.SubscribedQuality subscribed_qualities = 2;\n     */ this.subscribedQualities = [];\n        /**\n     * @generated from field: repeated livekit.SubscribedCodec subscribed_codecs = 3;\n     */ this.subscribedCodecs = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SubscribedQualityUpdate().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SubscribedQualityUpdate().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SubscribedQualityUpdate().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SubscribedQualityUpdate, a, b);\n    }\n}\nSubscribedQualityUpdate.runtime = proto3;\nSubscribedQualityUpdate.typeName = \"livekit.SubscribedQualityUpdate\";\nSubscribedQualityUpdate.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"subscribed_qualities\",\n            kind: \"message\",\n            T: SubscribedQuality,\n            repeated: true\n        },\n        {\n            no: 3,\n            name: \"subscribed_codecs\",\n            kind: \"message\",\n            T: SubscribedCodec,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.TrackPermission\n */ class TrackPermission extends Message {\n    constructor(data){\n        super();\n        /**\n     * permission could be granted either by participant sid or identity\n     *\n     * @generated from field: string participant_sid = 1;\n     */ this.participantSid = \"\";\n        /**\n     * @generated from field: bool all_tracks = 2;\n     */ this.allTracks = false;\n        /**\n     * @generated from field: repeated string track_sids = 3;\n     */ this.trackSids = [];\n        /**\n     * @generated from field: string participant_identity = 4;\n     */ this.participantIdentity = \"\";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new TrackPermission().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new TrackPermission().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new TrackPermission().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(TrackPermission, a, b);\n    }\n}\nTrackPermission.runtime = proto3;\nTrackPermission.typeName = \"livekit.TrackPermission\";\nTrackPermission.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"participant_sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"all_tracks\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 3,\n            name: \"track_sids\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ ,\n            repeated: true\n        },\n        {\n            no: 4,\n            name: \"participant_identity\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * @generated from message livekit.SubscriptionPermission\n */ class SubscriptionPermission extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: bool all_participants = 1;\n     */ this.allParticipants = false;\n        /**\n     * @generated from field: repeated livekit.TrackPermission track_permissions = 2;\n     */ this.trackPermissions = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SubscriptionPermission().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SubscriptionPermission().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SubscriptionPermission().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SubscriptionPermission, a, b);\n    }\n}\nSubscriptionPermission.runtime = proto3;\nSubscriptionPermission.typeName = \"livekit.SubscriptionPermission\";\nSubscriptionPermission.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"all_participants\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 2,\n            name: \"track_permissions\",\n            kind: \"message\",\n            T: TrackPermission,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.SubscriptionPermissionUpdate\n */ class SubscriptionPermissionUpdate extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string participant_sid = 1;\n     */ this.participantSid = \"\";\n        /**\n     * @generated from field: string track_sid = 2;\n     */ this.trackSid = \"\";\n        /**\n     * @generated from field: bool allowed = 3;\n     */ this.allowed = false;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SubscriptionPermissionUpdate().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SubscriptionPermissionUpdate().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SubscriptionPermissionUpdate().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SubscriptionPermissionUpdate, a, b);\n    }\n}\nSubscriptionPermissionUpdate.runtime = proto3;\nSubscriptionPermissionUpdate.typeName = \"livekit.SubscriptionPermissionUpdate\";\nSubscriptionPermissionUpdate.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"participant_sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 3,\n            name: \"allowed\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        }\n    ]);\n/**\n * @generated from message livekit.SyncState\n */ class SyncState extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated livekit.TrackPublishedResponse publish_tracks = 3;\n     */ this.publishTracks = [];\n        /**\n     * @generated from field: repeated livekit.DataChannelInfo data_channels = 4;\n     */ this.dataChannels = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SyncState().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SyncState().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SyncState().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SyncState, a, b);\n    }\n}\nSyncState.runtime = proto3;\nSyncState.typeName = \"livekit.SyncState\";\nSyncState.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"answer\",\n            kind: \"message\",\n            T: SessionDescription\n        },\n        {\n            no: 2,\n            name: \"subscription\",\n            kind: \"message\",\n            T: UpdateSubscription\n        },\n        {\n            no: 3,\n            name: \"publish_tracks\",\n            kind: \"message\",\n            T: TrackPublishedResponse,\n            repeated: true\n        },\n        {\n            no: 4,\n            name: \"data_channels\",\n            kind: \"message\",\n            T: DataChannelInfo,\n            repeated: true\n        },\n        {\n            no: 5,\n            name: \"offer\",\n            kind: \"message\",\n            T: SessionDescription\n        }\n    ]);\n/**\n * @generated from message livekit.DataChannelInfo\n */ class DataChannelInfo extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string label = 1;\n     */ this.label = \"\";\n        /**\n     * @generated from field: uint32 id = 2;\n     */ this.id = 0;\n        /**\n     * @generated from field: livekit.SignalTarget target = 3;\n     */ this.target = SignalTarget.PUBLISHER;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new DataChannelInfo().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new DataChannelInfo().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new DataChannelInfo().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(DataChannelInfo, a, b);\n    }\n}\nDataChannelInfo.runtime = proto3;\nDataChannelInfo.typeName = \"livekit.DataChannelInfo\";\nDataChannelInfo.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"label\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"id\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 3,\n            name: \"target\",\n            kind: \"enum\",\n            T: proto3.getEnumType(SignalTarget)\n        }\n    ]);\n/**\n * @generated from message livekit.SimulateScenario\n */ class SimulateScenario extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from oneof livekit.SimulateScenario.scenario\n     */ this.scenario = {\n            case: undefined\n        };\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SimulateScenario().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SimulateScenario().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SimulateScenario().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SimulateScenario, a, b);\n    }\n}\nSimulateScenario.runtime = proto3;\nSimulateScenario.typeName = \"livekit.SimulateScenario\";\nSimulateScenario.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"speaker_update\",\n            kind: \"scalar\",\n            T: 5 /* ScalarType.INT32 */ ,\n            oneof: \"scenario\"\n        },\n        {\n            no: 2,\n            name: \"node_failure\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ ,\n            oneof: \"scenario\"\n        },\n        {\n            no: 3,\n            name: \"migration\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ ,\n            oneof: \"scenario\"\n        },\n        {\n            no: 4,\n            name: \"server_leave\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ ,\n            oneof: \"scenario\"\n        },\n        {\n            no: 5,\n            name: \"switch_candidate_protocol\",\n            kind: \"enum\",\n            T: proto3.getEnumType(CandidateProtocol),\n            oneof: \"scenario\"\n        },\n        {\n            no: 6,\n            name: \"subscriber_bandwidth\",\n            kind: \"scalar\",\n            T: 3 /* ScalarType.INT64 */ ,\n            oneof: \"scenario\"\n        },\n        {\n            no: 7,\n            name: \"disconnect_signal_on_resume\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ ,\n            oneof: \"scenario\"\n        },\n        {\n            no: 8,\n            name: \"disconnect_signal_on_resume_no_messages\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ ,\n            oneof: \"scenario\"\n        }\n    ]);\n/**\n * @generated from message livekit.Ping\n */ class Ping extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: int64 timestamp = 1;\n     */ this.timestamp = protoInt64.zero;\n        /**\n     * rtt in milliseconds calculated by client\n     *\n     * @generated from field: int64 rtt = 2;\n     */ this.rtt = protoInt64.zero;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new Ping().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new Ping().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new Ping().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(Ping, a, b);\n    }\n}\nPing.runtime = proto3;\nPing.typeName = \"livekit.Ping\";\nPing.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"timestamp\",\n            kind: \"scalar\",\n            T: 3 /* ScalarType.INT64 */ \n        },\n        {\n            no: 2,\n            name: \"rtt\",\n            kind: \"scalar\",\n            T: 3 /* ScalarType.INT64 */ \n        }\n    ]);\n/**\n * @generated from message livekit.Pong\n */ class Pong extends Message {\n    constructor(data){\n        super();\n        /**\n     * timestamp field of last received ping request\n     *\n     * @generated from field: int64 last_ping_timestamp = 1;\n     */ this.lastPingTimestamp = protoInt64.zero;\n        /**\n     * @generated from field: int64 timestamp = 2;\n     */ this.timestamp = protoInt64.zero;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new Pong().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new Pong().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new Pong().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(Pong, a, b);\n    }\n}\nPong.runtime = proto3;\nPong.typeName = \"livekit.Pong\";\nPong.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"last_ping_timestamp\",\n            kind: \"scalar\",\n            T: 3 /* ScalarType.INT64 */ \n        },\n        {\n            no: 2,\n            name: \"timestamp\",\n            kind: \"scalar\",\n            T: 3 /* ScalarType.INT64 */ \n        }\n    ]);\n/**\n * @generated from message livekit.RegionSettings\n */ class RegionSettings extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated livekit.RegionInfo regions = 1;\n     */ this.regions = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new RegionSettings().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new RegionSettings().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new RegionSettings().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(RegionSettings, a, b);\n    }\n}\nRegionSettings.runtime = proto3;\nRegionSettings.typeName = \"livekit.RegionSettings\";\nRegionSettings.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"regions\",\n            kind: \"message\",\n            T: RegionInfo,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.RegionInfo\n */ class RegionInfo extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string region = 1;\n     */ this.region = \"\";\n        /**\n     * @generated from field: string url = 2;\n     */ this.url = \"\";\n        /**\n     * @generated from field: int64 distance = 3;\n     */ this.distance = protoInt64.zero;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new RegionInfo().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new RegionInfo().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new RegionInfo().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(RegionInfo, a, b);\n    }\n}\nRegionInfo.runtime = proto3;\nRegionInfo.typeName = \"livekit.RegionInfo\";\nRegionInfo.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"region\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"url\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 3,\n            name: \"distance\",\n            kind: \"scalar\",\n            T: 3 /* ScalarType.INT64 */ \n        }\n    ]);\n/**\n * @generated from message livekit.SubscriptionResponse\n */ class SubscriptionResponse extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string track_sid = 1;\n     */ this.trackSid = \"\";\n        /**\n     * @generated from field: livekit.SubscriptionError err = 2;\n     */ this.err = SubscriptionError.SE_UNKNOWN;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SubscriptionResponse().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SubscriptionResponse().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SubscriptionResponse().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SubscriptionResponse, a, b);\n    }\n}\nSubscriptionResponse.runtime = proto3;\nSubscriptionResponse.typeName = \"livekit.SubscriptionResponse\";\nSubscriptionResponse.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"err\",\n            kind: \"enum\",\n            T: proto3.getEnumType(SubscriptionError)\n        }\n    ]);\nfunction cloneDeep(value) {\n    if (typeof value === 'undefined') {\n        return;\n    }\n    if (typeof structuredClone === 'function') {\n        return structuredClone(value);\n    } else {\n        return JSON.parse(JSON.stringify(value));\n    }\n}\nconst BACKGROUND_REACTION_DELAY = 5000;\n// keep old audio elements when detached, we would re-use them since on iOS\n// Safari tracks which audio elements have been \"blessed\" by the user.\nconst recycledElements = [];\nclass Track extends eventsExports.EventEmitter {\n    constructor(mediaTrack, kind){\n        let loggerOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var _a;\n        super();\n        this.attachedElements = [];\n        this.isMuted = false;\n        /**\n     * indicates current state of stream, it'll indicate `paused` if the track\n     * has been paused by congestion controller\n     */ this.streamState = Track.StreamState.Active;\n        this.isInBackground = false;\n        this._currentBitrate = 0;\n        this.log = livekitLogger;\n        this.appVisibilityChangedListener = ()=>{\n            if (this.backgroundTimeout) {\n                clearTimeout(this.backgroundTimeout);\n            }\n            // delay app visibility update if it goes to hidden\n            // update immediately if it comes back to focus\n            if (document.visibilityState === 'hidden') {\n                this.backgroundTimeout = setTimeout(()=>this.handleAppVisibilityChanged(), BACKGROUND_REACTION_DELAY);\n            } else {\n                this.handleAppVisibilityChanged();\n            }\n        };\n        this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Track);\n        this.loggerContextCb = loggerOptions.loggerContextCb;\n        this.setMaxListeners(100);\n        this.kind = kind;\n        this._mediaStreamTrack = mediaTrack;\n        this._mediaStreamID = mediaTrack.id;\n        this.source = Track.Source.Unknown;\n    }\n    get logContext() {\n        var _a;\n        return Object.assign(Object.assign({}, (_a = this.loggerContextCb) === null || _a === void 0 ? void 0 : _a.call(this)), getLogContextFromTrack(this));\n    }\n    /** current receive bits per second */ get currentBitrate() {\n        return this._currentBitrate;\n    }\n    get mediaStreamTrack() {\n        return this._mediaStreamTrack;\n    }\n    /**\n   * @internal\n   * used for keep mediaStream's first id, since it's id might change\n   * if we disable/enable a track\n   */ get mediaStreamID() {\n        return this._mediaStreamID;\n    }\n    attach(element) {\n        let elementType = 'audio';\n        if (this.kind === Track.Kind.Video) {\n            elementType = 'video';\n        }\n        if (this.attachedElements.length === 0 && Track.Kind.Video) {\n            this.addAppVisibilityListener();\n        }\n        if (!element) {\n            if (elementType === 'audio') {\n                recycledElements.forEach((e)=>{\n                    if (e.parentElement === null && !element) {\n                        element = e;\n                    }\n                });\n                if (element) {\n                    // remove it from pool\n                    recycledElements.splice(recycledElements.indexOf(element), 1);\n                }\n            }\n            if (!element) {\n                element = document.createElement(elementType);\n            }\n        }\n        if (!this.attachedElements.includes(element)) {\n            this.attachedElements.push(element);\n        }\n        // even if we believe it's already attached to the element, it's possible\n        // the element's srcObject was set to something else out of band.\n        // we'll want to re-attach it in that case\n        attachToElement(this.mediaStreamTrack, element);\n        // handle auto playback failures\n        const allMediaStreamTracks = element.srcObject.getTracks();\n        const hasAudio = allMediaStreamTracks.some((tr)=>tr.kind === 'audio');\n        // manually play media to detect auto playback status\n        element.play().then(()=>{\n            this.emit(hasAudio ? TrackEvent.AudioPlaybackStarted : TrackEvent.VideoPlaybackStarted);\n        }).catch((e)=>{\n            if (e.name === 'NotAllowedError') {\n                this.emit(hasAudio ? TrackEvent.AudioPlaybackFailed : TrackEvent.VideoPlaybackFailed, e);\n            } else if (e.name === 'AbortError') {\n                // commonly triggered by another `play` request, only log for debugging purposes\n                livekitLogger.debug(\"\".concat(hasAudio ? 'audio' : 'video', \" playback aborted, likely due to new play request\"));\n            } else {\n                livekitLogger.warn(\"could not playback \".concat(hasAudio ? 'audio' : 'video'), e);\n            }\n            // If audio playback isn't allowed make sure we still play back the video\n            if (hasAudio && element && allMediaStreamTracks.some((tr)=>tr.kind === 'video') && e.name === 'NotAllowedError') {\n                element.muted = true;\n                element.play().catch(()=>{\n                // catch for Safari, exceeded options at this point to automatically play the media element\n                });\n            }\n        });\n        this.emit(TrackEvent.ElementAttached, element);\n        return element;\n    }\n    detach(element) {\n        try {\n            // detach from a single element\n            if (element) {\n                detachTrack(this.mediaStreamTrack, element);\n                const idx = this.attachedElements.indexOf(element);\n                if (idx >= 0) {\n                    this.attachedElements.splice(idx, 1);\n                    this.recycleElement(element);\n                    this.emit(TrackEvent.ElementDetached, element);\n                }\n                return element;\n            }\n            const detached = [];\n            this.attachedElements.forEach((elm)=>{\n                detachTrack(this.mediaStreamTrack, elm);\n                detached.push(elm);\n                this.recycleElement(elm);\n                this.emit(TrackEvent.ElementDetached, elm);\n            });\n            // remove all tracks\n            this.attachedElements = [];\n            return detached;\n        } finally{\n            if (this.attachedElements.length === 0) {\n                this.removeAppVisibilityListener();\n            }\n        }\n    }\n    stop() {\n        this.stopMonitor();\n        this._mediaStreamTrack.stop();\n    }\n    enable() {\n        this._mediaStreamTrack.enabled = true;\n    }\n    disable() {\n        this._mediaStreamTrack.enabled = false;\n    }\n    /* @internal */ stopMonitor() {\n        if (this.monitorInterval) {\n            clearInterval(this.monitorInterval);\n        }\n    }\n    /** @internal */ updateLoggerOptions(loggerOptions) {\n        if (loggerOptions.loggerName) {\n            this.log = getLogger(loggerOptions.loggerName);\n        }\n        if (loggerOptions.loggerContextCb) {\n            this.loggerContextCb = loggerOptions.loggerContextCb;\n        }\n    }\n    recycleElement(element) {\n        if (element instanceof HTMLAudioElement) {\n            // we only need to re-use a single element\n            let shouldCache = true;\n            element.pause();\n            recycledElements.forEach((e)=>{\n                if (!e.parentElement) {\n                    shouldCache = false;\n                }\n            });\n            if (shouldCache) {\n                recycledElements.push(element);\n            }\n        }\n    }\n    handleAppVisibilityChanged() {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.isInBackground = document.visibilityState === 'hidden';\n        });\n    }\n    addAppVisibilityListener() {\n        if (isWeb()) {\n            this.isInBackground = document.visibilityState === 'hidden';\n            document.addEventListener('visibilitychange', this.appVisibilityChangedListener);\n        } else {\n            this.isInBackground = false;\n        }\n    }\n    removeAppVisibilityListener() {\n        if (isWeb()) {\n            document.removeEventListener('visibilitychange', this.appVisibilityChangedListener);\n        }\n    }\n}\nfunction attachToElement(track, element) {\n    let mediaStream;\n    if (element.srcObject instanceof MediaStream) {\n        mediaStream = element.srcObject;\n    } else {\n        mediaStream = new MediaStream();\n    }\n    // check if track matches existing track\n    let existingTracks;\n    if (track.kind === 'audio') {\n        existingTracks = mediaStream.getAudioTracks();\n    } else {\n        existingTracks = mediaStream.getVideoTracks();\n    }\n    if (!existingTracks.includes(track)) {\n        existingTracks.forEach((et)=>{\n            mediaStream.removeTrack(et);\n        });\n        mediaStream.addTrack(track);\n    }\n    if (!isSafari() || !(element instanceof HTMLVideoElement)) {\n        // when in low power mode (applies to both macOS and iOS), Safari will show a play/pause overlay\n        // when a video starts that has the `autoplay` attribute is set.\n        // we work around this by _not_ setting the autoplay attribute on safari and instead call `setTimeout(() => el.play(),0)` further down\n        element.autoplay = true;\n    }\n    // In case there are no audio tracks present on the mediastream, we set the element as muted to ensure autoplay works\n    element.muted = mediaStream.getAudioTracks().length === 0;\n    if (element instanceof HTMLVideoElement) {\n        element.playsInline = true;\n    }\n    // avoid flicker\n    if (element.srcObject !== mediaStream) {\n        element.srcObject = mediaStream;\n        if ((isSafari() || isFireFox()) && element instanceof HTMLVideoElement) {\n            // Firefox also has a timing issue where video doesn't actually get attached unless\n            // performed out-of-band\n            // Safari 15 has a bug where in certain layouts, video element renders\n            // black until the page is resized or other changes take place.\n            // Resetting the src triggers it to render.\n            // https://developer.apple.com/forums/thread/690523\n            setTimeout(()=>{\n                element.srcObject = mediaStream;\n                // Safari 15 sometimes fails to start a video\n                // when the window is backgrounded before the first frame is drawn\n                // manually calling play here seems to fix that\n                element.play().catch(()=>{\n                /** do nothing */ });\n            }, 0);\n        }\n    }\n}\n/** @internal */ function detachTrack(track, element) {\n    if (element.srcObject instanceof MediaStream) {\n        const mediaStream = element.srcObject;\n        mediaStream.removeTrack(track);\n        if (mediaStream.getTracks().length > 0) {\n            element.srcObject = mediaStream;\n        } else {\n            element.srcObject = null;\n        }\n    }\n}\n(function(Track) {\n    let Kind;\n    (function(Kind) {\n        Kind[\"Audio\"] = \"audio\";\n        Kind[\"Video\"] = \"video\";\n        Kind[\"Unknown\"] = \"unknown\";\n    })(Kind = Track.Kind || (Track.Kind = {}));\n    let Source;\n    (function(Source) {\n        Source[\"Camera\"] = \"camera\";\n        Source[\"Microphone\"] = \"microphone\";\n        Source[\"ScreenShare\"] = \"screen_share\";\n        Source[\"ScreenShareAudio\"] = \"screen_share_audio\";\n        Source[\"Unknown\"] = \"unknown\";\n    })(Source = Track.Source || (Track.Source = {}));\n    let StreamState$1;\n    (function(StreamState) {\n        StreamState[\"Active\"] = \"active\";\n        StreamState[\"Paused\"] = \"paused\";\n        StreamState[\"Unknown\"] = \"unknown\";\n    })(StreamState$1 = Track.StreamState || (Track.StreamState = {}));\n    /** @internal */ function kindToProto(k) {\n        switch(k){\n            case Kind.Audio:\n                return TrackType.AUDIO;\n            case Kind.Video:\n                return TrackType.VIDEO;\n            default:\n                // FIXME this was UNRECOGNIZED before\n                return TrackType.DATA;\n        }\n    }\n    Track.kindToProto = kindToProto;\n    /** @internal */ function kindFromProto(t) {\n        switch(t){\n            case TrackType.AUDIO:\n                return Kind.Audio;\n            case TrackType.VIDEO:\n                return Kind.Video;\n            default:\n                return Kind.Unknown;\n        }\n    }\n    Track.kindFromProto = kindFromProto;\n    /** @internal */ function sourceToProto(s) {\n        switch(s){\n            case Source.Camera:\n                return TrackSource.CAMERA;\n            case Source.Microphone:\n                return TrackSource.MICROPHONE;\n            case Source.ScreenShare:\n                return TrackSource.SCREEN_SHARE;\n            case Source.ScreenShareAudio:\n                return TrackSource.SCREEN_SHARE_AUDIO;\n            default:\n                return TrackSource.UNKNOWN;\n        }\n    }\n    Track.sourceToProto = sourceToProto;\n    /** @internal */ function sourceFromProto(s) {\n        switch(s){\n            case TrackSource.CAMERA:\n                return Source.Camera;\n            case TrackSource.MICROPHONE:\n                return Source.Microphone;\n            case TrackSource.SCREEN_SHARE:\n                return Source.ScreenShare;\n            case TrackSource.SCREEN_SHARE_AUDIO:\n                return Source.ScreenShareAudio;\n            default:\n                return Source.Unknown;\n        }\n    }\n    Track.sourceFromProto = sourceFromProto;\n    /** @internal */ function streamStateFromProto(s) {\n        switch(s){\n            case StreamState.ACTIVE:\n                return StreamState$1.Active;\n            case StreamState.PAUSED:\n                return StreamState$1.Paused;\n            default:\n                return StreamState$1.Unknown;\n        }\n    }\n    Track.streamStateFromProto = streamStateFromProto;\n})(Track || (Track = {}));\nfunction mergeDefaultOptions(options, audioDefaults, videoDefaults) {\n    var _a;\n    const opts = (_a = cloneDeep(options)) !== null && _a !== void 0 ? _a : {};\n    if (opts.audio === true) opts.audio = {};\n    if (opts.video === true) opts.video = {};\n    // use defaults\n    if (opts.audio) {\n        mergeObjectWithoutOverwriting(opts.audio, audioDefaults);\n    }\n    if (opts.video) {\n        mergeObjectWithoutOverwriting(opts.video, videoDefaults);\n    }\n    return opts;\n}\nfunction mergeObjectWithoutOverwriting(mainObject, objectToMerge) {\n    Object.keys(objectToMerge).forEach((key)=>{\n        if (mainObject[key] === undefined) mainObject[key] = objectToMerge[key];\n    });\n    return mainObject;\n}\nfunction constraintsForOptions(options) {\n    const constraints = {};\n    if (options.video) {\n        // default video options\n        if (typeof options.video === 'object') {\n            const videoOptions = {};\n            const target = videoOptions;\n            const source = options.video;\n            Object.keys(source).forEach((key)=>{\n                switch(key){\n                    case 'resolution':\n                        // flatten VideoResolution fields\n                        mergeObjectWithoutOverwriting(target, source.resolution);\n                        break;\n                    default:\n                        target[key] = source[key];\n                }\n            });\n            constraints.video = videoOptions;\n        } else {\n            constraints.video = options.video;\n        }\n    } else {\n        constraints.video = false;\n    }\n    if (options.audio) {\n        if (typeof options.audio === 'object') {\n            constraints.audio = options.audio;\n        } else {\n            constraints.audio = true;\n        }\n    } else {\n        constraints.audio = false;\n    }\n    return constraints;\n}\n/**\n * This function detects silence on a given [[Track]] instance.\n * Returns true if the track seems to be entirely silent.\n */ function detectSilence(track) {\n    let timeOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 200;\n    return __awaiter(this, void 0, void 0, function*() {\n        const ctx = getNewAudioContext();\n        if (ctx) {\n            const analyser = ctx.createAnalyser();\n            analyser.fftSize = 2048;\n            const bufferLength = analyser.frequencyBinCount;\n            const dataArray = new Uint8Array(bufferLength);\n            const source = ctx.createMediaStreamSource(new MediaStream([\n                track.mediaStreamTrack\n            ]));\n            source.connect(analyser);\n            yield sleep(timeOffset);\n            analyser.getByteTimeDomainData(dataArray);\n            const someNoise = dataArray.some((sample)=>sample !== 128 && sample !== 0);\n            ctx.close();\n            return !someNoise;\n        }\n        return false;\n    });\n}\n/**\n * @internal\n */ function getNewAudioContext() {\n    const AudioContext1 = // @ts-ignore\n     false && (0);\n    if (AudioContext1) {\n        return new AudioContext1({\n            latencyHint: 'interactive'\n        });\n    }\n}\n/**\n * @internal\n */ function sourceToKind(source) {\n    if (source === Track.Source.Microphone) {\n        return 'audioinput';\n    } else if (source === Track.Source.Camera) {\n        return 'videoinput';\n    } else {\n        return undefined;\n    }\n}\n/**\n * @internal\n */ function screenCaptureToDisplayMediaStreamOptions(options) {\n    var _a, _b;\n    let videoConstraints = (_a = options.video) !== null && _a !== void 0 ? _a : true;\n    // treat 0 as uncapped\n    if (options.resolution && options.resolution.width > 0 && options.resolution.height > 0) {\n        videoConstraints = typeof videoConstraints === 'boolean' ? {} : videoConstraints;\n        if (isSafari()) {\n            videoConstraints = Object.assign(Object.assign({}, videoConstraints), {\n                width: {\n                    max: options.resolution.width\n                },\n                height: {\n                    max: options.resolution.height\n                },\n                frameRate: options.resolution.frameRate\n            });\n        } else {\n            videoConstraints = Object.assign(Object.assign({}, videoConstraints), {\n                width: {\n                    ideal: options.resolution.width\n                },\n                height: {\n                    ideal: options.resolution.height\n                },\n                frameRate: options.resolution.frameRate\n            });\n        }\n    }\n    return {\n        audio: (_b = options.audio) !== null && _b !== void 0 ? _b : false,\n        video: videoConstraints,\n        // @ts-expect-error support for experimental display media features\n        controller: options.controller,\n        selfBrowserSurface: options.selfBrowserSurface,\n        surfaceSwitching: options.surfaceSwitching,\n        systemAudio: options.systemAudio\n    };\n}\nfunction mimeTypeToVideoCodecString(mimeType) {\n    const codec = mimeType.split('/')[1].toLowerCase();\n    if (!videoCodecs.includes(codec)) {\n        throw Error(\"Video codec not supported: \".concat(codec));\n    }\n    return codec;\n}\nfunction getTrackPublicationInfo(tracks) {\n    const infos = [];\n    tracks.forEach((track)=>{\n        if (track.track !== undefined) {\n            infos.push(new TrackPublishedResponse({\n                cid: track.track.mediaStreamID,\n                track: track.trackInfo\n            }));\n        }\n    });\n    return infos;\n}\nfunction getLogContextFromTrack(track) {\n    if (track instanceof Track) {\n        return {\n            trackSid: track.sid,\n            trackSource: track.source,\n            trackMuted: track.isMuted,\n            trackEnabled: track.mediaStreamTrack.enabled,\n            trackKind: track.kind\n        };\n    } else {\n        return {\n            trackSid: track.trackSid,\n            trackName: track.trackName,\n            track: track.track ? getLogContextFromTrack(track.track) : undefined,\n            trackEnabled: track.isEnabled,\n            trackEncrypted: track.isEncrypted,\n            trackMimeType: track.mimeType\n        };\n    }\n}\nconst separator = '|';\nconst ddExtensionURI = 'https://aomediacodec.github.io/av1-rtp-spec/#dependency-descriptor-rtp-header-extension';\nfunction unpackStreamId(packed) {\n    const parts = packed.split(separator);\n    if (parts.length > 1) {\n        return [\n            parts[0],\n            packed.substr(parts[0].length + 1)\n        ];\n    }\n    return [\n        packed,\n        ''\n    ];\n}\nfunction sleep(duration) {\n    return __awaiter(this, void 0, void 0, function*() {\n        return new Promise((resolve)=>CriticalTimers.setTimeout(resolve, duration));\n    });\n}\n/** @internal */ function supportsTransceiver() {\n    return 'addTransceiver' in RTCPeerConnection.prototype;\n}\n/** @internal */ function supportsAddTrack() {\n    return 'addTrack' in RTCPeerConnection.prototype;\n}\nfunction supportsAdaptiveStream() {\n    return typeof ResizeObserver !== undefined && typeof IntersectionObserver !== undefined;\n}\nfunction supportsDynacast() {\n    return supportsTransceiver();\n}\nfunction supportsAV1() {\n    if (!('getCapabilities' in RTCRtpSender)) {\n        return false;\n    }\n    if (isSafari()) {\n        // Safari 17 on iPhone14 reports AV1 capability, but does not actually support it\n        return false;\n    }\n    const capabilities = RTCRtpSender.getCapabilities('video');\n    let hasAV1 = false;\n    if (capabilities) {\n        for (const codec of capabilities.codecs){\n            if (codec.mimeType === 'video/AV1') {\n                hasAV1 = true;\n                break;\n            }\n        }\n    }\n    return hasAV1;\n}\nfunction supportsVP9() {\n    if (!('getCapabilities' in RTCRtpSender)) {\n        return false;\n    }\n    if (isFireFox()) {\n        // technically speaking FireFox supports VP9, but SVC publishing is broken\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1633876\n        return false;\n    }\n    if (isSafari()) {\n        const browser = getBrowser();\n        if ((browser === null || browser === void 0 ? void 0 : browser.version) && compareVersions(browser.version, '16') < 0) {\n            // Safari 16 and below does not support VP9\n            return false;\n        }\n    }\n    const capabilities = RTCRtpSender.getCapabilities('video');\n    let hasVP9 = false;\n    if (capabilities) {\n        for (const codec of capabilities.codecs){\n            if (codec.mimeType === 'video/VP9') {\n                hasVP9 = true;\n                break;\n            }\n        }\n    }\n    return hasVP9;\n}\nfunction isSVCCodec(codec) {\n    return codec === 'av1' || codec === 'vp9';\n}\nfunction supportsSetSinkId(elm) {\n    if (!document) {\n        return false;\n    }\n    if (!elm) {\n        elm = document.createElement('audio');\n    }\n    return 'setSinkId' in elm;\n}\nconst setCodecPreferencesVersions = {\n    Chrome: '100',\n    Safari: '15',\n    Firefox: '100'\n};\nfunction supportsSetCodecPreferences(transceiver) {\n    if (!isWeb()) {\n        return false;\n    }\n    if (!('setCodecPreferences' in transceiver)) {\n        return false;\n    }\n    const browser = getBrowser();\n    if (!(browser === null || browser === void 0 ? void 0 : browser.name) || !browser.version) {\n        // version is required\n        return false;\n    }\n    const v = setCodecPreferencesVersions[browser.name];\n    if (v) {\n        return compareVersions(browser.version, v) >= 0;\n    }\n    return false;\n}\nfunction isBrowserSupported() {\n    return supportsTransceiver() || supportsAddTrack();\n}\nfunction isFireFox() {\n    var _a;\n    return ((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.name) === 'Firefox';\n}\nfunction isChromiumBased() {\n    var _a;\n    return ((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.name) === 'Chrome';\n}\nfunction isSafari() {\n    var _a;\n    return ((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.name) === 'Safari';\n}\nfunction isSafari17() {\n    const b = getBrowser();\n    return (b === null || b === void 0 ? void 0 : b.name) === 'Safari' && b.version.startsWith('17.');\n}\nfunction isMobile() {\n    if (!isWeb()) return false;\n    return /Tablet|iPad|Mobile|Android|BlackBerry/.test(navigator.userAgent);\n}\nfunction isWeb() {\n    return typeof document !== 'undefined';\n}\nfunction isReactNative() {\n    // navigator.product is deprecated on browsers, but will be set appropriately for react-native.\n    return navigator.product == 'ReactNative';\n}\nfunction isCloud(serverUrl) {\n    return serverUrl.hostname.endsWith('.livekit.cloud') || serverUrl.hostname.endsWith('.livekit.run');\n}\nfunction getLKReactNativeInfo() {\n    // global defined only for ReactNative.\n    // @ts-ignore\n    if (global && global.LiveKitReactNativeGlobal) {\n        // @ts-ignore\n        return global.LiveKitReactNativeGlobal;\n    }\n    return undefined;\n}\nfunction getReactNativeOs() {\n    if (!isReactNative()) {\n        return undefined;\n    }\n    let info = getLKReactNativeInfo();\n    if (info) {\n        return info.platform;\n    }\n    return undefined;\n}\nfunction getDevicePixelRatio() {\n    if (isWeb()) {\n        return window.devicePixelRatio;\n    }\n    if (isReactNative()) {\n        let info = getLKReactNativeInfo();\n        if (info) {\n            return info.devicePixelRatio;\n        }\n    }\n    return 1;\n}\nfunction compareVersions(v1, v2) {\n    const parts1 = v1.split('.');\n    const parts2 = v2.split('.');\n    const k = Math.min(parts1.length, parts2.length);\n    for(let i = 0; i < k; ++i){\n        const p1 = parseInt(parts1[i], 10);\n        const p2 = parseInt(parts2[i], 10);\n        if (p1 > p2) return 1;\n        if (p1 < p2) return -1;\n        if (i === k - 1 && p1 === p2) return 0;\n    }\n    if (v1 === '' && v2 !== '') {\n        return -1;\n    } else if (v2 === '') {\n        return 1;\n    }\n    return parts1.length == parts2.length ? 0 : parts1.length < parts2.length ? -1 : 1;\n}\nfunction roDispatchCallback(entries) {\n    for (const entry of entries){\n        entry.target.handleResize(entry);\n    }\n}\nfunction ioDispatchCallback(entries) {\n    for (const entry of entries){\n        entry.target.handleVisibilityChanged(entry);\n    }\n}\nlet resizeObserver = null;\nconst getResizeObserver = ()=>{\n    if (!resizeObserver) resizeObserver = new ResizeObserver(roDispatchCallback);\n    return resizeObserver;\n};\nlet intersectionObserver = null;\nconst getIntersectionObserver = ()=>{\n    if (!intersectionObserver) {\n        intersectionObserver = new IntersectionObserver(ioDispatchCallback, {\n            root: null,\n            rootMargin: '0px'\n        });\n    }\n    return intersectionObserver;\n};\nfunction getClientInfo() {\n    var _a;\n    const info = new ClientInfo({\n        sdk: ClientInfo_SDK.JS,\n        protocol: protocolVersion,\n        version\n    });\n    if (isReactNative()) {\n        info.os = (_a = getReactNativeOs()) !== null && _a !== void 0 ? _a : '';\n    }\n    return info;\n}\nlet emptyVideoStreamTrack;\nfunction getEmptyVideoStreamTrack() {\n    if (!emptyVideoStreamTrack) {\n        emptyVideoStreamTrack = createDummyVideoStreamTrack();\n    }\n    return emptyVideoStreamTrack.clone();\n}\nfunction createDummyVideoStreamTrack() {\n    let width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 16;\n    let height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 16;\n    let enabled = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let paintContent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    const canvas = document.createElement('canvas');\n    // the canvas size is set to 16 by default, because electron apps seem to fail with smaller values\n    canvas.width = width;\n    canvas.height = height;\n    const ctx = canvas.getContext('2d');\n    ctx === null || ctx === void 0 ? void 0 : ctx.fillRect(0, 0, canvas.width, canvas.height);\n    if (paintContent && ctx) {\n        ctx.beginPath();\n        ctx.arc(width / 2, height / 2, 50, 0, Math.PI * 2, true);\n        ctx.closePath();\n        ctx.fillStyle = 'grey';\n        ctx.fill();\n    }\n    // @ts-ignore\n    const dummyStream = canvas.captureStream();\n    const [dummyTrack] = dummyStream.getTracks();\n    if (!dummyTrack) {\n        throw Error('Could not get empty media stream video track');\n    }\n    dummyTrack.enabled = enabled;\n    return dummyTrack;\n}\nlet emptyAudioStreamTrack;\nfunction getEmptyAudioStreamTrack() {\n    if (!emptyAudioStreamTrack) {\n        // implementation adapted from https://blog.mozilla.org/webrtc/warm-up-with-replacetrack/\n        const ctx = new AudioContext();\n        const oscillator = ctx.createOscillator();\n        const gain = ctx.createGain();\n        gain.gain.setValueAtTime(0, 0);\n        const dst = ctx.createMediaStreamDestination();\n        oscillator.connect(gain);\n        gain.connect(dst);\n        oscillator.start();\n        [emptyAudioStreamTrack] = dst.stream.getAudioTracks();\n        if (!emptyAudioStreamTrack) {\n            throw Error('Could not get empty media stream audio track');\n        }\n        emptyAudioStreamTrack.enabled = false;\n    }\n    return emptyAudioStreamTrack.clone();\n}\nclass Future {\n    constructor(futureBase, onFinally){\n        this.onFinally = onFinally;\n        this.promise = new Promise((resolve, reject)=>__awaiter(this, void 0, void 0, function*() {\n                this.resolve = resolve;\n                this.reject = reject;\n                if (futureBase) {\n                    yield futureBase(resolve, reject);\n                }\n            })).finally(()=>{\n            var _a;\n            return (_a = this.onFinally) === null || _a === void 0 ? void 0 : _a.call(this);\n        });\n    }\n}\n/**\n * Creates and returns an analyser web audio node that is attached to the provided track.\n * Additionally returns a convenience method `calculateVolume` to perform instant volume readings on that track.\n * Call the returned `cleanup` function to close the audioContext that has been created for the instance of this helper\n */ function createAudioAnalyser(track, options) {\n    const opts = Object.assign({\n        cloneTrack: false,\n        fftSize: 2048,\n        smoothingTimeConstant: 0.8,\n        minDecibels: -100,\n        maxDecibels: -80\n    }, options);\n    const audioContext = getNewAudioContext();\n    if (!audioContext) {\n        throw new Error('Audio Context not supported on this browser');\n    }\n    const streamTrack = opts.cloneTrack ? track.mediaStreamTrack.clone() : track.mediaStreamTrack;\n    const mediaStreamSource = audioContext.createMediaStreamSource(new MediaStream([\n        streamTrack\n    ]));\n    const analyser = audioContext.createAnalyser();\n    analyser.minDecibels = opts.minDecibels;\n    analyser.maxDecibels = opts.maxDecibels;\n    analyser.fftSize = opts.fftSize;\n    analyser.smoothingTimeConstant = opts.smoothingTimeConstant;\n    mediaStreamSource.connect(analyser);\n    const dataArray = new Uint8Array(analyser.frequencyBinCount);\n    /**\n   * Calculates the current volume of the track in the range from 0 to 1\n   */ const calculateVolume = ()=>{\n        analyser.getByteFrequencyData(dataArray);\n        let sum = 0;\n        for (const amplitude of dataArray){\n            sum += Math.pow(amplitude / 255, 2);\n        }\n        const volume = Math.sqrt(sum / dataArray.length);\n        return volume;\n    };\n    const cleanup = ()=>__awaiter(this, void 0, void 0, function*() {\n            yield audioContext.close();\n            if (opts.cloneTrack) {\n                streamTrack.stop();\n            }\n        });\n    return {\n        calculateVolume,\n        analyser,\n        cleanup\n    };\n}\nclass Mutex {\n    constructor(){\n        this._locking = Promise.resolve();\n        this._locks = 0;\n    }\n    isLocked() {\n        return this._locks > 0;\n    }\n    lock() {\n        this._locks += 1;\n        let unlockNext;\n        const willLock = new Promise((resolve)=>unlockNext = ()=>{\n                this._locks -= 1;\n                resolve();\n            });\n        const willUnlock = this._locking.then(()=>unlockNext);\n        this._locking = this._locking.then(()=>willLock);\n        return willUnlock;\n    }\n}\nfunction isVideoCodec(maybeCodec) {\n    return videoCodecs.includes(maybeCodec);\n}\nfunction unwrapConstraint(constraint) {\n    if (typeof constraint === 'string') {\n        return constraint;\n    }\n    if (Array.isArray(constraint)) {\n        return constraint[0];\n    }\n    if (constraint.exact) {\n        if (Array.isArray(constraint.exact)) {\n            return constraint.exact[0];\n        }\n        return constraint.exact;\n    }\n    if (constraint.ideal) {\n        if (Array.isArray(constraint.ideal)) {\n            return constraint.ideal[0];\n        }\n        return constraint.ideal;\n    }\n    throw Error('could not unwrap constraint');\n}\nfunction toWebsocketUrl(url) {\n    if (url.startsWith('http')) {\n        return url.replace(/^(http)/, 'ws');\n    }\n    return url;\n}\nfunction toHttpUrl(url) {\n    if (url.startsWith('ws')) {\n        return url.replace(/^(ws)/, 'http');\n    }\n    return url;\n}\nconst defaultId = 'default';\nclass DeviceManager {\n    static getInstance() {\n        if (this.instance === undefined) {\n            this.instance = new DeviceManager();\n        }\n        return this.instance;\n    }\n    getDevices(kind) {\n        let requestPermissions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (((_a = DeviceManager.userMediaPromiseMap) === null || _a === void 0 ? void 0 : _a.size) > 0) {\n                livekitLogger.debug('awaiting getUserMedia promise');\n                try {\n                    if (kind) {\n                        yield DeviceManager.userMediaPromiseMap.get(kind);\n                    } else {\n                        yield Promise.all(DeviceManager.userMediaPromiseMap.values());\n                    }\n                } catch (e) {\n                    livekitLogger.warn('error waiting for media permissons');\n                }\n            }\n            let devices = yield navigator.mediaDevices.enumerateDevices();\n            if (requestPermissions && // for safari we need to skip this check, as otherwise it will re-acquire user media and fail on iOS https://bugs.webkit.org/show_bug.cgi?id=179363\n            !(isSafari() && this.hasDeviceInUse(kind))) {\n                const isDummyDeviceOrEmpty = devices.length === 0 || devices.some((device)=>{\n                    const noLabel = device.label === '';\n                    const isRelevant = kind ? device.kind === kind : true;\n                    return noLabel && isRelevant;\n                });\n                if (isDummyDeviceOrEmpty) {\n                    const permissionsToAcquire = {\n                        video: kind !== 'audioinput' && kind !== 'audiooutput',\n                        audio: kind !== 'videoinput'\n                    };\n                    const stream = yield navigator.mediaDevices.getUserMedia(permissionsToAcquire);\n                    devices = yield navigator.mediaDevices.enumerateDevices();\n                    stream.getTracks().forEach((track)=>{\n                        track.stop();\n                    });\n                }\n            }\n            if (kind) {\n                devices = devices.filter((device)=>device.kind === kind);\n            }\n            return devices;\n        });\n    }\n    normalizeDeviceId(kind, deviceId, groupId) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (deviceId !== defaultId) {\n                return deviceId;\n            }\n            // resolve actual device id if it's 'default': Chrome returns it when no\n            // device has been chosen\n            const devices = yield this.getDevices(kind);\n            const device = devices.find((d)=>d.groupId === groupId && d.deviceId !== defaultId);\n            return device === null || device === void 0 ? void 0 : device.deviceId;\n        });\n    }\n    hasDeviceInUse(kind) {\n        return kind ? DeviceManager.userMediaPromiseMap.has(kind) : DeviceManager.userMediaPromiseMap.size > 0;\n    }\n}\nDeviceManager.mediaDeviceKinds = [\n    'audioinput',\n    'audiooutput',\n    'videoinput'\n];\nDeviceManager.userMediaPromiseMap = new Map();\nconst defaultDimensionsTimeout = 1000;\nclass LocalTrack extends Track {\n    get constraints() {\n        return this._constraints;\n    }\n    /**\n   *\n   * @param mediaTrack\n   * @param kind\n   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks\n   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK\n   */ constructor(mediaTrack, kind, constraints){\n        let userProvidedTrack = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n        let loggerOptions = arguments.length > 4 ? arguments[4] : undefined;\n        super(mediaTrack, kind, loggerOptions);\n        this._isUpstreamPaused = false;\n        this.handleTrackMuteEvent = ()=>this.debouncedTrackMuteHandler().catch(()=>this.log.debug('track mute bounce got cancelled by an unmute event', this.logContext));\n        this.debouncedTrackMuteHandler = r(()=>__awaiter(this, void 0, void 0, function*() {\n                yield this.pauseUpstream();\n            }), 5000);\n        this.handleTrackUnmuteEvent = ()=>__awaiter(this, void 0, void 0, function*() {\n                this.debouncedTrackMuteHandler.cancel('unmute');\n                yield this.resumeUpstream();\n            });\n        this.handleEnded = ()=>{\n            if (this.isInBackground) {\n                this.reacquireTrack = true;\n            }\n            this._mediaStreamTrack.removeEventListener('mute', this.handleTrackMuteEvent);\n            this._mediaStreamTrack.removeEventListener('unmute', this.handleTrackUnmuteEvent);\n            this.emit(TrackEvent.Ended, this);\n        };\n        this.reacquireTrack = false;\n        this.providedByUser = userProvidedTrack;\n        this.muteLock = new Mutex();\n        this.pauseUpstreamLock = new Mutex();\n        this.processorLock = new Mutex();\n        this.setMediaStreamTrack(mediaTrack, true);\n        // added to satisfy TS compiler, constraints are synced with MediaStreamTrack\n        this._constraints = mediaTrack.getConstraints();\n        if (constraints) {\n            this._constraints = constraints;\n        }\n    }\n    get id() {\n        return this._mediaStreamTrack.id;\n    }\n    get dimensions() {\n        if (this.kind !== Track.Kind.Video) {\n            return undefined;\n        }\n        const { width, height } = this._mediaStreamTrack.getSettings();\n        if (width && height) {\n            return {\n                width,\n                height\n            };\n        }\n        return undefined;\n    }\n    get isUpstreamPaused() {\n        return this._isUpstreamPaused;\n    }\n    get isUserProvided() {\n        return this.providedByUser;\n    }\n    get mediaStreamTrack() {\n        var _a, _b;\n        return (_b = (_a = this.processor) === null || _a === void 0 ? void 0 : _a.processedTrack) !== null && _b !== void 0 ? _b : this._mediaStreamTrack;\n    }\n    setMediaStreamTrack(newTrack, force) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (newTrack === this._mediaStreamTrack && !force) {\n                return;\n            }\n            if (this._mediaStreamTrack) {\n                // detach\n                this.attachedElements.forEach((el)=>{\n                    detachTrack(this._mediaStreamTrack, el);\n                });\n                this.debouncedTrackMuteHandler.cancel('new-track');\n                this._mediaStreamTrack.removeEventListener('ended', this.handleEnded);\n                this._mediaStreamTrack.removeEventListener('mute', this.handleTrackMuteEvent);\n                this._mediaStreamTrack.removeEventListener('unmute', this.handleTrackUnmuteEvent);\n            }\n            this.mediaStream = new MediaStream([\n                newTrack\n            ]);\n            if (newTrack) {\n                newTrack.addEventListener('ended', this.handleEnded);\n                // when underlying track emits mute, it indicates that the device is unable\n                // to produce media. In this case we'll need to signal with remote that\n                // the track is \"muted\"\n                // note this is different from LocalTrack.mute because we do not want to\n                // touch MediaStreamTrack.enabled\n                newTrack.addEventListener('mute', this.handleTrackMuteEvent);\n                newTrack.addEventListener('unmute', this.handleTrackUnmuteEvent);\n                this._constraints = newTrack.getConstraints();\n            }\n            let processedTrack;\n            if (this.processor && newTrack && this.processorElement) {\n                this.log.debug('restarting processor', this.logContext);\n                if (this.kind === 'unknown') {\n                    throw TypeError('cannot set processor on track of unknown kind');\n                }\n                attachToElement(newTrack, this.processorElement);\n                // ensure the processorElement itself stays muted\n                this.processorElement.muted = true;\n                yield this.processor.restart({\n                    track: newTrack,\n                    kind: this.kind,\n                    element: this.processorElement\n                });\n                processedTrack = this.processor.processedTrack;\n            }\n            if (this.sender) {\n                yield this.sender.replaceTrack(processedTrack !== null && processedTrack !== void 0 ? processedTrack : newTrack);\n            }\n            // if `newTrack` is different from the existing track, stop the\n            // older track just before replacing it\n            if (!this.providedByUser && this._mediaStreamTrack !== newTrack) {\n                this._mediaStreamTrack.stop();\n            }\n            this._mediaStreamTrack = newTrack;\n            if (newTrack) {\n                // sync muted state with the enabled state of the newly provided track\n                this._mediaStreamTrack.enabled = !this.isMuted;\n                // when a valid track is replace, we'd want to start producing\n                yield this.resumeUpstream();\n                this.attachedElements.forEach((el)=>{\n                    attachToElement(processedTrack !== null && processedTrack !== void 0 ? processedTrack : newTrack, el);\n                });\n            }\n        });\n    }\n    waitForDimensions() {\n        let timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultDimensionsTimeout;\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.kind === Track.Kind.Audio) {\n                throw new Error('cannot get dimensions for audio tracks');\n            }\n            if (((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.os) === 'iOS') {\n                // browsers report wrong initial resolution on iOS.\n                // when slightly delaying the call to .getSettings(), the correct resolution is being reported\n                yield sleep(10);\n            }\n            const started = Date.now();\n            while(Date.now() - started < timeout){\n                const dims = this.dimensions;\n                if (dims) {\n                    return dims;\n                }\n                yield sleep(50);\n            }\n            throw new TrackInvalidError('unable to get track dimensions after timeout');\n        });\n    }\n    /**\n   * @returns DeviceID of the device that is currently being used for this track\n   */ getDeviceId() {\n        return __awaiter(this, void 0, void 0, function*() {\n            // screen share doesn't have a usable device id\n            if (this.source === Track.Source.ScreenShare) {\n                return;\n            }\n            const { deviceId, groupId } = this._mediaStreamTrack.getSettings();\n            const kind = this.kind === Track.Kind.Audio ? 'audioinput' : 'videoinput';\n            return DeviceManager.getInstance().normalizeDeviceId(kind, deviceId, groupId);\n        });\n    }\n    mute() {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.setTrackMuted(true);\n            return this;\n        });\n    }\n    unmute() {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.setTrackMuted(false);\n            return this;\n        });\n    }\n    replaceTrack(track) {\n        let userProvidedTrack = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.sender) {\n                throw new TrackInvalidError('unable to replace an unpublished track');\n            }\n            this.log.debug('replace MediaStreamTrack', this.logContext);\n            yield this.setMediaStreamTrack(track);\n            // this must be synced *after* setting mediaStreamTrack above, since it relies\n            // on the previous state in order to cleanup\n            this.providedByUser = userProvidedTrack;\n            if (this.processor) {\n                yield this.stopProcessor();\n            }\n            return this;\n        });\n    }\n    restart(constraints) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!constraints) {\n                constraints = this._constraints;\n            }\n            this.log.debug('restarting track with constraints', Object.assign(Object.assign({}, this.logContext), {\n                constraints\n            }));\n            const streamConstraints = {\n                audio: false,\n                video: false\n            };\n            if (this.kind === Track.Kind.Video) {\n                streamConstraints.video = constraints;\n            } else {\n                streamConstraints.audio = constraints;\n            }\n            // these steps are duplicated from setMediaStreamTrack because we must stop\n            // the previous tracks before new tracks can be acquired\n            this.attachedElements.forEach((el)=>{\n                detachTrack(this.mediaStreamTrack, el);\n            });\n            this._mediaStreamTrack.removeEventListener('ended', this.handleEnded);\n            // on Safari, the old audio track must be stopped before attempting to acquire\n            // the new track, otherwise the new track will stop with\n            // 'A MediaStreamTrack ended due to a capture failure`\n            this._mediaStreamTrack.stop();\n            // create new track and attach\n            const mediaStream = yield navigator.mediaDevices.getUserMedia(streamConstraints);\n            const newTrack = mediaStream.getTracks()[0];\n            newTrack.addEventListener('ended', this.handleEnded);\n            this.log.debug('re-acquired MediaStreamTrack', this.logContext);\n            yield this.setMediaStreamTrack(newTrack);\n            this._constraints = constraints;\n            this.emit(TrackEvent.Restarted, this);\n            return this;\n        });\n    }\n    setTrackMuted(muted) {\n        this.log.debug(\"setting \".concat(this.kind, \" track \").concat(muted ? 'muted' : 'unmuted'), this.logContext);\n        if (this.isMuted === muted && this._mediaStreamTrack.enabled !== muted) {\n            return;\n        }\n        this.isMuted = muted;\n        this._mediaStreamTrack.enabled = !muted;\n        this.emit(muted ? TrackEvent.Muted : TrackEvent.Unmuted, this);\n    }\n    get needsReAcquisition() {\n        return this._mediaStreamTrack.readyState !== 'live' || this._mediaStreamTrack.muted || !this._mediaStreamTrack.enabled || this.reacquireTrack;\n    }\n    handleAppVisibilityChanged() {\n        const _super = Object.create(null, {\n            handleAppVisibilityChanged: {\n                get: ()=>super.handleAppVisibilityChanged\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            yield _super.handleAppVisibilityChanged.call(this);\n            if (!isMobile()) return;\n            this.log.debug(\"visibility changed, is in Background: \".concat(this.isInBackground), this.logContext);\n            if (!this.isInBackground && this.needsReAcquisition && !this.isUserProvided && !this.isMuted) {\n                this.log.debug(\"track needs to be reacquired, restarting \".concat(this.source), this.logContext);\n                yield this.restart();\n                this.reacquireTrack = false;\n            }\n        });\n    }\n    stop() {\n        var _a;\n        super.stop();\n        this._mediaStreamTrack.removeEventListener('ended', this.handleEnded);\n        this._mediaStreamTrack.removeEventListener('mute', this.handleTrackMuteEvent);\n        this._mediaStreamTrack.removeEventListener('unmute', this.handleTrackUnmuteEvent);\n        (_a = this.processor) === null || _a === void 0 ? void 0 : _a.destroy();\n        this.processor = undefined;\n    }\n    /**\n   * pauses publishing to the server without disabling the local MediaStreamTrack\n   * this is used to display a user's own video locally while pausing publishing to\n   * the server.\n   * this API is unsupported on Safari < 12 due to a bug\n   **/ pauseUpstream() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.pauseUpstreamLock.lock();\n            try {\n                if (this._isUpstreamPaused === true) {\n                    return;\n                }\n                if (!this.sender) {\n                    this.log.warn('unable to pause upstream for an unpublished track', this.logContext);\n                    return;\n                }\n                this._isUpstreamPaused = true;\n                this.emit(TrackEvent.UpstreamPaused, this);\n                const browser = getBrowser();\n                if ((browser === null || browser === void 0 ? void 0 : browser.name) === 'Safari' && compareVersions(browser.version, '12.0') < 0) {\n                    // https://bugs.webkit.org/show_bug.cgi?id=184911\n                    throw new DeviceUnsupportedError('pauseUpstream is not supported on Safari < 12.');\n                }\n                yield this.sender.replaceTrack(null);\n            } finally{\n                unlock();\n            }\n        });\n    }\n    resumeUpstream() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.pauseUpstreamLock.lock();\n            try {\n                if (this._isUpstreamPaused === false) {\n                    return;\n                }\n                if (!this.sender) {\n                    this.log.warn('unable to resume upstream for an unpublished track', this.logContext);\n                    return;\n                }\n                this._isUpstreamPaused = false;\n                this.emit(TrackEvent.UpstreamResumed, this);\n                // this operation is noop if mediastreamtrack is already being sent\n                yield this.sender.replaceTrack(this._mediaStreamTrack);\n            } finally{\n                unlock();\n            }\n        });\n    }\n    /**\n   * Gets the RTCStatsReport for the LocalTrack's underlying RTCRtpSender\n   * See https://developer.mozilla.org/en-US/docs/Web/API/RTCStatsReport\n   *\n   * @returns Promise<RTCStatsReport> | undefined\n   */ getRTCStatsReport() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!((_a = this.sender) === null || _a === void 0 ? void 0 : _a.getStats)) {\n                return;\n            }\n            const statsReport = yield this.sender.getStats();\n            return statsReport;\n        });\n    }\n    /**\n   * Sets a processor on this track.\n   * See https://github.com/livekit/track-processors-js for example usage\n   *\n   * @experimental\n   *\n   * @param processor\n   * @param showProcessedStreamLocally\n   * @returns\n   */ setProcessor(processor) {\n        let showProcessedStreamLocally = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.processorLock.lock();\n            try {\n                this.log.debug('setting up processor', this.logContext);\n                if (this.processor) {\n                    yield this.stopProcessor();\n                }\n                if (this.kind === 'unknown') {\n                    throw TypeError('cannot set processor on track of unknown kind');\n                }\n                this.processorElement = (_a = this.processorElement) !== null && _a !== void 0 ? _a : document.createElement(this.kind);\n                attachToElement(this._mediaStreamTrack, this.processorElement);\n                this.processorElement.muted = true;\n                this.processorElement.play().catch((error)=>this.log.error('failed to play processor element', Object.assign(Object.assign({}, this.logContext), {\n                        error\n                    })));\n                const processorOptions = {\n                    kind: this.kind,\n                    track: this._mediaStreamTrack,\n                    element: this.processorElement\n                };\n                yield processor.init(processorOptions);\n                this.processor = processor;\n                if (this.processor.processedTrack) {\n                    for (const el of this.attachedElements){\n                        if (el !== this.processorElement && showProcessedStreamLocally) {\n                            detachTrack(this._mediaStreamTrack, el);\n                            attachToElement(this.processor.processedTrack, el);\n                        }\n                    }\n                    yield (_b = this.sender) === null || _b === void 0 ? void 0 : _b.replaceTrack(this.processor.processedTrack);\n                }\n            } finally{\n                unlock();\n            }\n        });\n    }\n    getProcessor() {\n        return this.processor;\n    }\n    /**\n   * Stops the track processor\n   * See https://github.com/livekit/track-processors-js for example usage\n   *\n   * @experimental\n   * @returns\n   */ stopProcessor() {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.processor) return;\n            this.log.debug('stopping processor', this.logContext);\n            (_a = this.processor.processedTrack) === null || _a === void 0 ? void 0 : _a.stop();\n            yield this.processor.destroy();\n            this.processor = undefined;\n            (_b = this.processorElement) === null || _b === void 0 ? void 0 : _b.remove();\n            this.processorElement = undefined;\n            yield this.restart();\n        });\n    }\n}\n/**\n * @experimental\n */ class E2EEManager extends eventsExports.EventEmitter {\n    constructor(options){\n        super();\n        this.onWorkerMessage = (ev)=>{\n            var _a, _b;\n            const { kind, data } = ev.data;\n            switch(kind){\n                case 'error':\n                    livekitLogger.error(data.error.message);\n                    this.emit(EncryptionEvent.EncryptionError, data.error);\n                    break;\n                case 'initAck':\n                    if (data.enabled) {\n                        this.keyProvider.getKeys().forEach((keyInfo)=>{\n                            this.postKey(keyInfo);\n                        });\n                    }\n                    break;\n                case 'enable':\n                    if (this.encryptionEnabled !== data.enabled && data.participantIdentity === ((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity)) {\n                        this.emit(EncryptionEvent.ParticipantEncryptionStatusChanged, data.enabled, this.room.localParticipant);\n                        this.encryptionEnabled = data.enabled;\n                    } else if (data.participantIdentity) {\n                        const participant = (_b = this.room) === null || _b === void 0 ? void 0 : _b.getParticipantByIdentity(data.participantIdentity);\n                        if (!participant) {\n                            throw TypeError(\"couldn't set encryption status, participant not found\".concat(data.participantIdentity));\n                        }\n                        this.emit(EncryptionEvent.ParticipantEncryptionStatusChanged, data.enabled, participant);\n                    }\n                    if (this.encryptionEnabled) {\n                        this.keyProvider.getKeys().forEach((keyInfo)=>{\n                            this.postKey(keyInfo);\n                        });\n                    }\n                    break;\n                case 'ratchetKey':\n                    this.keyProvider.emit(KeyProviderEvent.KeyRatcheted, data.material, data.keyIndex);\n                    break;\n            }\n        };\n        this.onWorkerError = (ev)=>{\n            livekitLogger.error('e2ee worker encountered an error:', {\n                error: ev.error\n            });\n            this.emit(EncryptionEvent.EncryptionError, ev.error);\n        };\n        this.keyProvider = options.keyProvider;\n        this.worker = options.worker;\n        this.encryptionEnabled = false;\n    }\n    /**\n   * @internal\n   */ setup(room) {\n        if (!isE2EESupported()) {\n            throw new DeviceUnsupportedError('tried to setup end-to-end encryption on an unsupported browser');\n        }\n        livekitLogger.info('setting up e2ee');\n        if (room !== this.room) {\n            this.room = room;\n            this.setupEventListeners(room, this.keyProvider);\n            // this.worker = new Worker('');\n            const msg = {\n                kind: 'init',\n                data: {\n                    keyProviderOptions: this.keyProvider.getOptions()\n                }\n            };\n            if (this.worker) {\n                livekitLogger.info(\"initializing worker\", {\n                    worker: this.worker\n                });\n                this.worker.onmessage = this.onWorkerMessage;\n                this.worker.onerror = this.onWorkerError;\n                this.worker.postMessage(msg);\n            }\n        }\n    }\n    /**\n   * @internal\n   */ setParticipantCryptorEnabled(enabled, participantIdentity) {\n        livekitLogger.debug(\"set e2ee to \".concat(enabled, \" for participant \").concat(participantIdentity));\n        this.postEnable(enabled, participantIdentity);\n    }\n    /**\n   * @internal\n   */ setSifTrailer(trailer) {\n        if (!trailer || trailer.length === 0) {\n            livekitLogger.warn(\"ignoring server sent trailer as it's empty\");\n        } else {\n            this.postSifTrailer(trailer);\n        }\n    }\n    setupEngine(engine) {\n        engine.on(EngineEvent.RTPVideoMapUpdate, (rtpMap)=>{\n            this.postRTPMap(rtpMap);\n        });\n    }\n    setupEventListeners(room, keyProvider) {\n        room.on(RoomEvent.TrackPublished, (pub, participant)=>this.setParticipantCryptorEnabled(pub.trackInfo.encryption !== Encryption_Type.NONE, participant.identity));\n        room.on(RoomEvent.ConnectionStateChanged, (state)=>{\n            if (state === ConnectionState.Connected) {\n                room.participants.forEach((participant)=>{\n                    participant.tracks.forEach((pub)=>{\n                        this.setParticipantCryptorEnabled(pub.trackInfo.encryption !== Encryption_Type.NONE, participant.identity);\n                    });\n                });\n            }\n        }).on(RoomEvent.TrackUnsubscribed, (track, _, participant)=>{\n            var _a;\n            const msg = {\n                kind: 'removeTransform',\n                data: {\n                    participantIdentity: participant.identity,\n                    trackId: track.mediaStreamID\n                }\n            };\n            (_a = this.worker) === null || _a === void 0 ? void 0 : _a.postMessage(msg);\n        }).on(RoomEvent.TrackSubscribed, (track, pub, participant)=>{\n            this.setupE2EEReceiver(track, participant.identity, pub.trackInfo);\n        }).on(RoomEvent.SignalConnected, ()=>{\n            if (!this.room) {\n                throw new TypeError(\"expected room to be present on signal connect\");\n            }\n            this.setParticipantCryptorEnabled(this.room.localParticipant.isE2EEEnabled, this.room.localParticipant.identity);\n            keyProvider.getKeys().forEach((keyInfo)=>{\n                this.postKey(keyInfo);\n            });\n        });\n        room.localParticipant.on(ParticipantEvent.LocalTrackPublished, (publication)=>__awaiter(this, void 0, void 0, function*() {\n                this.setupE2EESender(publication.track, publication.track.sender);\n            }));\n        keyProvider.on(KeyProviderEvent.SetKey, (keyInfo)=>this.postKey(keyInfo)).on(KeyProviderEvent.RatchetRequest, (participantId, keyIndex)=>this.postRatchetRequest(participantId, keyIndex));\n    }\n    postRatchetRequest(participantIdentity, keyIndex) {\n        if (!this.worker) {\n            throw Error('could not ratchet key, worker is missing');\n        }\n        const msg = {\n            kind: 'ratchetRequest',\n            data: {\n                participantIdentity: participantIdentity,\n                keyIndex\n            }\n        };\n        this.worker.postMessage(msg);\n    }\n    postKey(_ref) {\n        let { key, participantIdentity, keyIndex } = _ref;\n        var _a;\n        if (!this.worker) {\n            throw Error('could not set key, worker is missing');\n        }\n        const msg = {\n            kind: 'setKey',\n            data: {\n                participantIdentity: participantIdentity,\n                isPublisher: participantIdentity === ((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity),\n                key,\n                keyIndex\n            }\n        };\n        this.worker.postMessage(msg);\n    }\n    postEnable(enabled, participantIdentity) {\n        if (this.worker) {\n            const enableMsg = {\n                kind: 'enable',\n                data: {\n                    enabled,\n                    participantIdentity\n                }\n            };\n            this.worker.postMessage(enableMsg);\n        } else {\n            throw new ReferenceError('failed to enable e2ee, worker is not ready');\n        }\n    }\n    postRTPMap(map) {\n        var _a;\n        if (!this.worker) {\n            throw TypeError('could not post rtp map, worker is missing');\n        }\n        if (!((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity)) {\n            throw TypeError('could not post rtp map, local participant identity is missing');\n        }\n        const msg = {\n            kind: 'setRTPMap',\n            data: {\n                map,\n                participantIdentity: this.room.localParticipant.identity\n            }\n        };\n        this.worker.postMessage(msg);\n    }\n    postSifTrailer(trailer) {\n        if (!this.worker) {\n            throw Error('could not post SIF trailer, worker is missing');\n        }\n        const msg = {\n            kind: 'setSifTrailer',\n            data: {\n                trailer\n            }\n        };\n        this.worker.postMessage(msg);\n    }\n    setupE2EEReceiver(track, remoteId, trackInfo) {\n        if (!track.receiver) {\n            return;\n        }\n        if (!(trackInfo === null || trackInfo === void 0 ? void 0 : trackInfo.mimeType) || trackInfo.mimeType === '') {\n            throw new TypeError('MimeType missing from trackInfo, cannot set up E2EE cryptor');\n        }\n        this.handleReceiver(track.receiver, track.mediaStreamID, remoteId, track.kind === 'video' ? mimeTypeToVideoCodecString(trackInfo.mimeType) : undefined);\n    }\n    setupE2EESender(track, sender) {\n        if (!(track instanceof LocalTrack) || !sender) {\n            if (!sender) livekitLogger.warn('early return because sender is not ready');\n            return;\n        }\n        this.handleSender(sender, track.mediaStreamID, undefined);\n    }\n    /**\n   * Handles the given {@code RTCRtpReceiver} by creating a {@code TransformStream} which will inject\n   * a frame decoder.\n   *\n   */ handleReceiver(receiver, trackId, participantIdentity, codec) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.worker) {\n                return;\n            }\n            if (isScriptTransformSupported()) {\n                const options = {\n                    kind: 'decode',\n                    participantIdentity,\n                    trackId,\n                    codec\n                };\n                // @ts-ignore\n                receiver.transform = new RTCRtpScriptTransform(this.worker, options);\n            } else {\n                if (E2EE_FLAG in receiver && codec) {\n                    // only update codec\n                    const msg = {\n                        kind: 'updateCodec',\n                        data: {\n                            trackId,\n                            codec,\n                            participantIdentity: participantIdentity\n                        }\n                    };\n                    this.worker.postMessage(msg);\n                    return;\n                }\n                // @ts-ignore\n                let writable = receiver.writableStream;\n                // @ts-ignore\n                let readable = receiver.readableStream;\n                if (!writable || !readable) {\n                    // @ts-ignore\n                    const receiverStreams = receiver.createEncodedStreams();\n                    // @ts-ignore\n                    receiver.writableStream = receiverStreams.writable;\n                    writable = receiverStreams.writable;\n                    // @ts-ignore\n                    receiver.readableStream = receiverStreams.readable;\n                    readable = receiverStreams.readable;\n                }\n                const msg = {\n                    kind: 'decode',\n                    data: {\n                        readableStream: readable,\n                        writableStream: writable,\n                        trackId: trackId,\n                        codec,\n                        participantIdentity: participantIdentity\n                    }\n                };\n                this.worker.postMessage(msg, [\n                    readable,\n                    writable\n                ]);\n            }\n            // @ts-ignore\n            receiver[E2EE_FLAG] = true;\n        });\n    }\n    /**\n   * Handles the given {@code RTCRtpSender} by creating a {@code TransformStream} which will inject\n   * a frame encoder.\n   *\n   */ handleSender(sender, trackId, codec) {\n        var _a;\n        if (E2EE_FLAG in sender || !this.worker) {\n            return;\n        }\n        if (!((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity) || this.room.localParticipant.identity === '') {\n            throw TypeError('local identity needs to be known in order to set up encrypted sender');\n        }\n        if (isScriptTransformSupported()) {\n            livekitLogger.info('initialize script transform');\n            const options = {\n                kind: 'encode',\n                participantIdentity: this.room.localParticipant.identity,\n                trackId,\n                codec\n            };\n            // @ts-ignore\n            sender.transform = new RTCRtpScriptTransform(this.worker, options);\n        } else {\n            livekitLogger.info('initialize encoded streams');\n            // @ts-ignore\n            const senderStreams = sender.createEncodedStreams();\n            const msg = {\n                kind: 'encode',\n                data: {\n                    readableStream: senderStreams.readable,\n                    writableStream: senderStreams.writable,\n                    codec,\n                    trackId,\n                    participantIdentity: this.room.localParticipant.identity\n                }\n            };\n            this.worker.postMessage(msg, [\n                senderStreams.readable,\n                senderStreams.writable\n            ]);\n        }\n        // @ts-ignore\n        sender[E2EE_FLAG] = true;\n    }\n}\nvar QueueTaskStatus;\n(function(QueueTaskStatus) {\n    QueueTaskStatus[QueueTaskStatus[\"WAITING\"] = 0] = \"WAITING\";\n    QueueTaskStatus[QueueTaskStatus[\"RUNNING\"] = 1] = \"RUNNING\";\n    QueueTaskStatus[QueueTaskStatus[\"COMPLETED\"] = 2] = \"COMPLETED\";\n})(QueueTaskStatus || (QueueTaskStatus = {}));\nclass AsyncQueue {\n    constructor(){\n        this.pendingTasks = new Map();\n        this.taskMutex = new Mutex();\n        this.nextTaskIndex = 0;\n    }\n    run(task) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const taskInfo = {\n                id: this.nextTaskIndex++,\n                enqueuedAt: Date.now(),\n                status: QueueTaskStatus.WAITING\n            };\n            this.pendingTasks.set(taskInfo.id, taskInfo);\n            const unlock = yield this.taskMutex.lock();\n            try {\n                taskInfo.executedAt = Date.now();\n                taskInfo.status = QueueTaskStatus.RUNNING;\n                return yield task();\n            } finally{\n                taskInfo.status = QueueTaskStatus.COMPLETED;\n                this.pendingTasks.delete(taskInfo.id);\n                unlock();\n            }\n        });\n    }\n    flush() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.run(()=>__awaiter(this, void 0, void 0, function*() {}));\n        });\n    }\n    snapshot() {\n        return Array.from(this.pendingTasks.values());\n    }\n}\nconst passThroughQueueSignals = [\n    'syncState',\n    'trickle',\n    'offer',\n    'answer',\n    'simulate',\n    'leave'\n];\nfunction canPassThroughQueue(req) {\n    const canPass = passThroughQueueSignals.indexOf(req.case) >= 0;\n    livekitLogger.trace('request allowed to bypass queue:', {\n        canPass,\n        req\n    });\n    return canPass;\n}\nvar SignalConnectionState;\n(function(SignalConnectionState) {\n    SignalConnectionState[SignalConnectionState[\"CONNECTING\"] = 0] = \"CONNECTING\";\n    SignalConnectionState[SignalConnectionState[\"CONNECTED\"] = 1] = \"CONNECTED\";\n    SignalConnectionState[SignalConnectionState[\"RECONNECTING\"] = 2] = \"RECONNECTING\";\n    SignalConnectionState[SignalConnectionState[\"DISCONNECTING\"] = 3] = \"DISCONNECTING\";\n    SignalConnectionState[SignalConnectionState[\"DISCONNECTED\"] = 4] = \"DISCONNECTED\";\n})(SignalConnectionState || (SignalConnectionState = {}));\n/** @internal */ class SignalClient {\n    get currentState() {\n        return this.state;\n    }\n    get isDisconnected() {\n        return this.state === SignalConnectionState.DISCONNECTING || this.state === SignalConnectionState.DISCONNECTED;\n    }\n    get isEstablishingConnection() {\n        return this.state === SignalConnectionState.CONNECTING || this.state === SignalConnectionState.RECONNECTING;\n    }\n    constructor(){\n        let useJSON = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n        let loggerOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var _a;\n        /** signal rtt in milliseconds */ this.rtt = 0;\n        this.state = SignalConnectionState.DISCONNECTED;\n        this.log = livekitLogger;\n        /** @internal */ this.resetCallbacks = ()=>{\n            this.onAnswer = undefined;\n            this.onLeave = undefined;\n            this.onLocalTrackPublished = undefined;\n            this.onLocalTrackUnpublished = undefined;\n            this.onNegotiateRequested = undefined;\n            this.onOffer = undefined;\n            this.onRemoteMuteChanged = undefined;\n            this.onSubscribedQualityUpdate = undefined;\n            this.onTokenRefresh = undefined;\n            this.onTrickle = undefined;\n            this.onClose = undefined;\n        };\n        this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Signal);\n        this.loggerContextCb = loggerOptions.loggerContextCb;\n        this.useJSON = useJSON;\n        this.requestQueue = new AsyncQueue();\n        this.queuedRequests = [];\n        this.closingLock = new Mutex();\n        this.connectionLock = new Mutex();\n        this.state = SignalConnectionState.DISCONNECTED;\n    }\n    get logContext() {\n        var _a, _b;\n        return (_b = (_a = this.loggerContextCb) === null || _a === void 0 ? void 0 : _a.call(this)) !== null && _b !== void 0 ? _b : {};\n    }\n    join(url, token, opts, abortSignal) {\n        return __awaiter(this, void 0, void 0, function*() {\n            // during a full reconnect, we'd want to start the sequence even if currently\n            // connected\n            this.state = SignalConnectionState.CONNECTING;\n            this.options = opts;\n            const res = yield this.connect(url, token, opts, abortSignal);\n            return res;\n        });\n    }\n    reconnect(url, token, sid, reason) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.options) {\n                this.log.warn('attempted to reconnect without signal options being set, ignoring', this.logContext);\n                return;\n            }\n            this.state = SignalConnectionState.RECONNECTING;\n            // clear ping interval and restart it once reconnected\n            this.clearPingInterval();\n            const res = yield this.connect(url, token, Object.assign(Object.assign({}, this.options), {\n                reconnect: true,\n                sid,\n                reconnectReason: reason\n            }));\n            return res;\n        });\n    }\n    connect(url, token, opts, abortSignal) {\n        this.connectOptions = opts;\n        url = toWebsocketUrl(url);\n        // strip trailing slash\n        url = url.replace(/\\/$/, '');\n        url += '/rtc';\n        const clientInfo = getClientInfo();\n        const params = createConnectionParams(token, clientInfo, opts);\n        return new Promise((resolve, reject)=>__awaiter(this, void 0, void 0, function*() {\n                const unlock = yield this.connectionLock.lock();\n                try {\n                    const abortHandler = ()=>__awaiter(this, void 0, void 0, function*() {\n                            this.close();\n                            clearTimeout(wsTimeout);\n                            reject(new ConnectionError('room connection has been cancelled (signal)'));\n                        });\n                    const wsTimeout = setTimeout(()=>{\n                        this.close();\n                        reject(new ConnectionError('room connection has timed out (signal)'));\n                    }, opts.websocketTimeout);\n                    if (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted) {\n                        abortHandler();\n                    }\n                    abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.addEventListener('abort', abortHandler);\n                    this.log.debug(\"connecting to \".concat(url + params), this.logContext);\n                    if (this.ws) {\n                        yield this.close(false);\n                    }\n                    this.ws = new WebSocket(url + params);\n                    this.ws.binaryType = 'arraybuffer';\n                    this.ws.onopen = ()=>{\n                        clearTimeout(wsTimeout);\n                    };\n                    this.ws.onerror = (ev)=>__awaiter(this, void 0, void 0, function*() {\n                            if (this.state !== SignalConnectionState.CONNECTED) {\n                                clearTimeout(wsTimeout);\n                                try {\n                                    const resp = yield fetch(\"http\".concat(url.substring(2), \"/validate\").concat(params));\n                                    if (resp.status.toFixed(0).startsWith('4')) {\n                                        const msg = yield resp.text();\n                                        reject(new ConnectionError(msg, 0 /* ConnectionErrorReason.NotAllowed */ , resp.status));\n                                    } else {\n                                        reject(new ConnectionError('Internal error', 2 /* ConnectionErrorReason.InternalError */ , resp.status));\n                                    }\n                                } catch (e) {\n                                    reject(new ConnectionError('server was not reachable', 1 /* ConnectionErrorReason.ServerUnreachable */ ));\n                                }\n                                return;\n                            }\n                            // other errors, handle\n                            this.handleWSError(ev);\n                        });\n                    this.ws.onmessage = (ev)=>__awaiter(this, void 0, void 0, function*() {\n                            var _a, _b, _c, _d;\n                            // not considered connected until JoinResponse is received\n                            let resp;\n                            if (typeof ev.data === 'string') {\n                                const json = JSON.parse(ev.data);\n                                resp = SignalResponse.fromJson(json);\n                            } else if (ev.data instanceof ArrayBuffer) {\n                                resp = SignalResponse.fromBinary(new Uint8Array(ev.data));\n                            } else {\n                                this.log.error(\"could not decode websocket message: \".concat(typeof ev.data), this.logContext);\n                                return;\n                            }\n                            if (this.state !== SignalConnectionState.CONNECTED) {\n                                let shouldProcessMessage = false;\n                                // handle join message only\n                                if (((_a = resp.message) === null || _a === void 0 ? void 0 : _a.case) === 'join') {\n                                    this.state = SignalConnectionState.CONNECTED;\n                                    abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.removeEventListener('abort', abortHandler);\n                                    this.pingTimeoutDuration = resp.message.value.pingTimeout;\n                                    this.pingIntervalDuration = resp.message.value.pingInterval;\n                                    if (this.pingTimeoutDuration && this.pingTimeoutDuration > 0) {\n                                        this.log.debug('ping config', Object.assign(Object.assign({}, this.logContext), {\n                                            timeout: this.pingTimeoutDuration,\n                                            interval: this.pingIntervalDuration\n                                        }));\n                                        this.startPingInterval();\n                                    }\n                                    resolve(resp.message.value);\n                                } else if (this.state === SignalConnectionState.RECONNECTING && resp.message.case !== 'leave') {\n                                    // in reconnecting, any message received means signal reconnected\n                                    this.state = SignalConnectionState.CONNECTED;\n                                    abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.removeEventListener('abort', abortHandler);\n                                    this.startPingInterval();\n                                    if (((_b = resp.message) === null || _b === void 0 ? void 0 : _b.case) === 'reconnect') {\n                                        resolve((_c = resp.message) === null || _c === void 0 ? void 0 : _c.value);\n                                    } else {\n                                        resolve();\n                                        shouldProcessMessage = true;\n                                    }\n                                } else if (this.isEstablishingConnection && resp.message.case === 'leave') {\n                                    reject(new ConnectionError('Received leave request while trying to (re)connect', 4 /* ConnectionErrorReason.LeaveRequest */ ));\n                                } else if (!opts.reconnect) {\n                                    // non-reconnect case, should receive join response first\n                                    reject(new ConnectionError(\"did not receive join response, got \".concat((_d = resp.message) === null || _d === void 0 ? void 0 : _d.case, \" instead\")));\n                                }\n                                if (!shouldProcessMessage) {\n                                    return;\n                                }\n                            }\n                            if (this.signalLatency) {\n                                yield sleep(this.signalLatency);\n                            }\n                            this.handleSignalResponse(resp);\n                        });\n                    this.ws.onclose = (ev)=>{\n                        if (this.isEstablishingConnection) {\n                            reject(new ConnectionError('Websocket got closed during a (re)connection attempt'));\n                        }\n                        this.log.warn(\"websocket closed\", Object.assign(Object.assign({}, this.logContext), {\n                            reason: ev.reason,\n                            state: this.state\n                        }));\n                        this.handleOnClose(ev.reason);\n                    };\n                } finally{\n                    unlock();\n                }\n            }));\n    }\n    close() {\n        let updateState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.closingLock.lock();\n            try {\n                if (updateState) {\n                    this.state = SignalConnectionState.DISCONNECTING;\n                }\n                if (this.ws) {\n                    this.ws.onmessage = null;\n                    this.ws.onopen = null;\n                    this.ws.onclose = null;\n                    // calling `ws.close()` only starts the closing handshake (CLOSING state), prefer to wait until state is actually CLOSED\n                    const closePromise = new Promise((resolve)=>{\n                        if (this.ws) {\n                            this.ws.onclose = ()=>{\n                                resolve();\n                            };\n                        } else {\n                            resolve();\n                        }\n                    });\n                    if (this.ws.readyState < this.ws.CLOSING) {\n                        this.ws.close();\n                        // 250ms grace period for ws to close gracefully\n                        yield Promise.race([\n                            closePromise,\n                            sleep(250)\n                        ]);\n                    }\n                    this.ws = undefined;\n                }\n            } finally{\n                if (updateState) {\n                    this.state = SignalConnectionState.DISCONNECTED;\n                }\n                this.clearPingInterval();\n                unlock();\n            }\n        });\n    }\n    // initial offer after joining\n    sendOffer(offer) {\n        this.log.debug('sending offer', Object.assign(Object.assign({}, this.logContext), {\n            offerSdp: offer.sdp\n        }));\n        this.sendRequest({\n            case: 'offer',\n            value: toProtoSessionDescription(offer)\n        });\n    }\n    // answer a server-initiated offer\n    sendAnswer(answer) {\n        this.log.debug('sending answer', Object.assign(Object.assign({}, this.logContext), {\n            answerSdp: answer.sdp\n        }));\n        return this.sendRequest({\n            case: 'answer',\n            value: toProtoSessionDescription(answer)\n        });\n    }\n    sendIceCandidate(candidate, target) {\n        this.log.trace('sending ice candidate', Object.assign(Object.assign({}, this.logContext), {\n            candidate\n        }));\n        return this.sendRequest({\n            case: 'trickle',\n            value: new TrickleRequest({\n                candidateInit: JSON.stringify(candidate),\n                target\n            })\n        });\n    }\n    sendMuteTrack(trackSid, muted) {\n        return this.sendRequest({\n            case: 'mute',\n            value: new MuteTrackRequest({\n                sid: trackSid,\n                muted\n            })\n        });\n    }\n    sendAddTrack(req) {\n        return this.sendRequest({\n            case: 'addTrack',\n            value: req\n        });\n    }\n    sendUpdateLocalMetadata(metadata, name) {\n        return this.sendRequest({\n            case: 'updateMetadata',\n            value: new UpdateParticipantMetadata({\n                metadata,\n                name\n            })\n        });\n    }\n    sendUpdateTrackSettings(settings) {\n        this.sendRequest({\n            case: 'trackSetting',\n            value: settings\n        });\n    }\n    sendUpdateSubscription(sub) {\n        return this.sendRequest({\n            case: 'subscription',\n            value: sub\n        });\n    }\n    sendSyncState(sync) {\n        return this.sendRequest({\n            case: 'syncState',\n            value: sync\n        });\n    }\n    sendUpdateVideoLayers(trackSid, layers) {\n        return this.sendRequest({\n            case: 'updateLayers',\n            value: new UpdateVideoLayers({\n                trackSid,\n                layers\n            })\n        });\n    }\n    sendUpdateSubscriptionPermissions(allParticipants, trackPermissions) {\n        return this.sendRequest({\n            case: 'subscriptionPermission',\n            value: new SubscriptionPermission({\n                allParticipants,\n                trackPermissions\n            })\n        });\n    }\n    sendSimulateScenario(scenario) {\n        return this.sendRequest({\n            case: 'simulate',\n            value: scenario\n        });\n    }\n    sendPing() {\n        /** send both of ping and pingReq for compatibility to old and new server */ return Promise.all([\n            this.sendRequest({\n                case: 'ping',\n                value: protoInt64.parse(Date.now())\n            }),\n            this.sendRequest({\n                case: 'pingReq',\n                value: new Ping({\n                    timestamp: protoInt64.parse(Date.now()),\n                    rtt: protoInt64.parse(this.rtt)\n                })\n            })\n        ]);\n    }\n    sendLeave() {\n        return this.sendRequest({\n            case: 'leave',\n            value: new LeaveRequest({\n                canReconnect: false,\n                reason: DisconnectReason.CLIENT_INITIATED\n            })\n        });\n    }\n    sendRequest(message) {\n        let fromQueue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        return __awaiter(this, void 0, void 0, function*() {\n            // capture all requests while reconnecting and put them in a queue\n            // unless the request originates from the queue, then don't enqueue again\n            const canQueue = !fromQueue && !canPassThroughQueue(message);\n            if (canQueue && this.state === SignalConnectionState.RECONNECTING) {\n                this.queuedRequests.push(()=>__awaiter(this, void 0, void 0, function*() {\n                        yield this.sendRequest(message, true);\n                    }));\n                return;\n            }\n            // make sure previously queued requests are being sent first\n            if (!fromQueue) {\n                yield this.requestQueue.flush();\n            }\n            if (this.signalLatency) {\n                yield sleep(this.signalLatency);\n            }\n            if (!this.ws || this.ws.readyState !== this.ws.OPEN) {\n                this.log.error(\"cannot send signal request before connected, type: \".concat(message === null || message === void 0 ? void 0 : message.case), this.logContext);\n                return;\n            }\n            const req = new SignalRequest({\n                message\n            });\n            try {\n                if (this.useJSON) {\n                    this.ws.send(req.toJsonString());\n                } else {\n                    this.ws.send(req.toBinary());\n                }\n            } catch (e) {\n                this.log.error('error sending signal message', Object.assign(Object.assign({}, this.logContext), {\n                    error: e\n                }));\n            }\n        });\n    }\n    handleSignalResponse(res) {\n        var _a, _b;\n        const msg = res.message;\n        if (msg == undefined) {\n            this.log.debug('received unsupported message', this.logContext);\n            return;\n        }\n        let pingHandled = false;\n        if (msg.case === 'answer') {\n            const sd = fromProtoSessionDescription(msg.value);\n            if (this.onAnswer) {\n                this.onAnswer(sd);\n            }\n        } else if (msg.case === 'offer') {\n            const sd = fromProtoSessionDescription(msg.value);\n            if (this.onOffer) {\n                this.onOffer(sd);\n            }\n        } else if (msg.case === 'trickle') {\n            const candidate = JSON.parse(msg.value.candidateInit);\n            if (this.onTrickle) {\n                this.onTrickle(candidate, msg.value.target);\n            }\n        } else if (msg.case === 'update') {\n            if (this.onParticipantUpdate) {\n                this.onParticipantUpdate((_a = msg.value.participants) !== null && _a !== void 0 ? _a : []);\n            }\n        } else if (msg.case === 'trackPublished') {\n            if (this.onLocalTrackPublished) {\n                this.onLocalTrackPublished(msg.value);\n            }\n        } else if (msg.case === 'speakersChanged') {\n            if (this.onSpeakersChanged) {\n                this.onSpeakersChanged((_b = msg.value.speakers) !== null && _b !== void 0 ? _b : []);\n            }\n        } else if (msg.case === 'leave') {\n            if (this.onLeave) {\n                this.onLeave(msg.value);\n            }\n        } else if (msg.case === 'mute') {\n            if (this.onRemoteMuteChanged) {\n                this.onRemoteMuteChanged(msg.value.sid, msg.value.muted);\n            }\n        } else if (msg.case === 'roomUpdate') {\n            if (this.onRoomUpdate && msg.value.room) {\n                this.onRoomUpdate(msg.value.room);\n            }\n        } else if (msg.case === 'connectionQuality') {\n            if (this.onConnectionQuality) {\n                this.onConnectionQuality(msg.value);\n            }\n        } else if (msg.case === 'streamStateUpdate') {\n            if (this.onStreamStateUpdate) {\n                this.onStreamStateUpdate(msg.value);\n            }\n        } else if (msg.case === 'subscribedQualityUpdate') {\n            if (this.onSubscribedQualityUpdate) {\n                this.onSubscribedQualityUpdate(msg.value);\n            }\n        } else if (msg.case === 'subscriptionPermissionUpdate') {\n            if (this.onSubscriptionPermissionUpdate) {\n                this.onSubscriptionPermissionUpdate(msg.value);\n            }\n        } else if (msg.case === 'refreshToken') {\n            if (this.onTokenRefresh) {\n                this.onTokenRefresh(msg.value);\n            }\n        } else if (msg.case === 'trackUnpublished') {\n            if (this.onLocalTrackUnpublished) {\n                this.onLocalTrackUnpublished(msg.value);\n            }\n        } else if (msg.case === 'subscriptionResponse') {\n            if (this.onSubscriptionError) {\n                this.onSubscriptionError(msg.value);\n            }\n        } else if (msg.case === 'pong') ;\n        else if (msg.case === 'pongResp') {\n            this.rtt = Date.now() - Number.parseInt(msg.value.lastPingTimestamp.toString());\n            this.resetPingTimeout();\n            pingHandled = true;\n        } else {\n            this.log.debug('unsupported message', Object.assign(Object.assign({}, this.logContext), {\n                msgCase: msg.case\n            }));\n        }\n        if (!pingHandled) {\n            this.resetPingTimeout();\n        }\n    }\n    setReconnected() {\n        while(this.queuedRequests.length > 0){\n            const req = this.queuedRequests.shift();\n            if (req) {\n                this.requestQueue.run(req);\n            }\n        }\n    }\n    handleOnClose(reason) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.state === SignalConnectionState.DISCONNECTED) return;\n            const onCloseCallback = this.onClose;\n            yield this.close();\n            this.log.debug(\"websocket connection closed: \".concat(reason), Object.assign(Object.assign({}, this.logContext), {\n                reason\n            }));\n            if (onCloseCallback) {\n                onCloseCallback(reason);\n            }\n        });\n    }\n    handleWSError(ev) {\n        this.log.error('websocket error', Object.assign(Object.assign({}, this.logContext), {\n            error: ev\n        }));\n    }\n    /**\n   * Resets the ping timeout and starts a new timeout.\n   * Call this after receiving a pong message\n   */ resetPingTimeout() {\n        this.clearPingTimeout();\n        if (!this.pingTimeoutDuration) {\n            this.log.warn('ping timeout duration not set', this.logContext);\n            return;\n        }\n        this.pingTimeout = CriticalTimers.setTimeout(()=>{\n            this.log.warn(\"ping timeout triggered. last pong received at: \".concat(new Date(Date.now() - this.pingTimeoutDuration * 1000).toUTCString()), this.logContext);\n            this.handleOnClose('ping timeout');\n        }, this.pingTimeoutDuration * 1000);\n    }\n    /**\n   * Clears ping timeout (does not start a new timeout)\n   */ clearPingTimeout() {\n        if (this.pingTimeout) {\n            CriticalTimers.clearTimeout(this.pingTimeout);\n        }\n    }\n    startPingInterval() {\n        this.clearPingInterval();\n        this.resetPingTimeout();\n        if (!this.pingIntervalDuration) {\n            this.log.warn('ping interval duration not set', this.logContext);\n            return;\n        }\n        this.log.debug('start ping interval', this.logContext);\n        this.pingInterval = CriticalTimers.setInterval(()=>{\n            this.sendPing();\n        }, this.pingIntervalDuration * 1000);\n    }\n    clearPingInterval() {\n        this.log.debug('clearing ping interval', this.logContext);\n        this.clearPingTimeout();\n        if (this.pingInterval) {\n            CriticalTimers.clearInterval(this.pingInterval);\n        }\n    }\n}\nfunction fromProtoSessionDescription(sd) {\n    const rsd = {\n        type: 'offer',\n        sdp: sd.sdp\n    };\n    switch(sd.type){\n        case 'answer':\n        case 'offer':\n        case 'pranswer':\n        case 'rollback':\n            rsd.type = sd.type;\n            break;\n    }\n    return rsd;\n}\nfunction toProtoSessionDescription(rsd) {\n    const sd = new SessionDescription({\n        sdp: rsd.sdp,\n        type: rsd.type\n    });\n    return sd;\n}\nfunction createConnectionParams(token, info, opts) {\n    var _a;\n    const params = new URLSearchParams();\n    params.set('access_token', token);\n    // opts\n    if (opts.reconnect) {\n        params.set('reconnect', '1');\n        if (opts.sid) {\n            params.set('sid', opts.sid);\n        }\n    }\n    params.set('auto_subscribe', opts.autoSubscribe ? '1' : '0');\n    // ClientInfo\n    params.set('sdk', isReactNative() ? 'reactnative' : 'js');\n    params.set('version', info.version);\n    params.set('protocol', info.protocol.toString());\n    if (info.deviceModel) {\n        params.set('device_model', info.deviceModel);\n    }\n    if (info.os) {\n        params.set('os', info.os);\n    }\n    if (info.osVersion) {\n        params.set('os_version', info.osVersion);\n    }\n    if (info.browser) {\n        params.set('browser', info.browser);\n    }\n    if (info.browserVersion) {\n        params.set('browser_version', info.browserVersion);\n    }\n    if (opts.publishOnly !== undefined) {\n        params.set('publish', opts.publishOnly);\n    }\n    if (opts.adaptiveStream) {\n        params.set('adaptive_stream', '1');\n    }\n    if (opts.reconnectReason) {\n        params.set('reconnect_reason', opts.reconnectReason.toString());\n    }\n    // @ts-ignore\n    if ((_a = navigator.connection) === null || _a === void 0 ? void 0 : _a.type) {\n        // @ts-ignore\n        params.set('network', navigator.connection.type);\n    }\n    return \"?\".concat(params.toString());\n}\nvar parser$1 = {};\nvar grammar$2 = {\n    exports: {}\n};\nvar grammar$1 = grammar$2.exports = {\n    v: [\n        {\n            name: 'version',\n            reg: /^(\\d*)$/\n        }\n    ],\n    o: [\n        {\n            // o=- 20518 0 IN IP4 203.0.113.1\n            // NB: sessionId will be a String in most cases because it is huge\n            name: 'origin',\n            reg: /^(\\S*) (\\d*) (\\d*) (\\S*) IP(\\d) (\\S*)/,\n            names: [\n                'username',\n                'sessionId',\n                'sessionVersion',\n                'netType',\n                'ipVer',\n                'address'\n            ],\n            format: '%s %s %d %s IP%d %s'\n        }\n    ],\n    // default parsing of these only (though some of these feel outdated)\n    s: [\n        {\n            name: 'name'\n        }\n    ],\n    i: [\n        {\n            name: 'description'\n        }\n    ],\n    u: [\n        {\n            name: 'uri'\n        }\n    ],\n    e: [\n        {\n            name: 'email'\n        }\n    ],\n    p: [\n        {\n            name: 'phone'\n        }\n    ],\n    z: [\n        {\n            name: 'timezones'\n        }\n    ],\n    // TODO: this one can actually be parsed properly...\n    r: [\n        {\n            name: 'repeats'\n        }\n    ],\n    // TODO: this one can also be parsed properly\n    // k: [{}], // outdated thing ignored\n    t: [\n        {\n            // t=0 0\n            name: 'timing',\n            reg: /^(\\d*) (\\d*)/,\n            names: [\n                'start',\n                'stop'\n            ],\n            format: '%d %d'\n        }\n    ],\n    c: [\n        {\n            // c=IN IP4 10.47.197.26\n            name: 'connection',\n            reg: /^IN IP(\\d) (\\S*)/,\n            names: [\n                'version',\n                'ip'\n            ],\n            format: 'IN IP%d %s'\n        }\n    ],\n    b: [\n        {\n            // b=AS:4000\n            push: 'bandwidth',\n            reg: /^(TIAS|AS|CT|RR|RS):(\\d*)/,\n            names: [\n                'type',\n                'limit'\n            ],\n            format: '%s:%s'\n        }\n    ],\n    m: [\n        {\n            // m=video 51744 RTP/AVP 126 97 98 34 31\n            // NB: special - pushes to session\n            // TODO: rtp/fmtp should be filtered by the payloads found here?\n            reg: /^(\\w*) (\\d*) ([\\w/]*)(?: (.*))?/,\n            names: [\n                'type',\n                'port',\n                'protocol',\n                'payloads'\n            ],\n            format: '%s %d %s %s'\n        }\n    ],\n    a: [\n        {\n            // a=rtpmap:110 opus/48000/2\n            push: 'rtp',\n            reg: /^rtpmap:(\\d*) ([\\w\\-.]*)(?:\\s*\\/(\\d*)(?:\\s*\\/(\\S*))?)?/,\n            names: [\n                'payload',\n                'codec',\n                'rate',\n                'encoding'\n            ],\n            format: function(o) {\n                return o.encoding ? 'rtpmap:%d %s/%s/%s' : o.rate ? 'rtpmap:%d %s/%s' : 'rtpmap:%d %s';\n            }\n        },\n        {\n            // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000\n            // a=fmtp:111 minptime=10; useinbandfec=1\n            push: 'fmtp',\n            reg: /^fmtp:(\\d*) ([\\S| ]*)/,\n            names: [\n                'payload',\n                'config'\n            ],\n            format: 'fmtp:%d %s'\n        },\n        {\n            // a=control:streamid=0\n            name: 'control',\n            reg: /^control:(.*)/,\n            format: 'control:%s'\n        },\n        {\n            // a=rtcp:65179 IN IP4 193.84.77.194\n            name: 'rtcp',\n            reg: /^rtcp:(\\d*)(?: (\\S*) IP(\\d) (\\S*))?/,\n            names: [\n                'port',\n                'netType',\n                'ipVer',\n                'address'\n            ],\n            format: function(o) {\n                return o.address != null ? 'rtcp:%d %s IP%d %s' : 'rtcp:%d';\n            }\n        },\n        {\n            // a=rtcp-fb:98 trr-int 100\n            push: 'rtcpFbTrrInt',\n            reg: /^rtcp-fb:(\\*|\\d*) trr-int (\\d*)/,\n            names: [\n                'payload',\n                'value'\n            ],\n            format: 'rtcp-fb:%s trr-int %d'\n        },\n        {\n            // a=rtcp-fb:98 nack rpsi\n            push: 'rtcpFb',\n            reg: /^rtcp-fb:(\\*|\\d*) ([\\w-_]*)(?: ([\\w-_]*))?/,\n            names: [\n                'payload',\n                'type',\n                'subtype'\n            ],\n            format: function(o) {\n                return o.subtype != null ? 'rtcp-fb:%s %s %s' : 'rtcp-fb:%s %s';\n            }\n        },\n        {\n            // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n            // a=extmap:1/recvonly URI-gps-string\n            // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24\n            push: 'ext',\n            reg: /^extmap:(\\d+)(?:\\/(\\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\\S*)(?: (\\S*))?/,\n            names: [\n                'value',\n                'direction',\n                'encrypt-uri',\n                'uri',\n                'config'\n            ],\n            format: function(o) {\n                return 'extmap:%d' + (o.direction ? '/%s' : '%v') + (o['encrypt-uri'] ? ' %s' : '%v') + ' %s' + (o.config ? ' %s' : '');\n            }\n        },\n        {\n            // a=extmap-allow-mixed\n            name: 'extmapAllowMixed',\n            reg: /^(extmap-allow-mixed)/\n        },\n        {\n            // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32\n            push: 'crypto',\n            reg: /^crypto:(\\d*) ([\\w_]*) (\\S*)(?: (\\S*))?/,\n            names: [\n                'id',\n                'suite',\n                'config',\n                'sessionConfig'\n            ],\n            format: function(o) {\n                return o.sessionConfig != null ? 'crypto:%d %s %s %s' : 'crypto:%d %s %s';\n            }\n        },\n        {\n            // a=setup:actpass\n            name: 'setup',\n            reg: /^setup:(\\w*)/,\n            format: 'setup:%s'\n        },\n        {\n            // a=connection:new\n            name: 'connectionType',\n            reg: /^connection:(new|existing)/,\n            format: 'connection:%s'\n        },\n        {\n            // a=mid:1\n            name: 'mid',\n            reg: /^mid:([^\\s]*)/,\n            format: 'mid:%s'\n        },\n        {\n            // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a\n            name: 'msid',\n            reg: /^msid:(.*)/,\n            format: 'msid:%s'\n        },\n        {\n            // a=ptime:20\n            name: 'ptime',\n            reg: /^ptime:(\\d*(?:\\.\\d*)*)/,\n            format: 'ptime:%d'\n        },\n        {\n            // a=maxptime:60\n            name: 'maxptime',\n            reg: /^maxptime:(\\d*(?:\\.\\d*)*)/,\n            format: 'maxptime:%d'\n        },\n        {\n            // a=sendrecv\n            name: 'direction',\n            reg: /^(sendrecv|recvonly|sendonly|inactive)/\n        },\n        {\n            // a=ice-lite\n            name: 'icelite',\n            reg: /^(ice-lite)/\n        },\n        {\n            // a=ice-ufrag:F7gI\n            name: 'iceUfrag',\n            reg: /^ice-ufrag:(\\S*)/,\n            format: 'ice-ufrag:%s'\n        },\n        {\n            // a=ice-pwd:x9cml/YzichV2+XlhiMu8g\n            name: 'icePwd',\n            reg: /^ice-pwd:(\\S*)/,\n            format: 'ice-pwd:%s'\n        },\n        {\n            // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33\n            name: 'fingerprint',\n            reg: /^fingerprint:(\\S*) (\\S*)/,\n            names: [\n                'type',\n                'hash'\n            ],\n            format: 'fingerprint:%s %s'\n        },\n        {\n            // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host\n            // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10\n            // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10\n            // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10\n            // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10\n            push: 'candidates',\n            reg: /^candidate:(\\S*) (\\d*) (\\S*) (\\d*) (\\S*) (\\d*) typ (\\S*)(?: raddr (\\S*) rport (\\d*))?(?: tcptype (\\S*))?(?: generation (\\d*))?(?: network-id (\\d*))?(?: network-cost (\\d*))?/,\n            names: [\n                'foundation',\n                'component',\n                'transport',\n                'priority',\n                'ip',\n                'port',\n                'type',\n                'raddr',\n                'rport',\n                'tcptype',\n                'generation',\n                'network-id',\n                'network-cost'\n            ],\n            format: function(o) {\n                var str = 'candidate:%s %d %s %d %s %d typ %s';\n                str += o.raddr != null ? ' raddr %s rport %d' : '%v%v';\n                // NB: candidate has three optional chunks, so %void middles one if it's missing\n                str += o.tcptype != null ? ' tcptype %s' : '%v';\n                if (o.generation != null) {\n                    str += ' generation %d';\n                }\n                str += o['network-id'] != null ? ' network-id %d' : '%v';\n                str += o['network-cost'] != null ? ' network-cost %d' : '%v';\n                return str;\n            }\n        },\n        {\n            // a=end-of-candidates (keep after the candidates line for readability)\n            name: 'endOfCandidates',\n            reg: /^(end-of-candidates)/\n        },\n        {\n            // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...\n            name: 'remoteCandidates',\n            reg: /^remote-candidates:(.*)/,\n            format: 'remote-candidates:%s'\n        },\n        {\n            // a=ice-options:google-ice\n            name: 'iceOptions',\n            reg: /^ice-options:(\\S*)/,\n            format: 'ice-options:%s'\n        },\n        {\n            // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1\n            push: 'ssrcs',\n            reg: /^ssrc:(\\d*) ([\\w_-]*)(?::(.*))?/,\n            names: [\n                'id',\n                'attribute',\n                'value'\n            ],\n            format: function(o) {\n                var str = 'ssrc:%d';\n                if (o.attribute != null) {\n                    str += ' %s';\n                    if (o.value != null) {\n                        str += ':%s';\n                    }\n                }\n                return str;\n            }\n        },\n        {\n            // a=ssrc-group:FEC 1 2\n            // a=ssrc-group:FEC-FR 3004364195 1080772241\n            push: 'ssrcGroups',\n            // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E\n            reg: /^ssrc-group:([\\x21\\x23\\x24\\x25\\x26\\x27\\x2A\\x2B\\x2D\\x2E\\w]*) (.*)/,\n            names: [\n                'semantics',\n                'ssrcs'\n            ],\n            format: 'ssrc-group:%s %s'\n        },\n        {\n            // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV\n            name: 'msidSemantic',\n            reg: /^msid-semantic:\\s?(\\w*) (\\S*)/,\n            names: [\n                'semantic',\n                'token'\n            ],\n            format: 'msid-semantic: %s %s' // space after ':' is not accidental\n        },\n        {\n            // a=group:BUNDLE audio video\n            push: 'groups',\n            reg: /^group:(\\w*) (.*)/,\n            names: [\n                'type',\n                'mids'\n            ],\n            format: 'group:%s %s'\n        },\n        {\n            // a=rtcp-mux\n            name: 'rtcpMux',\n            reg: /^(rtcp-mux)/\n        },\n        {\n            // a=rtcp-rsize\n            name: 'rtcpRsize',\n            reg: /^(rtcp-rsize)/\n        },\n        {\n            // a=sctpmap:5000 webrtc-datachannel 1024\n            name: 'sctpmap',\n            reg: /^sctpmap:([\\w_/]*) (\\S*)(?: (\\S*))?/,\n            names: [\n                'sctpmapNumber',\n                'app',\n                'maxMessageSize'\n            ],\n            format: function(o) {\n                return o.maxMessageSize != null ? 'sctpmap:%s %s %s' : 'sctpmap:%s %s';\n            }\n        },\n        {\n            // a=x-google-flag:conference\n            name: 'xGoogleFlag',\n            reg: /^x-google-flag:([^\\s]*)/,\n            format: 'x-google-flag:%s'\n        },\n        {\n            // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0\n            push: 'rids',\n            reg: /^rid:([\\d\\w]+) (\\w+)(?: ([\\S| ]*))?/,\n            names: [\n                'id',\n                'direction',\n                'params'\n            ],\n            format: function(o) {\n                return o.params ? 'rid:%s %s %s' : 'rid:%s %s';\n            }\n        },\n        {\n            // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]\n            // a=imageattr:* send [x=800,y=640] recv *\n            // a=imageattr:100 recv [x=320,y=240]\n            push: 'imageattrs',\n            reg: new RegExp(// a=imageattr:97\n            '^imageattr:(\\\\d+|\\\\*)' + // send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320]\n            '[\\\\s\\\\t]+(send|recv)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*)' + // recv [x=330,y=250]\n            '(?:[\\\\s\\\\t]+(recv|send)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*))?'),\n            names: [\n                'pt',\n                'dir1',\n                'attrs1',\n                'dir2',\n                'attrs2'\n            ],\n            format: function(o) {\n                return 'imageattr:%s %s %s' + (o.dir2 ? ' %s %s' : '');\n            }\n        },\n        {\n            // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8\n            // a=simulcast:recv 1;4,5 send 6;7\n            name: 'simulcast',\n            reg: new RegExp(// a=simulcast:\n            '^simulcast:' + // send 1,2,3;~4,~5\n            '(send|recv) ([a-zA-Z0-9\\\\-_~;,]+)' + // space + recv 6;~7,~8\n            '(?:\\\\s?(send|recv) ([a-zA-Z0-9\\\\-_~;,]+))?' + // end\n            '$'),\n            names: [\n                'dir1',\n                'list1',\n                'dir2',\n                'list2'\n            ],\n            format: function(o) {\n                return 'simulcast:%s %s' + (o.dir2 ? ' %s %s' : '');\n            }\n        },\n        {\n            // old simulcast draft 03 (implemented by Firefox)\n            //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03\n            // a=simulcast: recv pt=97;98 send pt=97\n            // a=simulcast: send rid=5;6;7 paused=6,7\n            name: 'simulcast_03',\n            reg: /^simulcast:[\\s\\t]+([\\S+\\s\\t]+)$/,\n            names: [\n                'value'\n            ],\n            format: 'simulcast: %s'\n        },\n        {\n            // a=framerate:25\n            // a=framerate:29.97\n            name: 'framerate',\n            reg: /^framerate:(\\d+(?:$|\\.\\d+))/,\n            format: 'framerate:%s'\n        },\n        {\n            // RFC4570\n            // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5\n            name: 'sourceFilter',\n            reg: /^source-filter: *(excl|incl) (\\S*) (IP4|IP6|\\*) (\\S*) (.*)/,\n            names: [\n                'filterMode',\n                'netType',\n                'addressTypes',\n                'destAddress',\n                'srcList'\n            ],\n            format: 'source-filter: %s %s %s %s %s'\n        },\n        {\n            // a=bundle-only\n            name: 'bundleOnly',\n            reg: /^(bundle-only)/\n        },\n        {\n            // a=label:1\n            name: 'label',\n            reg: /^label:(.+)/,\n            format: 'label:%s'\n        },\n        {\n            // RFC version 26 for SCTP over DTLS\n            // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5\n            name: 'sctpPort',\n            reg: /^sctp-port:(\\d+)$/,\n            format: 'sctp-port:%s'\n        },\n        {\n            // RFC version 26 for SCTP over DTLS\n            // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6\n            name: 'maxMessageSize',\n            reg: /^max-message-size:(\\d+)$/,\n            format: 'max-message-size:%s'\n        },\n        {\n            // RFC7273\n            // a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37\n            push: 'tsRefClocks',\n            reg: /^ts-refclk:([^\\s=]*)(?:=(\\S*))?/,\n            names: [\n                'clksrc',\n                'clksrcExt'\n            ],\n            format: function(o) {\n                return 'ts-refclk:%s' + (o.clksrcExt != null ? '=%s' : '');\n            }\n        },\n        {\n            // RFC7273\n            // a=mediaclk:direct=963214424\n            name: 'mediaClk',\n            reg: /^mediaclk:(?:id=(\\S*))? *([^\\s=]*)(?:=(\\S*))?(?: *rate=(\\d+)\\/(\\d+))?/,\n            names: [\n                'id',\n                'mediaClockName',\n                'mediaClockValue',\n                'rateNumerator',\n                'rateDenominator'\n            ],\n            format: function(o) {\n                var str = 'mediaclk:';\n                str += o.id != null ? 'id=%s %s' : '%v%s';\n                str += o.mediaClockValue != null ? '=%s' : '';\n                str += o.rateNumerator != null ? ' rate=%s' : '';\n                str += o.rateDenominator != null ? '/%s' : '';\n                return str;\n            }\n        },\n        {\n            // a=keywds:keywords\n            name: 'keywords',\n            reg: /^keywds:(.+)$/,\n            format: 'keywds:%s'\n        },\n        {\n            // a=content:main\n            name: 'content',\n            reg: /^content:(.+)/,\n            format: 'content:%s'\n        },\n        // BFCP https://tools.ietf.org/html/rfc4583\n        {\n            // a=floorctrl:c-s\n            name: 'bfcpFloorCtrl',\n            reg: /^floorctrl:(c-only|s-only|c-s)/,\n            format: 'floorctrl:%s'\n        },\n        {\n            // a=confid:1\n            name: 'bfcpConfId',\n            reg: /^confid:(\\d+)/,\n            format: 'confid:%s'\n        },\n        {\n            // a=userid:1\n            name: 'bfcpUserId',\n            reg: /^userid:(\\d+)/,\n            format: 'userid:%s'\n        },\n        {\n            // a=floorid:1\n            name: 'bfcpFloorId',\n            reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,\n            names: [\n                'id',\n                'mStream'\n            ],\n            format: 'floorid:%s mstrm:%s'\n        },\n        {\n            // any a= that we don't understand is kept verbatim on media.invalid\n            push: 'invalid',\n            names: [\n                'value'\n            ]\n        }\n    ]\n};\n// set sensible defaults to avoid polluting the grammar with boring details\nObject.keys(grammar$1).forEach(function(key) {\n    var objs = grammar$1[key];\n    objs.forEach(function(obj) {\n        if (!obj.reg) {\n            obj.reg = /(.*)/;\n        }\n        if (!obj.format) {\n            obj.format = '%s';\n        }\n    });\n});\nvar grammarExports = grammar$2.exports;\n(function(exports) {\n    var toIntIfInt = function(v) {\n        return String(Number(v)) === v ? Number(v) : v;\n    };\n    var attachProperties = function(match, location, names, rawName) {\n        if (rawName && !names) {\n            location[rawName] = toIntIfInt(match[1]);\n        } else {\n            for(var i = 0; i < names.length; i += 1){\n                if (match[i + 1] != null) {\n                    location[names[i]] = toIntIfInt(match[i + 1]);\n                }\n            }\n        }\n    };\n    var parseReg = function(obj, location, content) {\n        var needsBlank = obj.name && obj.names;\n        if (obj.push && !location[obj.push]) {\n            location[obj.push] = [];\n        } else if (needsBlank && !location[obj.name]) {\n            location[obj.name] = {};\n        }\n        var keyLocation = obj.push ? {} : // blank object that will be pushed\n        needsBlank ? location[obj.name] : location; // otherwise, named location or root\n        attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);\n        if (obj.push) {\n            location[obj.push].push(keyLocation);\n        }\n    };\n    var grammar = grammarExports;\n    var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);\n    exports.parse = function(sdp) {\n        var session = {}, media = [], location = session; // points at where properties go under (one of the above)\n        // parse lines we understand\n        sdp.split(/(\\r\\n|\\r|\\n)/).filter(validLine).forEach(function(l) {\n            var type = l[0];\n            var content = l.slice(2);\n            if (type === 'm') {\n                media.push({\n                    rtp: [],\n                    fmtp: []\n                });\n                location = media[media.length - 1]; // point at latest media line\n            }\n            for(var j = 0; j < (grammar[type] || []).length; j += 1){\n                var obj = grammar[type][j];\n                if (obj.reg.test(content)) {\n                    return parseReg(obj, location, content);\n                }\n            }\n        });\n        session.media = media; // link it up\n        return session;\n    };\n    var paramReducer = function(acc, expr) {\n        var s = expr.split(/=(.+)/, 2);\n        if (s.length === 2) {\n            acc[s[0]] = toIntIfInt(s[1]);\n        } else if (s.length === 1 && expr.length > 1) {\n            acc[s[0]] = undefined;\n        }\n        return acc;\n    };\n    exports.parseParams = function(str) {\n        return str.split(/;\\s?/).reduce(paramReducer, {});\n    };\n    // For backward compatibility - alias will be removed in 3.0.0\n    exports.parseFmtpConfig = exports.parseParams;\n    exports.parsePayloads = function(str) {\n        return str.toString().split(' ').map(Number);\n    };\n    exports.parseRemoteCandidates = function(str) {\n        var candidates = [];\n        var parts = str.split(' ').map(toIntIfInt);\n        for(var i = 0; i < parts.length; i += 3){\n            candidates.push({\n                component: parts[i],\n                ip: parts[i + 1],\n                port: parts[i + 2]\n            });\n        }\n        return candidates;\n    };\n    exports.parseImageAttributes = function(str) {\n        return str.split(' ').map(function(item) {\n            return item.substring(1, item.length - 1).split(',').reduce(paramReducer, {});\n        });\n    };\n    exports.parseSimulcastStreamList = function(str) {\n        return str.split(';').map(function(stream) {\n            return stream.split(',').map(function(format) {\n                var scid, paused = false;\n                if (format[0] !== '~') {\n                    scid = toIntIfInt(format);\n                } else {\n                    scid = toIntIfInt(format.substring(1, format.length));\n                    paused = true;\n                }\n                return {\n                    scid: scid,\n                    paused: paused\n                };\n            });\n        });\n    };\n})(parser$1);\nvar grammar = grammarExports;\n// customized util.format - discards excess arguments and can void middle ones\nvar formatRegExp = /%[sdv%]/g;\nvar format = function(formatStr) {\n    var i = 1;\n    var args = arguments;\n    var len = args.length;\n    return formatStr.replace(formatRegExp, function(x) {\n        if (i >= len) {\n            return x; // missing argument\n        }\n        var arg = args[i];\n        i += 1;\n        switch(x){\n            case '%%':\n                return '%';\n            case '%s':\n                return String(arg);\n            case '%d':\n                return Number(arg);\n            case '%v':\n                return '';\n        }\n    });\n// NB: we discard excess arguments - they are typically undefined from makeLine\n};\nvar makeLine = function(type, obj, location) {\n    var str = obj.format instanceof Function ? obj.format(obj.push ? location : location[obj.name]) : obj.format;\n    var args = [\n        type + '=' + str\n    ];\n    if (obj.names) {\n        for(var i = 0; i < obj.names.length; i += 1){\n            var n = obj.names[i];\n            if (obj.name) {\n                args.push(location[obj.name][n]);\n            } else {\n                // for mLine and push attributes\n                args.push(location[obj.names[i]]);\n            }\n        }\n    } else {\n        args.push(location[obj.name]);\n    }\n    return format.apply(null, args);\n};\n// RFC specified order\n// TODO: extend this with all the rest\nvar defaultOuterOrder = [\n    'v',\n    'o',\n    's',\n    'i',\n    'u',\n    'e',\n    'p',\n    'c',\n    'b',\n    't',\n    'r',\n    'z',\n    'a'\n];\nvar defaultInnerOrder = [\n    'i',\n    'c',\n    'b',\n    'a'\n];\nvar writer$1 = function(session, opts) {\n    opts = opts || {};\n    // ensure certain properties exist\n    if (session.version == null) {\n        session.version = 0; // 'v=0' must be there (only defined version atm)\n    }\n    if (session.name == null) {\n        session.name = ' '; // 's= ' must be there if no meaningful name set\n    }\n    session.media.forEach(function(mLine) {\n        if (mLine.payloads == null) {\n            mLine.payloads = '';\n        }\n    });\n    var outerOrder = opts.outerOrder || defaultOuterOrder;\n    var innerOrder = opts.innerOrder || defaultInnerOrder;\n    var sdp = [];\n    // loop through outerOrder for matching properties on session\n    outerOrder.forEach(function(type) {\n        grammar[type].forEach(function(obj) {\n            if (obj.name in session && session[obj.name] != null) {\n                sdp.push(makeLine(type, obj, session));\n            } else if (obj.push in session && session[obj.push] != null) {\n                session[obj.push].forEach(function(el) {\n                    sdp.push(makeLine(type, obj, el));\n                });\n            }\n        });\n    });\n    // then for each media line, follow the innerOrder\n    session.media.forEach(function(mLine) {\n        sdp.push(makeLine('m', grammar.m[0], mLine));\n        innerOrder.forEach(function(type) {\n            grammar[type].forEach(function(obj) {\n                if (obj.name in mLine && mLine[obj.name] != null) {\n                    sdp.push(makeLine(type, obj, mLine));\n                } else if (obj.push in mLine && mLine[obj.push] != null) {\n                    mLine[obj.push].forEach(function(el) {\n                        sdp.push(makeLine(type, obj, el));\n                    });\n                }\n            });\n        });\n    });\n    return sdp.join('\\r\\n') + '\\r\\n';\n};\nvar parser = parser$1;\nvar writer = writer$1;\nvar write = writer;\nvar parse = parser.parse;\nparser.parseParams;\nparser.parseFmtpConfig; // Alias of parseParams().\nparser.parsePayloads;\nparser.parseRemoteCandidates;\nparser.parseImageAttributes;\nparser.parseSimulcastStreamList;\n/* The svc codec (av1/vp9) would use a very low bitrate at the begining and\nincrease slowly by the bandwidth estimator until it reach the target bitrate. The\nprocess commonly cost more than 10 seconds cause subscriber will get blur video at\nthe first few seconds. So we use a 70% of target bitrate here as the start bitrate to\neliminate this issue.\n*/ const startBitrateForSVC = 0.7;\nconst PCEvents = {\n    NegotiationStarted: 'negotiationStarted',\n    NegotiationComplete: 'negotiationComplete',\n    RTPVideoPayloadTypes: 'rtpVideoPayloadTypes'\n};\n/** @internal */ class PCTransport extends eventsExports.EventEmitter {\n    get pc() {\n        if (!this._pc) {\n            this._pc = this.createPC();\n        }\n        return this._pc;\n    }\n    constructor(config){\n        let mediaConstraints = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        let loggerOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var _a;\n        super();\n        this.log = livekitLogger;\n        this.pendingCandidates = [];\n        this.restartingIce = false;\n        this.renegotiate = false;\n        this.trackBitrates = [];\n        this.remoteStereoMids = [];\n        this.remoteNackMids = [];\n        // debounced negotiate interface\n        this.negotiate = r((onError)=>__awaiter(this, void 0, void 0, function*() {\n                this.emit(PCEvents.NegotiationStarted);\n                try {\n                    yield this.createAndSendOffer();\n                } catch (e) {\n                    if (onError) {\n                        onError(e);\n                    } else {\n                        throw e;\n                    }\n                }\n            }), 100);\n        this.close = ()=>{\n            if (!this._pc) {\n                return;\n            }\n            this._pc.close();\n            this._pc.onconnectionstatechange = null;\n            this._pc.oniceconnectionstatechange = null;\n            this._pc.onicegatheringstatechange = null;\n            this._pc.ondatachannel = null;\n            this._pc.onnegotiationneeded = null;\n            this._pc.onsignalingstatechange = null;\n            this._pc.onicecandidate = null;\n            this._pc.ondatachannel = null;\n            this._pc.ontrack = null;\n            this._pc.onconnectionstatechange = null;\n            this._pc.oniceconnectionstatechange = null;\n            this._pc = null;\n        };\n        this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.PCTransport);\n        this.loggerOptions = loggerOptions;\n        this.config = config;\n        this.mediaConstraints = mediaConstraints;\n        this._pc = this.createPC();\n    }\n    createPC() {\n        const pc = isChromiumBased() ? // @ts-expect-error chrome allows additional media constraints to be passed into the RTCPeerConnection constructor\n        new RTCPeerConnection(this.config, this.mediaConstraints) : new RTCPeerConnection(this.config);\n        pc.onicecandidate = (ev)=>{\n            var _a;\n            if (!ev.candidate) return;\n            (_a = this.onIceCandidate) === null || _a === void 0 ? void 0 : _a.call(this, ev.candidate);\n        };\n        pc.onicecandidateerror = (ev)=>{\n            var _a;\n            (_a = this.onIceCandidateError) === null || _a === void 0 ? void 0 : _a.call(this, ev);\n        };\n        pc.oniceconnectionstatechange = ()=>{\n            var _a;\n            (_a = this.onIceConnectionStateChange) === null || _a === void 0 ? void 0 : _a.call(this, pc.iceConnectionState);\n        };\n        pc.onsignalingstatechange = ()=>{\n            var _a;\n            (_a = this.onSignalingStatechange) === null || _a === void 0 ? void 0 : _a.call(this, pc.signalingState);\n        };\n        pc.onconnectionstatechange = ()=>{\n            var _a;\n            (_a = this.onConnectionStateChange) === null || _a === void 0 ? void 0 : _a.call(this, pc.connectionState);\n        };\n        pc.ondatachannel = (ev)=>{\n            var _a;\n            (_a = this.onDataChannel) === null || _a === void 0 ? void 0 : _a.call(this, ev);\n        };\n        pc.ontrack = (ev)=>{\n            var _a;\n            (_a = this.onTrack) === null || _a === void 0 ? void 0 : _a.call(this, ev);\n        };\n        return pc;\n    }\n    get logContext() {\n        var _a, _b;\n        return Object.assign({}, (_b = (_a = this.loggerOptions).loggerContextCb) === null || _b === void 0 ? void 0 : _b.call(_a));\n    }\n    get isICEConnected() {\n        return this._pc !== null && (this.pc.iceConnectionState === 'connected' || this.pc.iceConnectionState === 'completed');\n    }\n    addIceCandidate(candidate) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.pc.remoteDescription && !this.restartingIce) {\n                return this.pc.addIceCandidate(candidate);\n            }\n            this.pendingCandidates.push(candidate);\n        });\n    }\n    setRemoteDescription(sd) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            let mungedSDP = undefined;\n            if (sd.type === 'offer') {\n                let { stereoMids, nackMids } = extractStereoAndNackAudioFromOffer(sd);\n                this.remoteStereoMids = stereoMids;\n                this.remoteNackMids = nackMids;\n            } else if (sd.type === 'answer') {\n                const sdpParsed = parse((_a = sd.sdp) !== null && _a !== void 0 ? _a : '');\n                sdpParsed.media.forEach((media)=>{\n                    if (media.type === 'audio') {\n                        // mung sdp for opus bitrate settings\n                        this.trackBitrates.some((trackbr)=>{\n                            if (!trackbr.transceiver || media.mid != trackbr.transceiver.mid) {\n                                return false;\n                            }\n                            let codecPayload = 0;\n                            media.rtp.some((rtp)=>{\n                                if (rtp.codec.toUpperCase() === trackbr.codec.toUpperCase()) {\n                                    codecPayload = rtp.payload;\n                                    return true;\n                                }\n                                return false;\n                            });\n                            if (codecPayload === 0) {\n                                return true;\n                            }\n                            let fmtpFound = false;\n                            for (const fmtp of media.fmtp){\n                                if (fmtp.payload === codecPayload) {\n                                    fmtp.config = fmtp.config.split(';').filter((attr)=>!attr.includes('maxaveragebitrate')).join(';');\n                                    if (trackbr.maxbr > 0) {\n                                        fmtp.config += \";maxaveragebitrate=\".concat(trackbr.maxbr * 1000);\n                                    }\n                                    fmtpFound = true;\n                                    break;\n                                }\n                            }\n                            if (!fmtpFound) {\n                                if (trackbr.maxbr > 0) {\n                                    media.fmtp.push({\n                                        payload: codecPayload,\n                                        config: \"maxaveragebitrate=\".concat(trackbr.maxbr * 1000)\n                                    });\n                                }\n                            }\n                            return true;\n                        });\n                    }\n                });\n                mungedSDP = write(sdpParsed);\n            }\n            yield this.setMungedSDP(sd, mungedSDP, true);\n            this.pendingCandidates.forEach((candidate)=>{\n                this.pc.addIceCandidate(candidate);\n            });\n            this.pendingCandidates = [];\n            this.restartingIce = false;\n            if (this.renegotiate) {\n                this.renegotiate = false;\n                yield this.createAndSendOffer();\n            } else if (sd.type === 'answer') {\n                this.emit(PCEvents.NegotiationComplete);\n                if (sd.sdp) {\n                    const sdpParsed = parse(sd.sdp);\n                    sdpParsed.media.forEach((media)=>{\n                        if (media.type === 'video') {\n                            this.emit(PCEvents.RTPVideoPayloadTypes, media.rtp);\n                        }\n                    });\n                }\n            }\n        });\n    }\n    createAndSendOffer(options) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.onOffer === undefined) {\n                return;\n            }\n            if (options === null || options === void 0 ? void 0 : options.iceRestart) {\n                this.log.debug('restarting ICE', this.logContext);\n                this.restartingIce = true;\n            }\n            if (this._pc && this._pc.signalingState === 'have-local-offer') {\n                // we're waiting for the peer to accept our offer, so we'll just wait\n                // the only exception to this is when ICE restart is needed\n                const currentSD = this._pc.remoteDescription;\n                if ((options === null || options === void 0 ? void 0 : options.iceRestart) && currentSD) {\n                    // TODO: handle when ICE restart is needed but we don't have a remote description\n                    // the best thing to do is to recreate the peerconnection\n                    yield this._pc.setRemoteDescription(currentSD);\n                } else {\n                    this.renegotiate = true;\n                    return;\n                }\n            } else if (!this._pc || this._pc.signalingState === 'closed') {\n                this.log.warn('could not createOffer with closed peer connection', this.logContext);\n                return;\n            }\n            // actually negotiate\n            this.log.debug('starting to negotiate', this.logContext);\n            const offer = yield this.pc.createOffer(options);\n            const sdpParsed = parse((_a = offer.sdp) !== null && _a !== void 0 ? _a : '');\n            sdpParsed.media.forEach((media)=>{\n                if (media.type === 'audio') {\n                    ensureAudioNackAndStereo(media, [], []);\n                } else if (media.type === 'video') {\n                    ensureVideoDDExtensionForSVC(media);\n                    // mung sdp for codec bitrate setting that can't apply by sendEncoding\n                    this.trackBitrates.some((trackbr)=>{\n                        if (!media.msid || !trackbr.cid || !media.msid.includes(trackbr.cid)) {\n                            return false;\n                        }\n                        let codecPayload = 0;\n                        media.rtp.some((rtp)=>{\n                            if (rtp.codec.toUpperCase() === trackbr.codec.toUpperCase()) {\n                                codecPayload = rtp.payload;\n                                return true;\n                            }\n                            return false;\n                        });\n                        if (codecPayload === 0) {\n                            return true;\n                        }\n                        let fmtpFound = false;\n                        for (const fmtp of media.fmtp){\n                            if (fmtp.payload === codecPayload) {\n                                if (!fmtp.config.includes('x-google-start-bitrate')) {\n                                    fmtp.config += \";x-google-start-bitrate=\".concat(Math.round(trackbr.maxbr * startBitrateForSVC));\n                                }\n                                if (!fmtp.config.includes('x-google-max-bitrate')) {\n                                    fmtp.config += \";x-google-max-bitrate=\".concat(trackbr.maxbr);\n                                }\n                                fmtpFound = true;\n                                break;\n                            }\n                        }\n                        if (!fmtpFound) {\n                            media.fmtp.push({\n                                payload: codecPayload,\n                                config: \"x-google-start-bitrate=\".concat(Math.round(trackbr.maxbr * startBitrateForSVC), \";x-google-max-bitrate=\").concat(trackbr.maxbr)\n                            });\n                        }\n                        return true;\n                    });\n                }\n            });\n            yield this.setMungedSDP(offer, write(sdpParsed));\n            this.onOffer(offer);\n        });\n    }\n    createAndSetAnswer() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const answer = yield this.pc.createAnswer();\n            const sdpParsed = parse((_a = answer.sdp) !== null && _a !== void 0 ? _a : '');\n            sdpParsed.media.forEach((media)=>{\n                if (media.type === 'audio') {\n                    ensureAudioNackAndStereo(media, this.remoteStereoMids, this.remoteNackMids);\n                }\n            });\n            yield this.setMungedSDP(answer, write(sdpParsed));\n            return answer;\n        });\n    }\n    createDataChannel(label, dataChannelDict) {\n        return this.pc.createDataChannel(label, dataChannelDict);\n    }\n    addTransceiver(mediaStreamTrack, transceiverInit) {\n        return this.pc.addTransceiver(mediaStreamTrack, transceiverInit);\n    }\n    addTrack(track) {\n        if (!this._pc) {\n            throw new UnexpectedConnectionState('PC closed, cannot add track');\n        }\n        return this._pc.addTrack(track);\n    }\n    setTrackCodecBitrate(info) {\n        this.trackBitrates.push(info);\n    }\n    setConfiguration(rtcConfig) {\n        var _a;\n        if (!this._pc) {\n            throw new UnexpectedConnectionState('PC closed, cannot configure');\n        }\n        return (_a = this._pc) === null || _a === void 0 ? void 0 : _a.setConfiguration(rtcConfig);\n    }\n    canRemoveTrack() {\n        var _a;\n        return !!((_a = this._pc) === null || _a === void 0 ? void 0 : _a.removeTrack);\n    }\n    removeTrack(sender) {\n        var _a;\n        return (_a = this._pc) === null || _a === void 0 ? void 0 : _a.removeTrack(sender);\n    }\n    getConnectionState() {\n        var _a, _b;\n        return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.connectionState) !== null && _b !== void 0 ? _b : 'closed';\n    }\n    getICEConnectionState() {\n        var _a, _b;\n        return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.iceConnectionState) !== null && _b !== void 0 ? _b : 'closed';\n    }\n    getSignallingState() {\n        var _a, _b;\n        return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.signalingState) !== null && _b !== void 0 ? _b : 'closed';\n    }\n    getTransceivers() {\n        var _a, _b;\n        return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.getTransceivers()) !== null && _b !== void 0 ? _b : [];\n    }\n    getSenders() {\n        var _a, _b;\n        return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.getSenders()) !== null && _b !== void 0 ? _b : [];\n    }\n    getLocalDescription() {\n        var _a;\n        return (_a = this._pc) === null || _a === void 0 ? void 0 : _a.localDescription;\n    }\n    getRemoteDescription() {\n        var _a;\n        return (_a = this.pc) === null || _a === void 0 ? void 0 : _a.remoteDescription;\n    }\n    getStats() {\n        return this.pc.getStats();\n    }\n    getConnectedAddress() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this._pc) {\n                return;\n            }\n            let selectedCandidatePairId = '';\n            const candidatePairs = new Map();\n            // id -> candidate ip\n            const candidates = new Map();\n            const stats = yield this._pc.getStats();\n            stats.forEach((v)=>{\n                switch(v.type){\n                    case 'transport':\n                        selectedCandidatePairId = v.selectedCandidatePairId;\n                        break;\n                    case 'candidate-pair':\n                        if (selectedCandidatePairId === '' && v.selected) {\n                            selectedCandidatePairId = v.id;\n                        }\n                        candidatePairs.set(v.id, v);\n                        break;\n                    case 'remote-candidate':\n                        candidates.set(v.id, \"\".concat(v.address, \":\").concat(v.port));\n                        break;\n                }\n            });\n            if (selectedCandidatePairId === '') {\n                return undefined;\n            }\n            const selectedID = (_a = candidatePairs.get(selectedCandidatePairId)) === null || _a === void 0 ? void 0 : _a.remoteCandidateId;\n            if (selectedID === undefined) {\n                return undefined;\n            }\n            return candidates.get(selectedID);\n        });\n    }\n    setMungedSDP(sd, munged, remote) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (munged) {\n                const originalSdp = sd.sdp;\n                sd.sdp = munged;\n                try {\n                    this.log.debug(\"setting munged \".concat(remote ? 'remote' : 'local', \" description\"), this.logContext);\n                    if (remote) {\n                        yield this.pc.setRemoteDescription(sd);\n                    } else {\n                        yield this.pc.setLocalDescription(sd);\n                    }\n                    return;\n                } catch (e) {\n                    this.log.warn(\"not able to set \".concat(sd.type, \", falling back to unmodified sdp\"), Object.assign(Object.assign({}, this.logContext), {\n                        error: e,\n                        sdp: munged\n                    }));\n                    sd.sdp = originalSdp;\n                }\n            }\n            try {\n                if (remote) {\n                    yield this.pc.setRemoteDescription(sd);\n                } else {\n                    yield this.pc.setLocalDescription(sd);\n                }\n            } catch (e) {\n                // this error cannot always be caught.\n                // If the local description has a setCodecPreferences error, this error will be uncaught\n                let msg = 'unknown error';\n                if (e instanceof Error) {\n                    msg = e.message;\n                } else if (typeof e === 'string') {\n                    msg = e;\n                }\n                const fields = {\n                    error: msg,\n                    sdp: sd.sdp\n                };\n                if (!remote && this.pc.remoteDescription) {\n                    fields.remoteSdp = this.pc.remoteDescription;\n                }\n                this.log.error(\"unable to set \".concat(sd.type), Object.assign(Object.assign({}, this.logContext), {\n                    fields\n                }));\n                throw new NegotiationError(msg);\n            }\n        });\n    }\n}\nfunction ensureAudioNackAndStereo(media, stereoMids, nackMids) {\n    // found opus codec to add nack fb\n    let opusPayload = 0;\n    media.rtp.some((rtp)=>{\n        if (rtp.codec === 'opus') {\n            opusPayload = rtp.payload;\n            return true;\n        }\n        return false;\n    });\n    // add nack rtcpfb if not exist\n    if (opusPayload > 0) {\n        if (!media.rtcpFb) {\n            media.rtcpFb = [];\n        }\n        if (nackMids.includes(media.mid) && !media.rtcpFb.some((fb)=>fb.payload === opusPayload && fb.type === 'nack')) {\n            media.rtcpFb.push({\n                payload: opusPayload,\n                type: 'nack'\n            });\n        }\n        if (stereoMids.includes(media.mid)) {\n            media.fmtp.some((fmtp)=>{\n                if (fmtp.payload === opusPayload) {\n                    if (!fmtp.config.includes('stereo=1')) {\n                        fmtp.config += ';stereo=1';\n                    }\n                    return true;\n                }\n                return false;\n            });\n        }\n    }\n}\nfunction ensureVideoDDExtensionForSVC(media) {\n    var _a, _b, _c, _d;\n    const codec = (_b = (_a = media.rtp[0]) === null || _a === void 0 ? void 0 : _a.codec) === null || _b === void 0 ? void 0 : _b.toLowerCase();\n    if (!isSVCCodec(codec)) {\n        return;\n    }\n    let maxID = 0;\n    const ddFound = (_c = media.ext) === null || _c === void 0 ? void 0 : _c.some((ext)=>{\n        if (ext.uri === ddExtensionURI) {\n            return true;\n        }\n        if (ext.value > maxID) {\n            maxID = ext.value;\n        }\n        return false;\n    });\n    if (!ddFound) {\n        (_d = media.ext) === null || _d === void 0 ? void 0 : _d.push({\n            value: maxID + 1,\n            uri: ddExtensionURI\n        });\n    }\n}\nfunction extractStereoAndNackAudioFromOffer(offer) {\n    var _a;\n    const stereoMids = [];\n    const nackMids = [];\n    const sdpParsed = parse((_a = offer.sdp) !== null && _a !== void 0 ? _a : '');\n    let opusPayload = 0;\n    sdpParsed.media.forEach((media)=>{\n        var _a;\n        if (media.type === 'audio') {\n            media.rtp.some((rtp)=>{\n                if (rtp.codec === 'opus') {\n                    opusPayload = rtp.payload;\n                    return true;\n                }\n                return false;\n            });\n            if ((_a = media.rtcpFb) === null || _a === void 0 ? void 0 : _a.some((fb)=>fb.payload === opusPayload && fb.type === 'nack')) {\n                nackMids.push(media.mid);\n            }\n            media.fmtp.some((fmtp)=>{\n                if (fmtp.payload === opusPayload) {\n                    if (fmtp.config.includes('sprop-stereo=1')) {\n                        stereoMids.push(media.mid);\n                    }\n                    return true;\n                }\n                return false;\n            });\n        }\n    });\n    return {\n        stereoMids,\n        nackMids\n    };\n}\nconst defaultVideoCodec = 'vp8';\nconst publishDefaults = {\n    /**\n   * @deprecated\n   */ audioBitrate: AudioPresets.music.maxBitrate,\n    audioPreset: AudioPresets.music,\n    dtx: true,\n    red: true,\n    forceStereo: false,\n    simulcast: true,\n    screenShareEncoding: ScreenSharePresets.h1080fps15.encoding,\n    stopMicTrackOnMute: false,\n    videoCodec: defaultVideoCodec,\n    backupCodec: true\n};\nconst audioDefaults = {\n    autoGainControl: true,\n    echoCancellation: true,\n    noiseSuppression: true\n};\nconst videoDefaults = {\n    resolution: VideoPresets.h720.resolution\n};\nconst roomOptionDefaults = {\n    adaptiveStream: false,\n    dynacast: false,\n    stopLocalTrackOnUnpublish: true,\n    reconnectPolicy: new DefaultReconnectPolicy(),\n    disconnectOnPageLeave: true,\n    expWebAudioMix: false\n};\nconst roomConnectOptionDefaults = {\n    autoSubscribe: true,\n    maxRetries: 1,\n    peerConnectionTimeout: 15000,\n    websocketTimeout: 15000\n};\nvar PCTransportState;\n(function(PCTransportState) {\n    PCTransportState[PCTransportState[\"NEW\"] = 0] = \"NEW\";\n    PCTransportState[PCTransportState[\"CONNECTING\"] = 1] = \"CONNECTING\";\n    PCTransportState[PCTransportState[\"CONNECTED\"] = 2] = \"CONNECTED\";\n    PCTransportState[PCTransportState[\"FAILED\"] = 3] = \"FAILED\";\n    PCTransportState[PCTransportState[\"CLOSING\"] = 4] = \"CLOSING\";\n    PCTransportState[PCTransportState[\"CLOSED\"] = 5] = \"CLOSED\";\n})(PCTransportState || (PCTransportState = {}));\nclass PCTransportManager {\n    get needsPublisher() {\n        return this.isPublisherConnectionRequired;\n    }\n    get needsSubscriber() {\n        return this.isSubscriberConnectionRequired;\n    }\n    get currentState() {\n        return this.state;\n    }\n    constructor(rtcConfig, subscriberPrimary, loggerOptions){\n        var _a;\n        this.peerConnectionTimeout = roomConnectOptionDefaults.peerConnectionTimeout;\n        this.log = livekitLogger;\n        this.updateState = ()=>{\n            var _a;\n            const previousState = this.state;\n            const connectionStates = this.requiredTransports.map((tr)=>tr.getConnectionState());\n            if (connectionStates.every((st)=>st === 'connected')) {\n                this.state = PCTransportState.CONNECTED;\n            } else if (connectionStates.some((st)=>st === 'failed')) {\n                this.state = PCTransportState.FAILED;\n            } else if (connectionStates.some((st)=>st === 'connecting')) {\n                this.state = PCTransportState.CONNECTING;\n            } else if (connectionStates.every((st)=>st === 'closed')) {\n                this.state = PCTransportState.CLOSED;\n            } else if (connectionStates.some((st)=>st === 'closed')) {\n                this.state = PCTransportState.CLOSING;\n            } else if (connectionStates.every((st)=>st === 'new')) {\n                this.state = PCTransportState.NEW;\n            }\n            if (previousState !== this.state) {\n                this.log.debug(\"pc state change: from \".concat(PCTransportState[previousState], \" to \").concat(PCTransportState[this.state]), this.logContext);\n                (_a = this.onStateChange) === null || _a === void 0 ? void 0 : _a.call(this, this.state, this.publisher.getConnectionState(), this.subscriber.getConnectionState());\n            }\n        };\n        this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.PCManager);\n        this.loggerOptions = loggerOptions;\n        this.isPublisherConnectionRequired = !subscriberPrimary;\n        this.isSubscriberConnectionRequired = subscriberPrimary;\n        const googConstraints = {\n            optional: [\n                {\n                    googDscp: true\n                }\n            ]\n        };\n        this.publisher = new PCTransport(rtcConfig, googConstraints, loggerOptions);\n        this.subscriber = new PCTransport(rtcConfig, undefined, loggerOptions);\n        this.publisher.onConnectionStateChange = this.updateState;\n        this.subscriber.onConnectionStateChange = this.updateState;\n        this.publisher.onIceConnectionStateChange = this.updateState;\n        this.subscriber.onIceConnectionStateChange = this.updateState;\n        this.publisher.onSignalingStatechange = this.updateState;\n        this.subscriber.onSignalingStatechange = this.updateState;\n        this.publisher.onIceCandidate = (candidate)=>{\n            var _a;\n            (_a = this.onIceCandidate) === null || _a === void 0 ? void 0 : _a.call(this, candidate, SignalTarget.PUBLISHER);\n        };\n        this.subscriber.onIceCandidate = (candidate)=>{\n            var _a;\n            (_a = this.onIceCandidate) === null || _a === void 0 ? void 0 : _a.call(this, candidate, SignalTarget.SUBSCRIBER);\n        };\n        // in subscriber primary mode, server side opens sub data channels.\n        this.subscriber.onDataChannel = (ev)=>{\n            var _a;\n            (_a = this.onDataChannel) === null || _a === void 0 ? void 0 : _a.call(this, ev);\n        };\n        this.subscriber.onTrack = (ev)=>{\n            var _a;\n            (_a = this.onTrack) === null || _a === void 0 ? void 0 : _a.call(this, ev);\n        };\n        this.publisher.onOffer = (offer)=>{\n            var _a;\n            (_a = this.onPublisherOffer) === null || _a === void 0 ? void 0 : _a.call(this, offer);\n        };\n        this.state = PCTransportState.NEW;\n        this.connectionLock = new Mutex();\n    }\n    get logContext() {\n        var _a, _b;\n        return Object.assign({}, (_b = (_a = this.loggerOptions).loggerContextCb) === null || _b === void 0 ? void 0 : _b.call(_a));\n    }\n    requirePublisher() {\n        let require = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        this.isPublisherConnectionRequired = require;\n        this.updateState();\n    }\n    requireSubscriber() {\n        let require = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        this.isSubscriberConnectionRequired = require;\n        this.updateState();\n    }\n    createAndSendPublisherOffer(options) {\n        return this.publisher.createAndSendOffer(options);\n    }\n    setPublisherAnswer(sd) {\n        return this.publisher.setRemoteDescription(sd);\n    }\n    removeTrack(sender) {\n        return this.publisher.removeTrack(sender);\n    }\n    close() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.publisher && this.publisher.getSignallingState() !== 'closed') {\n                const publisher = this.publisher;\n                for (const sender of publisher.getSenders()){\n                    try {\n                        // TODO: react-native-webrtc doesn't have removeTrack yet.\n                        if (publisher.canRemoveTrack()) {\n                            publisher.removeTrack(sender);\n                        }\n                    } catch (e) {\n                        this.log.warn('could not removeTrack', Object.assign(Object.assign({}, this.logContext), {\n                            error: e\n                        }));\n                    }\n                }\n            }\n            yield Promise.all([\n                this.publisher.close(),\n                this.subscriber.close()\n            ]);\n            this.updateState();\n        });\n    }\n    triggerIceRestart() {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.subscriber.restartingIce = true;\n            // only restart publisher if it's needed\n            if (this.needsPublisher) {\n                yield this.createAndSendPublisherOffer({\n                    iceRestart: true\n                });\n            }\n        });\n    }\n    addIceCandidate(candidate, target) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (target === SignalTarget.PUBLISHER) {\n                yield this.publisher.addIceCandidate(candidate);\n            } else {\n                yield this.subscriber.addIceCandidate(candidate);\n            }\n        });\n    }\n    createSubscriberAnswerFromOffer(sd) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.log.debug('received server offer', Object.assign(Object.assign({}, this.logContext), {\n                RTCSdpType: sd.type,\n                sdp: sd.sdp,\n                signalingState: this.subscriber.getSignallingState().toString()\n            }));\n            yield this.subscriber.setRemoteDescription(sd);\n            // answer the offer\n            const answer = yield this.subscriber.createAndSetAnswer();\n            return answer;\n        });\n    }\n    updateConfiguration(config, iceRestart) {\n        this.publisher.setConfiguration(config);\n        this.subscriber.setConfiguration(config);\n        if (iceRestart) {\n            this.triggerIceRestart();\n        }\n    }\n    ensurePCTransportConnection(abortController, timeout) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.connectionLock.lock();\n            try {\n                if (this.isPublisherConnectionRequired && this.publisher.getConnectionState() !== 'connected' && this.publisher.getConnectionState() !== 'connecting') {\n                    this.log.debug('negotiation required, start negotiating', this.logContext);\n                    this.publisher.negotiate();\n                }\n                yield Promise.all((_a = this.requiredTransports) === null || _a === void 0 ? void 0 : _a.map((transport)=>this.ensureTransportConnected(transport, abortController, timeout)));\n            } finally{\n                unlock();\n            }\n        });\n    }\n    negotiate(abortController) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return new Promise((resolve, reject)=>__awaiter(this, void 0, void 0, function*() {\n                    const negotiationTimeout = setTimeout(()=>{\n                        reject('negotiation timed out');\n                    }, this.peerConnectionTimeout);\n                    const abortHandler = ()=>{\n                        clearTimeout(negotiationTimeout);\n                        reject('negotiation aborted');\n                    };\n                    abortController.signal.addEventListener('abort', abortHandler);\n                    this.publisher.once(PCEvents.NegotiationStarted, ()=>{\n                        if (abortController.signal.aborted) {\n                            return;\n                        }\n                        this.publisher.once(PCEvents.NegotiationComplete, ()=>{\n                            clearTimeout(negotiationTimeout);\n                            resolve();\n                        });\n                    });\n                    yield this.publisher.negotiate((e)=>{\n                        clearTimeout(negotiationTimeout);\n                        reject(e);\n                    });\n                }));\n        });\n    }\n    addPublisherTransceiver(track, transceiverInit) {\n        return this.publisher.addTransceiver(track, transceiverInit);\n    }\n    addPublisherTrack(track) {\n        return this.publisher.addTrack(track);\n    }\n    createPublisherDataChannel(label, dataChannelDict) {\n        return this.publisher.createDataChannel(label, dataChannelDict);\n    }\n    /**\n   * Returns the first required transport's address if no explicit target is specified\n   */ getConnectedAddress(target) {\n        if (target === SignalTarget.PUBLISHER) {\n            return this.publisher.getConnectedAddress();\n        } else if (target === SignalTarget.SUBSCRIBER) {\n            return this.publisher.getConnectedAddress();\n        }\n        return this.requiredTransports[0].getConnectedAddress();\n    }\n    get requiredTransports() {\n        const transports = [];\n        if (this.isPublisherConnectionRequired) {\n            transports.push(this.publisher);\n        }\n        if (this.isSubscriberConnectionRequired) {\n            transports.push(this.subscriber);\n        }\n        return transports;\n    }\n    ensureTransportConnected(pcTransport, abortController) {\n        let timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.peerConnectionTimeout;\n        return __awaiter(this, void 0, void 0, function*() {\n            const connectionState = pcTransport.getConnectionState();\n            if (connectionState === 'connected') {\n                return;\n            }\n            return new Promise((resolve, reject)=>__awaiter(this, void 0, void 0, function*() {\n                    const abortHandler = ()=>{\n                        this.log.warn('abort transport connection', this.logContext);\n                        CriticalTimers.clearTimeout(connectTimeout);\n                        reject(new ConnectionError('room connection has been cancelled', 3 /* ConnectionErrorReason.Cancelled */ ));\n                    };\n                    if (abortController === null || abortController === void 0 ? void 0 : abortController.signal.aborted) {\n                        abortHandler();\n                    }\n                    abortController === null || abortController === void 0 ? void 0 : abortController.signal.addEventListener('abort', abortHandler);\n                    const connectTimeout = CriticalTimers.setTimeout(()=>{\n                        abortController === null || abortController === void 0 ? void 0 : abortController.signal.removeEventListener('abort', abortHandler);\n                        reject(new ConnectionError('could not establish pc connection'));\n                    }, timeout);\n                    while(this.state !== PCTransportState.CONNECTED){\n                        yield sleep(50); // FIXME we shouldn't rely on `sleep` in the connection paths, as it invokes `setTimeout` which can be drastically throttled by browser implementations\n                        if (abortController === null || abortController === void 0 ? void 0 : abortController.signal.aborted) {\n                            reject(new ConnectionError('room connection has been cancelled', 3 /* ConnectionErrorReason.Cancelled */ ));\n                            return;\n                        }\n                    }\n                    CriticalTimers.clearTimeout(connectTimeout);\n                    abortController === null || abortController === void 0 ? void 0 : abortController.signal.removeEventListener('abort', abortHandler);\n                    resolve();\n                }));\n        });\n    }\n}\nconst lossyDataChannel = '_lossy';\nconst reliableDataChannel = '_reliable';\nconst minReconnectWait = 2 * 1000;\nconst leaveReconnect = 'leave-reconnect';\nvar PCState;\n(function(PCState) {\n    PCState[PCState[\"New\"] = 0] = \"New\";\n    PCState[PCState[\"Connected\"] = 1] = \"Connected\";\n    PCState[PCState[\"Disconnected\"] = 2] = \"Disconnected\";\n    PCState[PCState[\"Reconnecting\"] = 3] = \"Reconnecting\";\n    PCState[PCState[\"Closed\"] = 4] = \"Closed\";\n})(PCState || (PCState = {}));\n/** @internal */ class RTCEngine extends eventsExports.EventEmitter {\n    get isClosed() {\n        return this._isClosed;\n    }\n    constructor(options){\n        var _a;\n        super();\n        this.options = options;\n        this.rtcConfig = {};\n        this.peerConnectionTimeout = roomConnectOptionDefaults.peerConnectionTimeout;\n        this.fullReconnectOnNext = false;\n        this.subscriberPrimary = false;\n        this.pcState = PCState.New;\n        this._isClosed = true;\n        this.pendingTrackResolvers = {};\n        this.reconnectAttempts = 0;\n        this.reconnectStart = 0;\n        this.attemptingReconnect = false;\n        /** keeps track of how often an initial join connection has been tried */ this.joinAttempts = 0;\n        /** specifies how often an initial join connection is allowed to retry */ this.maxJoinAttempts = 1;\n        this.shouldFailNext = false;\n        this.log = livekitLogger;\n        this.handleDataChannel = (_ref)=>{\n            let { channel } = _ref;\n            return __awaiter(this, void 0, void 0, function*() {\n                if (!channel) {\n                    return;\n                }\n                if (channel.label === reliableDataChannel) {\n                    this.reliableDCSub = channel;\n                } else if (channel.label === lossyDataChannel) {\n                    this.lossyDCSub = channel;\n                } else {\n                    return;\n                }\n                this.log.debug(\"on data channel \".concat(channel.id, \", \").concat(channel.label), this.logContext);\n                channel.onmessage = this.handleDataMessage;\n            });\n        };\n        this.handleDataMessage = (message)=>__awaiter(this, void 0, void 0, function*() {\n                var _b, _c;\n                // make sure to respect incoming data message order by processing message events one after the other\n                const unlock = yield this.dataProcessLock.lock();\n                try {\n                    // decode\n                    let buffer;\n                    if (message.data instanceof ArrayBuffer) {\n                        buffer = message.data;\n                    } else if (message.data instanceof Blob) {\n                        buffer = yield message.data.arrayBuffer();\n                    } else {\n                        this.log.error('unsupported data type', Object.assign(Object.assign({}, this.logContext), {\n                            data: message.data\n                        }));\n                        return;\n                    }\n                    const dp = DataPacket.fromBinary(new Uint8Array(buffer));\n                    if (((_b = dp.value) === null || _b === void 0 ? void 0 : _b.case) === 'speaker') {\n                        // dispatch speaker updates\n                        this.emit(EngineEvent.ActiveSpeakersUpdate, dp.value.value.speakers);\n                    } else if (((_c = dp.value) === null || _c === void 0 ? void 0 : _c.case) === 'user') {\n                        this.emit(EngineEvent.DataPacketReceived, dp.value.value, dp.kind);\n                    }\n                } finally{\n                    unlock();\n                }\n            });\n        this.handleDataError = (event)=>{\n            const channel = event.currentTarget;\n            const channelKind = channel.maxRetransmits === 0 ? 'lossy' : 'reliable';\n            if (event instanceof ErrorEvent && event.error) {\n                const { error } = event.error;\n                this.log.error(\"DataChannel error on \".concat(channelKind, \": \").concat(event.message), Object.assign(Object.assign({}, this.logContext), {\n                    error\n                }));\n            } else {\n                this.log.error(\"Unknown DataChannel error on \".concat(channelKind), Object.assign(Object.assign({}, this.logContext), {\n                    event\n                }));\n            }\n        };\n        this.handleBufferedAmountLow = (event)=>{\n            const channel = event.currentTarget;\n            const channelKind = channel.maxRetransmits === 0 ? DataPacket_Kind.LOSSY : DataPacket_Kind.RELIABLE;\n            this.updateAndEmitDCBufferStatus(channelKind);\n        };\n        // websocket reconnect behavior. if websocket is interrupted, and the PeerConnection\n        // continues to work, we can reconnect to websocket to continue the session\n        // after a number of retries, we'll close and give up permanently\n        this.handleDisconnect = (connection, disconnectReason)=>{\n            if (this._isClosed) {\n                return;\n            }\n            this.log.warn(\"\".concat(connection, \" disconnected\"), this.logContext);\n            if (this.reconnectAttempts === 0) {\n                // only reset start time on the first try\n                this.reconnectStart = Date.now();\n            }\n            const disconnect = (duration)=>{\n                this.log.warn(\"could not recover connection after \".concat(this.reconnectAttempts, \" attempts, \").concat(duration, \"ms. giving up\"), this.logContext);\n                this.emit(EngineEvent.Disconnected);\n                this.close();\n            };\n            const duration = Date.now() - this.reconnectStart;\n            let delay = this.getNextRetryDelay({\n                elapsedMs: duration,\n                retryCount: this.reconnectAttempts\n            });\n            if (delay === null) {\n                disconnect(duration);\n                return;\n            }\n            if (connection === leaveReconnect) {\n                delay = 0;\n            }\n            this.log.debug(\"reconnecting in \".concat(delay, \"ms\"), this.logContext);\n            this.clearReconnectTimeout();\n            if (this.token && this.regionUrlProvider) {\n                // token may have been refreshed, we do not want to recreate the regionUrlProvider\n                // since the current engine may have inherited a regional url\n                this.regionUrlProvider.updateToken(this.token);\n            }\n            this.reconnectTimeout = CriticalTimers.setTimeout(()=>this.attemptReconnect(disconnectReason), delay);\n        };\n        this.waitForRestarted = ()=>{\n            return new Promise((resolve, reject)=>{\n                if (this.pcState === PCState.Connected) {\n                    resolve();\n                }\n                const onRestarted = ()=>{\n                    this.off(EngineEvent.Disconnected, onDisconnected);\n                    resolve();\n                };\n                const onDisconnected = ()=>{\n                    this.off(EngineEvent.Restarted, onRestarted);\n                    reject();\n                };\n                this.once(EngineEvent.Restarted, onRestarted);\n                this.once(EngineEvent.Disconnected, onDisconnected);\n            });\n        };\n        this.updateAndEmitDCBufferStatus = (kind)=>{\n            const status = this.isBufferStatusLow(kind);\n            if (typeof status !== 'undefined' && status !== this.dcBufferStatus.get(kind)) {\n                this.dcBufferStatus.set(kind, status);\n                this.emit(EngineEvent.DCBufferStatusChanged, status, kind);\n            }\n        };\n        this.isBufferStatusLow = (kind)=>{\n            const dc = this.dataChannelForKind(kind);\n            if (dc) {\n                return dc.bufferedAmount <= dc.bufferedAmountLowThreshold;\n            }\n        };\n        this.handleBrowserOnLine = ()=>{\n            // in case the engine is currently reconnecting, attempt a reconnect immediately after the browser state has changed to 'onLine'\n            if (this.client.currentState === SignalConnectionState.RECONNECTING) {\n                this.clearReconnectTimeout();\n                this.attemptReconnect(ReconnectReason.RR_SIGNAL_DISCONNECTED);\n            }\n        };\n        this.log = getLogger((_a = options.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Engine);\n        this.loggerOptions = {\n            loggerName: options.loggerName,\n            loggerContextCb: ()=>this.logContext\n        };\n        this.client = new SignalClient(undefined, this.loggerOptions);\n        this.client.signalLatency = this.options.expSignalLatency;\n        this.reconnectPolicy = this.options.reconnectPolicy;\n        this.registerOnLineListener();\n        this.closingLock = new Mutex();\n        this.dataProcessLock = new Mutex();\n        this.dcBufferStatus = new Map([\n            [\n                DataPacket_Kind.LOSSY,\n                true\n            ],\n            [\n                DataPacket_Kind.RELIABLE,\n                true\n            ]\n        ]);\n        this.client.onParticipantUpdate = (updates)=>this.emit(EngineEvent.ParticipantUpdate, updates);\n        this.client.onConnectionQuality = (update)=>this.emit(EngineEvent.ConnectionQualityUpdate, update);\n        this.client.onRoomUpdate = (update)=>this.emit(EngineEvent.RoomUpdate, update);\n        this.client.onSubscriptionError = (resp)=>this.emit(EngineEvent.SubscriptionError, resp);\n        this.client.onSubscriptionPermissionUpdate = (update)=>this.emit(EngineEvent.SubscriptionPermissionUpdate, update);\n        this.client.onSpeakersChanged = (update)=>this.emit(EngineEvent.SpeakersChanged, update);\n        this.client.onStreamStateUpdate = (update)=>this.emit(EngineEvent.StreamStateChanged, update);\n    }\n    /** @internal */ get logContext() {\n        var _a, _b, _c, _d, _e, _f;\n        return {\n            room: (_b = (_a = this.latestJoinResponse) === null || _a === void 0 ? void 0 : _a.room) === null || _b === void 0 ? void 0 : _b.name,\n            roomSid: (_d = (_c = this.latestJoinResponse) === null || _c === void 0 ? void 0 : _c.room) === null || _d === void 0 ? void 0 : _d.sid,\n            identity: (_f = (_e = this.latestJoinResponse) === null || _e === void 0 ? void 0 : _e.participant) === null || _f === void 0 ? void 0 : _f.identity\n        };\n    }\n    join(url, token, opts, abortSignal) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.url = url;\n            this.token = token;\n            this.signalOpts = opts;\n            this.maxJoinAttempts = opts.maxRetries;\n            try {\n                this.joinAttempts += 1;\n                this.setupSignalClientCallbacks();\n                const joinResponse = yield this.client.join(url, token, opts, abortSignal);\n                this._isClosed = false;\n                this.latestJoinResponse = joinResponse;\n                this.subscriberPrimary = joinResponse.subscriberPrimary;\n                if (!this.pcManager) {\n                    yield this.configure(joinResponse);\n                }\n                // create offer\n                if (!this.subscriberPrimary) {\n                    this.negotiate();\n                }\n                this.clientConfiguration = joinResponse.clientConfiguration;\n                return joinResponse;\n            } catch (e) {\n                if (e instanceof ConnectionError) {\n                    if (e.reason === 1 /* ConnectionErrorReason.ServerUnreachable */ ) {\n                        this.log.warn(\"Couldn't connect to server, attempt \".concat(this.joinAttempts, \" of \").concat(this.maxJoinAttempts), this.logContext);\n                        if (this.joinAttempts < this.maxJoinAttempts) {\n                            return this.join(url, token, opts, abortSignal);\n                        }\n                    }\n                }\n                throw e;\n            }\n        });\n    }\n    close() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.closingLock.lock();\n            if (this.isClosed) {\n                unlock();\n                return;\n            }\n            try {\n                this._isClosed = true;\n                this.emit(EngineEvent.Closing);\n                this.removeAllListeners();\n                this.deregisterOnLineListener();\n                this.clearPendingReconnect();\n                yield this.cleanupPeerConnections();\n                yield this.cleanupClient();\n            } finally{\n                unlock();\n            }\n        });\n    }\n    cleanupPeerConnections() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            yield (_a = this.pcManager) === null || _a === void 0 ? void 0 : _a.close();\n            this.pcManager = undefined;\n            const dcCleanup = (dc)=>{\n                if (!dc) return;\n                dc.close();\n                dc.onbufferedamountlow = null;\n                dc.onclose = null;\n                dc.onclosing = null;\n                dc.onerror = null;\n                dc.onmessage = null;\n                dc.onopen = null;\n            };\n            dcCleanup(this.lossyDC);\n            dcCleanup(this.lossyDCSub);\n            dcCleanup(this.reliableDC);\n            dcCleanup(this.reliableDCSub);\n            this.lossyDC = undefined;\n            this.lossyDCSub = undefined;\n            this.reliableDC = undefined;\n            this.reliableDCSub = undefined;\n        });\n    }\n    cleanupClient() {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.client.close();\n            this.client.resetCallbacks();\n        });\n    }\n    addTrack(req) {\n        if (this.pendingTrackResolvers[req.cid]) {\n            throw new TrackInvalidError('a track with the same ID has already been published');\n        }\n        return new Promise((resolve, reject)=>{\n            const publicationTimeout = setTimeout(()=>{\n                delete this.pendingTrackResolvers[req.cid];\n                reject(new ConnectionError('publication of local track timed out, no response from server'));\n            }, 10000);\n            this.pendingTrackResolvers[req.cid] = {\n                resolve: (info)=>{\n                    clearTimeout(publicationTimeout);\n                    resolve(info);\n                },\n                reject: ()=>{\n                    clearTimeout(publicationTimeout);\n                    reject(new Error('Cancelled publication by calling unpublish'));\n                }\n            };\n            this.client.sendAddTrack(req);\n        });\n    }\n    /**\n   * Removes sender from PeerConnection, returning true if it was removed successfully\n   * and a negotiation is necessary\n   * @param sender\n   * @returns\n   */ removeTrack(sender) {\n        if (sender.track && this.pendingTrackResolvers[sender.track.id]) {\n            const { reject } = this.pendingTrackResolvers[sender.track.id];\n            if (reject) {\n                reject();\n            }\n            delete this.pendingTrackResolvers[sender.track.id];\n        }\n        try {\n            this.pcManager.removeTrack(sender);\n            return true;\n        } catch (e) {\n            this.log.warn('failed to remove track', Object.assign(Object.assign({}, this.logContext), {\n                error: e\n            }));\n        }\n        return false;\n    }\n    updateMuteStatus(trackSid, muted) {\n        this.client.sendMuteTrack(trackSid, muted);\n    }\n    get dataSubscriberReadyState() {\n        var _a;\n        return (_a = this.reliableDCSub) === null || _a === void 0 ? void 0 : _a.readyState;\n    }\n    getConnectedServerAddress() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            return (_a = this.pcManager) === null || _a === void 0 ? void 0 : _a.getConnectedAddress();\n        });\n    }\n    /* @internal */ setRegionUrlProvider(provider) {\n        this.regionUrlProvider = provider;\n    }\n    configure(joinResponse) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            // already configured\n            if (this.pcManager && this.pcManager.currentState !== PCTransportState.NEW) {\n                return;\n            }\n            this.participantSid = (_a = joinResponse.participant) === null || _a === void 0 ? void 0 : _a.sid;\n            const rtcConfig = this.makeRTCConfiguration(joinResponse);\n            this.pcManager = new PCTransportManager(rtcConfig, joinResponse.subscriberPrimary, this.loggerOptions);\n            this.emit(EngineEvent.TransportsCreated, this.pcManager.publisher, this.pcManager.subscriber);\n            this.pcManager.onIceCandidate = (candidate, target)=>{\n                this.client.sendIceCandidate(candidate, target);\n            };\n            this.pcManager.onPublisherOffer = (offer)=>{\n                this.client.sendOffer(offer);\n            };\n            this.pcManager.onDataChannel = this.handleDataChannel;\n            this.pcManager.onStateChange = (connectionState, publisherState, subscriberState)=>__awaiter(this, void 0, void 0, function*() {\n                    this.log.debug(\"primary PC state changed \".concat(connectionState), this.logContext);\n                    if (connectionState === PCTransportState.CONNECTED) {\n                        const shouldEmit = this.pcState === PCState.New;\n                        this.pcState = PCState.Connected;\n                        if (shouldEmit) {\n                            this.emit(EngineEvent.Connected, joinResponse);\n                        }\n                    } else if (connectionState === PCTransportState.FAILED) {\n                        // on Safari, PeerConnection will switch to 'disconnected' during renegotiation\n                        if (this.pcState === PCState.Connected) {\n                            this.pcState = PCState.Disconnected;\n                            this.handleDisconnect('peerconnection failed', subscriberState === 'failed' ? ReconnectReason.RR_SUBSCRIBER_FAILED : ReconnectReason.RR_PUBLISHER_FAILED);\n                        }\n                    }\n                });\n            this.pcManager.onTrack = (ev)=>{\n                this.emit(EngineEvent.MediaTrackAdded, ev.track, ev.streams[0], ev.receiver);\n            };\n            this.createDataChannels();\n        });\n    }\n    setupSignalClientCallbacks() {\n        // configure signaling client\n        this.client.onAnswer = (sd)=>__awaiter(this, void 0, void 0, function*() {\n                if (!this.pcManager) {\n                    return;\n                }\n                this.log.debug('received server answer', Object.assign(Object.assign({}, this.logContext), {\n                    RTCSdpType: sd.type\n                }));\n                yield this.pcManager.setPublisherAnswer(sd);\n            });\n        // add candidate on trickle\n        this.client.onTrickle = (candidate, target)=>{\n            if (!this.pcManager) {\n                return;\n            }\n            this.log.trace('got ICE candidate from peer', Object.assign(Object.assign({}, this.logContext), {\n                candidate,\n                target\n            }));\n            this.pcManager.addIceCandidate(candidate, target);\n        };\n        // when server creates an offer for the client\n        this.client.onOffer = (sd)=>__awaiter(this, void 0, void 0, function*() {\n                if (!this.pcManager) {\n                    return;\n                }\n                const answer = yield this.pcManager.createSubscriberAnswerFromOffer(sd);\n                this.client.sendAnswer(answer);\n            });\n        this.client.onLocalTrackPublished = (res)=>{\n            var _a;\n            this.log.debug('received trackPublishedResponse', Object.assign(Object.assign({}, this.logContext), {\n                cid: res.cid,\n                track: (_a = res.track) === null || _a === void 0 ? void 0 : _a.sid\n            }));\n            if (!this.pendingTrackResolvers[res.cid]) {\n                this.log.error(\"missing track resolver for \".concat(res.cid), Object.assign(Object.assign({}, this.logContext), {\n                    cid: res.cid\n                }));\n                return;\n            }\n            const { resolve } = this.pendingTrackResolvers[res.cid];\n            delete this.pendingTrackResolvers[res.cid];\n            resolve(res.track);\n        };\n        this.client.onLocalTrackUnpublished = (response)=>{\n            this.emit(EngineEvent.LocalTrackUnpublished, response);\n        };\n        this.client.onTokenRefresh = (token)=>{\n            this.token = token;\n        };\n        this.client.onRemoteMuteChanged = (trackSid, muted)=>{\n            this.emit(EngineEvent.RemoteMute, trackSid, muted);\n        };\n        this.client.onSubscribedQualityUpdate = (update)=>{\n            this.emit(EngineEvent.SubscribedQualityUpdate, update);\n        };\n        this.client.onClose = ()=>{\n            this.handleDisconnect('signal', ReconnectReason.RR_SIGNAL_DISCONNECTED);\n        };\n        this.client.onLeave = (leave)=>{\n            if (leave === null || leave === void 0 ? void 0 : leave.canReconnect) {\n                this.fullReconnectOnNext = true;\n                // reconnect immediately instead of waiting for next attempt\n                this.handleDisconnect(leaveReconnect);\n            } else {\n                this.emit(EngineEvent.Disconnected, leave === null || leave === void 0 ? void 0 : leave.reason);\n                this.close();\n            }\n            this.log.debug('client leave request', Object.assign(Object.assign({}, this.logContext), {\n                reason: leave === null || leave === void 0 ? void 0 : leave.reason\n            }));\n        };\n    }\n    makeRTCConfiguration(serverResponse) {\n        var _a;\n        const rtcConfig = Object.assign({}, this.rtcConfig);\n        if ((_a = this.signalOpts) === null || _a === void 0 ? void 0 : _a.e2eeEnabled) {\n            this.log.debug('E2EE - setting up transports with insertable streams', this.logContext);\n            //  this makes sure that no data is sent before the transforms are ready\n            // @ts-ignore\n            rtcConfig.encodedInsertableStreams = true;\n        }\n        // update ICE servers before creating PeerConnection\n        if (serverResponse.iceServers && !rtcConfig.iceServers) {\n            const rtcIceServers = [];\n            serverResponse.iceServers.forEach((iceServer)=>{\n                const rtcIceServer = {\n                    urls: iceServer.urls\n                };\n                if (iceServer.username) rtcIceServer.username = iceServer.username;\n                if (iceServer.credential) {\n                    rtcIceServer.credential = iceServer.credential;\n                }\n                rtcIceServers.push(rtcIceServer);\n            });\n            rtcConfig.iceServers = rtcIceServers;\n        }\n        if (serverResponse.clientConfiguration && serverResponse.clientConfiguration.forceRelay === ClientConfigSetting.ENABLED) {\n            rtcConfig.iceTransportPolicy = 'relay';\n        }\n        // @ts-ignore\n        rtcConfig.sdpSemantics = 'unified-plan';\n        // @ts-ignore\n        rtcConfig.continualGatheringPolicy = 'gather_continually';\n        return rtcConfig;\n    }\n    createDataChannels() {\n        if (!this.pcManager) {\n            return;\n        }\n        // clear old data channel callbacks if recreate\n        if (this.lossyDC) {\n            this.lossyDC.onmessage = null;\n            this.lossyDC.onerror = null;\n        }\n        if (this.reliableDC) {\n            this.reliableDC.onmessage = null;\n            this.reliableDC.onerror = null;\n        }\n        // create data channels\n        this.lossyDC = this.pcManager.createPublisherDataChannel(lossyDataChannel, {\n            // will drop older packets that arrive\n            ordered: true,\n            maxRetransmits: 0\n        });\n        this.reliableDC = this.pcManager.createPublisherDataChannel(reliableDataChannel, {\n            ordered: true\n        });\n        // also handle messages over the pub channel, for backwards compatibility\n        this.lossyDC.onmessage = this.handleDataMessage;\n        this.reliableDC.onmessage = this.handleDataMessage;\n        // handle datachannel errors\n        this.lossyDC.onerror = this.handleDataError;\n        this.reliableDC.onerror = this.handleDataError;\n        // set up dc buffer threshold, set to 64kB (otherwise 0 by default)\n        this.lossyDC.bufferedAmountLowThreshold = 65535;\n        this.reliableDC.bufferedAmountLowThreshold = 65535;\n        // handle buffer amount low events\n        this.lossyDC.onbufferedamountlow = this.handleBufferedAmountLow;\n        this.reliableDC.onbufferedamountlow = this.handleBufferedAmountLow;\n    }\n    setPreferredCodec(transceiver, kind, videoCodec) {\n        if (!('getCapabilities' in RTCRtpReceiver)) {\n            return;\n        }\n        // when setting codec preferences, the capabilites need to be read from the RTCRtpReceiver\n        const cap = RTCRtpReceiver.getCapabilities(kind);\n        if (!cap) return;\n        this.log.debug('get receiver capabilities', Object.assign(Object.assign({}, this.logContext), {\n            cap\n        }));\n        const matched = [];\n        const partialMatched = [];\n        const unmatched = [];\n        cap.codecs.forEach((c)=>{\n            const codec = c.mimeType.toLowerCase();\n            if (codec === 'audio/opus') {\n                matched.push(c);\n                return;\n            }\n            const matchesVideoCodec = codec === \"video/\".concat(videoCodec);\n            if (!matchesVideoCodec) {\n                unmatched.push(c);\n                return;\n            }\n            // for h264 codecs that have sdpFmtpLine available, use only if the\n            // profile-level-id is 42e01f for cross-browser compatibility\n            if (videoCodec === 'h264') {\n                if (c.sdpFmtpLine && c.sdpFmtpLine.includes('profile-level-id=42e01f')) {\n                    matched.push(c);\n                } else {\n                    partialMatched.push(c);\n                }\n                return;\n            }\n            matched.push(c);\n        });\n        if (supportsSetCodecPreferences(transceiver)) {\n            transceiver.setCodecPreferences(matched.concat(partialMatched, unmatched));\n        }\n    }\n    createSender(track, opts, encodings) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (supportsTransceiver()) {\n                const sender = yield this.createTransceiverRTCRtpSender(track, opts, encodings);\n                return sender;\n            }\n            if (supportsAddTrack()) {\n                this.log.warn('using add-track fallback', this.logContext);\n                const sender = yield this.createRTCRtpSender(track.mediaStreamTrack);\n                return sender;\n            }\n            throw new UnexpectedConnectionState('Required webRTC APIs not supported on this device');\n        });\n    }\n    createSimulcastSender(track, simulcastTrack, opts, encodings) {\n        return __awaiter(this, void 0, void 0, function*() {\n            // store RTCRtpSender\n            if (supportsTransceiver()) {\n                return this.createSimulcastTransceiverSender(track, simulcastTrack, opts, encodings);\n            }\n            if (supportsAddTrack()) {\n                this.log.debug('using add-track fallback', this.logContext);\n                return this.createRTCRtpSender(track.mediaStreamTrack);\n            }\n            throw new UnexpectedConnectionState('Cannot stream on this device');\n        });\n    }\n    createTransceiverRTCRtpSender(track, opts, encodings) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.pcManager) {\n                throw new UnexpectedConnectionState('publisher is closed');\n            }\n            const streams = [];\n            if (track.mediaStream) {\n                streams.push(track.mediaStream);\n            }\n            const transceiverInit = {\n                direction: 'sendonly',\n                streams\n            };\n            if (encodings) {\n                transceiverInit.sendEncodings = encodings;\n            }\n            // addTransceiver for react-native is async. web is synchronous, but await won't effect it.\n            const transceiver = yield this.pcManager.addPublisherTransceiver(track.mediaStreamTrack, transceiverInit);\n            if (track.kind === Track.Kind.Video && opts.videoCodec) {\n                this.setPreferredCodec(transceiver, track.kind, opts.videoCodec);\n                track.codec = opts.videoCodec;\n            }\n            return transceiver.sender;\n        });\n    }\n    createSimulcastTransceiverSender(track, simulcastTrack, opts, encodings) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.pcManager) {\n                throw new UnexpectedConnectionState('publisher is closed');\n            }\n            const transceiverInit = {\n                direction: 'sendonly'\n            };\n            if (encodings) {\n                transceiverInit.sendEncodings = encodings;\n            }\n            // addTransceiver for react-native is async. web is synchronous, but await won't effect it.\n            const transceiver = yield this.pcManager.addPublisherTransceiver(simulcastTrack.mediaStreamTrack, transceiverInit);\n            if (!opts.videoCodec) {\n                return;\n            }\n            this.setPreferredCodec(transceiver, track.kind, opts.videoCodec);\n            track.setSimulcastTrackSender(opts.videoCodec, transceiver.sender);\n            return transceiver.sender;\n        });\n    }\n    createRTCRtpSender(track) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.pcManager) {\n                throw new UnexpectedConnectionState('publisher is closed');\n            }\n            return this.pcManager.addPublisherTrack(track);\n        });\n    }\n    attemptReconnect(reason) {\n        var _a, _b, _c;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this._isClosed) {\n                return;\n            }\n            // guard for attempting reconnection multiple times while one attempt is still not finished\n            if (this.attemptingReconnect) {\n                livekitLogger.warn('already attempting reconnect, returning early', this.logContext);\n                return;\n            }\n            if (((_a = this.clientConfiguration) === null || _a === void 0 ? void 0 : _a.resumeConnection) === ClientConfigSetting.DISABLED || // signaling state could change to closed due to hardware sleep\n            // those connections cannot be resumed\n            ((_c = (_b = this.pcManager) === null || _b === void 0 ? void 0 : _b.currentState) !== null && _c !== void 0 ? _c : PCTransportState.NEW) === PCTransportState.NEW) {\n                this.fullReconnectOnNext = true;\n            }\n            try {\n                this.attemptingReconnect = true;\n                if (this.fullReconnectOnNext) {\n                    yield this.restartConnection();\n                } else {\n                    yield this.resumeConnection(reason);\n                }\n                this.clearPendingReconnect();\n                this.fullReconnectOnNext = false;\n            } catch (e) {\n                this.reconnectAttempts += 1;\n                let recoverable = true;\n                if (e instanceof UnexpectedConnectionState) {\n                    this.log.debug('received unrecoverable error', Object.assign(Object.assign({}, this.logContext), {\n                        error: e\n                    }));\n                    // unrecoverable\n                    recoverable = false;\n                } else if (!(e instanceof SignalReconnectError)) {\n                    // cannot resume\n                    this.fullReconnectOnNext = true;\n                }\n                if (recoverable) {\n                    this.handleDisconnect('reconnect', ReconnectReason.RR_UNKNOWN);\n                } else {\n                    this.log.info(\"could not recover connection after \".concat(this.reconnectAttempts, \" attempts, \").concat(Date.now() - this.reconnectStart, \"ms. giving up\"), this.logContext);\n                    this.emit(EngineEvent.Disconnected);\n                    yield this.close();\n                }\n            } finally{\n                this.attemptingReconnect = false;\n            }\n        });\n    }\n    getNextRetryDelay(context) {\n        try {\n            return this.reconnectPolicy.nextRetryDelayInMs(context);\n        } catch (e) {\n            this.log.warn('encountered error in reconnect policy', Object.assign(Object.assign({}, this.logContext), {\n                error: e\n            }));\n        }\n        // error in user code with provided reconnect policy, stop reconnecting\n        return null;\n    }\n    restartConnection(regionUrl) {\n        var _a, _b, _c;\n        return __awaiter(this, void 0, void 0, function*() {\n            try {\n                if (!this.url || !this.token) {\n                    // permanent failure, don't attempt reconnection\n                    throw new UnexpectedConnectionState('could not reconnect, url or token not saved');\n                }\n                this.log.info(\"reconnecting, attempt: \".concat(this.reconnectAttempts), this.logContext);\n                this.emit(EngineEvent.Restarting);\n                if (!this.client.isDisconnected) {\n                    yield this.client.sendLeave();\n                }\n                yield this.cleanupPeerConnections();\n                yield this.cleanupClient();\n                let joinResponse;\n                try {\n                    if (!this.signalOpts) {\n                        this.log.warn('attempted connection restart, without signal options present', this.logContext);\n                        throw new SignalReconnectError();\n                    }\n                    // in case a regionUrl is passed, the region URL takes precedence\n                    joinResponse = yield this.join(regionUrl !== null && regionUrl !== void 0 ? regionUrl : this.url, this.token, this.signalOpts);\n                } catch (e) {\n                    if (e instanceof ConnectionError && e.reason === 0 /* ConnectionErrorReason.NotAllowed */ ) {\n                        throw new UnexpectedConnectionState('could not reconnect, token might be expired');\n                    }\n                    throw new SignalReconnectError();\n                }\n                if (this.shouldFailNext) {\n                    this.shouldFailNext = false;\n                    throw new Error('simulated failure');\n                }\n                this.client.setReconnected();\n                this.emit(EngineEvent.SignalRestarted, joinResponse);\n                yield this.waitForPCReconnected();\n                // re-check signal connection state before setting engine as resumed\n                if (this.client.currentState !== SignalConnectionState.CONNECTED) {\n                    throw new SignalReconnectError('Signal connection got severed during reconnect');\n                }\n                (_a = this.regionUrlProvider) === null || _a === void 0 ? void 0 : _a.resetAttempts();\n                // reconnect success\n                this.emit(EngineEvent.Restarted);\n            } catch (error) {\n                const nextRegionUrl = yield (_b = this.regionUrlProvider) === null || _b === void 0 ? void 0 : _b.getNextBestRegionUrl();\n                if (nextRegionUrl) {\n                    yield this.restartConnection(nextRegionUrl);\n                    return;\n                } else {\n                    // no more regions to try (or we're not on cloud)\n                    (_c = this.regionUrlProvider) === null || _c === void 0 ? void 0 : _c.resetAttempts();\n                    throw error;\n                }\n            }\n        });\n    }\n    resumeConnection(reason) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.url || !this.token) {\n                // permanent failure, don't attempt reconnection\n                throw new UnexpectedConnectionState('could not reconnect, url or token not saved');\n            }\n            // trigger publisher reconnect\n            if (!this.pcManager) {\n                throw new UnexpectedConnectionState('publisher and subscriber connections unset');\n            }\n            this.log.info(\"resuming signal connection, attempt \".concat(this.reconnectAttempts), this.logContext);\n            this.emit(EngineEvent.Resuming);\n            try {\n                this.setupSignalClientCallbacks();\n                const res = yield this.client.reconnect(this.url, this.token, this.participantSid, reason);\n                if (res) {\n                    const rtcConfig = this.makeRTCConfiguration(res);\n                    this.pcManager.updateConfiguration(rtcConfig);\n                }\n            } catch (error) {\n                let message = '';\n                if (error instanceof Error) {\n                    message = error.message;\n                    this.log.error(error.message, Object.assign(Object.assign({}, this.logContext), {\n                        error\n                    }));\n                }\n                if (error instanceof ConnectionError && error.reason === 0 /* ConnectionErrorReason.NotAllowed */ ) {\n                    throw new UnexpectedConnectionState('could not reconnect, token might be expired');\n                }\n                if (error instanceof ConnectionError && error.reason === 4 /* ConnectionErrorReason.LeaveRequest */ ) {\n                    throw error;\n                }\n                throw new SignalReconnectError(message);\n            }\n            this.emit(EngineEvent.SignalResumed);\n            if (this.shouldFailNext) {\n                this.shouldFailNext = false;\n                throw new Error('simulated failure');\n            }\n            yield this.pcManager.triggerIceRestart();\n            yield this.waitForPCReconnected();\n            // re-check signal connection state before setting engine as resumed\n            if (this.client.currentState !== SignalConnectionState.CONNECTED) {\n                throw new SignalReconnectError('Signal connection got severed during reconnect');\n            }\n            this.client.setReconnected();\n            // recreate publish datachannel if it's id is null\n            // (for safari https://bugs.webkit.org/show_bug.cgi?id=184688)\n            if (((_a = this.reliableDC) === null || _a === void 0 ? void 0 : _a.readyState) === 'open' && this.reliableDC.id === null) {\n                this.createDataChannels();\n            }\n            // resume success\n            this.emit(EngineEvent.Resumed);\n        });\n    }\n    waitForPCInitialConnection(timeout, abortController) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.pcManager) {\n                throw new UnexpectedConnectionState('PC manager is closed');\n            }\n            yield this.pcManager.ensurePCTransportConnection(abortController, timeout);\n        });\n    }\n    waitForPCReconnected() {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.pcState = PCState.Reconnecting;\n            this.log.debug('waiting for peer connection to reconnect', this.logContext);\n            try {\n                yield sleep(minReconnectWait); // FIXME setTimeout again not ideal for a connection critical path\n                if (!this.pcManager) {\n                    throw new UnexpectedConnectionState('PC manager is closed');\n                }\n                yield this.pcManager.ensurePCTransportConnection(undefined, this.peerConnectionTimeout);\n                this.pcState = PCState.Connected;\n            } catch (e) {\n                // TODO do we need a `failed` state here for the PC?\n                this.pcState = PCState.Disconnected;\n                throw new ConnectionError(\"could not establish PC connection, \".concat(e.message));\n            }\n        });\n    }\n    /* @internal */ sendDataPacket(packet, kind) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const msg = packet.toBinary();\n            // make sure we do have a data connection\n            yield this.ensurePublisherConnected(kind);\n            const dc = this.dataChannelForKind(kind);\n            if (dc) {\n                dc.send(msg);\n            }\n            this.updateAndEmitDCBufferStatus(kind);\n        });\n    }\n    /**\n   * @internal\n   */ ensureDataTransportConnected(kind) {\n        let subscriber = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.subscriberPrimary;\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.pcManager) {\n                throw new UnexpectedConnectionState('PC manager is closed');\n            }\n            const transport = subscriber ? this.pcManager.subscriber : this.pcManager.publisher;\n            const transportName = subscriber ? 'Subscriber' : 'Publisher';\n            if (!transport) {\n                throw new ConnectionError(\"\".concat(transportName, \" connection not set\"));\n            }\n            if (!subscriber && !this.pcManager.publisher.isICEConnected && this.pcManager.publisher.getICEConnectionState() !== 'checking') {\n                // start negotiation\n                this.negotiate();\n            }\n            const targetChannel = this.dataChannelForKind(kind, subscriber);\n            if ((targetChannel === null || targetChannel === void 0 ? void 0 : targetChannel.readyState) === 'open') {\n                return;\n            }\n            // wait until ICE connected\n            const endTime = new Date().getTime() + this.peerConnectionTimeout;\n            while(new Date().getTime() < endTime){\n                if (transport.isICEConnected && ((_a = this.dataChannelForKind(kind, subscriber)) === null || _a === void 0 ? void 0 : _a.readyState) === 'open') {\n                    return;\n                }\n                yield sleep(50);\n            }\n            throw new ConnectionError(\"could not establish \".concat(transportName, \" connection, state: \").concat(transport.getICEConnectionState()));\n        });\n    }\n    ensurePublisherConnected(kind) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.ensureDataTransportConnected(kind, false);\n        });\n    }\n    /* @internal */ verifyTransport() {\n        if (!this.pcManager) {\n            return false;\n        }\n        // primary connection\n        if (this.pcManager.currentState !== PCTransportState.CONNECTED) {\n            return false;\n        }\n        // ensure signal is connected\n        if (!this.client.ws || this.client.ws.readyState === WebSocket.CLOSED) {\n            return false;\n        }\n        return true;\n    }\n    /** @internal */ negotiate() {\n        return __awaiter(this, void 0, void 0, function*() {\n            // observe signal state\n            return new Promise((resolve, reject)=>__awaiter(this, void 0, void 0, function*() {\n                    if (!this.pcManager) {\n                        reject(new NegotiationError('PC manager is closed'));\n                        return;\n                    }\n                    this.pcManager.requirePublisher();\n                    const abortController = new AbortController();\n                    const handleClosed = ()=>{\n                        abortController.abort();\n                        this.log.debug('engine disconnected while negotiation was ongoing', this.logContext);\n                        resolve();\n                        return;\n                    };\n                    if (this.isClosed) {\n                        reject('cannot negotiate on closed engine');\n                    }\n                    this.on(EngineEvent.Closing, handleClosed);\n                    this.pcManager.publisher.once(PCEvents.RTPVideoPayloadTypes, (rtpTypes)=>{\n                        const rtpMap = new Map();\n                        rtpTypes.forEach((rtp)=>{\n                            const codec = rtp.codec.toLowerCase();\n                            if (isVideoCodec(codec)) {\n                                rtpMap.set(rtp.payload, codec);\n                            }\n                        });\n                        this.emit(EngineEvent.RTPVideoMapUpdate, rtpMap);\n                    });\n                    try {\n                        yield this.pcManager.negotiate(abortController);\n                        resolve();\n                    } catch (e) {\n                        if (e instanceof NegotiationError) {\n                            this.fullReconnectOnNext = true;\n                        }\n                        this.handleDisconnect('negotiation', ReconnectReason.RR_UNKNOWN);\n                        reject(e);\n                    } finally{\n                        this.off(EngineEvent.Closing, handleClosed);\n                    }\n                }));\n        });\n    }\n    dataChannelForKind(kind, sub) {\n        if (!sub) {\n            if (kind === DataPacket_Kind.LOSSY) {\n                return this.lossyDC;\n            }\n            if (kind === DataPacket_Kind.RELIABLE) {\n                return this.reliableDC;\n            }\n        } else {\n            if (kind === DataPacket_Kind.LOSSY) {\n                return this.lossyDCSub;\n            }\n            if (kind === DataPacket_Kind.RELIABLE) {\n                return this.reliableDCSub;\n            }\n        }\n    }\n    /** @internal */ sendSyncState(remoteTracks, localTracks) {\n        var _a, _b;\n        if (!this.pcManager) {\n            this.log.warn('sync state cannot be sent without peer connection setup', this.logContext);\n            return;\n        }\n        const previousAnswer = this.pcManager.subscriber.getLocalDescription();\n        const previousOffer = this.pcManager.subscriber.getRemoteDescription();\n        /* 1. autosubscribe on, so subscribed tracks = all tracks - unsub tracks,\n          in this case, we send unsub tracks, so server add all tracks to this\n          subscribe pc and unsub special tracks from it.\n       2. autosubscribe off, we send subscribed tracks.\n    */ const autoSubscribe = (_b = (_a = this.signalOpts) === null || _a === void 0 ? void 0 : _a.autoSubscribe) !== null && _b !== void 0 ? _b : true;\n        const trackSids = new Array();\n        remoteTracks.forEach((track)=>{\n            if (track.isDesired !== autoSubscribe) {\n                trackSids.push(track.trackSid);\n            }\n        });\n        this.client.sendSyncState(new SyncState({\n            answer: previousAnswer ? toProtoSessionDescription({\n                sdp: previousAnswer.sdp,\n                type: previousAnswer.type\n            }) : undefined,\n            offer: previousOffer ? toProtoSessionDescription({\n                sdp: previousOffer.sdp,\n                type: previousOffer.type\n            }) : undefined,\n            subscription: new UpdateSubscription({\n                trackSids,\n                subscribe: !autoSubscribe,\n                participantTracks: []\n            }),\n            publishTracks: getTrackPublicationInfo(localTracks),\n            dataChannels: this.dataChannelsInfo()\n        }));\n    }\n    /* @internal */ failNext() {\n        // debugging method to fail the next reconnect/resume attempt\n        this.shouldFailNext = true;\n    }\n    dataChannelsInfo() {\n        const infos = [];\n        const getInfo = (dc, target)=>{\n            if ((dc === null || dc === void 0 ? void 0 : dc.id) !== undefined && dc.id !== null) {\n                infos.push(new DataChannelInfo({\n                    label: dc.label,\n                    id: dc.id,\n                    target\n                }));\n            }\n        };\n        getInfo(this.dataChannelForKind(DataPacket_Kind.LOSSY), SignalTarget.PUBLISHER);\n        getInfo(this.dataChannelForKind(DataPacket_Kind.RELIABLE), SignalTarget.PUBLISHER);\n        getInfo(this.dataChannelForKind(DataPacket_Kind.LOSSY, true), SignalTarget.SUBSCRIBER);\n        getInfo(this.dataChannelForKind(DataPacket_Kind.RELIABLE, true), SignalTarget.SUBSCRIBER);\n        return infos;\n    }\n    clearReconnectTimeout() {\n        if (this.reconnectTimeout) {\n            CriticalTimers.clearTimeout(this.reconnectTimeout);\n        }\n    }\n    clearPendingReconnect() {\n        this.clearReconnectTimeout();\n        this.reconnectAttempts = 0;\n    }\n    registerOnLineListener() {\n        if (isWeb()) {\n            window.addEventListener('online', this.handleBrowserOnLine);\n        }\n    }\n    deregisterOnLineListener() {\n        if (isWeb()) {\n            window.removeEventListener('online', this.handleBrowserOnLine);\n        }\n    }\n}\nclass SignalReconnectError extends Error {\n}\nclass RegionUrlProvider {\n    constructor(url, token){\n        this.lastUpdateAt = 0;\n        this.settingsCacheTime = 3000;\n        this.attemptedRegions = [];\n        this.serverUrl = new URL(url);\n        this.token = token;\n    }\n    updateToken(token) {\n        this.token = token;\n    }\n    isCloud() {\n        return isCloud(this.serverUrl);\n    }\n    getServerUrl() {\n        return this.serverUrl;\n    }\n    getNextBestRegionUrl(abortSignal) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.isCloud()) {\n                throw Error('region availability is only supported for LiveKit Cloud domains');\n            }\n            if (!this.regionSettings || Date.now() - this.lastUpdateAt > this.settingsCacheTime) {\n                this.regionSettings = yield this.fetchRegionSettings(abortSignal);\n            }\n            const regionsLeft = this.regionSettings.regions.filter((region)=>!this.attemptedRegions.find((attempted)=>attempted.url === region.url));\n            if (regionsLeft.length > 0) {\n                const nextRegion = regionsLeft[0];\n                this.attemptedRegions.push(nextRegion);\n                livekitLogger.debug(\"next region: \".concat(nextRegion.region));\n                return nextRegion.url;\n            } else {\n                return null;\n            }\n        });\n    }\n    resetAttempts() {\n        this.attemptedRegions = [];\n    }\n    /* @internal */ fetchRegionSettings(signal) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const regionSettingsResponse = yield fetch(\"\".concat(getCloudConfigUrl(this.serverUrl), \"/regions\"), {\n                headers: {\n                    authorization: \"Bearer \".concat(this.token)\n                },\n                signal\n            });\n            if (regionSettingsResponse.ok) {\n                const regionSettings = yield regionSettingsResponse.json();\n                this.lastUpdateAt = Date.now();\n                return regionSettings;\n            } else {\n                throw new ConnectionError(\"Could not fetch region settings: \".concat(regionSettingsResponse.statusText), regionSettingsResponse.status === 401 ? 0 /* ConnectionErrorReason.NotAllowed */  : undefined, regionSettingsResponse.status);\n            }\n        });\n    }\n}\nfunction getCloudConfigUrl(serverUrl) {\n    return \"\".concat(serverUrl.protocol.replace('ws', 'http'), \"//\").concat(serverUrl.host, \"/settings\");\n}\nconst monitorFrequency = 2000;\nfunction computeBitrate(currentStats, prevStats) {\n    if (!prevStats) {\n        return 0;\n    }\n    let bytesNow;\n    let bytesPrev;\n    if ('bytesReceived' in currentStats) {\n        bytesNow = currentStats.bytesReceived;\n        bytesPrev = prevStats.bytesReceived;\n    } else if ('bytesSent' in currentStats) {\n        bytesNow = currentStats.bytesSent;\n        bytesPrev = prevStats.bytesSent;\n    }\n    if (bytesNow === undefined || bytesPrev === undefined || currentStats.timestamp === undefined || prevStats.timestamp === undefined) {\n        return 0;\n    }\n    return (bytesNow - bytesPrev) * 8 * 1000 / (currentStats.timestamp - prevStats.timestamp);\n}\nclass LocalAudioTrack extends LocalTrack {\n    /**\n   *\n   * @param mediaTrack\n   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks\n   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK\n   */ constructor(mediaTrack, constraints){\n        let userProvidedTrack = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n        let audioContext = arguments.length > 3 ? arguments[3] : undefined;\n        let loggerOptions = arguments.length > 4 ? arguments[4] : undefined;\n        super(mediaTrack, Track.Kind.Audio, constraints, userProvidedTrack, loggerOptions);\n        /** @internal */ this.stopOnMute = false;\n        this.monitorSender = ()=>__awaiter(this, void 0, void 0, function*() {\n                if (!this.sender) {\n                    this._currentBitrate = 0;\n                    return;\n                }\n                let stats;\n                try {\n                    stats = yield this.getSenderStats();\n                } catch (e) {\n                    this.log.error('could not get audio sender stats', Object.assign(Object.assign({}, this.logContext), {\n                        error: e\n                    }));\n                    return;\n                }\n                if (stats && this.prevStats) {\n                    this._currentBitrate = computeBitrate(stats, this.prevStats);\n                }\n                this.prevStats = stats;\n            });\n        this.audioContext = audioContext;\n        this.checkForSilence();\n    }\n    setDeviceId(deviceId) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this._constraints.deviceId === deviceId) {\n                return true;\n            }\n            this._constraints.deviceId = deviceId;\n            if (!this.isMuted) {\n                yield this.restartTrack();\n            }\n            return this.isMuted || unwrapConstraint(deviceId) === this.mediaStreamTrack.getSettings().deviceId;\n        });\n    }\n    mute() {\n        const _super = Object.create(null, {\n            mute: {\n                get: ()=>super.mute\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.muteLock.lock();\n            try {\n                // disabled special handling as it will cause BT headsets to switch communication modes\n                if (this.source === Track.Source.Microphone && this.stopOnMute && !this.isUserProvided) {\n                    this.log.debug('stopping mic track', this.logContext);\n                    // also stop the track, so that microphone indicator is turned off\n                    this._mediaStreamTrack.stop();\n                }\n                yield _super.mute.call(this);\n                return this;\n            } finally{\n                unlock();\n            }\n        });\n    }\n    unmute() {\n        const _super = Object.create(null, {\n            unmute: {\n                get: ()=>super.unmute\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.muteLock.lock();\n            try {\n                const deviceHasChanged = this._constraints.deviceId && this._mediaStreamTrack.getSettings().deviceId !== unwrapConstraint(this._constraints.deviceId);\n                if (this.source === Track.Source.Microphone && (this.stopOnMute || this._mediaStreamTrack.readyState === 'ended' || deviceHasChanged) && !this.isUserProvided) {\n                    this.log.debug('reacquiring mic track', this.logContext);\n                    yield this.restartTrack();\n                }\n                yield _super.unmute.call(this);\n                return this;\n            } finally{\n                unlock();\n            }\n        });\n    }\n    restartTrack(options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            let constraints;\n            if (options) {\n                const streamConstraints = constraintsForOptions({\n                    audio: options\n                });\n                if (typeof streamConstraints.audio !== 'boolean') {\n                    constraints = streamConstraints.audio;\n                }\n            }\n            yield this.restart(constraints);\n        });\n    }\n    restart(constraints) {\n        const _super = Object.create(null, {\n            restart: {\n                get: ()=>super.restart\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            const track = yield _super.restart.call(this, constraints);\n            this.checkForSilence();\n            return track;\n        });\n    }\n    /* @internal */ startMonitor() {\n        if (!isWeb()) {\n            return;\n        }\n        if (this.monitorInterval) {\n            return;\n        }\n        this.monitorInterval = setInterval(()=>{\n            this.monitorSender();\n        }, monitorFrequency);\n    }\n    setProcessor(processor) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.processorLock.lock();\n            try {\n                if (!this.audioContext) {\n                    throw Error('Audio context needs to be set on LocalAudioTrack in order to enable processors');\n                }\n                if (this.processor) {\n                    yield this.stopProcessor();\n                }\n                if (this.kind === 'unknown') {\n                    throw TypeError('cannot set processor on track of unknown kind');\n                }\n                const processorOptions = {\n                    kind: this.kind,\n                    track: this._mediaStreamTrack,\n                    audioContext: this.audioContext\n                };\n                this.log.debug(\"setting up audio processor \".concat(processor.name), this.logContext);\n                yield processor.init(processorOptions);\n                this.processor = processor;\n                if (this.processor.processedTrack) {\n                    yield (_a = this.sender) === null || _a === void 0 ? void 0 : _a.replaceTrack(this.processor.processedTrack);\n                }\n            } finally{\n                unlock();\n            }\n        });\n    }\n    /**\n   * @internal\n   * @experimental\n   */ setAudioContext(audioContext) {\n        this.audioContext = audioContext;\n    }\n    getSenderStats() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!((_a = this.sender) === null || _a === void 0 ? void 0 : _a.getStats)) {\n                return undefined;\n            }\n            const stats = yield this.sender.getStats();\n            let audioStats;\n            stats.forEach((v)=>{\n                if (v.type === 'outbound-rtp') {\n                    audioStats = {\n                        type: 'audio',\n                        streamId: v.id,\n                        packetsSent: v.packetsSent,\n                        packetsLost: v.packetsLost,\n                        bytesSent: v.bytesSent,\n                        timestamp: v.timestamp,\n                        roundTripTime: v.roundTripTime,\n                        jitter: v.jitter\n                    };\n                }\n            });\n            return audioStats;\n        });\n    }\n    checkForSilence() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const trackIsSilent = yield detectSilence(this);\n            if (trackIsSilent) {\n                if (!this.isMuted) {\n                    this.log.warn('silence detected on local audio track', this.logContext);\n                }\n                this.emit(TrackEvent.AudioSilenceDetected);\n            }\n            return trackIsSilent;\n        });\n    }\n}\n/** @internal */ function mediaTrackToLocalTrack(mediaStreamTrack, constraints, loggerOptions) {\n    switch(mediaStreamTrack.kind){\n        case 'audio':\n            return new LocalAudioTrack(mediaStreamTrack, constraints, false, undefined, loggerOptions);\n        case 'video':\n            return new LocalVideoTrack(mediaStreamTrack, constraints, false, loggerOptions);\n        default:\n            throw new TrackInvalidError(\"unsupported track type: \".concat(mediaStreamTrack.kind));\n    }\n}\n/* @internal */ const presets169 = Object.values(VideoPresets);\n/* @internal */ const presets43 = Object.values(VideoPresets43);\n/* @internal */ const presetsScreenShare = Object.values(ScreenSharePresets);\n/* @internal */ const defaultSimulcastPresets169 = [\n    VideoPresets.h180,\n    VideoPresets.h360\n];\n/* @internal */ const defaultSimulcastPresets43 = [\n    VideoPresets43.h180,\n    VideoPresets43.h360\n];\n/* @internal */ const computeDefaultScreenShareSimulcastPresets = (fromPreset)=>{\n    const layers = [\n        {\n            scaleResolutionDownBy: 2,\n            fps: fromPreset.encoding.maxFramerate\n        }\n    ];\n    return layers.map((t)=>{\n        var _a, _b;\n        return new VideoPreset(Math.floor(fromPreset.width / t.scaleResolutionDownBy), Math.floor(fromPreset.height / t.scaleResolutionDownBy), Math.max(150000, Math.floor(fromPreset.encoding.maxBitrate / (Math.pow(t.scaleResolutionDownBy, 2) * (((_a = fromPreset.encoding.maxFramerate) !== null && _a !== void 0 ? _a : 30) / ((_b = t.fps) !== null && _b !== void 0 ? _b : 30))))), t.fps, fromPreset.encoding.priority);\n    });\n};\n// /**\n//  *\n//  * @internal\n//  * @experimental\n//  */\n// const computeDefaultMultiCodecSimulcastEncodings = (width: number, height: number) => {\n//   // use vp8 as a default\n//   const vp8 = determineAppropriateEncoding(false, width, height);\n//   const vp9 = { ...vp8, maxBitrate: vp8.maxBitrate * 0.9 };\n//   const h264 = { ...vp8, maxBitrate: vp8.maxBitrate * 1.1 };\n//   const av1 = { ...vp8, maxBitrate: vp8.maxBitrate * 0.7 };\n//   return {\n//     vp8,\n//     vp9,\n//     h264,\n//     av1,\n//   };\n// };\nconst videoRids = [\n    'q',\n    'h',\n    'f'\n];\n/* @internal */ function computeVideoEncodings(isScreenShare, width, height, options) {\n    var _a, _b;\n    let videoEncoding = options === null || options === void 0 ? void 0 : options.videoEncoding;\n    if (isScreenShare) {\n        videoEncoding = options === null || options === void 0 ? void 0 : options.screenShareEncoding;\n    }\n    const useSimulcast = options === null || options === void 0 ? void 0 : options.simulcast;\n    const scalabilityMode = options === null || options === void 0 ? void 0 : options.scalabilityMode;\n    const videoCodec = options === null || options === void 0 ? void 0 : options.videoCodec;\n    if (!videoEncoding && !useSimulcast && !scalabilityMode || !width || !height) {\n        // when we aren't simulcasting or svc, will need to return a single encoding without\n        // capping bandwidth. we always require a encoding for dynacast\n        return [\n            {}\n        ];\n    }\n    if (!videoEncoding) {\n        // find the right encoding based on width/height\n        videoEncoding = determineAppropriateEncoding(isScreenShare, width, height, videoCodec);\n        livekitLogger.debug('using video encoding', videoEncoding);\n    }\n    const original = new VideoPreset(width, height, videoEncoding.maxBitrate, videoEncoding.maxFramerate, videoEncoding.priority);\n    if (scalabilityMode && isSVCCodec(videoCodec)) {\n        livekitLogger.debug(\"using svc with scalabilityMode \".concat(scalabilityMode));\n        const sm = new ScalabilityMode(scalabilityMode);\n        const encodings = [];\n        if (sm.spatial > 3) {\n            throw new Error(\"unsupported scalabilityMode: \".concat(scalabilityMode));\n        }\n        for(let i = 0; i < sm.spatial; i += 1){\n            encodings.push({\n                rid: videoRids[2 - i],\n                maxBitrate: videoEncoding.maxBitrate / Math.pow(3, i),\n                /* @ts-ignore */ maxFramerate: original.encoding.maxFramerate\n            });\n        }\n        /* @ts-ignore */ encodings[0].scalabilityMode = scalabilityMode;\n        livekitLogger.debug('encodings', encodings);\n        return encodings;\n    }\n    if (!useSimulcast) {\n        return [\n            videoEncoding\n        ];\n    }\n    let presets = [];\n    if (isScreenShare) {\n        presets = (_a = sortPresets(options === null || options === void 0 ? void 0 : options.screenShareSimulcastLayers)) !== null && _a !== void 0 ? _a : defaultSimulcastLayers(isScreenShare, original);\n    } else {\n        presets = (_b = sortPresets(options === null || options === void 0 ? void 0 : options.videoSimulcastLayers)) !== null && _b !== void 0 ? _b : defaultSimulcastLayers(isScreenShare, original);\n    }\n    let midPreset;\n    if (presets.length > 0) {\n        const lowPreset = presets[0];\n        if (presets.length > 1) {\n            [, midPreset] = presets;\n        }\n        // NOTE:\n        //   1. Ordering of these encodings is important. Chrome seems\n        //      to use the index into encodings to decide which layer\n        //      to disable when CPU constrained.\n        //      So encodings should be ordered in increasing spatial\n        //      resolution order.\n        //   2. ion-sfu translates rids into layers. So, all encodings\n        //      should have the base layer `q` and then more added\n        //      based on other conditions.\n        const size = Math.max(width, height);\n        if (size >= 960 && midPreset) {\n            return encodingsFromPresets(width, height, [\n                lowPreset,\n                midPreset,\n                original\n            ]);\n        }\n        if (size >= 480) {\n            return encodingsFromPresets(width, height, [\n                lowPreset,\n                original\n            ]);\n        }\n    }\n    return encodingsFromPresets(width, height, [\n        original\n    ]);\n}\nfunction computeTrackBackupEncodings(track, videoCodec, opts) {\n    var _a, _b, _c, _d;\n    // backupCodec should not be true anymore, default codec is set in LocalParticipant.publish\n    if (!opts.backupCodec || opts.backupCodec === true || opts.backupCodec.codec === opts.videoCodec) {\n        // backup codec publishing is disabled\n        return;\n    }\n    if (videoCodec !== opts.backupCodec.codec) {\n        livekitLogger.warn('requested a different codec than specified as backup', {\n            serverRequested: videoCodec,\n            backup: opts.backupCodec.codec\n        });\n    }\n    opts.videoCodec = videoCodec;\n    // use backup encoding setting as videoEncoding for backup codec publishing\n    opts.videoEncoding = opts.backupCodec.encoding;\n    const settings = track.mediaStreamTrack.getSettings();\n    const width = (_a = settings.width) !== null && _a !== void 0 ? _a : (_b = track.dimensions) === null || _b === void 0 ? void 0 : _b.width;\n    const height = (_c = settings.height) !== null && _c !== void 0 ? _c : (_d = track.dimensions) === null || _d === void 0 ? void 0 : _d.height;\n    const encodings = computeVideoEncodings(track.source === Track.Source.ScreenShare, width, height, opts);\n    return encodings;\n}\n/* @internal */ function determineAppropriateEncoding(isScreenShare, width, height, codec) {\n    const presets = presetsForResolution(isScreenShare, width, height);\n    let { encoding } = presets[0];\n    // handle portrait by swapping dimensions\n    const size = Math.max(width, height);\n    for(let i = 0; i < presets.length; i += 1){\n        const preset = presets[i];\n        encoding = preset.encoding;\n        if (preset.width >= size) {\n            break;\n        }\n    }\n    // presets are based on the assumption of vp8 as a codec\n    // for other codecs we adjust the maxBitrate if no specific videoEncoding has been provided\n    // users should override these with ones that are optimized for their use case\n    // NOTE: SVC codec bitrates are inclusive of all scalability layers. while\n    // bitrate for non-SVC codecs does not include other simulcast layers.\n    if (codec) {\n        switch(codec){\n            case 'av1':\n                encoding = Object.assign({}, encoding);\n                encoding.maxBitrate = encoding.maxBitrate * 0.7;\n                break;\n            case 'vp9':\n                encoding = Object.assign({}, encoding);\n                encoding.maxBitrate = encoding.maxBitrate * 0.85;\n                break;\n        }\n    }\n    return encoding;\n}\n/* @internal */ function presetsForResolution(isScreenShare, width, height) {\n    if (isScreenShare) {\n        return presetsScreenShare;\n    }\n    const aspect = width > height ? width / height : height / width;\n    if (Math.abs(aspect - 16.0 / 9) < Math.abs(aspect - 4.0 / 3)) {\n        return presets169;\n    }\n    return presets43;\n}\n/* @internal */ function defaultSimulcastLayers(isScreenShare, original) {\n    if (isScreenShare) {\n        return computeDefaultScreenShareSimulcastPresets(original);\n    }\n    const { width, height } = original;\n    const aspect = width > height ? width / height : height / width;\n    if (Math.abs(aspect - 16.0 / 9) < Math.abs(aspect - 4.0 / 3)) {\n        return defaultSimulcastPresets169;\n    }\n    return defaultSimulcastPresets43;\n}\n// presets should be ordered by low, medium, high\nfunction encodingsFromPresets(width, height, presets) {\n    const encodings = [];\n    presets.forEach((preset, idx)=>{\n        if (idx >= videoRids.length) {\n            return;\n        }\n        const size = Math.min(width, height);\n        const rid = videoRids[idx];\n        const encoding = {\n            rid,\n            scaleResolutionDownBy: Math.max(1, size / Math.min(preset.width, preset.height)),\n            maxBitrate: preset.encoding.maxBitrate\n        };\n        if (preset.encoding.maxFramerate) {\n            encoding.maxFramerate = preset.encoding.maxFramerate;\n        }\n        const canSetPriority = isFireFox() || idx === 0;\n        if (preset.encoding.priority && canSetPriority) {\n            encoding.priority = preset.encoding.priority;\n            encoding.networkPriority = preset.encoding.priority;\n        }\n        encodings.push(encoding);\n    });\n    // RN ios simulcast requires all same framerates.\n    if (isReactNative() && getReactNativeOs() === 'ios') {\n        let topFramerate = undefined;\n        encodings.forEach((encoding)=>{\n            if (!topFramerate) {\n                topFramerate = encoding.maxFramerate;\n            } else if (encoding.maxFramerate && encoding.maxFramerate > topFramerate) {\n                topFramerate = encoding.maxFramerate;\n            }\n        });\n        let notifyOnce = true;\n        encodings.forEach((encoding)=>{\n            var _a;\n            if (encoding.maxFramerate != topFramerate) {\n                if (notifyOnce) {\n                    notifyOnce = false;\n                    livekitLogger.info(\"Simulcast on iOS React-Native requires all encodings to share the same framerate.\");\n                }\n                livekitLogger.info(\"Setting framerate of encoding \\\"\".concat((_a = encoding.rid) !== null && _a !== void 0 ? _a : '', \"\\\" to \").concat(topFramerate));\n                encoding.maxFramerate = topFramerate;\n            }\n        });\n    }\n    return encodings;\n}\n/** @internal */ function sortPresets(presets) {\n    if (!presets) return;\n    return presets.sort((a, b)=>{\n        const { encoding: aEnc } = a;\n        const { encoding: bEnc } = b;\n        if (aEnc.maxBitrate > bEnc.maxBitrate) {\n            return 1;\n        }\n        if (aEnc.maxBitrate < bEnc.maxBitrate) return -1;\n        if (aEnc.maxBitrate === bEnc.maxBitrate && aEnc.maxFramerate && bEnc.maxFramerate) {\n            return aEnc.maxFramerate > bEnc.maxFramerate ? 1 : -1;\n        }\n        return 0;\n    });\n}\n/** @internal */ class ScalabilityMode {\n    constructor(scalabilityMode){\n        const results = scalabilityMode.match(/^L(\\d)T(\\d)(h|_KEY|_KEY_SHIFT){0,1}$/);\n        if (!results) {\n            throw new Error('invalid scalability mode');\n        }\n        this.spatial = parseInt(results[1]);\n        this.temporal = parseInt(results[2]);\n        if (results.length > 3) {\n            switch(results[3]){\n                case 'h':\n                case '_KEY':\n                case '_KEY_SHIFT':\n                    this.suffix = results[3];\n            }\n        }\n    }\n    toString() {\n        var _a;\n        return \"L\".concat(this.spatial, \"T\").concat(this.temporal).concat((_a = this.suffix) !== null && _a !== void 0 ? _a : '');\n    }\n}\nconst refreshSubscribedCodecAfterNewCodec = 5000;\nclass LocalVideoTrack extends LocalTrack {\n    /**\n   *\n   * @param mediaTrack\n   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks\n   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK\n   */ constructor(mediaTrack, constraints){\n        let userProvidedTrack = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n        let loggerOptions = arguments.length > 3 ? arguments[3] : undefined;\n        super(mediaTrack, Track.Kind.Video, constraints, userProvidedTrack, loggerOptions);\n        /* @internal */ this.simulcastCodecs = new Map();\n        this.monitorSender = ()=>__awaiter(this, void 0, void 0, function*() {\n                if (!this.sender) {\n                    this._currentBitrate = 0;\n                    return;\n                }\n                let stats;\n                try {\n                    stats = yield this.getSenderStats();\n                } catch (e) {\n                    this.log.error('could not get audio sender stats', Object.assign(Object.assign({}, this.logContext), {\n                        error: e\n                    }));\n                    return;\n                }\n                const statsMap = new Map(stats.map((s)=>[\n                        s.rid,\n                        s\n                    ]));\n                if (this.prevStats) {\n                    let totalBitrate = 0;\n                    statsMap.forEach((s, key)=>{\n                        var _a;\n                        const prev = (_a = this.prevStats) === null || _a === void 0 ? void 0 : _a.get(key);\n                        totalBitrate += computeBitrate(s, prev);\n                    });\n                    this._currentBitrate = totalBitrate;\n                }\n                this.prevStats = statsMap;\n            });\n        this.senderLock = new Mutex();\n    }\n    get isSimulcast() {\n        if (this.sender && this.sender.getParameters().encodings.length > 1) {\n            return true;\n        }\n        return false;\n    }\n    /* @internal */ startMonitor(signalClient) {\n        var _a;\n        this.signalClient = signalClient;\n        if (!isWeb()) {\n            return;\n        }\n        // save original encodings\n        // TODO : merge simulcast tracks stats\n        const params = (_a = this.sender) === null || _a === void 0 ? void 0 : _a.getParameters();\n        if (params) {\n            this.encodings = params.encodings;\n        }\n        if (this.monitorInterval) {\n            return;\n        }\n        this.monitorInterval = setInterval(()=>{\n            this.monitorSender();\n        }, monitorFrequency);\n    }\n    stop() {\n        this._mediaStreamTrack.getConstraints();\n        this.simulcastCodecs.forEach((trackInfo)=>{\n            trackInfo.mediaStreamTrack.stop();\n        });\n        super.stop();\n    }\n    pauseUpstream() {\n        const _super = Object.create(null, {\n            pauseUpstream: {\n                get: ()=>super.pauseUpstream\n            }\n        });\n        var _a, e_1, _b, _c;\n        var _d;\n        return __awaiter(this, void 0, void 0, function*() {\n            yield _super.pauseUpstream.call(this);\n            try {\n                for(var _e = true, _f = __asyncValues(this.simulcastCodecs.values()), _g; _g = yield _f.next(), _a = _g.done, !_a; _e = true){\n                    _c = _g.value;\n                    _e = false;\n                    const sc = _c;\n                    yield (_d = sc.sender) === null || _d === void 0 ? void 0 : _d.replaceTrack(null);\n                }\n            } catch (e_1_1) {\n                e_1 = {\n                    error: e_1_1\n                };\n            } finally{\n                try {\n                    if (!_e && !_a && (_b = _f.return)) yield _b.call(_f);\n                } finally{\n                    if (e_1) throw e_1.error;\n                }\n            }\n        });\n    }\n    resumeUpstream() {\n        const _super = Object.create(null, {\n            resumeUpstream: {\n                get: ()=>super.resumeUpstream\n            }\n        });\n        var _a, e_2, _b, _c;\n        var _d;\n        return __awaiter(this, void 0, void 0, function*() {\n            yield _super.resumeUpstream.call(this);\n            try {\n                for(var _e = true, _f = __asyncValues(this.simulcastCodecs.values()), _g; _g = yield _f.next(), _a = _g.done, !_a; _e = true){\n                    _c = _g.value;\n                    _e = false;\n                    const sc = _c;\n                    yield (_d = sc.sender) === null || _d === void 0 ? void 0 : _d.replaceTrack(sc.mediaStreamTrack);\n                }\n            } catch (e_2_1) {\n                e_2 = {\n                    error: e_2_1\n                };\n            } finally{\n                try {\n                    if (!_e && !_a && (_b = _f.return)) yield _b.call(_f);\n                } finally{\n                    if (e_2) throw e_2.error;\n                }\n            }\n        });\n    }\n    mute() {\n        const _super = Object.create(null, {\n            mute: {\n                get: ()=>super.mute\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.muteLock.lock();\n            try {\n                if (this.source === Track.Source.Camera && !this.isUserProvided) {\n                    this.log.debug('stopping camera track', this.logContext);\n                    // also stop the track, so that camera indicator is turned off\n                    this._mediaStreamTrack.stop();\n                }\n                yield _super.mute.call(this);\n                return this;\n            } finally{\n                unlock();\n            }\n        });\n    }\n    unmute() {\n        const _super = Object.create(null, {\n            unmute: {\n                get: ()=>super.unmute\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.muteLock.lock();\n            try {\n                if (this.source === Track.Source.Camera && !this.isUserProvided) {\n                    this.log.debug('reacquiring camera track', this.logContext);\n                    yield this.restartTrack();\n                }\n                yield _super.unmute.call(this);\n                return this;\n            } finally{\n                unlock();\n            }\n        });\n    }\n    setTrackMuted(muted) {\n        super.setTrackMuted(muted);\n        for (const sc of this.simulcastCodecs.values()){\n            sc.mediaStreamTrack.enabled = !muted;\n        }\n    }\n    getSenderStats() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!((_a = this.sender) === null || _a === void 0 ? void 0 : _a.getStats)) {\n                return [];\n            }\n            const items = [];\n            const stats = yield this.sender.getStats();\n            stats.forEach((v)=>{\n                var _a;\n                if (v.type === 'outbound-rtp') {\n                    const vs = {\n                        type: 'video',\n                        streamId: v.id,\n                        frameHeight: v.frameHeight,\n                        frameWidth: v.frameWidth,\n                        firCount: v.firCount,\n                        pliCount: v.pliCount,\n                        nackCount: v.nackCount,\n                        packetsSent: v.packetsSent,\n                        bytesSent: v.bytesSent,\n                        framesSent: v.framesSent,\n                        timestamp: v.timestamp,\n                        rid: (_a = v.rid) !== null && _a !== void 0 ? _a : v.id,\n                        retransmittedPacketsSent: v.retransmittedPacketsSent,\n                        qualityLimitationReason: v.qualityLimitationReason,\n                        qualityLimitationResolutionChanges: v.qualityLimitationResolutionChanges\n                    };\n                    //locate the appropriate remote-inbound-rtp item\n                    const r = stats.get(v.remoteId);\n                    if (r) {\n                        vs.jitter = r.jitter;\n                        vs.packetsLost = r.packetsLost;\n                        vs.roundTripTime = r.roundTripTime;\n                    }\n                    items.push(vs);\n                }\n            });\n            return items;\n        });\n    }\n    setPublishingQuality(maxQuality) {\n        const qualities = [];\n        for(let q = VideoQuality.LOW; q <= VideoQuality.HIGH; q += 1){\n            qualities.push(new SubscribedQuality({\n                quality: q,\n                enabled: q <= maxQuality\n            }));\n        }\n        this.log.debug(\"setting publishing quality. max quality \".concat(maxQuality), this.logContext);\n        this.setPublishingLayers(qualities);\n    }\n    setDeviceId(deviceId) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this._constraints.deviceId === deviceId && this._mediaStreamTrack.getSettings().deviceId === unwrapConstraint(deviceId)) {\n                return true;\n            }\n            this._constraints.deviceId = deviceId;\n            // when video is muted, underlying media stream track is stopped and\n            // will be restarted later\n            if (!this.isMuted) {\n                yield this.restartTrack();\n            }\n            return this.isMuted || unwrapConstraint(deviceId) === this._mediaStreamTrack.getSettings().deviceId;\n        });\n    }\n    restartTrack(options) {\n        var _a, e_3, _b, _c;\n        return __awaiter(this, void 0, void 0, function*() {\n            let constraints;\n            if (options) {\n                const streamConstraints = constraintsForOptions({\n                    video: options\n                });\n                if (typeof streamConstraints.video !== 'boolean') {\n                    constraints = streamConstraints.video;\n                }\n            }\n            yield this.restart(constraints);\n            try {\n                for(var _d = true, _e = __asyncValues(this.simulcastCodecs.values()), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true){\n                    _c = _f.value;\n                    _d = false;\n                    const sc = _c;\n                    if (sc.sender) {\n                        sc.mediaStreamTrack = this.mediaStreamTrack.clone();\n                        yield sc.sender.replaceTrack(sc.mediaStreamTrack);\n                    }\n                }\n            } catch (e_3_1) {\n                e_3 = {\n                    error: e_3_1\n                };\n            } finally{\n                try {\n                    if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);\n                } finally{\n                    if (e_3) throw e_3.error;\n                }\n            }\n        });\n    }\n    setProcessor(processor) {\n        let showProcessedStreamLocally = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        const _super = Object.create(null, {\n            setProcessor: {\n                get: ()=>super.setProcessor\n            }\n        });\n        var _a, e_4, _b, _c;\n        var _d, _e;\n        return __awaiter(this, void 0, void 0, function*() {\n            yield _super.setProcessor.call(this, processor, showProcessedStreamLocally);\n            if ((_d = this.processor) === null || _d === void 0 ? void 0 : _d.processedTrack) {\n                try {\n                    for(var _f = true, _g = __asyncValues(this.simulcastCodecs.values()), _h; _h = yield _g.next(), _a = _h.done, !_a; _f = true){\n                        _c = _h.value;\n                        _f = false;\n                        const sc = _c;\n                        yield (_e = sc.sender) === null || _e === void 0 ? void 0 : _e.replaceTrack(this.processor.processedTrack);\n                    }\n                } catch (e_4_1) {\n                    e_4 = {\n                        error: e_4_1\n                    };\n                } finally{\n                    try {\n                        if (!_f && !_a && (_b = _g.return)) yield _b.call(_g);\n                    } finally{\n                        if (e_4) throw e_4.error;\n                    }\n                }\n            }\n        });\n    }\n    addSimulcastTrack(codec, encodings) {\n        if (this.simulcastCodecs.has(codec)) {\n            throw new Error(\"\".concat(codec, \" already added\"));\n        }\n        const simulcastCodecInfo = {\n            codec,\n            mediaStreamTrack: this.mediaStreamTrack.clone(),\n            sender: undefined,\n            encodings\n        };\n        this.simulcastCodecs.set(codec, simulcastCodecInfo);\n        return simulcastCodecInfo;\n    }\n    setSimulcastTrackSender(codec, sender) {\n        const simulcastCodecInfo = this.simulcastCodecs.get(codec);\n        if (!simulcastCodecInfo) {\n            return;\n        }\n        simulcastCodecInfo.sender = sender;\n        // browser will reenable disabled codec/layers after new codec has been published,\n        // so refresh subscribedCodecs after publish a new codec\n        setTimeout(()=>{\n            if (this.subscribedCodecs) {\n                this.setPublishingCodecs(this.subscribedCodecs);\n            }\n        }, refreshSubscribedCodecAfterNewCodec);\n    }\n    /**\n   * @internal\n   * Sets codecs that should be publishing, returns new codecs that have not yet\n   * been published\n   */ setPublishingCodecs(codecs) {\n        var _a, codecs_1, codecs_1_1;\n        var _b, e_5, _c, _d;\n        return __awaiter(this, void 0, void 0, function*() {\n            this.log.debug('setting publishing codecs', Object.assign(Object.assign({}, this.logContext), {\n                codecs,\n                currentCodec: this.codec\n            }));\n            // only enable simulcast codec for preference codec setted\n            if (!this.codec && codecs.length > 0) {\n                yield this.setPublishingLayers(codecs[0].qualities);\n                return [];\n            }\n            this.subscribedCodecs = codecs;\n            const newCodecs = [];\n            try {\n                for(_a = true, codecs_1 = __asyncValues(codecs); codecs_1_1 = yield codecs_1.next(), _b = codecs_1_1.done, !_b; _a = true){\n                    _d = codecs_1_1.value;\n                    _a = false;\n                    const codec = _d;\n                    if (!this.codec || this.codec === codec.codec) {\n                        yield this.setPublishingLayers(codec.qualities);\n                    } else {\n                        const simulcastCodecInfo = this.simulcastCodecs.get(codec.codec);\n                        this.log.debug(\"try setPublishingCodec for \".concat(codec.codec), Object.assign(Object.assign({}, this.logContext), {\n                            simulcastCodecInfo\n                        }));\n                        if (!simulcastCodecInfo || !simulcastCodecInfo.sender) {\n                            for (const q of codec.qualities){\n                                if (q.enabled) {\n                                    newCodecs.push(codec.codec);\n                                    break;\n                                }\n                            }\n                        } else if (simulcastCodecInfo.encodings) {\n                            this.log.debug(\"try setPublishingLayersForSender \".concat(codec.codec), this.logContext);\n                            yield setPublishingLayersForSender(simulcastCodecInfo.sender, simulcastCodecInfo.encodings, codec.qualities, this.senderLock, this.log, this.logContext);\n                        }\n                    }\n                }\n            } catch (e_5_1) {\n                e_5 = {\n                    error: e_5_1\n                };\n            } finally{\n                try {\n                    if (!_a && !_b && (_c = codecs_1.return)) yield _c.call(codecs_1);\n                } finally{\n                    if (e_5) throw e_5.error;\n                }\n            }\n            return newCodecs;\n        });\n    }\n    /**\n   * @internal\n   * Sets layers that should be publishing\n   */ setPublishingLayers(qualities) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.log.debug('setting publishing layers', Object.assign(Object.assign({}, this.logContext), {\n                qualities\n            }));\n            if (!this.sender || !this.encodings) {\n                return;\n            }\n            yield setPublishingLayersForSender(this.sender, this.encodings, qualities, this.senderLock, this.log, this.logContext);\n        });\n    }\n    handleAppVisibilityChanged() {\n        const _super = Object.create(null, {\n            handleAppVisibilityChanged: {\n                get: ()=>super.handleAppVisibilityChanged\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            yield _super.handleAppVisibilityChanged.call(this);\n            if (!isMobile()) return;\n            if (this.isInBackground && this.source === Track.Source.Camera) {\n                this._mediaStreamTrack.enabled = false;\n            }\n        });\n    }\n}\nfunction setPublishingLayersForSender(sender, senderEncodings, qualities, senderLock, log, logContext) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const unlock = yield senderLock.lock();\n        log.debug('setPublishingLayersForSender', Object.assign(Object.assign({}, logContext), {\n            sender,\n            qualities,\n            senderEncodings\n        }));\n        try {\n            const params = sender.getParameters();\n            const { encodings } = params;\n            if (!encodings) {\n                return;\n            }\n            if (encodings.length !== senderEncodings.length) {\n                log.warn('cannot set publishing layers, encodings mismatch');\n                return;\n            }\n            let hasChanged = false;\n            /* disable closable spatial layer as it has video blur / frozen issue with current server / client\n      1. chrome 113: when switching to up layer with scalability Mode change, it will generate a\n            low resolution frame and recover very quickly, but noticable\n      2. livekit sfu: additional pli request cause video frozen for a few frames, also noticable */ const closableSpatial = false;\n            /* @ts-ignore */ if (closableSpatial && encodings[0].scalabilityMode) ;\n            else {\n                // simulcast dynacast encodings\n                encodings.forEach((encoding, idx)=>{\n                    var _a;\n                    let rid = (_a = encoding.rid) !== null && _a !== void 0 ? _a : '';\n                    if (rid === '') {\n                        rid = 'q';\n                    }\n                    const quality = videoQualityForRid(rid);\n                    const subscribedQuality = qualities.find((q)=>q.quality === quality);\n                    if (!subscribedQuality) {\n                        return;\n                    }\n                    if (encoding.active !== subscribedQuality.enabled) {\n                        hasChanged = true;\n                        encoding.active = subscribedQuality.enabled;\n                        log.debug(\"setting layer \".concat(subscribedQuality.quality, \" to \").concat(encoding.active ? 'enabled' : 'disabled'), logContext);\n                        // FireFox does not support setting encoding.active to false, so we\n                        // have a workaround of lowering its bitrate and resolution to the min.\n                        if (isFireFox()) {\n                            if (subscribedQuality.enabled) {\n                                encoding.scaleResolutionDownBy = senderEncodings[idx].scaleResolutionDownBy;\n                                encoding.maxBitrate = senderEncodings[idx].maxBitrate;\n                                /* @ts-ignore */ encoding.maxFrameRate = senderEncodings[idx].maxFrameRate;\n                            } else {\n                                encoding.scaleResolutionDownBy = 4;\n                                encoding.maxBitrate = 10;\n                                /* @ts-ignore */ encoding.maxFrameRate = 2;\n                            }\n                        }\n                    }\n                });\n            }\n            if (hasChanged) {\n                params.encodings = encodings;\n                log.debug(\"setting encodings\", Object.assign(Object.assign({}, logContext), {\n                    encodings: params.encodings\n                }));\n                yield sender.setParameters(params);\n            }\n        } finally{\n            unlock();\n        }\n    });\n}\nfunction videoQualityForRid(rid) {\n    switch(rid){\n        case 'f':\n            return VideoQuality.HIGH;\n        case 'h':\n            return VideoQuality.MEDIUM;\n        case 'q':\n            return VideoQuality.LOW;\n        default:\n            return VideoQuality.HIGH;\n    }\n}\nfunction videoLayersFromEncodings(width, height, encodings, svc) {\n    // default to a single layer, HQ\n    if (!encodings) {\n        return [\n            new VideoLayer({\n                quality: VideoQuality.HIGH,\n                width,\n                height,\n                bitrate: 0,\n                ssrc: 0\n            })\n        ];\n    }\n    if (svc) {\n        // svc layers\n        /* @ts-ignore */ const encodingSM = encodings[0].scalabilityMode;\n        const sm = new ScalabilityMode(encodingSM);\n        const layers = [];\n        for(let i = 0; i < sm.spatial; i += 1){\n            layers.push(new VideoLayer({\n                quality: VideoQuality.HIGH - i,\n                width: Math.ceil(width / Math.pow(2, i)),\n                height: Math.ceil(height / Math.pow(2, i)),\n                bitrate: encodings[0].maxBitrate ? Math.ceil(encodings[0].maxBitrate / Math.pow(3, i)) : 0,\n                ssrc: 0\n            }));\n        }\n        return layers;\n    }\n    return encodings.map((encoding)=>{\n        var _a, _b, _c;\n        const scale = (_a = encoding.scaleResolutionDownBy) !== null && _a !== void 0 ? _a : 1;\n        let quality = videoQualityForRid((_b = encoding.rid) !== null && _b !== void 0 ? _b : '');\n        return new VideoLayer({\n            quality,\n            width: Math.ceil(width / scale),\n            height: Math.ceil(height / scale),\n            bitrate: (_c = encoding.maxBitrate) !== null && _c !== void 0 ? _c : 0,\n            ssrc: 0\n        });\n    });\n}\nclass RemoteTrack extends Track {\n    constructor(mediaTrack, sid, kind, receiver, loggerOptions){\n        super(mediaTrack, kind, loggerOptions);\n        this.sid = sid;\n        this.receiver = receiver;\n    }\n    /** @internal */ setMuted(muted) {\n        if (this.isMuted !== muted) {\n            this.isMuted = muted;\n            this._mediaStreamTrack.enabled = !muted;\n            this.emit(muted ? TrackEvent.Muted : TrackEvent.Unmuted, this);\n        }\n    }\n    /** @internal */ setMediaStream(stream) {\n        // this is needed to determine when the track is finished\n        this.mediaStream = stream;\n        const onRemoveTrack = (event)=>{\n            if (event.track === this._mediaStreamTrack) {\n                stream.removeEventListener('removetrack', onRemoveTrack);\n                this.receiver = undefined;\n                this._currentBitrate = 0;\n                this.emit(TrackEvent.Ended, this);\n            }\n        };\n        stream.addEventListener('removetrack', onRemoveTrack);\n    }\n    start() {\n        this.startMonitor();\n        // use `enabled` of track to enable re-use of transceiver\n        super.enable();\n    }\n    stop() {\n        this.stopMonitor();\n        // use `enabled` of track to enable re-use of transceiver\n        super.disable();\n    }\n    /**\n   * Gets the RTCStatsReport for the RemoteTrack's underlying RTCRtpReceiver\n   * See https://developer.mozilla.org/en-US/docs/Web/API/RTCStatsReport\n   *\n   * @returns Promise<RTCStatsReport> | undefined\n   */ getRTCStatsReport() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!((_a = this.receiver) === null || _a === void 0 ? void 0 : _a.getStats)) {\n                return;\n            }\n            const statsReport = yield this.receiver.getStats();\n            return statsReport;\n        });\n    }\n    /* @internal */ startMonitor() {\n        if (!this.monitorInterval) {\n            this.monitorInterval = setInterval(()=>this.monitorReceiver(), monitorFrequency);\n        }\n    }\n}\nclass RemoteAudioTrack extends RemoteTrack {\n    constructor(mediaTrack, sid, receiver, audioContext, audioOutput, loggerOptions){\n        super(mediaTrack, sid, Track.Kind.Audio, receiver, loggerOptions);\n        this.monitorReceiver = ()=>__awaiter(this, void 0, void 0, function*() {\n                if (!this.receiver) {\n                    this._currentBitrate = 0;\n                    return;\n                }\n                const stats = yield this.getReceiverStats();\n                if (stats && this.prevStats && this.receiver) {\n                    this._currentBitrate = computeBitrate(stats, this.prevStats);\n                }\n                this.prevStats = stats;\n            });\n        this.audioContext = audioContext;\n        this.webAudioPluginNodes = [];\n        if (audioOutput) {\n            this.sinkId = audioOutput.deviceId;\n        }\n    }\n    /**\n   * sets the volume for all attached audio elements\n   */ setVolume(volume) {\n        var _a;\n        for (const el of this.attachedElements){\n            if (this.audioContext) {\n                (_a = this.gainNode) === null || _a === void 0 ? void 0 : _a.gain.setTargetAtTime(volume, 0, 0.1);\n            } else {\n                el.volume = volume;\n            }\n        }\n        if (isReactNative()) {\n            // @ts-ignore\n            this._mediaStreamTrack._setVolume(volume);\n        }\n        this.elementVolume = volume;\n    }\n    /**\n   * gets the volume of attached audio elements (loudest)\n   */ getVolume() {\n        if (this.elementVolume) {\n            return this.elementVolume;\n        }\n        if (isReactNative()) {\n            // RN volume value defaults to 1.0 if hasn't been changed.\n            return 1.0;\n        }\n        let highestVolume = 0;\n        this.attachedElements.forEach((element)=>{\n            if (element.volume > highestVolume) {\n                highestVolume = element.volume;\n            }\n        });\n        return highestVolume;\n    }\n    /**\n   * calls setSinkId on all attached elements, if supported\n   * @param deviceId audio output device\n   */ setSinkId(deviceId) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.sinkId = deviceId;\n            yield Promise.all(this.attachedElements.map((elm)=>{\n                if (!supportsSetSinkId(elm)) {\n                    return;\n                }\n                /* @ts-ignore */ return elm.setSinkId(deviceId);\n            }));\n        });\n    }\n    attach(element) {\n        const needsNewWebAudioConnection = this.attachedElements.length === 0;\n        if (!element) {\n            element = super.attach();\n        } else {\n            super.attach(element);\n        }\n        if (this.sinkId && supportsSetSinkId(element)) {\n            /* @ts-ignore */ element.setSinkId(this.sinkId);\n        }\n        if (this.audioContext && needsNewWebAudioConnection) {\n            this.log.debug('using audio context mapping', this.logContext);\n            this.connectWebAudio(this.audioContext, element);\n            element.volume = 0;\n            element.muted = true;\n        }\n        if (this.elementVolume) {\n            // make sure volume setting is being applied to the newly attached element\n            this.setVolume(this.elementVolume);\n        }\n        return element;\n    }\n    detach(element) {\n        let detached;\n        if (!element) {\n            detached = super.detach();\n            this.disconnectWebAudio();\n        } else {\n            detached = super.detach(element);\n            // if there are still any attached elements after detaching, connect webaudio to the first element that's left\n            // disconnect webaudio otherwise\n            if (this.audioContext) {\n                if (this.attachedElements.length > 0) {\n                    this.connectWebAudio(this.audioContext, this.attachedElements[0]);\n                } else {\n                    this.disconnectWebAudio();\n                }\n            }\n        }\n        return detached;\n    }\n    /**\n   * @internal\n   * @experimental\n   */ setAudioContext(audioContext) {\n        this.audioContext = audioContext;\n        if (audioContext && this.attachedElements.length > 0) {\n            this.connectWebAudio(audioContext, this.attachedElements[0]);\n        } else if (!audioContext) {\n            this.disconnectWebAudio();\n        }\n    }\n    /**\n   * @internal\n   * @experimental\n   * @param {AudioNode[]} nodes - An array of WebAudio nodes. These nodes should not be connected to each other when passed, as the sdk will take care of connecting them in the order of the array.\n   */ setWebAudioPlugins(nodes) {\n        this.webAudioPluginNodes = nodes;\n        if (this.attachedElements.length > 0 && this.audioContext) {\n            this.connectWebAudio(this.audioContext, this.attachedElements[0]);\n        }\n    }\n    connectWebAudio(context, element) {\n        this.disconnectWebAudio();\n        // @ts-ignore attached elements always have a srcObject set\n        this.sourceNode = context.createMediaStreamSource(element.srcObject);\n        let lastNode = this.sourceNode;\n        this.webAudioPluginNodes.forEach((node)=>{\n            lastNode.connect(node);\n            lastNode = node;\n        });\n        this.gainNode = context.createGain();\n        lastNode.connect(this.gainNode);\n        this.gainNode.connect(context.destination);\n        if (this.elementVolume) {\n            this.gainNode.gain.setTargetAtTime(this.elementVolume, 0, 0.1);\n        }\n        // try to resume the context if it isn't running already\n        if (context.state !== 'running') {\n            context.resume().then(()=>{\n                if (context.state !== 'running') {\n                    this.emit(TrackEvent.AudioPlaybackFailed, new Error(\"Audio Context couldn't be started automatically\"));\n                }\n            }).catch((e)=>{\n                this.emit(TrackEvent.AudioPlaybackFailed, e);\n            });\n        }\n    }\n    disconnectWebAudio() {\n        var _a, _b;\n        (_a = this.gainNode) === null || _a === void 0 ? void 0 : _a.disconnect();\n        (_b = this.sourceNode) === null || _b === void 0 ? void 0 : _b.disconnect();\n        this.gainNode = undefined;\n        this.sourceNode = undefined;\n    }\n    getReceiverStats() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.receiver || !this.receiver.getStats) {\n                return;\n            }\n            const stats = yield this.receiver.getStats();\n            let receiverStats;\n            stats.forEach((v)=>{\n                if (v.type === 'inbound-rtp') {\n                    receiverStats = {\n                        type: 'audio',\n                        timestamp: v.timestamp,\n                        jitter: v.jitter,\n                        bytesReceived: v.bytesReceived,\n                        concealedSamples: v.concealedSamples,\n                        concealmentEvents: v.concealmentEvents,\n                        silentConcealedSamples: v.silentConcealedSamples,\n                        silentConcealmentEvents: v.silentConcealmentEvents,\n                        totalAudioEnergy: v.totalAudioEnergy,\n                        totalSamplesDuration: v.totalSamplesDuration\n                    };\n                }\n            });\n            return receiverStats;\n        });\n    }\n}\nconst REACTION_DELAY = 100;\nclass RemoteVideoTrack extends RemoteTrack {\n    constructor(mediaTrack, sid, receiver, adaptiveStreamSettings, loggerOptions){\n        super(mediaTrack, sid, Track.Kind.Video, receiver, loggerOptions);\n        this.elementInfos = [];\n        this.monitorReceiver = ()=>__awaiter(this, void 0, void 0, function*() {\n                if (!this.receiver) {\n                    this._currentBitrate = 0;\n                    return;\n                }\n                const stats = yield this.getReceiverStats();\n                if (stats && this.prevStats && this.receiver) {\n                    this._currentBitrate = computeBitrate(stats, this.prevStats);\n                }\n                this.prevStats = stats;\n            });\n        this.debouncedHandleResize = r(()=>{\n            this.updateDimensions();\n        }, REACTION_DELAY);\n        this.adaptiveStreamSettings = adaptiveStreamSettings;\n    }\n    get isAdaptiveStream() {\n        return this.adaptiveStreamSettings !== undefined;\n    }\n    /**\n   * Note: When using adaptiveStream, you need to use remoteVideoTrack.attach() to add the track to a HTMLVideoElement, otherwise your video tracks might never start\n   */ get mediaStreamTrack() {\n        return this._mediaStreamTrack;\n    }\n    /** @internal */ setMuted(muted) {\n        super.setMuted(muted);\n        this.attachedElements.forEach((element)=>{\n            // detach or attach\n            if (muted) {\n                detachTrack(this._mediaStreamTrack, element);\n            } else {\n                attachToElement(this._mediaStreamTrack, element);\n            }\n        });\n    }\n    attach(element) {\n        if (!element) {\n            element = super.attach();\n        } else {\n            super.attach(element);\n        }\n        // It's possible attach is called multiple times on an element. When that's\n        // the case, we'd want to avoid adding duplicate elementInfos\n        if (this.adaptiveStreamSettings && this.elementInfos.find((info)=>info.element === element) === undefined) {\n            const elementInfo = new HTMLElementInfo(element);\n            this.observeElementInfo(elementInfo);\n        }\n        return element;\n    }\n    /**\n   * Observe an ElementInfo for changes when adaptive streaming.\n   * @param elementInfo\n   * @internal\n   */ observeElementInfo(elementInfo) {\n        if (this.adaptiveStreamSettings && this.elementInfos.find((info)=>info === elementInfo) === undefined) {\n            elementInfo.handleResize = ()=>{\n                this.debouncedHandleResize();\n            };\n            elementInfo.handleVisibilityChanged = ()=>{\n                this.updateVisibility();\n            };\n            this.elementInfos.push(elementInfo);\n            elementInfo.observe();\n            // trigger the first resize update cycle\n            // if the tab is backgrounded, the initial resize event does not fire until\n            // the tab comes into focus for the first time.\n            this.debouncedHandleResize();\n            this.updateVisibility();\n        } else {\n            this.log.warn('visibility resize observer not triggered', this.logContext);\n        }\n    }\n    /**\n   * Stop observing an ElementInfo for changes.\n   * @param elementInfo\n   * @internal\n   */ stopObservingElementInfo(elementInfo) {\n        if (!this.isAdaptiveStream) {\n            this.log.warn('stopObservingElementInfo ignored', this.logContext);\n            return;\n        }\n        const stopElementInfos = this.elementInfos.filter((info)=>info === elementInfo);\n        for (const info of stopElementInfos){\n            info.stopObserving();\n        }\n        this.elementInfos = this.elementInfos.filter((info)=>info !== elementInfo);\n        this.updateVisibility();\n        this.debouncedHandleResize();\n    }\n    detach(element) {\n        let detachedElements = [];\n        if (element) {\n            this.stopObservingElement(element);\n            return super.detach(element);\n        }\n        detachedElements = super.detach();\n        for (const e of detachedElements){\n            this.stopObservingElement(e);\n        }\n        return detachedElements;\n    }\n    /** @internal */ getDecoderImplementation() {\n        var _a;\n        return (_a = this.prevStats) === null || _a === void 0 ? void 0 : _a.decoderImplementation;\n    }\n    getReceiverStats() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.receiver || !this.receiver.getStats) {\n                return;\n            }\n            const stats = yield this.receiver.getStats();\n            let receiverStats;\n            let codecID = '';\n            let codecs = new Map();\n            stats.forEach((v)=>{\n                if (v.type === 'inbound-rtp') {\n                    codecID = v.codecId;\n                    receiverStats = {\n                        type: 'video',\n                        framesDecoded: v.framesDecoded,\n                        framesDropped: v.framesDropped,\n                        framesReceived: v.framesReceived,\n                        packetsReceived: v.packetsReceived,\n                        packetsLost: v.packetsLost,\n                        frameWidth: v.frameWidth,\n                        frameHeight: v.frameHeight,\n                        pliCount: v.pliCount,\n                        firCount: v.firCount,\n                        nackCount: v.nackCount,\n                        jitter: v.jitter,\n                        timestamp: v.timestamp,\n                        bytesReceived: v.bytesReceived,\n                        decoderImplementation: v.decoderImplementation\n                    };\n                } else if (v.type === 'codec') {\n                    codecs.set(v.id, v);\n                }\n            });\n            if (receiverStats && codecID !== '' && codecs.get(codecID)) {\n                receiverStats.mimeType = codecs.get(codecID).mimeType;\n            }\n            return receiverStats;\n        });\n    }\n    stopObservingElement(element) {\n        const stopElementInfos = this.elementInfos.filter((info)=>info.element === element);\n        for (const info of stopElementInfos){\n            this.stopObservingElementInfo(info);\n        }\n    }\n    handleAppVisibilityChanged() {\n        const _super = Object.create(null, {\n            handleAppVisibilityChanged: {\n                get: ()=>super.handleAppVisibilityChanged\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            yield _super.handleAppVisibilityChanged.call(this);\n            if (!this.isAdaptiveStream) return;\n            this.updateVisibility();\n        });\n    }\n    updateVisibility() {\n        var _a, _b;\n        const lastVisibilityChange = this.elementInfos.reduce((prev, info)=>Math.max(prev, info.visibilityChangedAt || 0), 0);\n        const backgroundPause = ((_b = (_a = this.adaptiveStreamSettings) === null || _a === void 0 ? void 0 : _a.pauseVideoInBackground) !== null && _b !== void 0 ? _b : true // default to true\n        ) ? this.isInBackground : false;\n        const isPiPMode = this.elementInfos.some((info)=>info.pictureInPicture);\n        const isVisible = this.elementInfos.some((info)=>info.visible) && !backgroundPause || isPiPMode;\n        if (this.lastVisible === isVisible) {\n            return;\n        }\n        if (!isVisible && Date.now() - lastVisibilityChange < REACTION_DELAY) {\n            // delay hidden events\n            CriticalTimers.setTimeout(()=>{\n                this.updateVisibility();\n            }, REACTION_DELAY);\n            return;\n        }\n        this.lastVisible = isVisible;\n        this.emit(TrackEvent.VisibilityChanged, isVisible, this);\n    }\n    updateDimensions() {\n        var _a, _b;\n        let maxWidth = 0;\n        let maxHeight = 0;\n        const pixelDensity = this.getPixelDensity();\n        for (const info of this.elementInfos){\n            const currentElementWidth = info.width() * pixelDensity;\n            const currentElementHeight = info.height() * pixelDensity;\n            if (currentElementWidth + currentElementHeight > maxWidth + maxHeight) {\n                maxWidth = currentElementWidth;\n                maxHeight = currentElementHeight;\n            }\n        }\n        if (((_a = this.lastDimensions) === null || _a === void 0 ? void 0 : _a.width) === maxWidth && ((_b = this.lastDimensions) === null || _b === void 0 ? void 0 : _b.height) === maxHeight) {\n            return;\n        }\n        this.lastDimensions = {\n            width: maxWidth,\n            height: maxHeight\n        };\n        this.emit(TrackEvent.VideoDimensionsChanged, this.lastDimensions, this);\n    }\n    getPixelDensity() {\n        var _a;\n        const pixelDensity = (_a = this.adaptiveStreamSettings) === null || _a === void 0 ? void 0 : _a.pixelDensity;\n        if (pixelDensity === 'screen') {\n            return getDevicePixelRatio();\n        } else if (!pixelDensity) {\n            // when unset, we'll pick a sane default here.\n            // for higher pixel density devices (mobile phones, etc), we'll use 2\n            // otherwise it defaults to 1\n            const devicePixelRatio = getDevicePixelRatio();\n            if (devicePixelRatio > 2) {\n                return 2;\n            } else {\n                return 1;\n            }\n        }\n        return pixelDensity;\n    }\n}\nclass HTMLElementInfo {\n    get visible() {\n        return this.isPiP || this.isIntersecting;\n    }\n    get pictureInPicture() {\n        return this.isPiP;\n    }\n    constructor(element, visible){\n        this.onVisibilityChanged = (entry)=>{\n            var _a;\n            const { target, isIntersecting } = entry;\n            if (target === this.element) {\n                this.isIntersecting = isIntersecting;\n                this.visibilityChangedAt = Date.now();\n                (_a = this.handleVisibilityChanged) === null || _a === void 0 ? void 0 : _a.call(this);\n            }\n        };\n        this.onEnterPiP = ()=>{\n            var _a;\n            this.isPiP = true;\n            (_a = this.handleVisibilityChanged) === null || _a === void 0 ? void 0 : _a.call(this);\n        };\n        this.onLeavePiP = ()=>{\n            var _a;\n            this.isPiP = false;\n            (_a = this.handleVisibilityChanged) === null || _a === void 0 ? void 0 : _a.call(this);\n        };\n        this.element = element;\n        this.isIntersecting = visible !== null && visible !== void 0 ? visible : isElementInViewport(element);\n        this.isPiP = isWeb() && document.pictureInPictureElement === element;\n        this.visibilityChangedAt = 0;\n    }\n    width() {\n        return this.element.clientWidth;\n    }\n    height() {\n        return this.element.clientHeight;\n    }\n    observe() {\n        // make sure we update the current visible state once we start to observe\n        this.isIntersecting = isElementInViewport(this.element);\n        this.isPiP = document.pictureInPictureElement === this.element;\n        this.element.handleResize = ()=>{\n            var _a;\n            (_a = this.handleResize) === null || _a === void 0 ? void 0 : _a.call(this);\n        };\n        this.element.handleVisibilityChanged = this.onVisibilityChanged;\n        getIntersectionObserver().observe(this.element);\n        getResizeObserver().observe(this.element);\n        this.element.addEventListener('enterpictureinpicture', this.onEnterPiP);\n        this.element.addEventListener('leavepictureinpicture', this.onLeavePiP);\n    }\n    stopObserving() {\n        var _a, _b;\n        (_a = getIntersectionObserver()) === null || _a === void 0 ? void 0 : _a.unobserve(this.element);\n        (_b = getResizeObserver()) === null || _b === void 0 ? void 0 : _b.unobserve(this.element);\n        this.element.removeEventListener('enterpictureinpicture', this.onEnterPiP);\n        this.element.removeEventListener('leavepictureinpicture', this.onLeavePiP);\n    }\n}\n// does not account for occlusion by other elements\nfunction isElementInViewport(el) {\n    let top = el.offsetTop;\n    let left = el.offsetLeft;\n    const width = el.offsetWidth;\n    const height = el.offsetHeight;\n    const { hidden } = el;\n    const { opacity, display } = getComputedStyle(el);\n    while(el.offsetParent){\n        el = el.offsetParent;\n        top += el.offsetTop;\n        left += el.offsetLeft;\n    }\n    return top < window.pageYOffset + window.innerHeight && left < window.pageXOffset + window.innerWidth && top + height > window.pageYOffset && left + width > window.pageXOffset && !hidden && (opacity !== '' ? parseFloat(opacity) > 0 : true) && display !== 'none';\n}\nclass TrackPublication extends eventsExports.EventEmitter {\n    constructor(kind, id, name, loggerOptions){\n        var _a;\n        super();\n        this.metadataMuted = false;\n        this.encryption = Encryption_Type.NONE;\n        this.log = livekitLogger;\n        this.handleMuted = ()=>{\n            this.emit(TrackEvent.Muted);\n        };\n        this.handleUnmuted = ()=>{\n            this.emit(TrackEvent.Unmuted);\n        };\n        this.log = getLogger((_a = loggerOptions === null || loggerOptions === void 0 ? void 0 : loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Publication);\n        this.loggerContextCb = this.loggerContextCb;\n        this.setMaxListeners(100);\n        this.kind = kind;\n        this.trackSid = id;\n        this.trackName = name;\n        this.source = Track.Source.Unknown;\n    }\n    /** @internal */ setTrack(track) {\n        if (this.track) {\n            this.track.off(TrackEvent.Muted, this.handleMuted);\n            this.track.off(TrackEvent.Unmuted, this.handleUnmuted);\n        }\n        this.track = track;\n        if (track) {\n            // forward events\n            track.on(TrackEvent.Muted, this.handleMuted);\n            track.on(TrackEvent.Unmuted, this.handleUnmuted);\n        }\n    }\n    get logContext() {\n        var _a;\n        return Object.assign(Object.assign({}, (_a = this.loggerContextCb) === null || _a === void 0 ? void 0 : _a.call(this)), getLogContextFromTrack(this));\n    }\n    get isMuted() {\n        return this.metadataMuted;\n    }\n    get isEnabled() {\n        return true;\n    }\n    get isSubscribed() {\n        return this.track !== undefined;\n    }\n    get isEncrypted() {\n        return this.encryption !== Encryption_Type.NONE;\n    }\n    /**\n   * an [AudioTrack] if this publication holds an audio track\n   */ get audioTrack() {\n        if (this.track instanceof LocalAudioTrack || this.track instanceof RemoteAudioTrack) {\n            return this.track;\n        }\n    }\n    /**\n   * an [VideoTrack] if this publication holds a video track\n   */ get videoTrack() {\n        if (this.track instanceof LocalVideoTrack || this.track instanceof RemoteVideoTrack) {\n            return this.track;\n        }\n    }\n    /** @internal */ updateInfo(info) {\n        this.trackSid = info.sid;\n        this.trackName = info.name;\n        this.source = Track.sourceFromProto(info.source);\n        this.mimeType = info.mimeType;\n        if (this.kind === Track.Kind.Video && info.width > 0) {\n            this.dimensions = {\n                width: info.width,\n                height: info.height\n            };\n            this.simulcasted = info.simulcast;\n        }\n        this.encryption = info.encryption;\n        this.trackInfo = info;\n        this.log.debug('update publication info', Object.assign(Object.assign({}, this.logContext), {\n            info\n        }));\n    }\n}\n(function(TrackPublication) {\n    (function(SubscriptionStatus) {\n        SubscriptionStatus[\"Desired\"] = \"desired\";\n        SubscriptionStatus[\"Subscribed\"] = \"subscribed\";\n        SubscriptionStatus[\"Unsubscribed\"] = \"unsubscribed\";\n    })(TrackPublication.SubscriptionStatus || (TrackPublication.SubscriptionStatus = {}));\n    (function(PermissionStatus) {\n        PermissionStatus[\"Allowed\"] = \"allowed\";\n        PermissionStatus[\"NotAllowed\"] = \"not_allowed\";\n    })(TrackPublication.PermissionStatus || (TrackPublication.PermissionStatus = {}));\n})(TrackPublication || (TrackPublication = {}));\nclass LocalTrackPublication extends TrackPublication {\n    get isUpstreamPaused() {\n        var _a;\n        return (_a = this.track) === null || _a === void 0 ? void 0 : _a.isUpstreamPaused;\n    }\n    constructor(kind, ti, track, loggerOptions){\n        super(kind, ti.sid, ti.name, loggerOptions);\n        this.track = undefined;\n        this.handleTrackEnded = ()=>{\n            this.emit(TrackEvent.Ended);\n        };\n        this.updateInfo(ti);\n        this.setTrack(track);\n    }\n    setTrack(track) {\n        if (this.track) {\n            this.track.off(TrackEvent.Ended, this.handleTrackEnded);\n        }\n        super.setTrack(track);\n        if (track) {\n            track.on(TrackEvent.Ended, this.handleTrackEnded);\n        }\n    }\n    get isMuted() {\n        if (this.track) {\n            return this.track.isMuted;\n        }\n        return super.isMuted;\n    }\n    get audioTrack() {\n        return super.audioTrack;\n    }\n    get videoTrack() {\n        return super.videoTrack;\n    }\n    /**\n   * Mute the track associated with this publication\n   */ mute() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            return (_a = this.track) === null || _a === void 0 ? void 0 : _a.mute();\n        });\n    }\n    /**\n   * Unmute track associated with this publication\n   */ unmute() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            return (_a = this.track) === null || _a === void 0 ? void 0 : _a.unmute();\n        });\n    }\n    /**\n   * Pauses the media stream track associated with this publication from being sent to the server\n   * and signals \"muted\" event to other participants\n   * Useful if you want to pause the stream without pausing the local media stream track\n   */ pauseUpstream() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            yield (_a = this.track) === null || _a === void 0 ? void 0 : _a.pauseUpstream();\n        });\n    }\n    /**\n   * Resumes sending the media stream track associated with this publication to the server after a call to [[pauseUpstream()]]\n   * and signals \"unmuted\" event to other participants (unless the track is explicitly muted)\n   */ resumeUpstream() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            yield (_a = this.track) === null || _a === void 0 ? void 0 : _a.resumeUpstream();\n        });\n    }\n}\nvar ConnectionQuality;\n(function(ConnectionQuality) {\n    ConnectionQuality[\"Excellent\"] = \"excellent\";\n    ConnectionQuality[\"Good\"] = \"good\";\n    ConnectionQuality[\"Poor\"] = \"poor\";\n    /**\n   * Indicates that a participant has temporarily (or permanently) lost connection to LiveKit.\n   * For permanent disconnection a `ParticipantDisconnected` event will be emitted after a timeout\n   */ ConnectionQuality[\"Lost\"] = \"lost\";\n    ConnectionQuality[\"Unknown\"] = \"unknown\";\n})(ConnectionQuality || (ConnectionQuality = {}));\nfunction qualityFromProto(q) {\n    switch(q){\n        case ConnectionQuality$1.EXCELLENT:\n            return ConnectionQuality.Excellent;\n        case ConnectionQuality$1.GOOD:\n            return ConnectionQuality.Good;\n        case ConnectionQuality$1.POOR:\n            return ConnectionQuality.Poor;\n        case ConnectionQuality$1.LOST:\n            return ConnectionQuality.Lost;\n        default:\n            return ConnectionQuality.Unknown;\n    }\n}\nclass Participant extends eventsExports.EventEmitter {\n    get logContext() {\n        var _a, _b;\n        return Object.assign(Object.assign({}, (_b = (_a = this.loggerOptions) === null || _a === void 0 ? void 0 : _a.loggerContextCb) === null || _b === void 0 ? void 0 : _b.call(_a)), {\n            participantSid: this.sid,\n            participantId: this.identity\n        });\n    }\n    get isEncrypted() {\n        return this.tracks.size > 0 && Array.from(this.tracks.values()).every((tr)=>tr.isEncrypted);\n    }\n    get isAgent() {\n        var _a, _b;\n        return (_b = (_a = this.permissions) === null || _a === void 0 ? void 0 : _a.agent) !== null && _b !== void 0 ? _b : false;\n    }\n    /** @internal */ constructor(sid, identity, name, metadata, loggerOptions){\n        var _a;\n        super();\n        /** audio level between 0-1.0, 1 being loudest, 0 being softest */ this.audioLevel = 0;\n        /** if participant is currently speaking */ this.isSpeaking = false;\n        this._connectionQuality = ConnectionQuality.Unknown;\n        this.log = livekitLogger;\n        this.log = getLogger((_a = loggerOptions === null || loggerOptions === void 0 ? void 0 : loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Participant);\n        this.loggerOptions = loggerOptions;\n        this.setMaxListeners(100);\n        this.sid = sid;\n        this.identity = identity;\n        this.name = name;\n        this.metadata = metadata;\n        this.audioTracks = new Map();\n        this.videoTracks = new Map();\n        this.tracks = new Map();\n    }\n    getTracks() {\n        return Array.from(this.tracks.values());\n    }\n    /**\n   * Finds the first track that matches the source filter, for example, getting\n   * the user's camera track with getTrackBySource(Track.Source.Camera).\n   * @param source\n   * @returns\n   */ getTrack(source) {\n        for (const [, pub] of this.tracks){\n            if (pub.source === source) {\n                return pub;\n            }\n        }\n    }\n    /**\n   * Finds the first track that matches the track's name.\n   * @param name\n   * @returns\n   */ getTrackByName(name) {\n        for (const [, pub] of this.tracks){\n            if (pub.trackName === name) {\n                return pub;\n            }\n        }\n    }\n    get connectionQuality() {\n        return this._connectionQuality;\n    }\n    get isCameraEnabled() {\n        var _a;\n        const track = this.getTrack(Track.Source.Camera);\n        return !((_a = track === null || track === void 0 ? void 0 : track.isMuted) !== null && _a !== void 0 ? _a : true);\n    }\n    get isMicrophoneEnabled() {\n        var _a;\n        const track = this.getTrack(Track.Source.Microphone);\n        return !((_a = track === null || track === void 0 ? void 0 : track.isMuted) !== null && _a !== void 0 ? _a : true);\n    }\n    get isScreenShareEnabled() {\n        const track = this.getTrack(Track.Source.ScreenShare);\n        return !!track;\n    }\n    get isLocal() {\n        return false;\n    }\n    /** when participant joined the room */ get joinedAt() {\n        if (this.participantInfo) {\n            return new Date(Number.parseInt(this.participantInfo.joinedAt.toString()) * 1000);\n        }\n        return new Date();\n    }\n    /** @internal */ updateInfo(info) {\n        // it's possible the update could be applied out of order due to await\n        // during reconnect sequences. when that happens, it's possible for server\n        // to have sent more recent version of participant info while JS is waiting\n        // to process the existing payload.\n        // when the participant sid remains the same, and we already have a later version\n        // of the payload, they can be safely skipped\n        if (this.participantInfo && this.participantInfo.sid === info.sid && this.participantInfo.version > info.version) {\n            return false;\n        }\n        this.identity = info.identity;\n        this.sid = info.sid;\n        this._setName(info.name);\n        this._setMetadata(info.metadata);\n        if (info.permission) {\n            this.setPermissions(info.permission);\n        }\n        // set this last so setMetadata can detect changes\n        this.participantInfo = info;\n        this.log.trace('update participant info', Object.assign(Object.assign({}, this.logContext), {\n            info\n        }));\n        return true;\n    }\n    /**\n   * Updates metadata from server\n   **/ _setMetadata(md) {\n        const changed = this.metadata !== md;\n        const prevMetadata = this.metadata;\n        this.metadata = md;\n        if (changed) {\n            this.emit(ParticipantEvent.ParticipantMetadataChanged, prevMetadata);\n        }\n    }\n    _setName(name) {\n        const changed = this.name !== name;\n        this.name = name;\n        if (changed) {\n            this.emit(ParticipantEvent.ParticipantNameChanged, name);\n        }\n    }\n    /** @internal */ setPermissions(permissions) {\n        var _a, _b, _c, _d, _e;\n        const prevPermissions = this.permissions;\n        const changed = permissions.canPublish !== ((_a = this.permissions) === null || _a === void 0 ? void 0 : _a.canPublish) || permissions.canSubscribe !== ((_b = this.permissions) === null || _b === void 0 ? void 0 : _b.canSubscribe) || permissions.canPublishData !== ((_c = this.permissions) === null || _c === void 0 ? void 0 : _c.canPublishData) || permissions.hidden !== ((_d = this.permissions) === null || _d === void 0 ? void 0 : _d.hidden) || permissions.recorder !== ((_e = this.permissions) === null || _e === void 0 ? void 0 : _e.recorder) || permissions.canPublishSources.length !== this.permissions.canPublishSources.length || permissions.canPublishSources.some((value, index)=>{\n            var _a;\n            return value !== ((_a = this.permissions) === null || _a === void 0 ? void 0 : _a.canPublishSources[index]);\n        });\n        this.permissions = permissions;\n        if (changed) {\n            this.emit(ParticipantEvent.ParticipantPermissionsChanged, prevPermissions);\n        }\n        return changed;\n    }\n    /** @internal */ setIsSpeaking(speaking) {\n        if (speaking === this.isSpeaking) {\n            return;\n        }\n        this.isSpeaking = speaking;\n        if (speaking) {\n            this.lastSpokeAt = new Date();\n        }\n        this.emit(ParticipantEvent.IsSpeakingChanged, speaking);\n    }\n    /** @internal */ setConnectionQuality(q) {\n        const prevQuality = this._connectionQuality;\n        this._connectionQuality = qualityFromProto(q);\n        if (prevQuality !== this._connectionQuality) {\n            this.emit(ParticipantEvent.ConnectionQualityChanged, this._connectionQuality);\n        }\n    }\n    /**\n   * @internal\n   */ setAudioContext(ctx) {\n        this.audioContext = ctx;\n        this.audioTracks.forEach((track)=>(track.track instanceof RemoteAudioTrack || track.track instanceof LocalAudioTrack) && track.track.setAudioContext(ctx));\n    }\n    addTrackPublication(publication) {\n        // forward publication driven events\n        publication.on(TrackEvent.Muted, ()=>{\n            this.emit(ParticipantEvent.TrackMuted, publication);\n        });\n        publication.on(TrackEvent.Unmuted, ()=>{\n            this.emit(ParticipantEvent.TrackUnmuted, publication);\n        });\n        const pub = publication;\n        if (pub.track) {\n            pub.track.sid = publication.trackSid;\n        }\n        this.tracks.set(publication.trackSid, publication);\n        switch(publication.kind){\n            case Track.Kind.Audio:\n                this.audioTracks.set(publication.trackSid, publication);\n                break;\n            case Track.Kind.Video:\n                this.videoTracks.set(publication.trackSid, publication);\n                break;\n        }\n    }\n}\nfunction trackPermissionToProto(perms) {\n    var _a, _b, _c;\n    if (!perms.participantSid && !perms.participantIdentity) {\n        throw new Error('Invalid track permission, must provide at least one of participantIdentity and participantSid');\n    }\n    return new TrackPermission({\n        participantIdentity: (_a = perms.participantIdentity) !== null && _a !== void 0 ? _a : '',\n        participantSid: (_b = perms.participantSid) !== null && _b !== void 0 ? _b : '',\n        allTracks: (_c = perms.allowAll) !== null && _c !== void 0 ? _c : false,\n        trackSids: perms.allowedTrackSids || []\n    });\n}\nclass RemoteTrackPublication extends TrackPublication {\n    constructor(kind, ti, autoSubscribe, loggerOptions){\n        super(kind, ti.sid, ti.name, loggerOptions);\n        this.track = undefined;\n        /** @internal */ this.allowed = true;\n        this.disabled = false;\n        this.currentVideoQuality = VideoQuality.HIGH;\n        this.handleEnded = (track)=>{\n            this.setTrack(undefined);\n            this.emit(TrackEvent.Ended, track);\n        };\n        this.handleVisibilityChange = (visible)=>{\n            this.log.debug(\"adaptivestream video visibility \".concat(this.trackSid, \", visible=\").concat(visible), this.logContext);\n            this.disabled = !visible;\n            this.emitTrackUpdate();\n        };\n        this.handleVideoDimensionsChange = (dimensions)=>{\n            this.log.debug(\"adaptivestream video dimensions \".concat(dimensions.width, \"x\").concat(dimensions.height), this.logContext);\n            this.videoDimensions = dimensions;\n            this.emitTrackUpdate();\n        };\n        this.subscribed = autoSubscribe;\n        this.updateInfo(ti);\n    }\n    /**\n   * Subscribe or unsubscribe to this remote track\n   * @param subscribed true to subscribe to a track, false to unsubscribe\n   */ setSubscribed(subscribed) {\n        const prevStatus = this.subscriptionStatus;\n        const prevPermission = this.permissionStatus;\n        this.subscribed = subscribed;\n        // reset allowed status when desired subscription state changes\n        // server will notify client via signal message if it's not allowed\n        if (subscribed) {\n            this.allowed = true;\n        }\n        const sub = new UpdateSubscription({\n            trackSids: [\n                this.trackSid\n            ],\n            subscribe: this.subscribed,\n            participantTracks: [\n                new ParticipantTracks({\n                    // sending an empty participant id since TrackPublication doesn't keep it\n                    // this is filled in by the participant that receives this message\n                    participantSid: '',\n                    trackSids: [\n                        this.trackSid\n                    ]\n                })\n            ]\n        });\n        this.emit(TrackEvent.UpdateSubscription, sub);\n        this.emitSubscriptionUpdateIfChanged(prevStatus);\n        this.emitPermissionUpdateIfChanged(prevPermission);\n    }\n    get subscriptionStatus() {\n        if (this.subscribed === false) {\n            return TrackPublication.SubscriptionStatus.Unsubscribed;\n        }\n        if (!super.isSubscribed) {\n            return TrackPublication.SubscriptionStatus.Desired;\n        }\n        return TrackPublication.SubscriptionStatus.Subscribed;\n    }\n    get permissionStatus() {\n        return this.allowed ? TrackPublication.PermissionStatus.Allowed : TrackPublication.PermissionStatus.NotAllowed;\n    }\n    /**\n   * Returns true if track is subscribed, and ready for playback\n   */ get isSubscribed() {\n        if (this.subscribed === false) {\n            return false;\n        }\n        return super.isSubscribed;\n    }\n    // returns client's desire to subscribe to a track, also true if autoSubscribe is enabled\n    get isDesired() {\n        return this.subscribed !== false;\n    }\n    get isEnabled() {\n        return !this.disabled;\n    }\n    /**\n   * disable server from sending down data for this track. this is useful when\n   * the participant is off screen, you may disable streaming down their video\n   * to reduce bandwidth requirements\n   * @param enabled\n   */ setEnabled(enabled) {\n        if (!this.isManualOperationAllowed() || this.disabled === !enabled) {\n            return;\n        }\n        this.disabled = !enabled;\n        this.emitTrackUpdate();\n    }\n    /**\n   * for tracks that support simulcasting, adjust subscribed quality\n   *\n   * This indicates the highest quality the client can accept. if network\n   * bandwidth does not allow, server will automatically reduce quality to\n   * optimize for uninterrupted video\n   */ setVideoQuality(quality) {\n        if (!this.isManualOperationAllowed() || this.currentVideoQuality === quality) {\n            return;\n        }\n        this.currentVideoQuality = quality;\n        this.videoDimensions = undefined;\n        this.emitTrackUpdate();\n    }\n    setVideoDimensions(dimensions) {\n        var _a, _b;\n        if (!this.isManualOperationAllowed()) {\n            return;\n        }\n        if (((_a = this.videoDimensions) === null || _a === void 0 ? void 0 : _a.width) === dimensions.width && ((_b = this.videoDimensions) === null || _b === void 0 ? void 0 : _b.height) === dimensions.height) {\n            return;\n        }\n        if (this.track instanceof RemoteVideoTrack) {\n            this.videoDimensions = dimensions;\n        }\n        this.currentVideoQuality = undefined;\n        this.emitTrackUpdate();\n    }\n    setVideoFPS(fps) {\n        if (!this.isManualOperationAllowed()) {\n            return;\n        }\n        if (!(this.track instanceof RemoteVideoTrack)) {\n            return;\n        }\n        if (this.fps === fps) {\n            return;\n        }\n        this.fps = fps;\n        this.emitTrackUpdate();\n    }\n    get videoQuality() {\n        return this.currentVideoQuality;\n    }\n    /** @internal */ setTrack(track) {\n        const prevStatus = this.subscriptionStatus;\n        const prevPermission = this.permissionStatus;\n        const prevTrack = this.track;\n        if (prevTrack === track) {\n            return;\n        }\n        if (prevTrack) {\n            // unregister listener\n            prevTrack.off(TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange);\n            prevTrack.off(TrackEvent.VisibilityChanged, this.handleVisibilityChange);\n            prevTrack.off(TrackEvent.Ended, this.handleEnded);\n            prevTrack.detach();\n            prevTrack.stopMonitor();\n            this.emit(TrackEvent.Unsubscribed, prevTrack);\n        }\n        super.setTrack(track);\n        if (track) {\n            track.sid = this.trackSid;\n            track.on(TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange);\n            track.on(TrackEvent.VisibilityChanged, this.handleVisibilityChange);\n            track.on(TrackEvent.Ended, this.handleEnded);\n            this.emit(TrackEvent.Subscribed, track);\n        }\n        this.emitPermissionUpdateIfChanged(prevPermission);\n        this.emitSubscriptionUpdateIfChanged(prevStatus);\n    }\n    /** @internal */ setAllowed(allowed) {\n        const prevStatus = this.subscriptionStatus;\n        const prevPermission = this.permissionStatus;\n        this.allowed = allowed;\n        this.emitPermissionUpdateIfChanged(prevPermission);\n        this.emitSubscriptionUpdateIfChanged(prevStatus);\n    }\n    /** @internal */ setSubscriptionError(error) {\n        this.emit(TrackEvent.SubscriptionFailed, error);\n    }\n    /** @internal */ updateInfo(info) {\n        super.updateInfo(info);\n        const prevMetadataMuted = this.metadataMuted;\n        this.metadataMuted = info.muted;\n        if (this.track) {\n            this.track.setMuted(info.muted);\n        } else if (prevMetadataMuted !== info.muted) {\n            this.emit(info.muted ? TrackEvent.Muted : TrackEvent.Unmuted);\n        }\n    }\n    emitSubscriptionUpdateIfChanged(previousStatus) {\n        const currentStatus = this.subscriptionStatus;\n        if (previousStatus === currentStatus) {\n            return;\n        }\n        this.emit(TrackEvent.SubscriptionStatusChanged, currentStatus, previousStatus);\n    }\n    emitPermissionUpdateIfChanged(previousPermissionStatus) {\n        const currentPermissionStatus = this.permissionStatus;\n        if (currentPermissionStatus !== previousPermissionStatus) {\n            this.emit(TrackEvent.SubscriptionPermissionChanged, this.permissionStatus, previousPermissionStatus);\n        }\n    }\n    isManualOperationAllowed() {\n        if (this.kind === Track.Kind.Video && this.isAdaptiveStream) {\n            this.log.warn('adaptive stream is enabled, cannot change video track settings', this.logContext);\n            return false;\n        }\n        if (!this.isDesired) {\n            this.log.warn('cannot update track settings when not subscribed', this.logContext);\n            return false;\n        }\n        return true;\n    }\n    get isAdaptiveStream() {\n        return this.track instanceof RemoteVideoTrack && this.track.isAdaptiveStream;\n    }\n    /* @internal */ emitTrackUpdate() {\n        const settings = new UpdateTrackSettings({\n            trackSids: [\n                this.trackSid\n            ],\n            disabled: this.disabled,\n            fps: this.fps\n        });\n        if (this.videoDimensions) {\n            settings.width = Math.ceil(this.videoDimensions.width);\n            settings.height = Math.ceil(this.videoDimensions.height);\n        } else if (this.currentVideoQuality !== undefined) {\n            settings.quality = this.currentVideoQuality;\n        } else {\n            // defaults to high quality\n            settings.quality = VideoQuality.HIGH;\n        }\n        this.emit(TrackEvent.UpdateSettings, settings);\n    }\n}\nclass RemoteParticipant extends Participant {\n    /** @internal */ static fromParticipantInfo(signalClient, pi) {\n        return new RemoteParticipant(signalClient, pi.sid, pi.identity, pi.name, pi.metadata);\n    }\n    /** @internal */ constructor(signalClient, sid, identity, name, metadata, loggerOptions){\n        super(sid, identity || '', name, metadata, loggerOptions);\n        this.signalClient = signalClient;\n        this.tracks = new Map();\n        this.audioTracks = new Map();\n        this.videoTracks = new Map();\n        this.volumeMap = new Map();\n    }\n    addTrackPublication(publication) {\n        super.addTrackPublication(publication);\n        // register action events\n        publication.on(TrackEvent.UpdateSettings, (settings)=>{\n            this.log.debug('send update settings', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(publication)));\n            this.signalClient.sendUpdateTrackSettings(settings);\n        });\n        publication.on(TrackEvent.UpdateSubscription, (sub)=>{\n            sub.participantTracks.forEach((pt)=>{\n                pt.participantSid = this.sid;\n            });\n            this.signalClient.sendUpdateSubscription(sub);\n        });\n        publication.on(TrackEvent.SubscriptionPermissionChanged, (status)=>{\n            this.emit(ParticipantEvent.TrackSubscriptionPermissionChanged, publication, status);\n        });\n        publication.on(TrackEvent.SubscriptionStatusChanged, (status)=>{\n            this.emit(ParticipantEvent.TrackSubscriptionStatusChanged, publication, status);\n        });\n        publication.on(TrackEvent.Subscribed, (track)=>{\n            this.emit(ParticipantEvent.TrackSubscribed, track, publication);\n        });\n        publication.on(TrackEvent.Unsubscribed, (previousTrack)=>{\n            this.emit(ParticipantEvent.TrackUnsubscribed, previousTrack, publication);\n        });\n        publication.on(TrackEvent.SubscriptionFailed, (error)=>{\n            this.emit(ParticipantEvent.TrackSubscriptionFailed, publication.trackSid, error);\n        });\n    }\n    getTrack(source) {\n        const track = super.getTrack(source);\n        if (track) {\n            return track;\n        }\n    }\n    getTrackByName(name) {\n        const track = super.getTrackByName(name);\n        if (track) {\n            return track;\n        }\n    }\n    /**\n   * sets the volume on the participant's audio track\n   * by default, this affects the microphone publication\n   * a different source can be passed in as a second argument\n   * if no track exists the volume will be applied when the microphone track is added\n   */ setVolume(volume) {\n        let source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Track.Source.Microphone;\n        this.volumeMap.set(source, volume);\n        const audioPublication = this.getTrack(source);\n        if (audioPublication && audioPublication.track) {\n            audioPublication.track.setVolume(volume);\n        }\n    }\n    /**\n   * gets the volume on the participant's microphone track\n   */ getVolume() {\n        let source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Track.Source.Microphone;\n        const audioPublication = this.getTrack(source);\n        if (audioPublication && audioPublication.track) {\n            return audioPublication.track.getVolume();\n        }\n        return this.volumeMap.get(source);\n    }\n    /** @internal */ addSubscribedMediaTrack(mediaTrack, sid, mediaStream, receiver, adaptiveStreamSettings, triesLeft) {\n        // find the track publication\n        // it's possible for the media track to arrive before participant info\n        let publication = this.getTrackPublication(sid);\n        // it's also possible that the browser didn't honor our original track id\n        // FireFox would use its own local uuid instead of server track id\n        if (!publication) {\n            if (!sid.startsWith('TR')) {\n                // find the first track that matches type\n                this.tracks.forEach((p)=>{\n                    if (!publication && mediaTrack.kind === p.kind.toString()) {\n                        publication = p;\n                    }\n                });\n            }\n        }\n        // when we couldn't locate the track, it's possible that the metadata hasn't\n        // yet arrived. Wait a bit longer for it to arrive, or fire an error\n        if (!publication) {\n            if (triesLeft === 0) {\n                this.log.error('could not find published track', Object.assign(Object.assign({}, this.logContext), {\n                    trackSid: sid\n                }));\n                this.emit(ParticipantEvent.TrackSubscriptionFailed, sid);\n                return;\n            }\n            if (triesLeft === undefined) triesLeft = 20;\n            setTimeout(()=>{\n                this.addSubscribedMediaTrack(mediaTrack, sid, mediaStream, receiver, adaptiveStreamSettings, triesLeft - 1);\n            }, 150);\n            return;\n        }\n        if (mediaTrack.readyState === 'ended') {\n            this.log.error('unable to subscribe because MediaStreamTrack is ended. Do not call MediaStreamTrack.stop()', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(publication)));\n            this.emit(ParticipantEvent.TrackSubscriptionFailed, sid);\n            return;\n        }\n        const isVideo = mediaTrack.kind === 'video';\n        let track;\n        if (isVideo) {\n            track = new RemoteVideoTrack(mediaTrack, sid, receiver, adaptiveStreamSettings);\n        } else {\n            track = new RemoteAudioTrack(mediaTrack, sid, receiver, this.audioContext, this.audioOutput);\n        }\n        // set track info\n        track.source = publication.source;\n        // keep publication's muted status\n        track.isMuted = publication.isMuted;\n        track.setMediaStream(mediaStream);\n        track.start();\n        publication.setTrack(track);\n        // set participant volumes on new audio tracks\n        if (this.volumeMap.has(publication.source) && track instanceof RemoteAudioTrack) {\n            track.setVolume(this.volumeMap.get(publication.source));\n        }\n        return publication;\n    }\n    /** @internal */ get hasMetadata() {\n        return !!this.participantInfo;\n    }\n    getTrackPublication(sid) {\n        return this.tracks.get(sid);\n    }\n    /** @internal */ updateInfo(info) {\n        if (!super.updateInfo(info)) {\n            return false;\n        }\n        // we are getting a list of all available tracks, reconcile in here\n        // and send out events for changes\n        // reconcile track publications, publish events only if metadata is already there\n        // i.e. changes since the local participant has joined\n        const validTracks = new Map();\n        const newTracks = new Map();\n        info.tracks.forEach((ti)=>{\n            var _a, _b;\n            let publication = this.getTrackPublication(ti.sid);\n            if (!publication) {\n                // new publication\n                const kind = Track.kindFromProto(ti.type);\n                if (!kind) {\n                    return;\n                }\n                publication = new RemoteTrackPublication(kind, ti, (_a = this.signalClient.connectOptions) === null || _a === void 0 ? void 0 : _a.autoSubscribe, {\n                    loggerContextCb: ()=>this.logContext,\n                    loggerName: (_b = this.loggerOptions) === null || _b === void 0 ? void 0 : _b.loggerName\n                });\n                publication.updateInfo(ti);\n                newTracks.set(ti.sid, publication);\n                const existingTrackOfSource = Array.from(this.tracks.values()).find((publishedTrack)=>publishedTrack.source === (publication === null || publication === void 0 ? void 0 : publication.source));\n                if (existingTrackOfSource && publication.source !== Track.Source.Unknown) {\n                    this.log.debug(\"received a second track publication for \".concat(this.identity, \" with the same source: \").concat(publication.source), Object.assign(Object.assign({}, this.logContext), {\n                        oldTrack: getLogContextFromTrack(existingTrackOfSource),\n                        newTrack: getLogContextFromTrack(publication)\n                    }));\n                }\n                this.addTrackPublication(publication);\n            } else {\n                publication.updateInfo(ti);\n            }\n            validTracks.set(ti.sid, publication);\n        });\n        // detect removed tracks\n        this.tracks.forEach((publication)=>{\n            if (!validTracks.has(publication.trackSid)) {\n                this.log.trace('detected removed track on remote participant, unpublishing', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(publication)));\n                this.unpublishTrack(publication.trackSid, true);\n            }\n        });\n        // always emit events for new publications, Room will not forward them unless it's ready\n        newTracks.forEach((publication)=>{\n            this.emit(ParticipantEvent.TrackPublished, publication);\n        });\n        return true;\n    }\n    /** @internal */ unpublishTrack(sid, sendUnpublish) {\n        const publication = this.tracks.get(sid);\n        if (!publication) {\n            return;\n        }\n        // also send unsubscribe, if track is actively subscribed\n        const { track } = publication;\n        if (track) {\n            track.stop();\n            publication.setTrack(undefined);\n        }\n        // remove track from maps only after unsubscribed has been fired\n        this.tracks.delete(sid);\n        // remove from the right type map\n        switch(publication.kind){\n            case Track.Kind.Audio:\n                this.audioTracks.delete(sid);\n                break;\n            case Track.Kind.Video:\n                this.videoTracks.delete(sid);\n                break;\n        }\n        if (sendUnpublish) {\n            this.emit(ParticipantEvent.TrackUnpublished, publication);\n        }\n    }\n    /**\n   * @internal\n   */ setAudioOutput(output) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.audioOutput = output;\n            const promises = [];\n            this.audioTracks.forEach((pub)=>{\n                var _a;\n                if (pub.track instanceof RemoteAudioTrack) {\n                    promises.push(pub.track.setSinkId((_a = output.deviceId) !== null && _a !== void 0 ? _a : 'default'));\n                }\n            });\n            yield Promise.all(promises);\n        });\n    }\n    /** @internal */ emit(event) {\n        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            args[_key - 1] = arguments[_key];\n        }\n        this.log.trace('participant event', Object.assign(Object.assign({}, this.logContext), {\n            event,\n            args\n        }));\n        return super.emit(event, ...args);\n    }\n}\nclass LocalParticipant extends Participant {\n    /** @internal */ constructor(sid, identity, engine, options){\n        super(sid, identity, undefined, undefined, {\n            loggerName: options.loggerName,\n            loggerContextCb: ()=>this.engine.logContext\n        });\n        this.pendingPublishing = new Set();\n        this.pendingPublishPromises = new Map();\n        this.participantTrackPermissions = [];\n        this.allParticipantsAllowedToSubscribe = true;\n        this.encryptionType = Encryption_Type.NONE;\n        this.handleReconnecting = ()=>{\n            if (!this.reconnectFuture) {\n                this.reconnectFuture = new Future();\n            }\n        };\n        this.handleReconnected = ()=>{\n            var _a, _b;\n            (_b = (_a = this.reconnectFuture) === null || _a === void 0 ? void 0 : _a.resolve) === null || _b === void 0 ? void 0 : _b.call(_a);\n            this.reconnectFuture = undefined;\n            this.updateTrackSubscriptionPermissions();\n        };\n        this.handleDisconnected = ()=>{\n            var _a, _b;\n            if (this.reconnectFuture) {\n                this.reconnectFuture.promise.catch((e)=>this.log.warn(e.message, this.logContext));\n                (_b = (_a = this.reconnectFuture) === null || _a === void 0 ? void 0 : _a.reject) === null || _b === void 0 ? void 0 : _b.call(_a, 'Got disconnected during reconnection attempt');\n                this.reconnectFuture = undefined;\n            }\n        };\n        this.updateTrackSubscriptionPermissions = ()=>{\n            this.log.debug('updating track subscription permissions', Object.assign(Object.assign({}, this.logContext), {\n                allParticipantsAllowed: this.allParticipantsAllowedToSubscribe,\n                participantTrackPermissions: this.participantTrackPermissions\n            }));\n            this.engine.client.sendUpdateSubscriptionPermissions(this.allParticipantsAllowedToSubscribe, this.participantTrackPermissions.map((p)=>trackPermissionToProto(p)));\n        };\n        /** @internal */ this.onTrackUnmuted = (track)=>{\n            this.onTrackMuted(track, track.isUpstreamPaused);\n        };\n        // when the local track changes in mute status, we'll notify server as such\n        /** @internal */ this.onTrackMuted = (track, muted)=>{\n            if (muted === undefined) {\n                muted = true;\n            }\n            if (!track.sid) {\n                this.log.error('could not update mute status for unpublished track', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                return;\n            }\n            this.engine.updateMuteStatus(track.sid, muted);\n        };\n        this.onTrackUpstreamPaused = (track)=>{\n            this.log.debug('upstream paused', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n            this.onTrackMuted(track, true);\n        };\n        this.onTrackUpstreamResumed = (track)=>{\n            this.log.debug('upstream resumed', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n            this.onTrackMuted(track, track.isMuted);\n        };\n        this.handleSubscribedQualityUpdate = (update)=>__awaiter(this, void 0, void 0, function*() {\n                var _a, e_1, _b, _c;\n                var _d, _e;\n                if (!((_d = this.roomOptions) === null || _d === void 0 ? void 0 : _d.dynacast)) {\n                    return;\n                }\n                const pub = this.videoTracks.get(update.trackSid);\n                if (!pub) {\n                    this.log.warn('received subscribed quality update for unknown track', Object.assign(Object.assign({}, this.logContext), {\n                        trackSid: update.trackSid\n                    }));\n                    return;\n                }\n                if (update.subscribedCodecs.length > 0) {\n                    if (!pub.videoTrack) {\n                        return;\n                    }\n                    const newCodecs = yield pub.videoTrack.setPublishingCodecs(update.subscribedCodecs);\n                    try {\n                        for(var _f = true, newCodecs_1 = __asyncValues(newCodecs), newCodecs_1_1; newCodecs_1_1 = yield newCodecs_1.next(), _a = newCodecs_1_1.done, !_a; _f = true){\n                            _c = newCodecs_1_1.value;\n                            _f = false;\n                            const codec = _c;\n                            if (isBackupCodec(codec)) {\n                                this.log.debug(\"publish \".concat(codec, \" for \").concat(pub.videoTrack.sid), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(pub)));\n                                yield this.publishAdditionalCodecForTrack(pub.videoTrack, codec, pub.options);\n                            }\n                        }\n                    } catch (e_1_1) {\n                        e_1 = {\n                            error: e_1_1\n                        };\n                    } finally{\n                        try {\n                            if (!_f && !_a && (_b = newCodecs_1.return)) yield _b.call(newCodecs_1);\n                        } finally{\n                            if (e_1) throw e_1.error;\n                        }\n                    }\n                } else if (update.subscribedQualities.length > 0) {\n                    yield (_e = pub.videoTrack) === null || _e === void 0 ? void 0 : _e.setPublishingLayers(update.subscribedQualities);\n                }\n            });\n        this.handleLocalTrackUnpublished = (unpublished)=>{\n            const track = this.tracks.get(unpublished.trackSid);\n            if (!track) {\n                this.log.warn('received unpublished event for unknown track', Object.assign(Object.assign({}, this.logContext), {\n                    trackSid: unpublished.trackSid\n                }));\n                return;\n            }\n            this.unpublishTrack(track.track);\n        };\n        this.handleTrackEnded = (track)=>__awaiter(this, void 0, void 0, function*() {\n                if (track.source === Track.Source.ScreenShare || track.source === Track.Source.ScreenShareAudio) {\n                    this.log.debug('unpublishing local track due to TrackEnded', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                    this.unpublishTrack(track);\n                } else if (track.isUserProvided) {\n                    yield track.mute();\n                } else if (track instanceof LocalAudioTrack || track instanceof LocalVideoTrack) {\n                    try {\n                        if (isWeb()) {\n                            try {\n                                const currentPermissions = yield navigator === null || navigator === void 0 ? void 0 : navigator.permissions.query({\n                                    // the permission query for camera and microphone currently not supported in Safari and Firefox\n                                    // @ts-ignore\n                                    name: track.source === Track.Source.Camera ? 'camera' : 'microphone'\n                                });\n                                if (currentPermissions && currentPermissions.state === 'denied') {\n                                    this.log.warn(\"user has revoked access to \".concat(track.source), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                                    // detect granted change after permissions were denied to try and resume then\n                                    currentPermissions.onchange = ()=>{\n                                        if (currentPermissions.state !== 'denied') {\n                                            if (!track.isMuted) {\n                                                track.restartTrack();\n                                            }\n                                            currentPermissions.onchange = null;\n                                        }\n                                    };\n                                    throw new Error('GetUserMedia Permission denied');\n                                }\n                            } catch (e) {\n                            // permissions query fails for firefox, we continue and try to restart the track\n                            }\n                        }\n                        if (!track.isMuted) {\n                            this.log.debug('track ended, attempting to use a different device', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                            yield track.restartTrack();\n                        }\n                    } catch (e) {\n                        this.log.warn(\"could not restart track, muting instead\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                        yield track.mute();\n                    }\n                }\n            });\n        this.audioTracks = new Map();\n        this.videoTracks = new Map();\n        this.tracks = new Map();\n        this.engine = engine;\n        this.roomOptions = options;\n        this.setupEngine(engine);\n        this.activeDeviceMap = new Map();\n    }\n    get lastCameraError() {\n        return this.cameraError;\n    }\n    get lastMicrophoneError() {\n        return this.microphoneError;\n    }\n    get isE2EEEnabled() {\n        return this.encryptionType !== Encryption_Type.NONE;\n    }\n    getTrack(source) {\n        const track = super.getTrack(source);\n        if (track) {\n            return track;\n        }\n    }\n    getTrackByName(name) {\n        const track = super.getTrackByName(name);\n        if (track) {\n            return track;\n        }\n    }\n    /**\n   * @internal\n   */ setupEngine(engine) {\n        this.engine = engine;\n        this.engine.on(EngineEvent.RemoteMute, (trackSid, muted)=>{\n            const pub = this.tracks.get(trackSid);\n            if (!pub || !pub.track) {\n                return;\n            }\n            if (muted) {\n                pub.mute();\n            } else {\n                pub.unmute();\n            }\n        });\n        this.engine.on(EngineEvent.Connected, this.handleReconnected).on(EngineEvent.SignalRestarted, this.handleReconnected).on(EngineEvent.SignalResumed, this.handleReconnected).on(EngineEvent.Restarting, this.handleReconnecting).on(EngineEvent.Resuming, this.handleReconnecting).on(EngineEvent.LocalTrackUnpublished, this.handleLocalTrackUnpublished).on(EngineEvent.SubscribedQualityUpdate, this.handleSubscribedQualityUpdate).on(EngineEvent.Disconnected, this.handleDisconnected);\n    }\n    /**\n   * Sets and updates the metadata of the local participant.\n   * The change does not take immediate effect.\n   * If successful, a `ParticipantEvent.MetadataChanged` event will be emitted on the local participant.\n   * Note: this requires `canUpdateOwnMetadata` permission.\n   * @param metadata\n   */ setMetadata(metadata) {\n        var _a;\n        this.engine.client.sendUpdateLocalMetadata(metadata, (_a = this.name) !== null && _a !== void 0 ? _a : '');\n    }\n    /**\n   * Sets and updates the name of the local participant.\n   * The change does not take immediate effect.\n   * If successful, a `ParticipantEvent.ParticipantNameChanged` event will be emitted on the local participant.\n   * Note: this requires `canUpdateOwnMetadata` permission.\n   * @param metadata\n   */ setName(name) {\n        var _a;\n        this.engine.client.sendUpdateLocalMetadata((_a = this.metadata) !== null && _a !== void 0 ? _a : '', name);\n    }\n    /**\n   * Enable or disable a participant's camera track.\n   *\n   * If a track has already published, it'll mute or unmute the track.\n   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise\n   */ setCameraEnabled(enabled, options, publishOptions) {\n        return this.setTrackEnabled(Track.Source.Camera, enabled, options, publishOptions);\n    }\n    /**\n   * Enable or disable a participant's microphone track.\n   *\n   * If a track has already published, it'll mute or unmute the track.\n   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise\n   */ setMicrophoneEnabled(enabled, options, publishOptions) {\n        return this.setTrackEnabled(Track.Source.Microphone, enabled, options, publishOptions);\n    }\n    /**\n   * Start or stop sharing a participant's screen\n   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise\n   */ setScreenShareEnabled(enabled, options, publishOptions) {\n        return this.setTrackEnabled(Track.Source.ScreenShare, enabled, options, publishOptions);\n    }\n    /** @internal */ setPermissions(permissions) {\n        const prevPermissions = this.permissions;\n        const changed = super.setPermissions(permissions);\n        if (changed && prevPermissions) {\n            this.emit(ParticipantEvent.ParticipantPermissionsChanged, prevPermissions);\n        }\n        return changed;\n    }\n    /** @internal */ setE2EEEnabled(enabled) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.encryptionType = enabled ? Encryption_Type.GCM : Encryption_Type.NONE;\n            yield this.republishAllTracks(undefined, false);\n        });\n    }\n    setTrackEnabled(source, enabled, options, publishOptions) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function*() {\n            this.log.debug('setTrackEnabled', Object.assign(Object.assign({}, this.logContext), {\n                source,\n                enabled\n            }));\n            let track = this.getTrack(source);\n            if (enabled) {\n                if (track) {\n                    yield track.unmute();\n                } else {\n                    let localTracks;\n                    if (this.pendingPublishing.has(source)) {\n                        this.log.info('skipping duplicate published source', Object.assign(Object.assign({}, this.logContext), {\n                            source\n                        }));\n                        // no-op it's already been requested\n                        return;\n                    }\n                    this.pendingPublishing.add(source);\n                    try {\n                        switch(source){\n                            case Track.Source.Camera:\n                                localTracks = yield this.createTracks({\n                                    video: (_a = options) !== null && _a !== void 0 ? _a : true\n                                });\n                                break;\n                            case Track.Source.Microphone:\n                                localTracks = yield this.createTracks({\n                                    audio: (_b = options) !== null && _b !== void 0 ? _b : true\n                                });\n                                break;\n                            case Track.Source.ScreenShare:\n                                localTracks = yield this.createScreenTracks(Object.assign({}, options));\n                                break;\n                            default:\n                                throw new TrackInvalidError(source);\n                        }\n                        const publishPromises = [];\n                        for (const localTrack of localTracks){\n                            this.log.info('publishing track', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(localTrack)));\n                            publishPromises.push(this.publishTrack(localTrack, publishOptions));\n                        }\n                        const publishedTracks = yield Promise.all(publishPromises);\n                        // for screen share publications including audio, this will only return the screen share publication, not the screen share audio one\n                        // revisit if we want to return an array of tracks instead for v2\n                        [track] = publishedTracks;\n                    } catch (e) {\n                        localTracks === null || localTracks === void 0 ? void 0 : localTracks.forEach((tr)=>{\n                            tr.stop();\n                        });\n                        if (e instanceof Error && !(e instanceof TrackInvalidError)) {\n                            this.emit(ParticipantEvent.MediaDevicesError, e);\n                        }\n                        throw e;\n                    } finally{\n                        this.pendingPublishing.delete(source);\n                    }\n                }\n            } else if (track && track.track) {\n                // screenshare cannot be muted, unpublish instead\n                if (source === Track.Source.ScreenShare) {\n                    track = yield this.unpublishTrack(track.track);\n                    const screenAudioTrack = this.getTrack(Track.Source.ScreenShareAudio);\n                    if (screenAudioTrack && screenAudioTrack.track) {\n                        this.unpublishTrack(screenAudioTrack.track);\n                    }\n                } else {\n                    yield track.mute();\n                }\n            }\n            return track;\n        });\n    }\n    /**\n   * Publish both camera and microphone at the same time. This is useful for\n   * displaying a single Permission Dialog box to the end user.\n   */ enableCameraAndMicrophone() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.pendingPublishing.has(Track.Source.Camera) || this.pendingPublishing.has(Track.Source.Microphone)) {\n                // no-op it's already been requested\n                return;\n            }\n            this.pendingPublishing.add(Track.Source.Camera);\n            this.pendingPublishing.add(Track.Source.Microphone);\n            try {\n                const tracks = yield this.createTracks({\n                    audio: true,\n                    video: true\n                });\n                yield Promise.all(tracks.map((track)=>this.publishTrack(track)));\n            } finally{\n                this.pendingPublishing.delete(Track.Source.Camera);\n                this.pendingPublishing.delete(Track.Source.Microphone);\n            }\n        });\n    }\n    /**\n   * Create local camera and/or microphone tracks\n   * @param options\n   * @returns\n   */ createTracks(options) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function*() {\n            const opts = mergeDefaultOptions(options, (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.audioCaptureDefaults, (_b = this.roomOptions) === null || _b === void 0 ? void 0 : _b.videoCaptureDefaults);\n            const constraints = constraintsForOptions(opts);\n            let stream;\n            try {\n                stream = yield navigator.mediaDevices.getUserMedia(constraints);\n            } catch (err) {\n                if (err instanceof Error) {\n                    if (constraints.audio) {\n                        this.microphoneError = err;\n                    }\n                    if (constraints.video) {\n                        this.cameraError = err;\n                    }\n                }\n                throw err;\n            }\n            if (constraints.audio) {\n                this.microphoneError = undefined;\n                this.emit(ParticipantEvent.AudioStreamAcquired);\n            }\n            if (constraints.video) {\n                this.cameraError = undefined;\n            }\n            return stream.getTracks().map((mediaStreamTrack)=>{\n                const isAudio = mediaStreamTrack.kind === 'audio';\n                isAudio ? options.audio : options.video;\n                let trackConstraints;\n                const conOrBool = isAudio ? constraints.audio : constraints.video;\n                if (typeof conOrBool !== 'boolean') {\n                    trackConstraints = conOrBool;\n                }\n                const track = mediaTrackToLocalTrack(mediaStreamTrack, trackConstraints, {\n                    loggerName: this.roomOptions.loggerName,\n                    loggerContextCb: ()=>this.logContext\n                });\n                if (track.kind === Track.Kind.Video) {\n                    track.source = Track.Source.Camera;\n                } else if (track.kind === Track.Kind.Audio) {\n                    track.source = Track.Source.Microphone;\n                }\n                track.mediaStream = stream;\n                return track;\n            });\n        });\n    }\n    /**\n   * Creates a screen capture tracks with getDisplayMedia().\n   * A LocalVideoTrack is always created and returned.\n   * If { audio: true }, and the browser supports audio capture, a LocalAudioTrack is also created.\n   */ createScreenTracks(options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (options === undefined) {\n                options = {};\n            }\n            if (navigator.mediaDevices.getDisplayMedia === undefined) {\n                throw new DeviceUnsupportedError('getDisplayMedia not supported');\n            }\n            if (options.resolution === undefined && !isSafari17()) {\n                // we need to constrain the dimensions, otherwise it could lead to low bitrate\n                // due to encoding a huge video. Encoding such large surfaces is really expensive\n                // unfortunately Safari 17 has a but and cannot be constrained by default\n                options.resolution = ScreenSharePresets.h1080fps30.resolution;\n            }\n            const constraints = screenCaptureToDisplayMediaStreamOptions(options);\n            const stream = yield navigator.mediaDevices.getDisplayMedia(constraints);\n            const tracks = stream.getVideoTracks();\n            if (tracks.length === 0) {\n                throw new TrackInvalidError('no video track found');\n            }\n            const screenVideo = new LocalVideoTrack(tracks[0], undefined, false, {\n                loggerName: this.roomOptions.loggerName,\n                loggerContextCb: ()=>this.logContext\n            });\n            screenVideo.source = Track.Source.ScreenShare;\n            if (options.contentHint) {\n                screenVideo.mediaStreamTrack.contentHint = options.contentHint;\n            }\n            const localTracks = [\n                screenVideo\n            ];\n            if (stream.getAudioTracks().length > 0) {\n                this.emit(ParticipantEvent.AudioStreamAcquired);\n                const screenAudio = new LocalAudioTrack(stream.getAudioTracks()[0], undefined, false, this.audioContext, {\n                    loggerName: this.roomOptions.loggerName,\n                    loggerContextCb: ()=>this.logContext\n                });\n                screenAudio.source = Track.Source.ScreenShareAudio;\n                localTracks.push(screenAudio);\n            }\n            return localTracks;\n        });\n    }\n    /**\n   * Publish a new track to the room\n   * @param track\n   * @param options\n   */ publishTrack(track, options) {\n        var _a, _b, _c, _d;\n        return __awaiter(this, void 0, void 0, function*() {\n            yield (_a = this.reconnectFuture) === null || _a === void 0 ? void 0 : _a.promise;\n            if (track instanceof LocalTrack && this.pendingPublishPromises.has(track)) {\n                yield this.pendingPublishPromises.get(track);\n            }\n            let defaultConstraints;\n            if (track instanceof MediaStreamTrack) {\n                defaultConstraints = track.getConstraints();\n            } else {\n                // we want to access constraints directly as `track.mediaStreamTrack`\n                // might be pointing to a non-device track (e.g. processed track) already\n                defaultConstraints = track.constraints;\n                let deviceKind = undefined;\n                switch(track.source){\n                    case Track.Source.Microphone:\n                        deviceKind = 'audioinput';\n                        break;\n                    case Track.Source.Camera:\n                        deviceKind = 'videoinput';\n                }\n                if (deviceKind && this.activeDeviceMap.has(deviceKind)) {\n                    defaultConstraints = Object.assign(Object.assign({}, defaultConstraints), {\n                        deviceId: this.activeDeviceMap.get(deviceKind)\n                    });\n                }\n            }\n            // convert raw media track into audio or video track\n            if (track instanceof MediaStreamTrack) {\n                switch(track.kind){\n                    case 'audio':\n                        track = new LocalAudioTrack(track, defaultConstraints, true, this.audioContext, {\n                            loggerName: this.roomOptions.loggerName,\n                            loggerContextCb: ()=>this.logContext\n                        });\n                        break;\n                    case 'video':\n                        track = new LocalVideoTrack(track, defaultConstraints, true, {\n                            loggerName: this.roomOptions.loggerName,\n                            loggerContextCb: ()=>this.logContext\n                        });\n                        break;\n                    default:\n                        throw new TrackInvalidError(\"unsupported MediaStreamTrack kind \".concat(track.kind));\n                }\n            } else {\n                track.updateLoggerOptions({\n                    loggerName: this.roomOptions.loggerName,\n                    loggerContextCb: ()=>this.logContext\n                });\n            }\n            if (track instanceof LocalAudioTrack) {\n                track.setAudioContext(this.audioContext);\n            }\n            // is it already published? if so skip\n            let existingPublication;\n            this.tracks.forEach((publication)=>{\n                if (!publication.track) {\n                    return;\n                }\n                if (publication.track === track) {\n                    existingPublication = publication;\n                }\n            });\n            if (existingPublication) {\n                this.log.warn('track has already been published, skipping', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(existingPublication)));\n                return existingPublication;\n            }\n            const isStereoInput = 'channelCount' in track.mediaStreamTrack.getSettings() && // @ts-ignore `channelCount` on getSettings() is currently only available for Safari, but is generally the best way to determine a stereo track https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackSettings/channelCount\n            track.mediaStreamTrack.getSettings().channelCount === 2 || track.mediaStreamTrack.getConstraints().channelCount === 2;\n            const isStereo = (_b = options === null || options === void 0 ? void 0 : options.forceStereo) !== null && _b !== void 0 ? _b : isStereoInput;\n            // disable dtx for stereo track if not enabled explicitly\n            if (isStereo) {\n                if (!options) {\n                    options = {};\n                }\n                if (options.dtx === undefined) {\n                    this.log.info(\"Opus DTX will be disabled for stereo tracks by default. Enable them explicitly to make it work.\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                }\n                if (options.red === undefined) {\n                    this.log.info(\"Opus RED will be disabled for stereo tracks by default. Enable them explicitly to make it work.\");\n                }\n                (_c = options.dtx) !== null && _c !== void 0 ? _c : options.dtx = false;\n                (_d = options.red) !== null && _d !== void 0 ? _d : options.red = false;\n            }\n            const opts = Object.assign(Object.assign({}, this.roomOptions.publishDefaults), options);\n            // disable simulcast if e2ee is set on safari\n            if (isSafari() && this.roomOptions.e2ee) {\n                this.log.info(\"End-to-end encryption is set up, simulcast publishing will be disabled on Safari\", Object.assign({}, this.logContext));\n                opts.simulcast = false;\n            }\n            if (opts.source) {\n                track.source = opts.source;\n            }\n            const publishPromise = this.publish(track, opts, isStereo);\n            this.pendingPublishPromises.set(track, publishPromise);\n            try {\n                const publication = yield publishPromise;\n                return publication;\n            } catch (e) {\n                throw e;\n            } finally{\n                this.pendingPublishPromises.delete(track);\n            }\n        });\n    }\n    publish(track, opts, isStereo) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;\n        return __awaiter(this, void 0, void 0, function*() {\n            const existingTrackOfSource = Array.from(this.tracks.values()).find((publishedTrack)=>track instanceof LocalTrack && publishedTrack.source === track.source);\n            if (existingTrackOfSource && track.source !== Track.Source.Unknown) {\n                this.log.info(\"publishing a second track with the same source: \".concat(track.source), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n            }\n            if (opts.stopMicTrackOnMute && track instanceof LocalAudioTrack) {\n                track.stopOnMute = true;\n            }\n            if (track.source === Track.Source.ScreenShare && isFireFox()) {\n                // Firefox does not work well with simulcasted screen share\n                // we frequently get no data on layer 0 when enabled\n                opts.simulcast = false;\n            }\n            // require full AV1/VP9 SVC support prior to using it\n            if (opts.videoCodec === 'av1' && !supportsAV1()) {\n                opts.videoCodec = undefined;\n            }\n            if (opts.videoCodec === 'vp9' && !supportsVP9()) {\n                opts.videoCodec = undefined;\n            }\n            if (opts.videoCodec === undefined) {\n                opts.videoCodec = defaultVideoCodec;\n            }\n            const videoCodec = opts.videoCodec;\n            // handle track actions\n            track.on(TrackEvent.Muted, this.onTrackMuted);\n            track.on(TrackEvent.Unmuted, this.onTrackUnmuted);\n            track.on(TrackEvent.Ended, this.handleTrackEnded);\n            track.on(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused);\n            track.on(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed);\n            // create track publication from track\n            const req = new AddTrackRequest({\n                // get local track id for use during publishing\n                cid: track.mediaStreamTrack.id,\n                name: opts.name,\n                type: Track.kindToProto(track.kind),\n                muted: track.isMuted,\n                source: Track.sourceToProto(track.source),\n                disableDtx: !((_a = opts.dtx) !== null && _a !== void 0 ? _a : true),\n                encryption: this.encryptionType,\n                stereo: isStereo,\n                disableRed: this.isE2EEEnabled || !((_b = opts.red) !== null && _b !== void 0 ? _b : true),\n                stream: opts === null || opts === void 0 ? void 0 : opts.stream\n            });\n            // compute encodings and layers for video\n            let encodings;\n            if (track.kind === Track.Kind.Video) {\n                let dims = {\n                    width: 0,\n                    height: 0\n                };\n                try {\n                    dims = yield track.waitForDimensions();\n                } catch (e) {\n                    // use defaults, it's quite painful for congestion control without simulcast\n                    // so using default dims according to publish settings\n                    const defaultRes = (_d = (_c = this.roomOptions.videoCaptureDefaults) === null || _c === void 0 ? void 0 : _c.resolution) !== null && _d !== void 0 ? _d : VideoPresets.h720.resolution;\n                    dims = {\n                        width: defaultRes.width,\n                        height: defaultRes.height\n                    };\n                    // log failure\n                    this.log.error('could not determine track dimensions, using defaults', Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)), {\n                        dims\n                    }));\n                }\n                // width and height should be defined for video\n                req.width = dims.width;\n                req.height = dims.height;\n                // for svc codecs, disable simulcast and use vp8 for backup codec\n                if (track instanceof LocalVideoTrack) {\n                    if (isSVCCodec(videoCodec)) {\n                        // vp9 svc with screenshare has problem to encode, always use L1T3 here\n                        if (track.source === Track.Source.ScreenShare && videoCodec === 'vp9') {\n                            opts.scalabilityMode = 'L1T3';\n                        }\n                        // set scalabilityMode to 'L3T3_KEY' by default\n                        opts.scalabilityMode = (_e = opts.scalabilityMode) !== null && _e !== void 0 ? _e : 'L3T3_KEY';\n                    }\n                    req.simulcastCodecs = [\n                        new SimulcastCodec({\n                            codec: videoCodec,\n                            cid: track.mediaStreamTrack.id\n                        })\n                    ];\n                    // set up backup\n                    if (opts.backupCodec === true) {\n                        opts.backupCodec = {\n                            codec: defaultVideoCodec\n                        };\n                    }\n                    if (opts.backupCodec && videoCodec !== opts.backupCodec.codec && // TODO remove this once e2ee is supported for backup codecs\n                    req.encryption === Encryption_Type.NONE) {\n                        // multi-codec simulcast requires dynacast\n                        if (!this.roomOptions.dynacast) {\n                            this.roomOptions.dynacast = true;\n                        }\n                        req.simulcastCodecs.push(new SimulcastCodec({\n                            codec: opts.backupCodec.codec,\n                            cid: ''\n                        }));\n                    }\n                }\n                encodings = computeVideoEncodings(track.source === Track.Source.ScreenShare, req.width, req.height, opts);\n                req.layers = videoLayersFromEncodings(req.width, req.height, encodings, isSVCCodec(opts.videoCodec));\n            } else if (track.kind === Track.Kind.Audio) {\n                encodings = [\n                    {\n                        maxBitrate: (_g = (_f = opts.audioPreset) === null || _f === void 0 ? void 0 : _f.maxBitrate) !== null && _g !== void 0 ? _g : opts.audioBitrate,\n                        priority: (_j = (_h = opts.audioPreset) === null || _h === void 0 ? void 0 : _h.priority) !== null && _j !== void 0 ? _j : 'high',\n                        networkPriority: (_l = (_k = opts.audioPreset) === null || _k === void 0 ? void 0 : _k.priority) !== null && _l !== void 0 ? _l : 'high'\n                    }\n                ];\n            }\n            if (!this.engine || this.engine.isClosed) {\n                throw new UnexpectedConnectionState('cannot publish track when not connected');\n            }\n            const ti = yield this.engine.addTrack(req);\n            // server might not support the codec the client has requested, in that case, fallback\n            // to a supported codec\n            let primaryCodecMime;\n            ti.codecs.forEach((codec)=>{\n                if (primaryCodecMime === undefined) {\n                    primaryCodecMime = codec.mimeType;\n                }\n            });\n            if (primaryCodecMime && track.kind === Track.Kind.Video) {\n                const updatedCodec = mimeTypeToVideoCodecString(primaryCodecMime);\n                if (updatedCodec !== videoCodec) {\n                    this.log.debug('falling back to server selected codec', Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)), {\n                        codec: updatedCodec\n                    }));\n                    /* @ts-ignore */ opts.videoCodec = updatedCodec;\n                    // recompute encodings since bitrates/etc could have changed\n                    encodings = computeVideoEncodings(track.source === Track.Source.ScreenShare, req.width, req.height, opts);\n                }\n            }\n            const publication = new LocalTrackPublication(track.kind, ti, track, {\n                loggerName: this.roomOptions.loggerName,\n                loggerContextCb: ()=>this.logContext\n            });\n            // save options for when it needs to be republished again\n            publication.options = opts;\n            track.sid = ti.sid;\n            if (!this.engine.pcManager) {\n                throw new UnexpectedConnectionState('pcManager is not ready');\n            }\n            this.log.debug(\"publishing \".concat(track.kind, \" with encodings\"), Object.assign(Object.assign({}, this.logContext), {\n                encodings,\n                trackInfo: ti\n            }));\n            track.sender = yield this.engine.createSender(track, opts, encodings);\n            if (encodings) {\n                if (isFireFox() && track.kind === Track.Kind.Audio) {\n                    /* Refer to RFC https://datatracker.ietf.org/doc/html/rfc7587#section-6.1,\n             livekit-server uses maxaveragebitrate=510000 in the answer sdp to permit client to\n             publish high quality audio track. But firefox always uses this value as the actual\n             bitrates, causing the audio bitrates to rise to 510Kbps in any stereo case unexpectedly.\n             So the client need to modify maxaverragebitrates in answer sdp to user provided value to\n             fix the issue.\n           */ let trackTransceiver = undefined;\n                    for (const transceiver of this.engine.pcManager.publisher.getTransceivers()){\n                        if (transceiver.sender === track.sender) {\n                            trackTransceiver = transceiver;\n                            break;\n                        }\n                    }\n                    if (trackTransceiver) {\n                        this.engine.pcManager.publisher.setTrackCodecBitrate({\n                            transceiver: trackTransceiver,\n                            codec: 'opus',\n                            maxbr: ((_m = encodings[0]) === null || _m === void 0 ? void 0 : _m.maxBitrate) ? encodings[0].maxBitrate / 1000 : 0\n                        });\n                    }\n                } else if (track.codec && isSVCCodec(track.codec) && ((_o = encodings[0]) === null || _o === void 0 ? void 0 : _o.maxBitrate)) {\n                    this.engine.pcManager.publisher.setTrackCodecBitrate({\n                        cid: req.cid,\n                        codec: track.codec,\n                        maxbr: encodings[0].maxBitrate / 1000\n                    });\n                }\n            }\n            yield this.engine.negotiate();\n            if (track instanceof LocalVideoTrack) {\n                track.startMonitor(this.engine.client);\n            } else if (track instanceof LocalAudioTrack) {\n                track.startMonitor();\n            }\n            this.addTrackPublication(publication);\n            // send event for publication\n            this.emit(ParticipantEvent.LocalTrackPublished, publication);\n            return publication;\n        });\n    }\n    get isLocal() {\n        return true;\n    }\n    /** @internal\n   * publish additional codec to existing track\n   */ publishAdditionalCodecForTrack(track, videoCodec, options) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            // TODO remove once e2ee is supported for backup tracks\n            if (this.encryptionType !== Encryption_Type.NONE) {\n                return;\n            }\n            // is it not published? if so skip\n            let existingPublication;\n            this.tracks.forEach((publication)=>{\n                if (!publication.track) {\n                    return;\n                }\n                if (publication.track === track) {\n                    existingPublication = publication;\n                }\n            });\n            if (!existingPublication) {\n                throw new TrackInvalidError('track is not published');\n            }\n            if (!(track instanceof LocalVideoTrack)) {\n                throw new TrackInvalidError('track is not a video track');\n            }\n            const opts = Object.assign(Object.assign({}, (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.publishDefaults), options);\n            const encodings = computeTrackBackupEncodings(track, videoCodec, opts);\n            if (!encodings) {\n                this.log.info(\"backup codec has been disabled, ignoring request to add additional codec for track\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                return;\n            }\n            const simulcastTrack = track.addSimulcastTrack(videoCodec, encodings);\n            const req = new AddTrackRequest({\n                cid: simulcastTrack.mediaStreamTrack.id,\n                type: Track.kindToProto(track.kind),\n                muted: track.isMuted,\n                source: Track.sourceToProto(track.source),\n                sid: track.sid,\n                simulcastCodecs: [\n                    {\n                        codec: opts.videoCodec,\n                        cid: simulcastTrack.mediaStreamTrack.id\n                    }\n                ]\n            });\n            req.layers = videoLayersFromEncodings(req.width, req.height, encodings);\n            if (!this.engine || this.engine.isClosed) {\n                throw new UnexpectedConnectionState('cannot publish track when not connected');\n            }\n            const ti = yield this.engine.addTrack(req);\n            yield this.engine.createSimulcastSender(track, simulcastTrack, opts, encodings);\n            yield this.engine.negotiate();\n            this.log.debug(\"published \".concat(videoCodec, \" for track \").concat(track.sid), Object.assign(Object.assign({}, this.logContext), {\n                encodings,\n                trackInfo: ti\n            }));\n        });\n    }\n    unpublishTrack(track, stopOnUnpublish) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function*() {\n            // look through all published tracks to find the right ones\n            const publication = this.getPublicationForTrack(track);\n            const pubLogContext = publication ? getLogContextFromTrack(publication) : undefined;\n            this.log.debug('unpublishing track', Object.assign(Object.assign({}, this.logContext), pubLogContext));\n            if (!publication || !publication.track) {\n                this.log.warn('track was not unpublished because no publication was found', Object.assign(Object.assign({}, this.logContext), pubLogContext));\n                return undefined;\n            }\n            track = publication.track;\n            track.off(TrackEvent.Muted, this.onTrackMuted);\n            track.off(TrackEvent.Unmuted, this.onTrackUnmuted);\n            track.off(TrackEvent.Ended, this.handleTrackEnded);\n            track.off(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused);\n            track.off(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed);\n            if (stopOnUnpublish === undefined) {\n                stopOnUnpublish = (_b = (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.stopLocalTrackOnUnpublish) !== null && _b !== void 0 ? _b : true;\n            }\n            if (stopOnUnpublish) {\n                track.stop();\n            }\n            let negotiationNeeded = false;\n            const trackSender = track.sender;\n            track.sender = undefined;\n            if (this.engine.pcManager && this.engine.pcManager.currentState < PCTransportState.FAILED && trackSender) {\n                try {\n                    for (const transceiver of this.engine.pcManager.publisher.getTransceivers()){\n                        // if sender is not currently sending (after replaceTrack(null))\n                        // removeTrack would have no effect.\n                        // to ensure we end up successfully removing the track, manually set\n                        // the transceiver to inactive\n                        if (transceiver.sender === trackSender) {\n                            transceiver.direction = 'inactive';\n                            negotiationNeeded = true;\n                        }\n                    }\n                    if (this.engine.removeTrack(trackSender)) {\n                        negotiationNeeded = true;\n                    }\n                    if (track instanceof LocalVideoTrack) {\n                        for (const [, trackInfo] of track.simulcastCodecs){\n                            if (trackInfo.sender) {\n                                if (this.engine.removeTrack(trackInfo.sender)) {\n                                    negotiationNeeded = true;\n                                }\n                                trackInfo.sender = undefined;\n                            }\n                        }\n                        track.simulcastCodecs.clear();\n                    }\n                } catch (e) {\n                    this.log.warn('failed to unpublish track', Object.assign(Object.assign(Object.assign({}, this.logContext), pubLogContext), {\n                        error: e\n                    }));\n                }\n            }\n            // remove from our maps\n            this.tracks.delete(publication.trackSid);\n            switch(publication.kind){\n                case Track.Kind.Audio:\n                    this.audioTracks.delete(publication.trackSid);\n                    break;\n                case Track.Kind.Video:\n                    this.videoTracks.delete(publication.trackSid);\n                    break;\n            }\n            this.emit(ParticipantEvent.LocalTrackUnpublished, publication);\n            publication.setTrack(undefined);\n            if (negotiationNeeded) {\n                yield this.engine.negotiate();\n            }\n            return publication;\n        });\n    }\n    unpublishTracks(tracks) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const results = yield Promise.all(tracks.map((track)=>this.unpublishTrack(track)));\n            return results.filter((track)=>track instanceof LocalTrackPublication);\n        });\n    }\n    republishAllTracks(options) {\n        let restartTracks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        return __awaiter(this, void 0, void 0, function*() {\n            const localPubs = [];\n            this.tracks.forEach((pub)=>{\n                if (pub.track) {\n                    if (options) {\n                        pub.options = Object.assign(Object.assign({}, pub.options), options);\n                    }\n                    localPubs.push(pub);\n                }\n            });\n            yield Promise.all(localPubs.map((pub)=>__awaiter(this, void 0, void 0, function*() {\n                    const track = pub.track;\n                    yield this.unpublishTrack(track, false);\n                    if (restartTracks && !track.isMuted && track.source !== Track.Source.ScreenShare && track.source !== Track.Source.ScreenShareAudio && (track instanceof LocalAudioTrack || track instanceof LocalVideoTrack) && !track.isUserProvided) {\n                        // generally we need to restart the track before publishing, often a full reconnect\n                        // is necessary because computer had gone to sleep.\n                        this.log.debug('restarting existing track', Object.assign(Object.assign({}, this.logContext), {\n                            track: pub.trackSid\n                        }));\n                        yield track.restartTrack();\n                    }\n                    yield this.publishTrack(track, pub.options);\n                })));\n        });\n    }\n    publishData(data, kind) {\n        let publishOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        return __awaiter(this, void 0, void 0, function*() {\n            const destination = Array.isArray(publishOptions) ? publishOptions : publishOptions === null || publishOptions === void 0 ? void 0 : publishOptions.destination;\n            const destinationSids = [];\n            const topic = !Array.isArray(publishOptions) ? publishOptions.topic : undefined;\n            if (destination !== undefined) {\n                destination.forEach((val)=>{\n                    if (val instanceof RemoteParticipant) {\n                        destinationSids.push(val.sid);\n                    } else {\n                        destinationSids.push(val);\n                    }\n                });\n            }\n            const packet = new DataPacket({\n                kind,\n                value: {\n                    case: 'user',\n                    value: new UserPacket({\n                        participantSid: this.sid,\n                        payload: data,\n                        destinationSids: destinationSids,\n                        topic\n                    })\n                }\n            });\n            yield this.engine.sendDataPacket(packet, kind);\n        });\n    }\n    /**\n   * Control who can subscribe to LocalParticipant's published tracks.\n   *\n   * By default, all participants can subscribe. This allows fine-grained control over\n   * who is able to subscribe at a participant and track level.\n   *\n   * Note: if access is given at a track-level (i.e. both [allParticipantsAllowed] and\n   * [ParticipantTrackPermission.allTracksAllowed] are false), any newer published tracks\n   * will not grant permissions to any participants and will require a subsequent\n   * permissions update to allow subscription.\n   *\n   * @param allParticipantsAllowed Allows all participants to subscribe all tracks.\n   *  Takes precedence over [[participantTrackPermissions]] if set to true.\n   *  By default this is set to true.\n   * @param participantTrackPermissions Full list of individual permissions per\n   *  participant/track. Any omitted participants will not receive any permissions.\n   */ setTrackSubscriptionPermissions(allParticipantsAllowed) {\n        let participantTrackPermissions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n        this.participantTrackPermissions = participantTrackPermissions;\n        this.allParticipantsAllowedToSubscribe = allParticipantsAllowed;\n        if (!this.engine.client.isDisconnected) {\n            this.updateTrackSubscriptionPermissions();\n        }\n    }\n    /** @internal */ updateInfo(info) {\n        if (info.sid !== this.sid) {\n            // drop updates that specify a wrong sid.\n            // the sid for local participant is only explicitly set on join and full reconnect\n            return false;\n        }\n        if (!super.updateInfo(info)) {\n            return false;\n        }\n        // reconcile track mute status.\n        // if server's track mute status doesn't match actual, we'll have to update\n        // the server's copy\n        info.tracks.forEach((ti)=>{\n            var _a, _b;\n            const pub = this.tracks.get(ti.sid);\n            if (pub) {\n                const mutedOnServer = pub.isMuted || ((_b = (_a = pub.track) === null || _a === void 0 ? void 0 : _a.isUpstreamPaused) !== null && _b !== void 0 ? _b : false);\n                if (mutedOnServer !== ti.muted) {\n                    this.log.debug('updating server mute state after reconcile', Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(pub)), {\n                        mutedOnServer\n                    }));\n                    this.engine.client.sendMuteTrack(ti.sid, mutedOnServer);\n                }\n            }\n        });\n        return true;\n    }\n    getPublicationForTrack(track) {\n        let publication;\n        this.tracks.forEach((pub)=>{\n            const localTrack = pub.track;\n            if (!localTrack) {\n                return;\n            }\n            // this looks overly complicated due to this object tree\n            if (track instanceof MediaStreamTrack) {\n                if (localTrack instanceof LocalAudioTrack || localTrack instanceof LocalVideoTrack) {\n                    if (localTrack.mediaStreamTrack === track) {\n                        publication = pub;\n                    }\n                }\n            } else if (track === localTrack) {\n                publication = pub;\n            }\n        });\n        return publication;\n    }\n}\nvar ConnectionState;\n(function(ConnectionState) {\n    ConnectionState[\"Disconnected\"] = \"disconnected\";\n    ConnectionState[\"Connecting\"] = \"connecting\";\n    ConnectionState[\"Connected\"] = \"connected\";\n    ConnectionState[\"Reconnecting\"] = \"reconnecting\";\n})(ConnectionState || (ConnectionState = {}));\nconst connectionReconcileFrequency = 2 * 1000;\n/** @deprecated RoomState has been renamed to [[ConnectionState]] */ const RoomState = ConnectionState;\n/**\n * In LiveKit, a room is the logical grouping for a list of participants.\n * Participants in a room can publish tracks, and subscribe to others' tracks.\n *\n * a Room fires [[RoomEvent | RoomEvents]].\n *\n * @noInheritDoc\n */ class Room extends eventsExports.EventEmitter {\n    /**\n   * Creates a new Room, the primary construct for a LiveKit session.\n   * @param options\n   */ constructor(options){\n        var _this;\n        var _a, _b;\n        super();\n        _this = this;\n        this.state = ConnectionState.Disconnected;\n        /**\n     * list of participants that are actively speaking. when this changes\n     * a [[RoomEvent.ActiveSpeakersChanged]] event is fired\n     */ this.activeSpeakers = [];\n        /** reflects the sender encryption status of the local participant */ this.isE2EEEnabled = false;\n        this.audioEnabled = true;\n        this.isVideoPlaybackBlocked = false;\n        this.log = livekitLogger;\n        this.bufferedEvents = [];\n        this.connect = (url, token, opts)=>__awaiter(this, void 0, void 0, function*() {\n                var _c;\n                // In case a disconnect called happened right before the connect call, make sure the disconnect is completed first by awaiting its lock\n                const unlockDisconnect = yield this.disconnectLock.lock();\n                if (this.state === ConnectionState.Connected) {\n                    // when the state is reconnecting or connected, this function returns immediately\n                    this.log.info(\"already connected to room \".concat(this.name), this.logContext);\n                    unlockDisconnect();\n                    return Promise.resolve();\n                }\n                if (this.connectFuture) {\n                    unlockDisconnect();\n                    return this.connectFuture.promise;\n                }\n                this.setAndEmitConnectionState(ConnectionState.Connecting);\n                if (((_c = this.regionUrlProvider) === null || _c === void 0 ? void 0 : _c.getServerUrl().toString()) !== url) {\n                    this.regionUrl = undefined;\n                    this.regionUrlProvider = undefined;\n                }\n                if (isCloud(new URL(url))) {\n                    if (this.regionUrlProvider === undefined) {\n                        this.regionUrlProvider = new RegionUrlProvider(url, token);\n                    } else {\n                        this.regionUrlProvider.updateToken(token);\n                    }\n                    // trigger the first fetch without waiting for a response\n                    // if initial connection fails, this will speed up picking regional url\n                    // on subsequent runs\n                    this.regionUrlProvider.fetchRegionSettings().catch((e)=>{\n                        this.log.warn('could not fetch region settings', Object.assign(Object.assign({}, this.logContext), {\n                            error: e\n                        }));\n                    });\n                }\n                const connectFn = (resolve, reject, regionUrl)=>__awaiter(this, void 0, void 0, function*() {\n                        var _d;\n                        if (this.abortController) {\n                            this.abortController.abort();\n                        }\n                        // explicit creation as local var needed to satisfy TS compiler when passing it to `attemptConnection` further down\n                        const abortController = new AbortController();\n                        this.abortController = abortController;\n                        // at this point the intention to connect has been signalled so we can allow cancelling of the connection via disconnect() again\n                        unlockDisconnect === null || unlockDisconnect === void 0 ? void 0 : unlockDisconnect();\n                        try {\n                            yield this.attemptConnection(regionUrl !== null && regionUrl !== void 0 ? regionUrl : url, token, opts, abortController);\n                            this.abortController = undefined;\n                            resolve();\n                        } catch (e) {\n                            if (this.regionUrlProvider && e instanceof ConnectionError && e.reason !== 3 /* ConnectionErrorReason.Cancelled */  && e.reason !== 0 /* ConnectionErrorReason.NotAllowed */ ) {\n                                let nextUrl = null;\n                                try {\n                                    nextUrl = yield this.regionUrlProvider.getNextBestRegionUrl((_d = this.abortController) === null || _d === void 0 ? void 0 : _d.signal);\n                                } catch (error) {\n                                    if (error instanceof ConnectionError && (error.status === 401 || error.reason === 3 /* ConnectionErrorReason.Cancelled */ )) {\n                                        this.handleDisconnect(this.options.stopLocalTrackOnUnpublish);\n                                        reject(error);\n                                        return;\n                                    }\n                                }\n                                if (nextUrl) {\n                                    this.log.info(\"Initial connection failed with ConnectionError: \".concat(e.message, \". Retrying with another region: \").concat(nextUrl), this.logContext);\n                                    yield connectFn(resolve, reject, nextUrl);\n                                } else {\n                                    this.handleDisconnect(this.options.stopLocalTrackOnUnpublish);\n                                    reject(e);\n                                }\n                            } else {\n                                this.handleDisconnect(this.options.stopLocalTrackOnUnpublish);\n                                reject(e);\n                            }\n                        }\n                    });\n                const regionUrl = this.regionUrl;\n                this.regionUrl = undefined;\n                this.connectFuture = new Future((resolve, reject)=>{\n                    connectFn(resolve, reject, regionUrl);\n                }, ()=>{\n                    this.clearConnectionFutures();\n                });\n                return this.connectFuture.promise;\n            });\n        this.connectSignal = (url, token, engine, connectOptions, roomOptions, abortController)=>__awaiter(this, void 0, void 0, function*() {\n                var _e, _f, _g;\n                const joinResponse = yield engine.join(url, token, {\n                    autoSubscribe: connectOptions.autoSubscribe,\n                    publishOnly: connectOptions.publishOnly,\n                    adaptiveStream: typeof roomOptions.adaptiveStream === 'object' ? true : roomOptions.adaptiveStream,\n                    maxRetries: connectOptions.maxRetries,\n                    e2eeEnabled: !!this.e2eeManager,\n                    websocketTimeout: connectOptions.websocketTimeout\n                }, abortController.signal);\n                let serverInfo = joinResponse.serverInfo;\n                if (!serverInfo) {\n                    serverInfo = {\n                        version: joinResponse.serverVersion,\n                        region: joinResponse.serverRegion\n                    };\n                }\n                this.log.debug(\"connected to Livekit Server \".concat(Object.entries(serverInfo).map((_ref)=>{\n                    let [key, value] = _ref;\n                    return \"\".concat(key, \": \").concat(value);\n                }).join(', ')), {\n                    room: (_e = joinResponse.room) === null || _e === void 0 ? void 0 : _e.name,\n                    roomSid: (_f = joinResponse.room) === null || _f === void 0 ? void 0 : _f.sid,\n                    identity: (_g = joinResponse.participant) === null || _g === void 0 ? void 0 : _g.identity\n                });\n                if (!joinResponse.serverVersion) {\n                    throw new UnsupportedServer('unknown server version');\n                }\n                if (joinResponse.serverVersion === '0.15.1' && this.options.dynacast) {\n                    this.log.debug('disabling dynacast due to server version', this.logContext);\n                    // dynacast has a bug in 0.15.1, so we cannot use it then\n                    roomOptions.dynacast = false;\n                }\n                return joinResponse;\n            });\n        this.applyJoinResponse = (joinResponse)=>{\n            const pi = joinResponse.participant;\n            this.localParticipant.sid = pi.sid;\n            this.localParticipant.identity = pi.identity;\n            // populate remote participants, these should not trigger new events\n            this.handleParticipantUpdates([\n                pi,\n                ...joinResponse.otherParticipants\n            ]);\n            if (joinResponse.room) {\n                this.handleRoomUpdate(joinResponse.room);\n            }\n            if (this.options.e2ee && this.e2eeManager) {\n                this.e2eeManager.setSifTrailer(joinResponse.sifTrailer);\n            }\n        };\n        this.attemptConnection = (url, token, opts, abortController)=>__awaiter(this, void 0, void 0, function*() {\n                var _h, _j;\n                if (this.state === ConnectionState.Reconnecting) {\n                    this.log.info('Reconnection attempt replaced by new connection attempt', this.logContext);\n                    // make sure we close and recreate the existing engine in order to get rid of any potentially ongoing reconnection attempts\n                    this.recreateEngine();\n                } else {\n                    // create engine if previously disconnected\n                    this.maybeCreateEngine();\n                }\n                if ((_h = this.regionUrlProvider) === null || _h === void 0 ? void 0 : _h.isCloud()) {\n                    this.engine.setRegionUrlProvider(this.regionUrlProvider);\n                }\n                this.acquireAudioContext();\n                this.connOptions = Object.assign(Object.assign({}, roomConnectOptionDefaults), opts);\n                if (this.connOptions.rtcConfig) {\n                    this.engine.rtcConfig = this.connOptions.rtcConfig;\n                }\n                if (this.connOptions.peerConnectionTimeout) {\n                    this.engine.peerConnectionTimeout = this.connOptions.peerConnectionTimeout;\n                }\n                try {\n                    const joinResponse = yield this.connectSignal(url, token, this.engine, this.connOptions, this.options, abortController);\n                    this.applyJoinResponse(joinResponse);\n                    // forward metadata changed for the local participant\n                    this.setupLocalParticipantEvents();\n                    this.emit(RoomEvent.SignalConnected);\n                } catch (err) {\n                    yield this.engine.close();\n                    this.recreateEngine();\n                    const resultingError = new ConnectionError(\"could not establish signal connection\");\n                    if (err instanceof Error) {\n                        resultingError.message = \"\".concat(resultingError.message, \": \").concat(err.message);\n                    }\n                    if (err instanceof ConnectionError) {\n                        resultingError.reason = err.reason;\n                        resultingError.status = err.status;\n                    }\n                    this.log.debug(\"error trying to establish signal connection\", Object.assign(Object.assign({}, this.logContext), {\n                        error: err\n                    }));\n                    throw resultingError;\n                }\n                if (abortController.signal.aborted) {\n                    yield this.engine.close();\n                    this.recreateEngine();\n                    throw new ConnectionError(\"Connection attempt aborted\");\n                }\n                try {\n                    yield this.engine.waitForPCInitialConnection(this.connOptions.peerConnectionTimeout, abortController);\n                } catch (e) {\n                    yield this.engine.close();\n                    this.recreateEngine();\n                    throw e;\n                }\n                // also hook unload event\n                if (isWeb() && this.options.disconnectOnPageLeave) {\n                    // capturing both 'pagehide' and 'beforeunload' to capture broadest set of browser behaviors\n                    window.addEventListener('pagehide', this.onPageLeave);\n                    window.addEventListener('beforeunload', this.onPageLeave);\n                }\n                if (isWeb()) {\n                    document.addEventListener('freeze', this.onPageLeave);\n                    (_j = navigator.mediaDevices) === null || _j === void 0 ? void 0 : _j.addEventListener('devicechange', this.handleDeviceChange);\n                }\n                this.setAndEmitConnectionState(ConnectionState.Connected);\n                this.emit(RoomEvent.Connected);\n                this.registerConnectionReconcile();\n            });\n        /**\n     * disconnects the room, emits [[RoomEvent.Disconnected]]\n     */ this.disconnect = function() {\n            let stopTracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n            return __awaiter(_this, void 0, void 0, function*() {\n                var _k, _l, _m, _o;\n                const unlock = yield this.disconnectLock.lock();\n                try {\n                    if (this.state === ConnectionState.Disconnected) {\n                        this.log.debug('already disconnected', this.logContext);\n                        return;\n                    }\n                    this.log.info('disconnect from room', Object.assign({}, this.logContext));\n                    if (this.state === ConnectionState.Connecting || this.state === ConnectionState.Reconnecting) {\n                        // try aborting pending connection attempt\n                        this.log.warn('abort connection attempt', this.logContext);\n                        (_k = this.abortController) === null || _k === void 0 ? void 0 : _k.abort();\n                        // in case the abort controller didn't manage to cancel the connection attempt, reject the connect promise explicitly\n                        (_m = (_l = this.connectFuture) === null || _l === void 0 ? void 0 : _l.reject) === null || _m === void 0 ? void 0 : _m.call(_l, new ConnectionError('Client initiated disconnect'));\n                        this.connectFuture = undefined;\n                    }\n                    // send leave\n                    if (!((_o = this.engine) === null || _o === void 0 ? void 0 : _o.client.isDisconnected)) {\n                        yield this.engine.client.sendLeave();\n                    }\n                    // close engine (also closes client)\n                    if (this.engine) {\n                        yield this.engine.close();\n                    }\n                    this.handleDisconnect(stopTracks, DisconnectReason.CLIENT_INITIATED);\n                    /* @ts-ignore */ this.engine = undefined;\n                } finally{\n                    unlock();\n                }\n            });\n        };\n        this.onPageLeave = ()=>__awaiter(this, void 0, void 0, function*() {\n                yield this.disconnect();\n            });\n        /**\n     * Browsers have different policies regarding audio playback. Most requiring\n     * some form of user interaction (click/tap/etc).\n     * In those cases, audio will be silent until a click/tap triggering one of the following\n     * - `startAudio`\n     * - `getUserMedia`\n     */ this.startAudio = ()=>__awaiter(this, void 0, void 0, function*() {\n                const elements = [];\n                const browser = getBrowser();\n                if (browser && browser.os === 'iOS') {\n                    /**\n         * iOS blocks audio element playback if\n         * - user is not publishing audio themselves and\n         * - no other audio source is playing\n         *\n         * as a workaround, we create an audio element with an empty track, so that\n         * silent audio is always playing\n         */ const audioId = 'livekit-dummy-audio-el';\n                    let dummyAudioEl = document.getElementById(audioId);\n                    if (!dummyAudioEl) {\n                        dummyAudioEl = document.createElement('audio');\n                        dummyAudioEl.id = audioId;\n                        dummyAudioEl.autoplay = true;\n                        dummyAudioEl.hidden = true;\n                        const track = getEmptyAudioStreamTrack();\n                        track.enabled = true;\n                        const stream = new MediaStream([\n                            track\n                        ]);\n                        dummyAudioEl.srcObject = stream;\n                        document.addEventListener('visibilitychange', ()=>{\n                            if (!dummyAudioEl) {\n                                return;\n                            }\n                            // set the srcObject to null on page hide in order to prevent lock screen controls to show up for it\n                            dummyAudioEl.srcObject = document.hidden ? null : stream;\n                            if (!document.hidden) {\n                                this.log.debug('page visible again, triggering startAudio to resume playback and update playback status', this.logContext);\n                                this.startAudio();\n                            }\n                        });\n                        document.body.append(dummyAudioEl);\n                        this.once(RoomEvent.Disconnected, ()=>{\n                            dummyAudioEl === null || dummyAudioEl === void 0 ? void 0 : dummyAudioEl.remove();\n                            dummyAudioEl = null;\n                        });\n                    }\n                    elements.push(dummyAudioEl);\n                }\n                this.participants.forEach((p)=>{\n                    p.audioTracks.forEach((t)=>{\n                        if (t.track) {\n                            t.track.attachedElements.forEach((e)=>{\n                                elements.push(e);\n                            });\n                        }\n                    });\n                });\n                try {\n                    yield Promise.all([\n                        this.acquireAudioContext(),\n                        ...elements.map((e)=>{\n                            e.muted = false;\n                            return e.play();\n                        })\n                    ]);\n                    this.handleAudioPlaybackStarted();\n                } catch (err) {\n                    this.handleAudioPlaybackFailed(err);\n                    throw err;\n                }\n            });\n        this.startVideo = ()=>__awaiter(this, void 0, void 0, function*() {\n                const elements = [];\n                for (const p of this.participants.values()){\n                    p.videoTracks.forEach((tr)=>{\n                        var _a;\n                        (_a = tr.track) === null || _a === void 0 ? void 0 : _a.attachedElements.forEach((el)=>{\n                            if (!elements.includes(el)) {\n                                elements.push(el);\n                            }\n                        });\n                    });\n                }\n                yield Promise.all(elements.map((el)=>el.play())).then(()=>{\n                    this.handleVideoPlaybackStarted();\n                }).catch((e)=>{\n                    if (e.name === 'NotAllowedError') {\n                        this.handleVideoPlaybackFailed();\n                    } else {\n                        this.log.warn('Resuming video playback failed, make sure you call `startVideo` directly in a user gesture handler', this.logContext);\n                    }\n                });\n            });\n        this.handleRestarting = ()=>{\n            this.clearConnectionReconcile();\n            // also unwind existing participants & existing subscriptions\n            for (const p of this.participants.values()){\n                this.handleParticipantDisconnected(p.sid, p);\n            }\n            if (this.setAndEmitConnectionState(ConnectionState.Reconnecting)) {\n                this.emit(RoomEvent.Reconnecting);\n            }\n        };\n        this.handleSignalRestarted = (joinResponse)=>__awaiter(this, void 0, void 0, function*() {\n                this.log.debug(\"signal reconnected to server, region \".concat(joinResponse.serverRegion), Object.assign(Object.assign({}, this.logContext), {\n                    region: joinResponse.serverRegion\n                }));\n                this.bufferedEvents = [];\n                this.applyJoinResponse(joinResponse);\n                try {\n                    // unpublish & republish tracks\n                    yield this.localParticipant.republishAllTracks(undefined, true);\n                } catch (error) {\n                    this.log.error('error trying to re-publish tracks after reconnection', Object.assign(Object.assign({}, this.logContext), {\n                        error\n                    }));\n                }\n                try {\n                    yield this.engine.waitForRestarted();\n                    this.log.debug(\"fully reconnected to server\", Object.assign(Object.assign({}, this.logContext), {\n                        region: joinResponse.serverRegion\n                    }));\n                } catch (_p) {\n                    // reconnection failed, handleDisconnect is being invoked already, just return here\n                    return;\n                }\n                this.setAndEmitConnectionState(ConnectionState.Connected);\n                this.emit(RoomEvent.Reconnected);\n                this.registerConnectionReconcile();\n                this.emitBufferedEvents();\n            });\n        this.handleParticipantUpdates = (participantInfos)=>{\n            // handle changes to participant state, and send events\n            participantInfos.forEach((info)=>{\n                if (info.identity === this.localParticipant.identity) {\n                    this.localParticipant.updateInfo(info);\n                    return;\n                }\n                // ensure identity <=> sid mapping\n                const sid = this.identityToSid.get(info.identity);\n                if (sid && sid !== info.sid) {\n                    // sid had changed, need to remove previous participant\n                    this.handleParticipantDisconnected(sid, this.participants.get(sid));\n                }\n                let remoteParticipant = this.participants.get(info.sid);\n                const isNewParticipant = !remoteParticipant;\n                // when it's disconnected, send updates\n                if (info.state === ParticipantInfo_State.DISCONNECTED) {\n                    this.handleParticipantDisconnected(info.sid, remoteParticipant);\n                } else {\n                    // create participant if doesn't exist\n                    remoteParticipant = this.getOrCreateParticipant(info.sid, info);\n                    if (!isNewParticipant) {\n                        // just update, no events\n                        remoteParticipant.updateInfo(info);\n                    }\n                }\n            });\n        };\n        // updates are sent only when there's a change to speaker ordering\n        this.handleActiveSpeakersUpdate = (speakers)=>{\n            const activeSpeakers = [];\n            const seenSids = {};\n            speakers.forEach((speaker)=>{\n                seenSids[speaker.sid] = true;\n                if (speaker.sid === this.localParticipant.sid) {\n                    this.localParticipant.audioLevel = speaker.level;\n                    this.localParticipant.setIsSpeaking(true);\n                    activeSpeakers.push(this.localParticipant);\n                } else {\n                    const p = this.participants.get(speaker.sid);\n                    if (p) {\n                        p.audioLevel = speaker.level;\n                        p.setIsSpeaking(true);\n                        activeSpeakers.push(p);\n                    }\n                }\n            });\n            if (!seenSids[this.localParticipant.sid]) {\n                this.localParticipant.audioLevel = 0;\n                this.localParticipant.setIsSpeaking(false);\n            }\n            this.participants.forEach((p)=>{\n                if (!seenSids[p.sid]) {\n                    p.audioLevel = 0;\n                    p.setIsSpeaking(false);\n                }\n            });\n            this.activeSpeakers = activeSpeakers;\n            this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, activeSpeakers);\n        };\n        // process list of changed speakers\n        this.handleSpeakersChanged = (speakerUpdates)=>{\n            const lastSpeakers = new Map();\n            this.activeSpeakers.forEach((p)=>{\n                lastSpeakers.set(p.sid, p);\n            });\n            speakerUpdates.forEach((speaker)=>{\n                let p = this.participants.get(speaker.sid);\n                if (speaker.sid === this.localParticipant.sid) {\n                    p = this.localParticipant;\n                }\n                if (!p) {\n                    return;\n                }\n                p.audioLevel = speaker.level;\n                p.setIsSpeaking(speaker.active);\n                if (speaker.active) {\n                    lastSpeakers.set(speaker.sid, p);\n                } else {\n                    lastSpeakers.delete(speaker.sid);\n                }\n            });\n            const activeSpeakers = Array.from(lastSpeakers.values());\n            activeSpeakers.sort((a, b)=>b.audioLevel - a.audioLevel);\n            this.activeSpeakers = activeSpeakers;\n            this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, activeSpeakers);\n        };\n        this.handleStreamStateUpdate = (streamStateUpdate)=>{\n            streamStateUpdate.streamStates.forEach((streamState)=>{\n                const participant = this.participants.get(streamState.participantSid);\n                if (!participant) {\n                    return;\n                }\n                const pub = participant.getTrackPublication(streamState.trackSid);\n                if (!pub || !pub.track) {\n                    return;\n                }\n                pub.track.streamState = Track.streamStateFromProto(streamState.state);\n                participant.emit(ParticipantEvent.TrackStreamStateChanged, pub, pub.track.streamState);\n                this.emitWhenConnected(RoomEvent.TrackStreamStateChanged, pub, pub.track.streamState, participant);\n            });\n        };\n        this.handleSubscriptionPermissionUpdate = (update)=>{\n            const participant = this.participants.get(update.participantSid);\n            if (!participant) {\n                return;\n            }\n            const pub = participant.getTrackPublication(update.trackSid);\n            if (!pub) {\n                return;\n            }\n            pub.setAllowed(update.allowed);\n        };\n        this.handleSubscriptionError = (update)=>{\n            const participant = Array.from(this.participants.values()).find((p)=>p.tracks.has(update.trackSid));\n            if (!participant) {\n                return;\n            }\n            const pub = participant.getTrackPublication(update.trackSid);\n            if (!pub) {\n                return;\n            }\n            pub.setSubscriptionError(update.err);\n        };\n        this.handleDataPacket = (userPacket, kind)=>{\n            // find the participant\n            const participant = this.participants.get(userPacket.participantSid);\n            this.emit(RoomEvent.DataReceived, userPacket.payload, participant, kind, userPacket.topic);\n            // also emit on the participant\n            participant === null || participant === void 0 ? void 0 : participant.emit(ParticipantEvent.DataReceived, userPacket.payload, kind);\n        };\n        this.handleAudioPlaybackStarted = ()=>{\n            if (this.canPlaybackAudio) {\n                return;\n            }\n            this.audioEnabled = true;\n            this.emit(RoomEvent.AudioPlaybackStatusChanged, true);\n        };\n        this.handleAudioPlaybackFailed = (e)=>{\n            this.log.warn('could not playback audio', Object.assign(Object.assign({}, this.logContext), {\n                error: e\n            }));\n            if (!this.canPlaybackAudio) {\n                return;\n            }\n            this.audioEnabled = false;\n            this.emit(RoomEvent.AudioPlaybackStatusChanged, false);\n        };\n        this.handleVideoPlaybackStarted = ()=>{\n            if (this.isVideoPlaybackBlocked) {\n                this.isVideoPlaybackBlocked = false;\n                this.emit(RoomEvent.VideoPlaybackStatusChanged, true);\n            }\n        };\n        this.handleVideoPlaybackFailed = ()=>{\n            if (!this.isVideoPlaybackBlocked) {\n                this.isVideoPlaybackBlocked = true;\n                this.emit(RoomEvent.VideoPlaybackStatusChanged, false);\n            }\n        };\n        this.handleDeviceChange = ()=>__awaiter(this, void 0, void 0, function*() {\n                this.emit(RoomEvent.MediaDevicesChanged);\n            });\n        this.handleRoomUpdate = (room)=>{\n            const oldRoom = this.roomInfo;\n            this.roomInfo = room;\n            if (oldRoom && oldRoom.metadata !== room.metadata) {\n                this.emitWhenConnected(RoomEvent.RoomMetadataChanged, room.metadata);\n            }\n            if ((oldRoom === null || oldRoom === void 0 ? void 0 : oldRoom.activeRecording) !== room.activeRecording) {\n                this.emitWhenConnected(RoomEvent.RecordingStatusChanged, room.activeRecording);\n            }\n        };\n        this.handleConnectionQualityUpdate = (update)=>{\n            update.updates.forEach((info)=>{\n                if (info.participantSid === this.localParticipant.sid) {\n                    this.localParticipant.setConnectionQuality(info.quality);\n                    return;\n                }\n                const participant = this.participants.get(info.participantSid);\n                if (participant) {\n                    participant.setConnectionQuality(info.quality);\n                }\n            });\n        };\n        this.onLocalParticipantMetadataChanged = (metadata)=>{\n            this.emit(RoomEvent.ParticipantMetadataChanged, metadata, this.localParticipant);\n        };\n        this.onLocalParticipantNameChanged = (name)=>{\n            this.emit(RoomEvent.ParticipantNameChanged, name, this.localParticipant);\n        };\n        this.onLocalTrackMuted = (pub)=>{\n            this.emit(RoomEvent.TrackMuted, pub, this.localParticipant);\n        };\n        this.onLocalTrackUnmuted = (pub)=>{\n            this.emit(RoomEvent.TrackUnmuted, pub, this.localParticipant);\n        };\n        this.onLocalTrackPublished = (pub)=>__awaiter(this, void 0, void 0, function*() {\n                var _q;\n                this.emit(RoomEvent.LocalTrackPublished, pub, this.localParticipant);\n                if (pub.track instanceof LocalAudioTrack) {\n                    const trackIsSilent = yield pub.track.checkForSilence();\n                    if (trackIsSilent) {\n                        this.emit(RoomEvent.LocalAudioSilenceDetected, pub);\n                    }\n                }\n                const deviceId = yield (_q = pub.track) === null || _q === void 0 ? void 0 : _q.getDeviceId();\n                const deviceKind = sourceToKind(pub.source);\n                if (deviceKind && deviceId && deviceId !== this.localParticipant.activeDeviceMap.get(deviceKind)) {\n                    this.localParticipant.activeDeviceMap.set(deviceKind, deviceId);\n                    this.emit(RoomEvent.ActiveDeviceChanged, deviceKind, deviceId);\n                }\n            });\n        this.onLocalTrackUnpublished = (pub)=>{\n            this.emit(RoomEvent.LocalTrackUnpublished, pub, this.localParticipant);\n        };\n        this.onLocalConnectionQualityChanged = (quality)=>{\n            this.emit(RoomEvent.ConnectionQualityChanged, quality, this.localParticipant);\n        };\n        this.onMediaDevicesError = (e)=>{\n            this.emit(RoomEvent.MediaDevicesError, e);\n        };\n        this.onLocalParticipantPermissionsChanged = (prevPermissions)=>{\n            this.emit(RoomEvent.ParticipantPermissionsChanged, prevPermissions, this.localParticipant);\n        };\n        this.setMaxListeners(100);\n        this.participants = new Map();\n        this.identityToSid = new Map();\n        this.options = Object.assign(Object.assign({}, roomOptionDefaults), options);\n        this.log = getLogger((_a = this.options.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Room);\n        this.options.audioCaptureDefaults = Object.assign(Object.assign({}, audioDefaults), options === null || options === void 0 ? void 0 : options.audioCaptureDefaults);\n        this.options.videoCaptureDefaults = Object.assign(Object.assign({}, videoDefaults), options === null || options === void 0 ? void 0 : options.videoCaptureDefaults);\n        this.options.publishDefaults = Object.assign(Object.assign({}, publishDefaults), options === null || options === void 0 ? void 0 : options.publishDefaults);\n        this.maybeCreateEngine();\n        this.disconnectLock = new Mutex();\n        this.localParticipant = new LocalParticipant('', '', this.engine, this.options);\n        if (this.options.videoCaptureDefaults.deviceId) {\n            this.localParticipant.activeDeviceMap.set('videoinput', unwrapConstraint(this.options.videoCaptureDefaults.deviceId));\n        }\n        if (this.options.audioCaptureDefaults.deviceId) {\n            this.localParticipant.activeDeviceMap.set('audioinput', unwrapConstraint(this.options.audioCaptureDefaults.deviceId));\n        }\n        if ((_b = this.options.audioOutput) === null || _b === void 0 ? void 0 : _b.deviceId) {\n            this.switchActiveDevice('audiooutput', unwrapConstraint(this.options.audioOutput.deviceId)).catch((e)=>this.log.warn(\"Could not set audio output: \".concat(e.message), this.logContext));\n        }\n        if (this.options.e2ee) {\n            this.setupE2EE();\n        }\n    }\n    /**\n   * @experimental\n   */ setE2EEEnabled(enabled) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.e2eeManager) {\n                yield Promise.all([\n                    this.localParticipant.setE2EEEnabled(enabled)\n                ]);\n                if (this.localParticipant.identity !== '') {\n                    this.e2eeManager.setParticipantCryptorEnabled(enabled, this.localParticipant.identity);\n                }\n            } else {\n                throw Error('e2ee not configured, please set e2ee settings within the room options');\n            }\n        });\n    }\n    setupE2EE() {\n        var _a;\n        if (this.options.e2ee) {\n            this.e2eeManager = new E2EEManager(this.options.e2ee);\n            this.e2eeManager.on(EncryptionEvent.ParticipantEncryptionStatusChanged, (enabled, participant)=>{\n                if (participant instanceof LocalParticipant) {\n                    this.isE2EEEnabled = enabled;\n                }\n                this.emit(RoomEvent.ParticipantEncryptionStatusChanged, enabled, participant);\n            });\n            this.e2eeManager.on(EncryptionEvent.EncryptionError, (error)=>this.emit(RoomEvent.EncryptionError, error));\n            (_a = this.e2eeManager) === null || _a === void 0 ? void 0 : _a.setup(this);\n        }\n    }\n    get logContext() {\n        return {\n            room: this.name,\n            roomSid: this.sid,\n            identity: this.localParticipant.identity\n        };\n    }\n    /**\n   * if the current room has a participant with `recorder: true` in its JWT grant\n   **/ get isRecording() {\n        var _a, _b;\n        return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.activeRecording) !== null && _b !== void 0 ? _b : false;\n    }\n    /** server assigned unique room id */ get sid() {\n        var _a, _b;\n        return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.sid) !== null && _b !== void 0 ? _b : '';\n    }\n    /** user assigned name, derived from JWT token */ get name() {\n        var _a, _b;\n        return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : '';\n    }\n    /** room metadata */ get metadata() {\n        var _a;\n        return (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.metadata;\n    }\n    get numParticipants() {\n        var _a, _b;\n        return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.numParticipants) !== null && _b !== void 0 ? _b : 0;\n    }\n    get numPublishers() {\n        var _a, _b;\n        return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.numPublishers) !== null && _b !== void 0 ? _b : 0;\n    }\n    maybeCreateEngine() {\n        if (this.engine && !this.engine.isClosed) {\n            return;\n        }\n        this.engine = new RTCEngine(this.options);\n        this.engine.on(EngineEvent.ParticipantUpdate, this.handleParticipantUpdates).on(EngineEvent.RoomUpdate, this.handleRoomUpdate).on(EngineEvent.SpeakersChanged, this.handleSpeakersChanged).on(EngineEvent.StreamStateChanged, this.handleStreamStateUpdate).on(EngineEvent.ConnectionQualityUpdate, this.handleConnectionQualityUpdate).on(EngineEvent.SubscriptionError, this.handleSubscriptionError).on(EngineEvent.SubscriptionPermissionUpdate, this.handleSubscriptionPermissionUpdate).on(EngineEvent.MediaTrackAdded, (mediaTrack, stream, receiver)=>{\n            this.onTrackAdded(mediaTrack, stream, receiver);\n        }).on(EngineEvent.Disconnected, (reason)=>{\n            this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, reason);\n        }).on(EngineEvent.ActiveSpeakersUpdate, this.handleActiveSpeakersUpdate).on(EngineEvent.DataPacketReceived, this.handleDataPacket).on(EngineEvent.Resuming, ()=>{\n            this.clearConnectionReconcile();\n            if (this.setAndEmitConnectionState(ConnectionState.Reconnecting)) {\n                this.emit(RoomEvent.Reconnecting);\n            }\n        }).on(EngineEvent.Resumed, ()=>{\n            this.setAndEmitConnectionState(ConnectionState.Connected);\n            this.emit(RoomEvent.Reconnected);\n            this.registerConnectionReconcile();\n            this.updateSubscriptions();\n            this.emitBufferedEvents();\n        }).on(EngineEvent.SignalResumed, ()=>{\n            this.bufferedEvents = [];\n            if (this.state === ConnectionState.Reconnecting) {\n                this.sendSyncState();\n            }\n        }).on(EngineEvent.Restarting, this.handleRestarting).on(EngineEvent.SignalRestarted, this.handleSignalRestarted).on(EngineEvent.DCBufferStatusChanged, (status, kind)=>{\n            this.emit(RoomEvent.DCBufferStatusChanged, status, kind);\n        });\n        if (this.localParticipant) {\n            this.localParticipant.setupEngine(this.engine);\n        }\n        if (this.e2eeManager) {\n            this.e2eeManager.setupEngine(this.engine);\n        }\n    }\n    /**\n   * getLocalDevices abstracts navigator.mediaDevices.enumerateDevices.\n   * In particular, it handles Chrome's unique behavior of creating `default`\n   * devices. When encountered, it'll be removed from the list of devices.\n   * The actual default device will be placed at top.\n   * @param kind\n   * @returns a list of available local devices\n   */ static getLocalDevices(kind) {\n        let requestPermissions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        return DeviceManager.getInstance().getDevices(kind, requestPermissions);\n    }\n    /**\n   * prepareConnection should be called as soon as the page is loaded, in order\n   * to speed up the connection attempt. This function will\n   * - perform DNS resolution and pre-warm the DNS cache\n   * - establish TLS connection and cache TLS keys\n   *\n   * With LiveKit Cloud, it will also determine the best edge data center for\n   * the current client to connect to if a token is provided.\n   */ prepareConnection(url, token) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.state !== ConnectionState.Disconnected) {\n                return;\n            }\n            this.log.debug(\"prepareConnection to \".concat(url), this.logContext);\n            try {\n                if (isCloud(new URL(url)) && token) {\n                    this.regionUrlProvider = new RegionUrlProvider(url, token);\n                    const regionUrl = yield this.regionUrlProvider.getNextBestRegionUrl();\n                    // we will not replace the regionUrl if an attempt had already started\n                    // to avoid overriding regionUrl after a new connection attempt had started\n                    if (regionUrl && this.state === ConnectionState.Disconnected) {\n                        this.regionUrl = regionUrl;\n                        yield fetch(toHttpUrl(regionUrl), {\n                            method: 'HEAD'\n                        });\n                        this.log.debug(\"prepared connection to \".concat(regionUrl), this.logContext);\n                    }\n                } else {\n                    yield fetch(toHttpUrl(url), {\n                        method: 'HEAD'\n                    });\n                }\n            } catch (e) {\n                this.log.warn('could not prepare connection', Object.assign(Object.assign({}, this.logContext), {\n                    error: e\n                }));\n            }\n        });\n    }\n    /**\n   * retrieves a participant by identity\n   * @param identity\n   * @returns\n   */ getParticipantByIdentity(identity) {\n        if (this.localParticipant.identity === identity) {\n            return this.localParticipant;\n        }\n        const sid = this.identityToSid.get(identity);\n        if (sid) {\n            return this.participants.get(sid);\n        }\n    }\n    clearConnectionFutures() {\n        this.connectFuture = undefined;\n    }\n    /**\n   * @internal for testing\n   */ simulateScenario(scenario, arg) {\n        return __awaiter(this, void 0, void 0, function*() {\n            let postAction = ()=>{};\n            let req;\n            switch(scenario){\n                case 'signal-reconnect':\n                    // @ts-expect-error function is private\n                    yield this.engine.client.handleOnClose('simulate disconnect');\n                    break;\n                case 'speaker':\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: 'speakerUpdate',\n                            value: 3\n                        }\n                    });\n                    break;\n                case 'node-failure':\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: 'nodeFailure',\n                            value: true\n                        }\n                    });\n                    break;\n                case 'server-leave':\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: 'serverLeave',\n                            value: true\n                        }\n                    });\n                    break;\n                case 'migration':\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: 'migration',\n                            value: true\n                        }\n                    });\n                    break;\n                case 'resume-reconnect':\n                    this.engine.failNext();\n                    // @ts-expect-error function is private\n                    yield this.engine.client.handleOnClose('simulate resume-disconnect');\n                    break;\n                case 'disconnect-signal-on-resume':\n                    postAction = ()=>__awaiter(this, void 0, void 0, function*() {\n                            // @ts-expect-error function is private\n                            yield this.engine.client.handleOnClose('simulate resume-disconnect');\n                        });\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: 'disconnectSignalOnResume',\n                            value: true\n                        }\n                    });\n                    break;\n                case 'disconnect-signal-on-resume-no-messages':\n                    postAction = ()=>__awaiter(this, void 0, void 0, function*() {\n                            // @ts-expect-error function is private\n                            yield this.engine.client.handleOnClose('simulate resume-disconnect');\n                        });\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: 'disconnectSignalOnResumeNoMessages',\n                            value: true\n                        }\n                    });\n                    break;\n                case 'full-reconnect':\n                    this.engine.fullReconnectOnNext = true;\n                    // @ts-expect-error function is private\n                    yield this.engine.client.handleOnClose('simulate full-reconnect');\n                    break;\n                case 'force-tcp':\n                case 'force-tls':\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: 'switchCandidateProtocol',\n                            value: scenario === 'force-tls' ? 2 : 1\n                        }\n                    });\n                    postAction = ()=>__awaiter(this, void 0, void 0, function*() {\n                            const onLeave = this.engine.client.onLeave;\n                            if (onLeave) {\n                                onLeave(new LeaveRequest({\n                                    reason: DisconnectReason.CLIENT_INITIATED,\n                                    canReconnect: true\n                                }));\n                            }\n                        });\n                    break;\n                case 'subscriber-bandwidth':\n                    if (arg === undefined || typeof arg !== 'number') {\n                        throw new Error('subscriber-bandwidth requires a number as argument');\n                    }\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: 'subscriberBandwidth',\n                            value: BigInt(arg)\n                        }\n                    });\n                    break;\n            }\n            if (req) {\n                yield this.engine.client.sendSimulateScenario(req);\n                yield postAction();\n            }\n        });\n    }\n    /**\n   * Returns true if audio playback is enabled\n   */ get canPlaybackAudio() {\n        return this.audioEnabled;\n    }\n    /**\n   * Returns true if video playback is enabled\n   */ get canPlaybackVideo() {\n        return !this.isVideoPlaybackBlocked;\n    }\n    /**\n   * Returns the active audio output device used in this room.\n   * @return the previously successfully set audio output device ID or an empty string if the default device is used.\n   * @deprecated use `getActiveDevice('audiooutput')` instead\n   */ getActiveAudioOutputDevice() {\n        var _a, _b;\n        return (_b = (_a = this.options.audioOutput) === null || _a === void 0 ? void 0 : _a.deviceId) !== null && _b !== void 0 ? _b : '';\n    }\n    getActiveDevice(kind) {\n        return this.localParticipant.activeDeviceMap.get(kind);\n    }\n    /**\n   * Switches all active devices used in this room to the given device.\n   *\n   * Note: setting AudioOutput is not supported on some browsers. See [setSinkId](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/setSinkId#browser_compatibility)\n   *\n   * @param kind use `videoinput` for camera track,\n   *  `audioinput` for microphone track,\n   *  `audiooutput` to set speaker for all incoming audio tracks\n   * @param deviceId\n   */ switchActiveDevice(kind, deviceId) {\n        let exact = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        var _a, _b;\n        var _c;\n        return __awaiter(this, void 0, void 0, function*() {\n            let deviceHasChanged = false;\n            let success = true;\n            const deviceConstraint = exact ? {\n                exact: deviceId\n            } : deviceId;\n            if (kind === 'audioinput') {\n                const prevDeviceId = this.options.audioCaptureDefaults.deviceId;\n                this.options.audioCaptureDefaults.deviceId = deviceConstraint;\n                deviceHasChanged = prevDeviceId !== deviceConstraint;\n                const tracks = Array.from(this.localParticipant.audioTracks.values()).filter((track)=>track.source === Track.Source.Microphone);\n                try {\n                    success = (yield Promise.all(tracks.map((t)=>{\n                        var _a;\n                        return (_a = t.audioTrack) === null || _a === void 0 ? void 0 : _a.setDeviceId(deviceConstraint);\n                    }))).every((val)=>val === true);\n                } catch (e) {\n                    this.options.audioCaptureDefaults.deviceId = prevDeviceId;\n                    throw e;\n                }\n            } else if (kind === 'videoinput') {\n                const prevDeviceId = this.options.videoCaptureDefaults.deviceId;\n                this.options.videoCaptureDefaults.deviceId = deviceConstraint;\n                deviceHasChanged = prevDeviceId !== deviceConstraint;\n                const tracks = Array.from(this.localParticipant.videoTracks.values()).filter((track)=>track.source === Track.Source.Camera);\n                try {\n                    success = (yield Promise.all(tracks.map((t)=>{\n                        var _a;\n                        return (_a = t.videoTrack) === null || _a === void 0 ? void 0 : _a.setDeviceId(deviceConstraint);\n                    }))).every((val)=>val === true);\n                } catch (e) {\n                    this.options.videoCaptureDefaults.deviceId = prevDeviceId;\n                    throw e;\n                }\n            } else if (kind === 'audiooutput') {\n                if (!supportsSetSinkId() && !this.options.expWebAudioMix || this.options.expWebAudioMix && this.audioContext && !('setSinkId' in this.audioContext)) {\n                    throw new Error('cannot switch audio output, setSinkId not supported');\n                }\n                (_a = (_c = this.options).audioOutput) !== null && _a !== void 0 ? _a : _c.audioOutput = {};\n                const prevDeviceId = this.options.audioOutput.deviceId;\n                this.options.audioOutput.deviceId = deviceId;\n                deviceHasChanged = prevDeviceId !== deviceConstraint;\n                try {\n                    if (this.options.expWebAudioMix) {\n                        // @ts-expect-error setSinkId is not yet in the typescript type of AudioContext\n                        (_b = this.audioContext) === null || _b === void 0 ? void 0 : _b.setSinkId(deviceId);\n                    } else {\n                        yield Promise.all(Array.from(this.participants.values()).map((p)=>p.setAudioOutput({\n                                deviceId\n                            })));\n                    }\n                } catch (e) {\n                    this.options.audioOutput.deviceId = prevDeviceId;\n                    throw e;\n                }\n            }\n            if (deviceHasChanged && success) {\n                this.localParticipant.activeDeviceMap.set(kind, deviceId);\n                this.emit(RoomEvent.ActiveDeviceChanged, kind, deviceId);\n            }\n            return success;\n        });\n    }\n    setupLocalParticipantEvents() {\n        this.localParticipant.on(ParticipantEvent.ParticipantMetadataChanged, this.onLocalParticipantMetadataChanged).on(ParticipantEvent.ParticipantNameChanged, this.onLocalParticipantNameChanged).on(ParticipantEvent.TrackMuted, this.onLocalTrackMuted).on(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted).on(ParticipantEvent.LocalTrackPublished, this.onLocalTrackPublished).on(ParticipantEvent.LocalTrackUnpublished, this.onLocalTrackUnpublished).on(ParticipantEvent.ConnectionQualityChanged, this.onLocalConnectionQualityChanged).on(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError).on(ParticipantEvent.AudioStreamAcquired, this.startAudio).on(ParticipantEvent.ParticipantPermissionsChanged, this.onLocalParticipantPermissionsChanged);\n    }\n    recreateEngine() {\n        var _a;\n        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.close();\n        /* @ts-ignore */ this.engine = undefined;\n        // clear out existing remote participants, since they may have attached\n        // the old engine\n        this.participants.clear();\n        this.bufferedEvents = [];\n        this.maybeCreateEngine();\n    }\n    onTrackAdded(mediaTrack, stream, receiver) {\n        // don't fire onSubscribed when connecting\n        // WebRTC fires onTrack as soon as setRemoteDescription is called on the offer\n        // at that time, ICE connectivity has not been established so the track is not\n        // technically subscribed.\n        // We'll defer these events until when the room is connected or eventually disconnected.\n        if (this.state === ConnectionState.Connecting || this.state === ConnectionState.Reconnecting) {\n            const reconnectedHandler = ()=>{\n                this.onTrackAdded(mediaTrack, stream, receiver);\n                cleanup();\n            };\n            const cleanup = ()=>{\n                this.off(RoomEvent.Reconnected, reconnectedHandler);\n                this.off(RoomEvent.Connected, reconnectedHandler);\n                this.off(RoomEvent.Disconnected, cleanup);\n            };\n            this.once(RoomEvent.Reconnected, reconnectedHandler);\n            this.once(RoomEvent.Connected, reconnectedHandler);\n            this.once(RoomEvent.Disconnected, cleanup);\n            return;\n        }\n        if (this.state === ConnectionState.Disconnected) {\n            this.log.warn('skipping incoming track after Room disconnected', this.logContext);\n            return;\n        }\n        const parts = unpackStreamId(stream.id);\n        const participantId = parts[0];\n        let streamId = parts[1];\n        let trackId = mediaTrack.id;\n        // firefox will get streamId (pID|trackId) instead of (pID|streamId) as it doesn't support sync tracks by stream\n        // and generates its own track id instead of infer from sdp track id.\n        if (streamId && streamId.startsWith('TR')) trackId = streamId;\n        if (participantId === this.localParticipant.sid) {\n            this.log.warn('tried to create RemoteParticipant for local participant', this.logContext);\n            return;\n        }\n        const participant = this.participants.get(participantId);\n        if (!participant) {\n            this.log.error(\"Tried to add a track for a participant, that's not present. Sid: \".concat(participantId), this.logContext);\n            return;\n        }\n        let adaptiveStreamSettings;\n        if (this.options.adaptiveStream) {\n            if (typeof this.options.adaptiveStream === 'object') {\n                adaptiveStreamSettings = this.options.adaptiveStream;\n            } else {\n                adaptiveStreamSettings = {};\n            }\n        }\n        participant.addSubscribedMediaTrack(mediaTrack, trackId, stream, receiver, adaptiveStreamSettings);\n    }\n    handleDisconnect() {\n        let shouldStopTracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        let reason = arguments.length > 1 ? arguments[1] : undefined;\n        var _a;\n        this.clearConnectionReconcile();\n        this.bufferedEvents = [];\n        if (this.state === ConnectionState.Disconnected) {\n            return;\n        }\n        this.regionUrl = undefined;\n        try {\n            this.participants.forEach((p)=>{\n                p.tracks.forEach((pub)=>{\n                    p.unpublishTrack(pub.trackSid);\n                });\n            });\n            this.localParticipant.tracks.forEach((pub)=>{\n                var _a, _b;\n                if (pub.track) {\n                    this.localParticipant.unpublishTrack(pub.track, shouldStopTracks);\n                }\n                if (shouldStopTracks) {\n                    (_a = pub.track) === null || _a === void 0 ? void 0 : _a.detach();\n                    (_b = pub.track) === null || _b === void 0 ? void 0 : _b.stop();\n                }\n            });\n            this.localParticipant.off(ParticipantEvent.ParticipantMetadataChanged, this.onLocalParticipantMetadataChanged).off(ParticipantEvent.ParticipantNameChanged, this.onLocalParticipantNameChanged).off(ParticipantEvent.TrackMuted, this.onLocalTrackMuted).off(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted).off(ParticipantEvent.LocalTrackPublished, this.onLocalTrackPublished).off(ParticipantEvent.LocalTrackUnpublished, this.onLocalTrackUnpublished).off(ParticipantEvent.ConnectionQualityChanged, this.onLocalConnectionQualityChanged).off(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError).off(ParticipantEvent.AudioStreamAcquired, this.startAudio).off(ParticipantEvent.ParticipantPermissionsChanged, this.onLocalParticipantPermissionsChanged);\n            this.localParticipant.tracks.clear();\n            this.localParticipant.videoTracks.clear();\n            this.localParticipant.audioTracks.clear();\n            this.participants.clear();\n            this.activeSpeakers = [];\n            if (this.audioContext && typeof this.options.expWebAudioMix === 'boolean') {\n                this.audioContext.close();\n                this.audioContext = undefined;\n            }\n            if (isWeb()) {\n                window.removeEventListener('beforeunload', this.onPageLeave);\n                window.removeEventListener('pagehide', this.onPageLeave);\n                window.removeEventListener('freeze', this.onPageLeave);\n                (_a = navigator.mediaDevices) === null || _a === void 0 ? void 0 : _a.removeEventListener('devicechange', this.handleDeviceChange);\n            }\n        } finally{\n            this.setAndEmitConnectionState(ConnectionState.Disconnected);\n            this.emit(RoomEvent.Disconnected, reason);\n        }\n    }\n    handleParticipantDisconnected(sid, participant) {\n        // remove and send event\n        this.participants.delete(sid);\n        if (!participant) {\n            return;\n        }\n        this.identityToSid.delete(participant.identity);\n        participant.tracks.forEach((publication)=>{\n            participant.unpublishTrack(publication.trackSid, true);\n        });\n        this.emit(RoomEvent.ParticipantDisconnected, participant);\n    }\n    acquireAudioContext() {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (typeof this.options.expWebAudioMix !== 'boolean' && this.options.expWebAudioMix.audioContext) {\n                // override audio context with custom audio context if supplied by user\n                this.audioContext = this.options.expWebAudioMix.audioContext;\n            } else if (!this.audioContext || this.audioContext.state === 'closed') {\n                // by using an AudioContext, it reduces lag on audio elements\n                // https://stackoverflow.com/questions/9811429/html5-audio-tag-on-safari-has-a-delay/54119854#54119854\n                this.audioContext = (_a = getNewAudioContext()) !== null && _a !== void 0 ? _a : undefined;\n            }\n            if (this.audioContext && this.audioContext.state === 'suspended') {\n                // for iOS a newly created AudioContext is always in `suspended` state.\n                // we try our best to resume the context here, if that doesn't work, we just continue with regular processing\n                try {\n                    yield this.audioContext.resume();\n                } catch (e) {\n                    this.log.warn('Could not resume audio context', Object.assign(Object.assign({}, this.logContext), {\n                        error: e\n                    }));\n                }\n            }\n            if (this.options.expWebAudioMix) {\n                this.participants.forEach((participant)=>participant.setAudioContext(this.audioContext));\n            }\n            this.localParticipant.setAudioContext(this.audioContext);\n            const newContextIsRunning = ((_b = this.audioContext) === null || _b === void 0 ? void 0 : _b.state) === 'running';\n            if (newContextIsRunning !== this.canPlaybackAudio) {\n                this.audioEnabled = newContextIsRunning;\n                this.emit(RoomEvent.AudioPlaybackStatusChanged, newContextIsRunning);\n            }\n        });\n    }\n    createParticipant(id, info) {\n        var _a;\n        let participant;\n        if (info) {\n            participant = RemoteParticipant.fromParticipantInfo(this.engine.client, info);\n        } else {\n            participant = new RemoteParticipant(this.engine.client, id, '', undefined, undefined, {\n                loggerContextCb: ()=>this.logContext,\n                loggerName: this.options.loggerName\n            });\n        }\n        if (this.options.expWebAudioMix) {\n            participant.setAudioContext(this.audioContext);\n        }\n        if ((_a = this.options.audioOutput) === null || _a === void 0 ? void 0 : _a.deviceId) {\n            participant.setAudioOutput(this.options.audioOutput).catch((e)=>this.log.warn(\"Could not set audio output: \".concat(e.message), this.logContext));\n        }\n        return participant;\n    }\n    getOrCreateParticipant(id, info) {\n        if (this.participants.has(id)) {\n            return this.participants.get(id);\n        }\n        const participant = this.createParticipant(id, info);\n        this.participants.set(id, participant);\n        this.identityToSid.set(info.identity, info.sid);\n        // if we have valid info and the participant wasn't in the map before, we can assume the participant is new\n        // firing here to make sure that `ParticipantConnected` fires before the initial track events\n        this.emitWhenConnected(RoomEvent.ParticipantConnected, participant);\n        // also forward events\n        // trackPublished is only fired for tracks added after both local participant\n        // and remote participant joined the room\n        participant.on(ParticipantEvent.TrackPublished, (trackPublication)=>{\n            this.emitWhenConnected(RoomEvent.TrackPublished, trackPublication, participant);\n        }).on(ParticipantEvent.TrackSubscribed, (track, publication)=>{\n            // monitor playback status\n            if (track.kind === Track.Kind.Audio) {\n                track.on(TrackEvent.AudioPlaybackStarted, this.handleAudioPlaybackStarted);\n                track.on(TrackEvent.AudioPlaybackFailed, this.handleAudioPlaybackFailed);\n            } else if (track.kind === Track.Kind.Video) {\n                track.on(TrackEvent.VideoPlaybackFailed, this.handleVideoPlaybackFailed);\n                track.on(TrackEvent.VideoPlaybackStarted, this.handleVideoPlaybackStarted);\n            }\n            this.emit(RoomEvent.TrackSubscribed, track, publication, participant);\n        }).on(ParticipantEvent.TrackUnpublished, (publication)=>{\n            this.emit(RoomEvent.TrackUnpublished, publication, participant);\n        }).on(ParticipantEvent.TrackUnsubscribed, (track, publication)=>{\n            this.emit(RoomEvent.TrackUnsubscribed, track, publication, participant);\n        }).on(ParticipantEvent.TrackSubscriptionFailed, (sid)=>{\n            this.emit(RoomEvent.TrackSubscriptionFailed, sid, participant);\n        }).on(ParticipantEvent.TrackMuted, (pub)=>{\n            this.emitWhenConnected(RoomEvent.TrackMuted, pub, participant);\n        }).on(ParticipantEvent.TrackUnmuted, (pub)=>{\n            this.emitWhenConnected(RoomEvent.TrackUnmuted, pub, participant);\n        }).on(ParticipantEvent.ParticipantMetadataChanged, (metadata)=>{\n            this.emitWhenConnected(RoomEvent.ParticipantMetadataChanged, metadata, participant);\n        }).on(ParticipantEvent.ParticipantNameChanged, (name)=>{\n            this.emitWhenConnected(RoomEvent.ParticipantNameChanged, name, participant);\n        }).on(ParticipantEvent.ConnectionQualityChanged, (quality)=>{\n            this.emitWhenConnected(RoomEvent.ConnectionQualityChanged, quality, participant);\n        }).on(ParticipantEvent.ParticipantPermissionsChanged, (prevPermissions)=>{\n            this.emitWhenConnected(RoomEvent.ParticipantPermissionsChanged, prevPermissions, participant);\n        }).on(ParticipantEvent.TrackSubscriptionStatusChanged, (pub, status)=>{\n            this.emitWhenConnected(RoomEvent.TrackSubscriptionStatusChanged, pub, status, participant);\n        }).on(ParticipantEvent.TrackSubscriptionFailed, (trackSid, error)=>{\n            this.emit(RoomEvent.TrackSubscriptionFailed, trackSid, participant, error);\n        }).on(ParticipantEvent.TrackSubscriptionPermissionChanged, (pub, status)=>{\n            this.emitWhenConnected(RoomEvent.TrackSubscriptionPermissionChanged, pub, status, participant);\n        });\n        // update info at the end after callbacks have been set up\n        if (info) {\n            participant.updateInfo(info);\n        }\n        return participant;\n    }\n    sendSyncState() {\n        const remoteTracks = Array.from(this.participants.values()).reduce((acc, participant)=>{\n            acc.push(...participant.getTracks()); // FIXME would be nice to have this return RemoteTrackPublications directly instead of the type cast\n            return acc;\n        }, []);\n        const localTracks = this.localParticipant.getTracks(); // FIXME would be nice to have this return LocalTrackPublications directly instead of the type cast\n        this.engine.sendSyncState(remoteTracks, localTracks);\n    }\n    /**\n   * After resuming, we'll need to notify the server of the current\n   * subscription settings.\n   */ updateSubscriptions() {\n        for (const p of this.participants.values()){\n            for (const pub of p.videoTracks.values()){\n                if (pub.isSubscribed && pub instanceof RemoteTrackPublication) {\n                    pub.emitTrackUpdate();\n                }\n            }\n        }\n    }\n    registerConnectionReconcile() {\n        this.clearConnectionReconcile();\n        let consecutiveFailures = 0;\n        this.connectionReconcileInterval = CriticalTimers.setInterval(()=>{\n            if (// ensure we didn't tear it down\n            !this.engine || // engine detected close, but Room missed it\n            this.engine.isClosed || // transports failed without notifying engine\n            !this.engine.verifyTransport()) {\n                consecutiveFailures++;\n                this.log.warn('detected connection state mismatch', Object.assign(Object.assign({}, this.logContext), {\n                    numFailures: consecutiveFailures,\n                    engine: {\n                        closed: this.engine.isClosed,\n                        transportsConnected: this.engine.verifyTransport()\n                    }\n                }));\n                if (consecutiveFailures >= 3) {\n                    this.recreateEngine();\n                    this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, DisconnectReason.STATE_MISMATCH);\n                }\n            } else {\n                consecutiveFailures = 0;\n            }\n        }, connectionReconcileFrequency);\n    }\n    clearConnectionReconcile() {\n        if (this.connectionReconcileInterval) {\n            CriticalTimers.clearInterval(this.connectionReconcileInterval);\n        }\n    }\n    setAndEmitConnectionState(state) {\n        if (state === this.state) {\n            // unchanged\n            return false;\n        }\n        this.state = state;\n        this.emit(RoomEvent.ConnectionStateChanged, this.state);\n        return true;\n    }\n    emitBufferedEvents() {\n        this.bufferedEvents.forEach((_ref2)=>{\n            let [ev, args] = _ref2;\n            this.emit(ev, ...args);\n        });\n        this.bufferedEvents = [];\n    }\n    emitWhenConnected(event) {\n        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            args[_key - 1] = arguments[_key];\n        }\n        if (this.state === ConnectionState.Connected) {\n            return this.emit(event, ...args);\n        } else if (this.state === ConnectionState.Reconnecting) {\n            // in case the room is reconnecting, buffer the events by firing them later after emitting RoomEvent.Reconnected\n            this.bufferedEvents.push([\n                event,\n                args\n            ]);\n        }\n        return false;\n    }\n    /**\n   * Allows to populate a room with simulated participants.\n   * No actual connection to a server will be established, all state is\n   * @experimental\n   */ simulateParticipants(options) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function*() {\n            const publishOptions = Object.assign({\n                audio: true,\n                video: true,\n                useRealTracks: false\n            }, options.publish);\n            const participantOptions = Object.assign({\n                count: 9,\n                audio: false,\n                video: true,\n                aspectRatios: [\n                    1.66,\n                    1.7,\n                    1.3\n                ]\n            }, options.participants);\n            this.handleDisconnect();\n            this.roomInfo = new Room$1({\n                sid: 'RM_SIMULATED',\n                name: 'simulated-room',\n                emptyTimeout: 0,\n                maxParticipants: 0,\n                creationTime: protoInt64.parse(new Date().getTime()),\n                metadata: '',\n                numParticipants: 1,\n                numPublishers: 1,\n                turnPassword: '',\n                enabledCodecs: [],\n                activeRecording: false\n            });\n            this.localParticipant.updateInfo(new ParticipantInfo({\n                identity: 'simulated-local',\n                name: 'local-name'\n            }));\n            this.setupLocalParticipantEvents();\n            this.emit(RoomEvent.SignalConnected);\n            this.emit(RoomEvent.Connected);\n            this.setAndEmitConnectionState(ConnectionState.Connected);\n            if (publishOptions.video) {\n                const camPub = new LocalTrackPublication(Track.Kind.Video, new TrackInfo({\n                    source: TrackSource.CAMERA,\n                    sid: Math.floor(Math.random() * 10000).toString(),\n                    type: TrackType.AUDIO,\n                    name: 'video-dummy'\n                }), new LocalVideoTrack(publishOptions.useRealTracks ? (yield window.navigator.mediaDevices.getUserMedia({\n                    video: true\n                })).getVideoTracks()[0] : createDummyVideoStreamTrack(160 * ((_a = participantOptions.aspectRatios[0]) !== null && _a !== void 0 ? _a : 1), 160, true, true), undefined, false, {\n                    loggerName: this.options.loggerName,\n                    loggerContextCb: ()=>this.logContext\n                }), {\n                    loggerName: this.options.loggerName,\n                    loggerContextCb: ()=>this.logContext\n                });\n                // @ts-ignore\n                this.localParticipant.addTrackPublication(camPub);\n                this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, camPub);\n            }\n            if (publishOptions.audio) {\n                const audioPub = new LocalTrackPublication(Track.Kind.Audio, new TrackInfo({\n                    source: TrackSource.MICROPHONE,\n                    sid: Math.floor(Math.random() * 10000).toString(),\n                    type: TrackType.AUDIO\n                }), new LocalAudioTrack(publishOptions.useRealTracks ? (yield navigator.mediaDevices.getUserMedia({\n                    audio: true\n                })).getAudioTracks()[0] : getEmptyAudioStreamTrack(), undefined, false, this.audioContext, {\n                    loggerName: this.options.loggerName,\n                    loggerContextCb: ()=>this.logContext\n                }), {\n                    loggerName: this.options.loggerName,\n                    loggerContextCb: ()=>this.logContext\n                });\n                // @ts-ignore\n                this.localParticipant.addTrackPublication(audioPub);\n                this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, audioPub);\n            }\n            for(let i = 0; i < participantOptions.count - 1; i += 1){\n                let info = new ParticipantInfo({\n                    sid: Math.floor(Math.random() * 10000).toString(),\n                    identity: \"simulated-\".concat(i),\n                    state: ParticipantInfo_State.ACTIVE,\n                    tracks: [],\n                    joinedAt: protoInt64.parse(Date.now())\n                });\n                const p = this.getOrCreateParticipant(info.identity, info);\n                if (participantOptions.video) {\n                    const dummyVideo = createDummyVideoStreamTrack(160 * ((_b = participantOptions.aspectRatios[i % participantOptions.aspectRatios.length]) !== null && _b !== void 0 ? _b : 1), 160, false, true);\n                    const videoTrack = new TrackInfo({\n                        source: TrackSource.CAMERA,\n                        sid: Math.floor(Math.random() * 10000).toString(),\n                        type: TrackType.AUDIO\n                    });\n                    p.addSubscribedMediaTrack(dummyVideo, videoTrack.sid, new MediaStream([\n                        dummyVideo\n                    ]));\n                    info.tracks = [\n                        ...info.tracks,\n                        videoTrack\n                    ];\n                }\n                if (participantOptions.audio) {\n                    const dummyTrack = getEmptyAudioStreamTrack();\n                    const audioTrack = new TrackInfo({\n                        source: TrackSource.MICROPHONE,\n                        sid: Math.floor(Math.random() * 10000).toString(),\n                        type: TrackType.AUDIO\n                    });\n                    p.addSubscribedMediaTrack(dummyTrack, audioTrack.sid, new MediaStream([\n                        dummyTrack\n                    ]));\n                    info.tracks = [\n                        ...info.tracks,\n                        audioTrack\n                    ];\n                }\n                p.updateInfo(info);\n            }\n        });\n    }\n    // /** @internal */\n    emit(event) {\n        for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n            args[_key2 - 1] = arguments[_key2];\n        }\n        // active speaker updates are too spammy\n        if (event !== RoomEvent.ActiveSpeakersChanged) {\n            // only extract logContext from arguments in order to avoid logging the whole object tree\n            const minimizedArgs = mapArgs(args).filter((arg)=>arg !== undefined);\n            this.log.debug(\"room event \".concat(event), Object.assign(Object.assign({}, this.logContext), {\n                event,\n                args: minimizedArgs\n            }));\n        }\n        return super.emit(event, ...args);\n    }\n}\nfunction mapArgs(args) {\n    return args.map((arg)=>{\n        if (!arg) {\n            return;\n        }\n        if (Array.isArray(arg)) {\n            return mapArgs(arg);\n        }\n        if (typeof arg === 'object') {\n            return 'logContext' in arg && arg.logContext;\n        }\n        return arg;\n    });\n}\nvar CheckStatus;\n(function(CheckStatus) {\n    CheckStatus[CheckStatus[\"IDLE\"] = 0] = \"IDLE\";\n    CheckStatus[CheckStatus[\"RUNNING\"] = 1] = \"RUNNING\";\n    CheckStatus[CheckStatus[\"SKIPPED\"] = 2] = \"SKIPPED\";\n    CheckStatus[CheckStatus[\"SUCCESS\"] = 3] = \"SUCCESS\";\n    CheckStatus[CheckStatus[\"FAILED\"] = 4] = \"FAILED\";\n})(CheckStatus || (CheckStatus = {}));\nclass Checker extends eventsExports.EventEmitter {\n    constructor(url, token){\n        let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        super();\n        this.status = CheckStatus.IDLE;\n        this.logs = [];\n        this.errorsAsWarnings = false;\n        this.url = url;\n        this.token = token;\n        this.name = this.constructor.name;\n        this.room = new Room(options.roomOptions);\n        this.connectOptions = options.connectOptions;\n        if (options.errorsAsWarnings) {\n            this.errorsAsWarnings = options.errorsAsWarnings;\n        }\n    }\n    run(onComplete) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.status !== CheckStatus.IDLE) {\n                throw Error('check is running already');\n            }\n            this.setStatus(CheckStatus.RUNNING);\n            try {\n                yield this.perform();\n            } catch (err) {\n                if (err instanceof Error) {\n                    if (this.errorsAsWarnings) {\n                        this.appendWarning(err.message);\n                    } else {\n                        this.appendError(err.message);\n                    }\n                }\n            }\n            yield this.disconnect();\n            // sleep for a bit to ensure disconnect\n            yield new Promise((resolve)=>setTimeout(resolve, 500));\n            // @ts-ignore\n            if (this.status !== CheckStatus.SKIPPED) {\n                this.setStatus(this.isSuccess() ? CheckStatus.SUCCESS : CheckStatus.FAILED);\n            }\n            if (onComplete) {\n                onComplete();\n            }\n            return this.getInfo();\n        });\n    }\n    isSuccess() {\n        return !this.logs.some((l)=>l.level === 'error');\n    }\n    connect() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.room.state === ConnectionState.Connected) {\n                return this.room;\n            }\n            yield this.room.connect(this.url, this.token);\n            return this.room;\n        });\n    }\n    disconnect() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.room && this.room.state !== ConnectionState.Disconnected) {\n                yield this.room.disconnect();\n                // wait for it to go through\n                yield new Promise((resolve)=>setTimeout(resolve, 500));\n            }\n        });\n    }\n    skip() {\n        this.setStatus(CheckStatus.SKIPPED);\n    }\n    appendMessage(message) {\n        this.logs.push({\n            level: 'info',\n            message\n        });\n        this.emit('update', this.getInfo());\n    }\n    appendWarning(message) {\n        this.logs.push({\n            level: 'warning',\n            message\n        });\n        this.emit('update', this.getInfo());\n    }\n    appendError(message) {\n        this.logs.push({\n            level: 'error',\n            message\n        });\n        this.emit('update', this.getInfo());\n    }\n    setStatus(status) {\n        this.status = status;\n        this.emit('update', this.getInfo());\n    }\n    get engine() {\n        var _a;\n        return (_a = this.room) === null || _a === void 0 ? void 0 : _a.engine;\n    }\n    getInfo() {\n        return {\n            logs: this.logs,\n            name: this.name,\n            status: this.status,\n            description: this.description\n        };\n    }\n}\n/**\n * Creates a local video and audio track at the same time. When acquiring both\n * audio and video tracks together, it'll display a single permission prompt to\n * the user instead of two separate ones.\n * @param options\n */ function createLocalTracks(options) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function*() {\n        // set default options to true\n        options !== null && options !== void 0 ? options : options = {};\n        (_a = options.audio) !== null && _a !== void 0 ? _a : options.audio = true;\n        (_b = options.video) !== null && _b !== void 0 ? _b : options.video = true;\n        const opts = mergeDefaultOptions(options, audioDefaults, videoDefaults);\n        const constraints = constraintsForOptions(opts);\n        // Keep a reference to the promise on DeviceManager and await it in getLocalDevices()\n        // works around iOS Safari Bug https://bugs.webkit.org/show_bug.cgi?id=179363\n        const mediaPromise = navigator.mediaDevices.getUserMedia(constraints);\n        if (options.audio) {\n            DeviceManager.userMediaPromiseMap.set('audioinput', mediaPromise);\n            mediaPromise.catch(()=>DeviceManager.userMediaPromiseMap.delete('audioinput'));\n        }\n        if (options.video) {\n            DeviceManager.userMediaPromiseMap.set('videoinput', mediaPromise);\n            mediaPromise.catch(()=>DeviceManager.userMediaPromiseMap.delete('videoinput'));\n        }\n        const stream = yield mediaPromise;\n        return stream.getTracks().map((mediaStreamTrack)=>{\n            const isAudio = mediaStreamTrack.kind === 'audio';\n            isAudio ? options.audio : options.video;\n            let trackConstraints;\n            const conOrBool = isAudio ? constraints.audio : constraints.video;\n            if (typeof conOrBool !== 'boolean') {\n                trackConstraints = conOrBool;\n            }\n            // update the constraints with the device id the user gave permissions to in the permission prompt\n            // otherwise each track restart (e.g. mute - unmute) will try to initialize the device again -> causing additional permission prompts\n            if (trackConstraints) {\n                trackConstraints.deviceId = mediaStreamTrack.getSettings().deviceId;\n            } else {\n                trackConstraints = {\n                    deviceId: mediaStreamTrack.getSettings().deviceId\n                };\n            }\n            const track = mediaTrackToLocalTrack(mediaStreamTrack, trackConstraints);\n            if (track.kind === Track.Kind.Video) {\n                track.source = Track.Source.Camera;\n            } else if (track.kind === Track.Kind.Audio) {\n                track.source = Track.Source.Microphone;\n            }\n            track.mediaStream = stream;\n            return track;\n        });\n    });\n}\n/**\n * Creates a [[LocalVideoTrack]] with getUserMedia()\n * @param options\n */ function createLocalVideoTrack(options) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const tracks = yield createLocalTracks({\n            audio: false,\n            video: options\n        });\n        return tracks[0];\n    });\n}\nfunction createLocalAudioTrack(options) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const tracks = yield createLocalTracks({\n            audio: options,\n            video: false\n        });\n        return tracks[0];\n    });\n}\n/**\n * Creates a screen capture tracks with getDisplayMedia().\n * A LocalVideoTrack is always created and returned.\n * If { audio: true }, and the browser supports audio capture, a LocalAudioTrack is also created.\n */ function createLocalScreenTracks(options) {\n    return __awaiter(this, void 0, void 0, function*() {\n        if (options === undefined) {\n            options = {};\n        }\n        if (options.resolution === undefined && !isSafari17()) {\n            options.resolution = ScreenSharePresets.h1080fps30.resolution;\n        }\n        if (navigator.mediaDevices.getDisplayMedia === undefined) {\n            throw new DeviceUnsupportedError('getDisplayMedia not supported');\n        }\n        const constraints = screenCaptureToDisplayMediaStreamOptions(options);\n        const stream = yield navigator.mediaDevices.getDisplayMedia(constraints);\n        const tracks = stream.getVideoTracks();\n        if (tracks.length === 0) {\n            throw new TrackInvalidError('no video track found');\n        }\n        const screenVideo = new LocalVideoTrack(tracks[0], undefined, false);\n        screenVideo.source = Track.Source.ScreenShare;\n        const localTracks = [\n            screenVideo\n        ];\n        if (stream.getAudioTracks().length > 0) {\n            const screenAudio = new LocalAudioTrack(stream.getAudioTracks()[0], undefined, false);\n            screenAudio.source = Track.Source.ScreenShareAudio;\n            localTracks.push(screenAudio);\n        }\n        return localTracks;\n    });\n}\nclass PublishAudioCheck extends Checker {\n    get description() {\n        return 'Can publish audio';\n    }\n    perform() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const room = yield this.connect();\n            const track = yield createLocalAudioTrack();\n            room.localParticipant.publishTrack(track);\n            // wait for a few seconds to publish\n            yield new Promise((resolve)=>setTimeout(resolve, 3000));\n            // verify RTC stats that it's publishing\n            const stats = yield (_a = track.sender) === null || _a === void 0 ? void 0 : _a.getStats();\n            if (!stats) {\n                throw new Error('Could not get RTCStats');\n            }\n            let numPackets = 0;\n            stats.forEach((stat)=>{\n                if (stat.type === 'outbound-rtp' && stat.mediaType === 'audio') {\n                    numPackets = stat.packetsSent;\n                }\n            });\n            if (numPackets === 0) {\n                throw new Error('Could not determine packets are sent');\n            }\n            this.appendMessage(\"published \".concat(numPackets, \" audio packets\"));\n        });\n    }\n}\nclass PublishVideoCheck extends Checker {\n    get description() {\n        return 'Can publish video';\n    }\n    perform() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const room = yield this.connect();\n            const track = yield createLocalVideoTrack();\n            room.localParticipant.publishTrack(track);\n            // wait for a few seconds to publish\n            yield new Promise((resolve)=>setTimeout(resolve, 3000));\n            // verify RTC stats that it's publishing\n            const stats = yield (_a = track.sender) === null || _a === void 0 ? void 0 : _a.getStats();\n            if (!stats) {\n                throw new Error('Could not get RTCStats');\n            }\n            let numPackets = 0;\n            stats.forEach((stat)=>{\n                if (stat.type === 'outbound-rtp' && stat.mediaType === 'video') {\n                    numPackets = stat.packetsSent;\n                }\n            });\n            if (numPackets === 0) {\n                throw new Error('Could not determine packets are sent');\n            }\n            this.appendMessage(\"published \".concat(numPackets, \" video packets\"));\n        });\n    }\n}\nclass ReconnectCheck extends Checker {\n    get description() {\n        return 'Resuming connection after interruption';\n    }\n    perform() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const room = yield this.connect();\n            let reconnectingTriggered = false;\n            let reconnected = false;\n            let reconnectResolver;\n            const reconnectTimeout = new Promise((resolve)=>{\n                setTimeout(resolve, 5000);\n                reconnectResolver = resolve;\n            });\n            room.on(RoomEvent.Reconnecting, ()=>{\n                reconnectingTriggered = true;\n            }).on(RoomEvent.Reconnected, ()=>{\n                reconnected = true;\n                reconnectResolver(true);\n            });\n            (_a = room.engine.client.ws) === null || _a === void 0 ? void 0 : _a.close();\n            const onClose = room.engine.client.onClose;\n            if (onClose) {\n                onClose('');\n            }\n            yield reconnectTimeout;\n            if (!reconnectingTriggered) {\n                throw new Error('Did not attempt to reconnect');\n            } else if (!reconnected || room.state !== ConnectionState.Connected) {\n                this.appendWarning('reconnection is only possible in Redis-based configurations');\n                throw new Error('Not able to reconnect');\n            }\n        });\n    }\n}\nclass TURNCheck extends Checker {\n    get description() {\n        return 'Can connect via TURN';\n    }\n    perform() {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function*() {\n            const signalClient = new SignalClient();\n            const joinRes = yield signalClient.join(this.url, this.token, {\n                autoSubscribe: true,\n                maxRetries: 0,\n                e2eeEnabled: false,\n                websocketTimeout: 15000\n            });\n            let hasTLS = false;\n            let hasTURN = false;\n            let hasSTUN = false;\n            for (let iceServer of joinRes.iceServers){\n                for (let url of iceServer.urls){\n                    if (url.startsWith('turn:')) {\n                        hasTURN = true;\n                        hasSTUN = true;\n                    } else if (url.startsWith('turns:')) {\n                        hasTURN = true;\n                        hasSTUN = true;\n                        hasTLS = true;\n                    }\n                    if (url.startsWith('stun:')) {\n                        hasSTUN = true;\n                    }\n                }\n            }\n            if (!hasSTUN) {\n                this.appendWarning('No STUN servers configured on server side.');\n            } else if (hasTURN && !hasTLS) {\n                this.appendWarning('TURN is configured server side, but TURN/TLS is unavailable.');\n            }\n            yield signalClient.close();\n            if (((_b = (_a = this.connectOptions) === null || _a === void 0 ? void 0 : _a.rtcConfig) === null || _b === void 0 ? void 0 : _b.iceServers) || hasTURN) {\n                yield this.room.connect(this.url, this.token, {\n                    rtcConfig: {\n                        iceTransportPolicy: 'relay'\n                    }\n                });\n            } else {\n                this.appendWarning('No TURN servers configured.');\n                this.skip();\n                yield new Promise((resolve)=>setTimeout(resolve, 0));\n            }\n        });\n    }\n}\nclass WebRTCCheck extends Checker {\n    get description() {\n        return 'Establishing WebRTC connection';\n    }\n    perform() {\n        return __awaiter(this, void 0, void 0, function*() {\n            let hasTcp = false;\n            let hasIpv4Udp = false;\n            this.room.on(RoomEvent.SignalConnected, ()=>{\n                const prevTrickle = this.room.engine.client.onTrickle;\n                this.room.engine.client.onTrickle = (sd, target)=>{\n                    if (sd.candidate) {\n                        const candidate = new RTCIceCandidate(sd);\n                        let str = \"\".concat(candidate.protocol, \" \").concat(candidate.address, \":\").concat(candidate.port, \" \").concat(candidate.type);\n                        if (candidate.address) {\n                            if (isIPPrivate(candidate.address)) {\n                                str += ' (private)';\n                            } else {\n                                if (candidate.protocol === 'tcp' && candidate.tcpType === 'passive') {\n                                    hasTcp = true;\n                                    str += ' (passive)';\n                                } else if (candidate.protocol === 'udp') {\n                                    hasIpv4Udp = true;\n                                }\n                            }\n                        }\n                        this.appendMessage(str);\n                    }\n                    if (prevTrickle) {\n                        prevTrickle(sd, target);\n                    }\n                };\n                if (this.room.engine.pcManager) {\n                    this.room.engine.pcManager.subscriber.onIceCandidateError = (ev)=>{\n                        if (ev instanceof RTCPeerConnectionIceErrorEvent) {\n                            this.appendWarning(\"error with ICE candidate: \".concat(ev.errorCode, \" \").concat(ev.errorText, \" \").concat(ev.url));\n                        }\n                    };\n                }\n            });\n            try {\n                yield this.connect();\n                livekitLogger.info('now the room is connected');\n            } catch (err) {\n                this.appendWarning('ports need to be open on firewall in order to connect.');\n                throw err;\n            }\n            if (!hasTcp) {\n                this.appendWarning('Server is not configured for ICE/TCP');\n            }\n            if (!hasIpv4Udp) {\n                this.appendWarning('No public IPv4 UDP candidates were found. Your server is likely not configured correctly');\n            }\n        });\n    }\n}\nfunction isIPPrivate(address) {\n    const parts = address.split('.');\n    if (parts.length === 4) {\n        if (parts[0] === '10') {\n            return true;\n        } else if (parts[0] === '192' && parts[1] === '168') {\n            return true;\n        } else if (parts[0] === '172') {\n            const second = parseInt(parts[1], 10);\n            if (second >= 16 && second <= 31) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nclass WebSocketCheck extends Checker {\n    get description() {\n        return 'Connecting to signal connection via WebSocket';\n    }\n    perform() {\n        var _a, _b, _c;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.url.startsWith('ws:') || this.url.startsWith('http:')) {\n                this.appendWarning('Server is insecure, clients may block connections to it');\n            }\n            let signalClient = new SignalClient();\n            const joinRes = yield signalClient.join(this.url, this.token, {\n                autoSubscribe: true,\n                maxRetries: 0,\n                e2eeEnabled: false,\n                websocketTimeout: 15000\n            });\n            this.appendMessage(\"Connected to server, version \".concat(joinRes.serverVersion, \".\"));\n            if (((_a = joinRes.serverInfo) === null || _a === void 0 ? void 0 : _a.edition) === ServerInfo_Edition.Cloud && ((_b = joinRes.serverInfo) === null || _b === void 0 ? void 0 : _b.region)) {\n                this.appendMessage(\"LiveKit Cloud: \".concat((_c = joinRes.serverInfo) === null || _c === void 0 ? void 0 : _c.region));\n            }\n            yield signalClient.close();\n        });\n    }\n}\nclass ConnectionCheck extends eventsExports.EventEmitter {\n    constructor(url, token){\n        super();\n        this.checkResults = new Map();\n        this.url = url;\n        this.token = token;\n    }\n    getNextCheckId() {\n        const nextId = this.checkResults.size;\n        this.checkResults.set(nextId, {\n            logs: [],\n            status: CheckStatus.IDLE,\n            name: '',\n            description: ''\n        });\n        return nextId;\n    }\n    updateCheck(checkId, info) {\n        this.checkResults.set(checkId, info);\n        this.emit('checkUpdate', checkId, info);\n    }\n    isSuccess() {\n        return Array.from(this.checkResults.values()).every((r)=>r.status !== CheckStatus.FAILED);\n    }\n    getResults() {\n        return Array.from(this.checkResults.values());\n    }\n    createAndRunCheck(check) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const checkId = this.getNextCheckId();\n            const test = new check(this.url, this.token);\n            const handleUpdate = (info)=>{\n                this.updateCheck(checkId, info);\n            };\n            test.on('update', handleUpdate);\n            const result = yield test.run();\n            test.off('update', handleUpdate);\n            return result;\n        });\n    }\n    checkWebsocket() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.createAndRunCheck(WebSocketCheck);\n        });\n    }\n    checkWebRTC() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.createAndRunCheck(WebRTCCheck);\n        });\n    }\n    checkTURN() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.createAndRunCheck(TURNCheck);\n        });\n    }\n    checkReconnect() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.createAndRunCheck(ReconnectCheck);\n        });\n    }\n    checkPublishAudio() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.createAndRunCheck(PublishAudioCheck);\n        });\n    }\n    checkPublishVideo() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.createAndRunCheck(PublishVideoCheck);\n        });\n    }\n}\n/**\n * Try to analyze the local track to determine the facing mode of a track.\n *\n * @remarks\n * There is no property supported by all browsers to detect whether a video track originated from a user- or environment-facing camera device.\n * For this reason, we use the `facingMode` property when available, but will fall back on a string-based analysis of the device label to determine the facing mode.\n * If both methods fail, the default facing mode will be used.\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints/facingMode | MDN docs on facingMode}\n * @experimental\n */ function facingModeFromLocalTrack(localTrack) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _a;\n    const track = localTrack instanceof LocalTrack ? localTrack.mediaStreamTrack : localTrack;\n    const trackSettings = track.getSettings();\n    let result = {\n        facingMode: (_a = options.defaultFacingMode) !== null && _a !== void 0 ? _a : 'user',\n        confidence: 'low'\n    };\n    // 1. Try to get facingMode from track settings.\n    if ('facingMode' in trackSettings) {\n        const rawFacingMode = trackSettings.facingMode;\n        livekitLogger.debug('rawFacingMode', {\n            rawFacingMode\n        });\n        if (rawFacingMode && typeof rawFacingMode === 'string' && isFacingModeValue(rawFacingMode)) {\n            result = {\n                facingMode: rawFacingMode,\n                confidence: 'high'\n            };\n        }\n    }\n    // 2. If we don't have a high confidence we try to get the facing mode from the device label.\n    if ([\n        'low',\n        'medium'\n    ].includes(result.confidence)) {\n        livekitLogger.debug(\"Try to get facing mode from device label: (\".concat(track.label, \")\"));\n        const labelAnalysisResult = facingModeFromDeviceLabel(track.label);\n        if (labelAnalysisResult !== undefined) {\n            result = labelAnalysisResult;\n        }\n    }\n    return result;\n}\nconst knownDeviceLabels = new Map([\n    [\n        'obs virtual camera',\n        {\n            facingMode: 'environment',\n            confidence: 'medium'\n        }\n    ]\n]);\nconst knownDeviceLabelSections = new Map([\n    [\n        'iphone',\n        {\n            facingMode: 'environment',\n            confidence: 'medium'\n        }\n    ],\n    [\n        'ipad',\n        {\n            facingMode: 'environment',\n            confidence: 'medium'\n        }\n    ]\n]);\n/**\n * Attempt to analyze the device label to determine the facing mode.\n *\n * @experimental\n */ function facingModeFromDeviceLabel(deviceLabel) {\n    var _a;\n    const label = deviceLabel.trim().toLowerCase();\n    // Empty string is a valid device label but we can't infer anything from it.\n    if (label === '') {\n        return undefined;\n    }\n    // Can we match against widely known device labels.\n    if (knownDeviceLabels.has(label)) {\n        return knownDeviceLabels.get(label);\n    }\n    // Can we match against sections of the device label.\n    return (_a = Array.from(knownDeviceLabelSections.entries()).find((_ref)=>{\n        let [section] = _ref;\n        return label.includes(section);\n    })) === null || _a === void 0 ? void 0 : _a[1];\n}\nfunction isFacingModeValue(item) {\n    const allowedValues = [\n        'user',\n        'environment',\n        'left',\n        'right'\n    ];\n    return item === undefined || allowedValues.includes(item);\n}\n //# sourceMappingURL=livekit-client.esm.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vbGl2ZWtpdC1jbGllbnRAMS4xNS4xMy9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvZGlzdC9saXZla2l0LWNsaWVudC5lc20ubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBTVdBLFNBQUFBLElBQUksRUFBRUMsVUFBVSxFQUFFO1FBSWxCLElBQWtDQyxNQUFNLENBQUNDLE9BQU8sRUFBRTtZQUNyREQsTUFBQSxDQUFBQyxPQUFBLEdBQWlCRixVQUFVLEVBQUU7UUFDckMsQ0FBSyxNQUFNO1lBQ0hELElBQUksQ0FBQ0ksR0FBRyxHQUFHSCxVQUFVLEVBQUU7UUFDMUI7SUFDTCxDQUFDLEVBQUNJLGNBQUksRUFBRSxZQUFZO1FBR3BCO1FBQ0ksSUFBSUMsSUFBSSxHQUFHLFlBQVcsQ0FBRTtRQUN4QixJQUFJQyxhQUFhLEdBQUcsV0FBVztRQUMvQixJQUFJQyxJQUFJLEdBQUksT0FBT0MsTUFBTSxHQUFLRixhQUFhLElBQU0sT0FBT0UsTUFBTSxDQUFDQyxTQUFTLEtBQUtILGFBQWMsSUFDdkYsaUJBQWlCLENBQUNJLElBQUksQ0FBQ0YsTUFBTSxDQUFDQyxTQUFTLENBQUNFLFNBQVMsQ0FDcEQ7UUFFRCxJQUFJQyxVQUFVLEdBQUc7WUFDYixPQUFPO1lBQ1AsT0FBTztZQUNQLE1BQU07WUFDTixNQUFNO1lBQ04sT0FBTztTQUNWO1FBRUw7UUFDSSxTQUFTQyxVQUFVQSxDQUFDQyxHQUFHLEVBQUVDLFVBQVUsRUFBRTtZQUNqQyxJQUFJQyxNQUFNLEdBQUdGLEdBQUcsQ0FBQ0MsVUFBVSxDQUFDO1lBQzVCLElBQUksT0FBT0MsTUFBTSxDQUFDQyxJQUFJLEtBQUssVUFBVSxFQUFFO2dCQUNuQyxPQUFPRCxNQUFNLENB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Iiwic291cmNlcyI6WyIvaG9tZS91c2VyL0thbGktRS9ub2RlX21vZHVsZXMvLnBucG0vbG9nbGV2ZWxAMS44LjEvbm9kZV9tb2R1bGVzL2xvZ2xldmVsL2xpYi9sb2dsZXZlbC5qcyIsIi9ob21lL3VzZXIvS2FsaS1FL3NyYy9sb2dnZXIudHMiLCIvaG9tZS91c2VyL0thbGktRS9ub2RlX21vZHVsZXMvLnBucG0vQGJ1ZmJ1aWxkK3Byb3RvYnVmQDEuNC4yL25vZGVfbW9kdWxlcy9AYnVmYnVpbGQvcHJvdG9idWYvZGlzdC9lc20vcHJpdmF0ZS9hc3NlcnQuanMiLCIvaG9tZS91c2VyL0thbGktRS9ub2RlX21vZHVsZXMvLnBucG0vQGJ1ZmJ1aWxkK3Byb3RvYnVmQDEuNC4yL25vZGVfbW9kdWxlcy9AYnVmYnVpbGQvcHJvdG9idWYvZGlzdC9lc20vcHJpdmF0ZS9lbnVtLmpzIiwiL2hvbWUvdXNlci9LYWxpLUUvbm9kZV9tb2R1bGVzLy5wbnBtL0BidWZidWlsZCtwcm90b2J1ZkAxLjQuMi9ub2RlX21vZHVsZXMvQGJ1ZmJ1aWxkL3Byb3RvYnVmL2Rpc3QvZXNtL21lc3NhZ2UuanMiLCIvaG9tZS91c2VyL0thbGktRS9ub2RlX21vZHVsZXMvLnBucG0vQGJ1ZmJ1aWxkK3Byb3RvYnVmQDEuNC4yL25vZGVfbW9kdWxlcy9AYnVmYnVpbGQvcHJvdG9idWYvZGlzdC9lc20vcHJpdmF0ZS9tZXNzYWdlLXR5cGUuanMiLCIvaG9tZS91c2VyL0thbGktRS9ub2RlX21vZHVsZXMvLnBucG0vQGJ1ZmJ1aWxkK3Byb3RvYnVmQDEuNC4yL25vZGVfbW9kdWxlcy9AYnVmYnVpbGQvcHJvdG9idWYvZGlzdC9lc20vcHJpdmF0ZS9wcm90by1ydW50aW1lLmpzIiwiL2hvbWUvdXNlci9LYWxpLUUvbm9kZV9tb2R1bGVzLy5wbnBtL0BidWZidWlsZCtwcm90b2J1ZkAxLjQuMi9ub2RlX21vZHVsZXMvQGJ1ZmJ1aWxkL3Byb3RvYnVmL2Rpc3QvZXNtL2ZpZWxkLmpzIiwiL2hvbWUvdXNlci9LYWxpLUUvbm9kZV9tb2R1bGVzLy5wbnBtL0BidWZidWlsZCtwcm90b2J1ZkAxLjQuMi9ub2RlX21vZHVsZXMvQGJ1ZmJ1aWxkL3Byb3RvYnVmL2Rpc3QvZXNtL2dvb2dsZS92YXJpbnQuanMiLCIvaG9tZS91c2VyL0thbGktRS9ub2RlX21vZHVsZXMvLnBucG0vQGJ1ZmJ1aWxkK3Byb3RvYnVmQDEuNC4yL25vZGVfbW9kdWxlcy9AYnVmYnVpbGQvcHJvdG9idWYvZGlzdC9lc20vcHJvdG8taW50NjQuanMiLCIvaG9tZS91c2VyL0thbGktRS9ub2RlX21vZHVsZXMvLnBucG0vQGJ1ZmJ1aWxkK3Byb3RvYnVmQDEuNC4yL25vZGVfbW9kdWxlcy9AYnVmYnVpbGQvcHJvdG9idWYvZGlzdC9lc20vYmluYXJ5LWVuY29kaW5nLmpzIiwiL2hvbWUvdXNlci9LYWxpLUUvbm9kZV9tb2R1bGVzLy5wbnBtL0BidWZidWlsZCtwcm90b2J1ZkAxLjQuMi9ub2RlX21vZHVsZXMvQGJ1ZmJ1aWxkL3Byb3RvYnVmL2Rpc3QvZXNtL3ByaXZhdGUvZmllbGQtd3JhcHBlci5qcyIsIi9ob21lL3VzZXIvS2FsaS1FL25vZGVfbW9kdWxlcy8ucG5wbS9AYnVmYnVpbGQrcHJvdG9idWZAMS40LjIvbm9kZV9tb2R1bGVzL0BidWZidWlsZC9wcm90b2J1Zi9kaXN0L2VzbS9wcml2YXRlL3NjYWxhcnMuanMiLCIvaG9tZS91c2VyL0thbGktRS9ub2RlX21vZHVsZXMvLnBucG0vQGJ1ZmJ1aWxkK3Byb3RvYnVmQDEuNC4yL25vZGVfbW9kdWxlcy9AYnVmYnVpbGQvcHJvdG9idWYvZGlzdC9lc20vcHJpdmF0ZS9iaW5hcnktZm9ybWF0LWNvbW1vbi5qcyIsIi9ob21lL3VzZXIvS2FsaS1FL25vZGVfbW9kdWxlcy8ucG5wbS9AYnVmYnVpbGQrcHJvdG9idWZAMS40LjIvbm9kZV9tb2R1bGVzL0BidWZidWlsZC9wcm90b2J1Zi9kaXN0L2VzbS9wcml2YXRlL2JpbmFyeS1mb3JtYXQtcHJvdG8zLmpzIiwiL2hvbWUvdXNlci9LYWxpLUUvbm9kZV9tb2R1bGVzLy5wbnBtL0BidWZidWlsZCtwcm90b2J1ZkAxLjQuMi9ub2RlX21vZHVsZXMvQGJ1ZmJ1aWxkL3Byb3RvYnVmL2Rpc3QvZXNtL3Byb3RvLWJhc2U2NC5qcyIsIi9ob21lL3VzZXIvS2FsaS1FL25vZGVfbW9kdWxlcy8ucG5wbS9AYnVmYnVpbGQrcHJvdG9idWZAMS40LjIvbm9kZV9tb2R1bGVzL0BidWZidWlsZC9wcm90b2J1Zi9kaXN0L2VzbS9wcml2YXRlL2pzb24tZm9ybWF0LWNvbW1vbi5qcyIsIi9ob21lL3VzZXIvS2FsaS1FL25vZGVfbW9kdWxlcy8ucG5wbS9AYnVmYnVpbGQrcHJvdG9idWZAMS40LjIvbm9kZV9tb2R1bGVzL0BidWZidWlsZC9wcm90b2J1Zi9kaXN0L2VzbS9wcml2YXRlL2pzb24tZm9ybWF0LXByb3RvMy5qcyIsIi9ob21lL3VzZXIvS2FsaS1FL25vZGVfbW9kdWxlcy8ucG5wbS9AYnVmYnVpbGQrcHJvdG9idWZAMS40LjIvbm9kZV9tb2R1bGVzL0BidWZidWlsZC9wcm90b2J1Zi9kaXN0L2VzbS9wcml2YXRlL3V0aWwtY29tbW9uLmpzIiwiL2hvbWUvdXNlci9LYWxpLUUvbm9kZV9tb2R1bGVzLy5wbnBtL0BidWZidWlsZCtwcm90b2J1ZkAxLjQuMi9ub2RlX21vZHVsZXMvQGJ1ZmJ1aWxkL3Byb3RvYnVmL2Rpc3QvZXNtL3ByaXZhdGUvZmllbGQtbGlzdC5qcyIsIi9ob21lL3VzZXIvS2FsaS1FL25vZGVfbW9kdWxlcy8ucG5wbS9AYnVmYnVpbGQrcHJvdG9idWZAMS40LjIvbm9kZV9tb2R1bGVzL0BidWZidWlsZC9wcm90b2J1Zi9kaXN0L2VzbS9wcml2YXRlL25hbWVzLmpzIiwiL2hvbWUvdXNlci9LYWxpLUUvbm9kZV9tb2R1bGVzLy5wbnBtL0BidWZidWlsZCtwcm90b2J1ZkAxLjQuMi9ub2RlX21vZHVsZXMvQGJ1ZmJ1aWxkL3Byb3RvYnVmL2Rpc3QvZXNtL3ByaXZhdGUvZmllbGQuanMiLCIvaG9tZS91c2VyL0thbGktRS9ub2RlX21vZHVsZXMvLnBucG0vQGJ1ZmJ1aWxkK3Byb3RvYnVmQDEuNC4yL25vZGVfbW9kdWxlcy9AYnVmYnVpbGQvcHJvdG9idWYvZGlzdC9lc20vcHJvdG8zLmpzIiwiL2hvbWUvdXNlci9LYWxpLUUvbm9kZV9tb2R1bGVzLy5wbnBtL0BidWZidWlsZCtwcm90b2J1ZkAxLjQuMi9ub2RlX21vZHVsZXMvQGJ1ZmJ1aWxkL3Byb3RvYnVmL2Rpc3QvZXNtL2dvb2dsZS9wcm90b2J1Zi90aW1lc3RhbXBfcGIuanMiLCIvaG9tZS91c2VyL0thbGktRS9zcmMvcHJvdG8vbGl2ZWtpdF9tb2RlbHNfcGIudHMiLCIvaG9tZS91c2VyL0thbGktRS9zcmMvcm9vbS9EZWZhdWx0UmVjb25uZWN0UG9saWN5LnRzIiwiL2hvbWUvdXNlci9LYWxpLUUvbm9kZV9tb2R1bGVzLy5wbnBtL2V2ZW50c0AzLjMuMC9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIi9ob21lL3VzZXIvS2FsaS1FL25vZGVfbW9kdWxlcy8ucG5wbS93ZWJydGMtYWRhcHRlckA4LjIuMy9ub2RlX21vZHVsZXMvd2VicnRjLWFkYXB0ZXIvc3JjL2pzL3V0aWxzLmpzIiwiL2hvbWUvdXNlci9LYWxpLUUvbm9kZV9tb2R1bGVzLy5wbnBtL3dlYnJ0Yy1hZGFwdGVyQDguMi4zL25vZGVfbW9kdWxlcy93ZWJydGMtYWRhcHRlci9zcmMvanMvY2hyb21lL2dldHVzZXJtZWRpYS5qcyIsIi9ob21lL3VzZXIvS2FsaS1FL25vZGVfbW9kdWxlcy8ucG5wbS93ZWJydGMtYWRhcHRlckA4LjIuMy9ub2RlX21vZHVsZXMvd2VicnRjLWFkYXB0ZXIvc3JjL2pzL2Nocm9tZS9nZXRkaXNwbGF5bWVkaWEuanMiLCIvaG9tZS91c2VyL0thbGktRS9ub2RlX21vZHVsZXMvLnBucG0vd2VicnRjLWFkYXB0ZXJAOC4yLjMvbm9kZV9tb2R1bGVzL3dlYnJ0Yy1hZGFwdGVyL3NyYy9qcy9jaHJvbWUvY2hyb21lX3NoaW0uanMiLCIvaG9tZS91c2VyL0thbGktRS9ub2RlX21vZHVsZXMvLnBucG0vd2VicnRjLWFkYXB0ZXJAOC4yLjMvbm9kZV9tb2R1bGVzL3dlYnJ0Yy1hZGFwdGVyL3NyYy9qcy9maXJlZm94L2dldHVzZXJtZWRpYS5qcyIsIi9ob21lL3VzZXIvS2FsaS1FL25vZGVfbW9kdWxlcy8ucG5wbS93ZWJydGMtYWRhcHRlckA4LjIuMy9ub2RlX21vZHVsZXMvd2VicnRjLWFkYXB0ZXIvc3JjL2pzL2ZpcmVmb3gvZ2V0ZGlzcGxheW1lZGlhLmpzIiwiL2hvbWUvdXNlci9LYWxpLUUvbm9kZV9tb2R1bGVzLy5wbnBtL3dlYnJ0Yy1hZGFwdGVyQDguMi4zL25vZGVfbW9kdWxlcy93ZWJydGMtYWRhcHRlci9zcmMvanMvZmlyZWZveC9maXJlZm94X3NoaW0uanMiLCIvaG9tZS91c2VyL0thbGktRS9ub2RlX21vZHVsZXMvLnBucG0vd2VicnRjLWFkYXB0ZXJAOC4yLjMvbm9kZV9tb2R1bGVzL3dlYnJ0Yy1hZGFwdGVyL3NyYy9qcy9zYWZhcmkvc2FmYXJpX3NoaW0uanMiLCIvaG9tZS91c2VyL0thbGktRS9ub2RlX21vZHVsZXMvLnBucG0vc2RwQDMuMi4wL25vZGVfbW9kdWxlcy9zZHAvc2RwLmpzIiwiL2hvbWUvdXNlci9LYWxpLUUvbm9kZV9tb2R1bGVzLy5wbnBtL3dlYnJ0Yy1hZGFwdGVyQDguMi4zL25vZGVfbW9kdWxlcy93ZWJydGMtYWRhcHRlci9zcmMvanMvY29tbW9uX3NoaW0uanMiLCIvaG9tZS91c2VyL0thbGktRS9ub2RlX21vZHVsZXMvLnBucG0vd2VicnRjLWFkYXB0ZXJAOC4yLjMvbm9kZV9tb2R1bGVzL3dlYnJ0Yy1hZGFwdGVyL3NyYy9qcy9hZGFwdGVyX2ZhY3RvcnkuanMiLCIvaG9tZS91c2VyL0thbGktRS9ub2RlX21vZHVsZXMvLnBucG0vd2VicnRjLWFkYXB0ZXJAOC4yLjMvbm9kZV9tb2R1bGVzL3dlYnJ0Yy1hZGFwdGVyL3NyYy9qcy9hZGFwdGVyX2NvcmUuanMiLCIvaG9tZS91c2VyL0thbGktRS9zcmMvZTJlZS9jb25zdGFudHMudHMiLCIvaG9tZS91c2VyL0thbGktRS9zcmMvZTJlZS9ldmVudHMudHMiLCIvaG9tZS91c2VyL0thbGktRS9zcmMvZTJlZS91dGlscy50cyIsIi9ob21lL3VzZXIvS2FsaS1FL3NyYy9lMmVlL0tleVByb3ZpZGVyLnRzIiwiL2hvbWUvdXNlci9LYWxpLUUvc3JjL3Jvb20vZXJyb3JzLnRzIiwiL2hvbWUvdXNlci9LYWxpLUUvc3JjL3Jvb20vZXZlbnRzLnRzIiwiL2hvbWUvdXNlci9LYWxpLUUvbm9kZV9tb2R1bGVzLy5wbnBtL3RzLWRlYm91bmNlQDQuMC4wL25vZGVfbW9kdWxlcy90cy1kZWJvdW5jZS9kaXN0L3NyYy9pbmRleC5lc20uanMiLCIvaG9tZS91c2VyL0thbGktRS9zcmMvdXRpbHMvYnJvd3NlclBhcnNlci50cyIsIi9ob21lL3VzZXIvS2FsaS1FL3NyYy92ZXJzaW9uLnRzIiwiL2hvbWUvdXNlci9LYWxpLUUvc3JjL3Jvb20vdGltZXJzLnRzIiwiL2hvbWUvdXNlci9LYWxpLUUvc3JjL3Jvb20vdHJhY2svb3B0aW9ucy50cyIsIi9ob21lL3VzZXIvS2FsaS1FL3NyYy9wcm90by9saXZla2l0X3J0Y19wYi50cyIsIi9ob21lL3VzZXIvS2FsaS1FL3NyYy91dGlscy9jbG9uZURlZXAudHMiLCIvaG9tZS91c2VyL0thbGktRS9zcmMvcm9vbS90cmFjay9UcmFjay50cyIsIi9ob21lL3VzZXIvS2FsaS1FL3NyYy9yb29tL3RyYWNrL3V0aWxzLnRzIiwiL2hvbWUvdXNlci9LYWxpLUUvc3JjL3Jvb20vdXRpbHMudHMiLCIvaG9tZS91c2VyL0thbGktRS9zcmMvcm9vbS9EZXZpY2VNYW5hZ2VyLnRzIiwiL2hvbWUvdXNlci9LYWxpLUUvc3JjL3Jvb20vdHJhY2svTG9jYWxUcmFjay50cyIsIi9ob21lL3VzZXIvS2FsaS1FL3NyYy9lMmVlL0UyZWVNYW5hZ2VyLnRzIiwiL2hvbWUvdXNlci9LYWxpLUUvc3JjL3V0aWxzL0FzeW5jUXVldWUudHMiLCIvaG9tZS91c2VyL0thbGktRS9zcmMvYXBpL1NpZ25hbENsaWVudC50cyIsIi9ob21lL3VzZXIvS2FsaS1FL25vZGVfbW9kdWxlcy8ucG5wbS9zZHAtdHJhbnNmb3JtQDIuMTQuMS9ub2RlX21vZHVsZXMvc2RwLXRyYW5zZm9ybS9saWIvZ3JhbW1hci5qcyIsIi9ob21lL3VzZXIvS2FsaS1FL25vZGVfbW9kdWxlcy8ucG5wbS9zZHAtdHJhbnNmb3JtQDIuMTQuMS9ub2RlX21vZHVsZXMvc2RwLXRyYW5zZm9ybS9saWIvcGFyc2VyLmpzIiwiL2hvbWUvdXNlci9LYWxpLUUvbm9kZV9tb2R1bGVzLy5wbnBtL3NkcC10cmFuc2Zvcm1AMi4xNC4xL25vZGVfbW9kdWxlcy9zZHAtdHJhbnNmb3JtL2xpYi93cml0ZXIuanMiLCIvaG9tZS91c2VyL0thbGktRS9ub2RlX21vZHVsZXMvLnBucG0vc2RwLXRyYW5zZm9ybUAyLjE0LjEvbm9kZV9tb2R1bGVzL3NkcC10cmFuc2Zvcm0vbGliL2luZGV4LmpzIiwiL2hvbWUvdXNlci9LYWxpLUUvc3JjL3Jvb20vUENUcmFuc3BvcnQudHMiLCIvaG9tZS91c2VyL0thbGktRS9zcmMvcm9vbS9kZWZhdWx0cy50cyIsIi9ob21lL3VzZXIvS2FsaS1FL3NyYy9yb29tL1BDVHJhbnNwb3J0TWFuYWdlci50cyIsIi9ob21lL3VzZXIvS2FsaS1FL3NyYy9yb29tL1JUQ0VuZ2luZS50cyIsIi9ob21lL3VzZXIvS2FsaS1FL3NyYy9yb29tL1JlZ2lvblVybFByb3ZpZGVyLnRzIiwiL2hvbWUvdXNlci9LYWxpLUUvc3JjL3Jvb20vc3RhdHMudHMiLCIvaG9tZS91c2VyL0thbGktRS9zcmMvcm9vbS90cmFjay9Mb2NhbEF1ZGlvVHJhY2sudHMiLCIvaG9tZS91c2VyL0thbGktRS9zcmMvcm9vbS9wYXJ0aWNpcGFudC9wdWJsaXNoVXRpbHMudHMiLCIvaG9tZS91c2VyL0thbGktRS9zcmMvcm9vbS90cmFjay9Mb2NhbFZpZGVvVHJhY2sudHMiLCIvaG9tZS91c2VyL0thbGktRS9zcmMvcm9vbS90cmFjay9SZW1vdGVUcmFjay50cyIsIi9ob21lL3VzZXIvS2FsaS1FL3NyYy9yb29tL3RyYWNrL1JlbW90ZUF1ZGlvVHJhY2sudHMiLCIvaG9tZS91c2VyL0thbGktRS9zcmMvcm9vbS90cmFjay9SZW1vdGVWaWRlb1RyYWNrLnRzIiwiL2hvbWUvdXNlci9LYWxpLUUvc3JjL3Jvb20vdHJhY2svVHJhY2tQdWJsaWNhdGlvbi50cyIsIi9ob21lL3VzZXIvS2FsaS1FL3NyYy9yb29tL3RyYWNrL0xvY2FsVHJhY2tQdWJsaWNhdGlvbi50cyIsIi9ob21lL3VzZXIvS2FsaS1FL3NyYy9yb29tL3BhcnRpY2lwYW50L1BhcnRpY2lwYW50LnRzIiwiL2hvbWUvdXNlci9LYWxpLUUvc3JjL3Jvb20vcGFydGljaXBhbnQvUGFydGljaXBhbnRUcmFja1Blcm1pc3Npb24udHMiLCIvaG9tZS91c2VyL0thbGktRS9zcmMvcm9vbS90cmFjay9SZW1vdGVUcmFja1B1YmxpY2F0aW9uLnRzIiwiL2hvbWUvdXNlci9LYWxpLUUvc3JjL3Jvb20vcGFydGljaXBhbnQvUmVtb3RlUGFydGljaXBhbnQudHMiLCIvaG9tZS91c2VyL0thbGktRS9zcmMvcm9vbS9wYXJ0aWNpcGFudC9Mb2NhbFBhcnRpY2lwYW50LnRzIiwiL2hvbWUvdXNlci9LYWxpLUUvc3JjL3Jvb20vUm9vbS50cyIsIi9ob21lL3VzZXIvS2FsaS1FL3NyYy9jb25uZWN0aW9uSGVscGVyL2NoZWNrcy9DaGVja2VyLnRzIiwiL2hvbWUvdXNlci9LYWxpLUUvc3JjL3Jvb20vdHJhY2svY3JlYXRlLnRzIiwiL2hvbWUvdXNlci9LYWxpLUUvc3JjL2Nvbm5lY3Rpb25IZWxwZXIvY2hlY2tzL3B1Ymxpc2hBdWRpby50cyIsIi9ob21lL3VzZXIvS2FsaS1FL3NyYy9jb25uZWN0aW9uSGVscGVyL2NoZWNrcy9wdWJsaXNoVmlkZW8udHMiLCIvaG9tZS91c2VyL0thbGktRS9zcmMvY29ubmVjdGlvbkhlbHBlci9jaGVja3MvcmVjb25uZWN0LnRzIiwiL2hvbWUvdXNlci9LYWxpLUUvc3JjL2Nvbm5lY3Rpb25IZWxwZXIvY2hlY2tzL3R1cm4udHMiLCIvaG9tZS91c2VyL0thbGktRS9zcmMvY29ubmVjdGlvbkhlbHBlci9jaGVja3Mvd2VicnRjLnRzIiwiL2hvbWUvdXNlci9LYWxpLUUvc3JjL2Nvbm5lY3Rpb25IZWxwZXIvY2hlY2tzL3dlYnNvY2tldC50cyIsIi9ob21lL3VzZXIvS2FsaS1FL3NyYy9jb25uZWN0aW9uSGVscGVyL0Nvbm5lY3Rpb25DaGVjay50cyIsIi9ob21lL3VzZXIvS2FsaS1FL3NyYy9yb29tL3RyYWNrL2ZhY2luZ01vZGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiogbG9nbGV2ZWwgLSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWxcbipcbiogQ29weXJpZ2h0IChjKSAyMDEzIFRpbSBQZXJyeVxuKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4qL1xuKGZ1bmN0aW9uIChyb290LCBkZWZpbml0aW9uKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoZGVmaW5pdGlvbik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGRlZmluaXRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByb290LmxvZyA9IGRlZmluaXRpb24oKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vIFNsaWdodGx5IGR1YmlvdXMgdHJpY2tzIHRvIGN1dCBkb3duIG1pbmltaXplZCBmaWxlIHNpemVcbiAgICB2YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XG4gICAgdmFyIHVuZGVmaW5lZFR5cGUgPSBcInVuZGVmaW5lZFwiO1xuICAgIHZhciBpc0lFID0gKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUpICYmICh0eXBlb2Ygd2luZG93Lm5hdmlnYXRvciAhPT0gdW5kZWZpbmVkVHlwZSkgJiYgKFxuICAgICAgICAvVHJpZGVudFxcL3xNU0lFIC8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudClcbiAgICApO1xuXG4gICAgdmFyIGxvZ01ldGhvZHMgPSBbXG4gICAgICAgIFwidHJhY2VcIixcbiAgICAgICAgXCJkZWJ1Z1wiLFxuICAgICAgICBcImluZm9cIixcbiAgICAgICAgXCJ3YXJuXCIsXG4gICAgICAgIFwiZXJyb3JcIlxuICAgIF07XG5cbiAgICAvLyBDcm9zcy1icm93c2VyIGJpbmQgZXF1aXZhbGVudCB0aGF0IHdvcmtzIGF0IGxlYXN0IGJhY2sgdG8gSUU2XG4gICAgZnVuY3Rpb24gYmluZE1ldGhvZChvYmosIG1ldGhvZE5hbWUpIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IG9ialttZXRob2ROYW1lXTtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QuYmluZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5iaW5kKG9iaik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5jYWxsKG1ldGhvZCwgb2JqKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBNaXNzaW5nIGJpbmQgc2hpbSBvciBJRTggKyBNb2Rlcm5penIsIGZhbGxiYWNrIHRvIHdyYXBwaW5nXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmFwcGx5KG1ldGhvZCwgW29iaiwgYXJndW1lbnRzXSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRyYWNlKCkgZG9lc24ndCBwcmludCB0aGUgbWVzc2FnZSBpbiBJRSwgc28gZm9yIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIHdyYXAgaXRcbiAgICBmdW5jdGlvbiB0cmFjZUZvcklFKCkge1xuICAgICAgICBpZiAoY29uc29sZS5sb2cpIHtcbiAgICAgICAgICAgIGlmIChjb25zb2xlLmxvZy5hcHBseSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEluIG9sZCBJRSwgbmF0aXZlIGNvbnNvbGUgbWV0aG9kcyB0aGVtc2VsdmVzIGRvbid0IGhhdmUgYXBwbHkoKS5cbiAgICAgICAgICAgICAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkoY29uc29sZS5sb2csIFtjb25zb2xlLCBhcmd1bWVudHNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uc29sZS50cmFjZSkgY29uc29sZS50cmFjZSgpO1xuICAgIH1cblxuICAgIC8vIEJ1aWxkIHRoZSBiZXN0IGxvZ2dpbmcgbWV0aG9kIHBvc3NpYmxlIGZvciB0aGlzIGVudlxuICAgIC8vIFdoZXJldmVyIHBvc3NpYmxlIHdlIHdhbnQgdG8gYmluZCwgbm90IHdyYXAsIHRvIHByZXNlcnZlIHN0YWNrIHRyYWNlc1xuICAgIGZ1bmN0aW9uIHJlYWxNZXRob2QobWV0aG9kTmFtZSkge1xuICAgICAgICBpZiAobWV0aG9kTmFtZSA9PT0gJ2RlYnVnJykge1xuICAgICAgICAgICAgbWV0aG9kTmFtZSA9ICdsb2cnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIE5vIG1ldGhvZCBwb3NzaWJsZSwgZm9yIG5vdyAtIGZpeGVkIGxhdGVyIGJ5IGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXNcbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2ROYW1lID09PSAndHJhY2UnICYmIGlzSUUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmFjZUZvcklFO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbGVbbWV0aG9kTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgbWV0aG9kTmFtZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29uc29sZS5sb2cgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgJ2xvZycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGVzZSBwcml2YXRlIGZ1bmN0aW9ucyBhbHdheXMgbmVlZCBgdGhpc2AgdG8gYmUgc2V0IHByb3Blcmx5XG5cbiAgICBmdW5jdGlvbiByZXBsYWNlTG9nZ2luZ01ldGhvZHMobGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2dNZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kTmFtZSA9IGxvZ01ldGhvZHNbaV07XG4gICAgICAgICAgICB0aGlzW21ldGhvZE5hbWVdID0gKGkgPCBsZXZlbCkgP1xuICAgICAgICAgICAgICAgIG5vb3AgOlxuICAgICAgICAgICAgICAgIHRoaXMubWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWZpbmUgbG9nLmxvZyBhcyBhbiBhbGlhcyBmb3IgbG9nLmRlYnVnXG4gICAgICAgIHRoaXMubG9nID0gdGhpcy5kZWJ1ZztcbiAgICB9XG5cbiAgICAvLyBJbiBvbGQgSUUgdmVyc2lvbnMsIHRoZSBjb25zb2xlIGlzbid0IHByZXNlbnQgdW50aWwgeW91IGZpcnN0IG9wZW4gaXQuXG4gICAgLy8gV2UgYnVpbGQgcmVhbE1ldGhvZCgpIHJlcGxhY2VtZW50cyBoZXJlIHRoYXQgcmVnZW5lcmF0ZSBsb2dnaW5nIG1ldGhvZHNcbiAgICBmdW5jdGlvbiBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzKG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbCh0aGlzLCBsZXZlbCwgbG9nZ2VyTmFtZSk7XG4gICAgICAgICAgICAgICAgdGhpc1ttZXRob2ROYW1lXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEJ5IGRlZmF1bHQsIHdlIHVzZSBjbG9zZWx5IGJvdW5kIHJlYWwgbWV0aG9kcyB3aGVyZXZlciBwb3NzaWJsZSwgYW5kXG4gICAgLy8gb3RoZXJ3aXNlIHdlIHdhaXQgZm9yIGEgY29uc29sZSB0byBhcHBlYXIsIGFuZCB0aGVuIHRyeSBhZ2Fpbi5cbiAgICBmdW5jdGlvbiBkZWZhdWx0TWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSkge1xuICAgICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgICByZXR1cm4gcmVhbE1ldGhvZChtZXRob2ROYW1lKSB8fFxuICAgICAgICAgICAgICAgZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIExvZ2dlcihuYW1lLCBkZWZhdWx0TGV2ZWwsIGZhY3RvcnkpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBjdXJyZW50TGV2ZWw7XG4gICAgICBkZWZhdWx0TGV2ZWwgPSBkZWZhdWx0TGV2ZWwgPT0gbnVsbCA/IFwiV0FSTlwiIDogZGVmYXVsdExldmVsO1xuXG4gICAgICB2YXIgc3RvcmFnZUtleSA9IFwibG9nbGV2ZWxcIjtcbiAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBzdG9yYWdlS2V5ICs9IFwiOlwiICsgbmFtZTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5hbWUgPT09IFwic3ltYm9sXCIpIHtcbiAgICAgICAgc3RvcmFnZUtleSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcGVyc2lzdExldmVsSWZQb3NzaWJsZShsZXZlbE51bSkge1xuICAgICAgICAgIHZhciBsZXZlbE5hbWUgPSAobG9nTWV0aG9kc1tsZXZlbE51bV0gfHwgJ3NpbGVudCcpLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSB8fCAhc3RvcmFnZUtleSkgcmV0dXJuO1xuXG4gICAgICAgICAgLy8gVXNlIGxvY2FsU3RvcmFnZSBpZiBhdmFpbGFibGVcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlW3N0b3JhZ2VLZXldID0gbGV2ZWxOYW1lO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuXG4gICAgICAgICAgLy8gVXNlIHNlc3Npb24gY29va2llIGFzIGZhbGxiYWNrXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgd2luZG93LmRvY3VtZW50LmNvb2tpZSA9XG4gICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpICsgXCI9XCIgKyBsZXZlbE5hbWUgKyBcIjtcIjtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldFBlcnNpc3RlZExldmVsKCkge1xuICAgICAgICAgIHZhciBzdG9yZWRMZXZlbDtcblxuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlIHx8ICFzdG9yYWdlS2V5KSByZXR1cm47XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IHdpbmRvdy5sb2NhbFN0b3JhZ2Vbc3RvcmFnZUtleV07XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuXG4gICAgICAgICAgLy8gRmFsbGJhY2sgdG8gY29va2llcyBpZiBsb2NhbCBzdG9yYWdlIGdpdmVzIHVzIG5vdGhpbmdcbiAgICAgICAgICBpZiAodHlwZW9mIHN0b3JlZExldmVsID09PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY29va2llID0gd2luZG93LmRvY3VtZW50LmNvb2tpZTtcbiAgICAgICAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IGNvb2tpZS5pbmRleE9mKFxuICAgICAgICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdG9yYWdlS2V5KSArIFwiPVwiKTtcbiAgICAgICAgICAgICAgICAgIGlmIChsb2NhdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IC9eKFteO10rKS8uZXhlYyhjb29raWUuc2xpY2UobG9jYXRpb24pKVsxXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIHRoZSBzdG9yZWQgbGV2ZWwgaXMgbm90IHZhbGlkLCB0cmVhdCBpdCBhcyBpZiBub3RoaW5nIHdhcyBzdG9yZWQuXG4gICAgICAgICAgaWYgKHNlbGYubGV2ZWxzW3N0b3JlZExldmVsXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHN0b3JlZExldmVsID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzdG9yZWRMZXZlbDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY2xlYXJQZXJzaXN0ZWRMZXZlbCgpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSB8fCAhc3RvcmFnZUtleSkgcmV0dXJuO1xuXG4gICAgICAgICAgLy8gVXNlIGxvY2FsU3RvcmFnZSBpZiBhdmFpbGFibGVcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oc3RvcmFnZUtleSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgICAgICAgICAvLyBVc2Ugc2Vzc2lvbiBjb29raWUgYXMgZmFsbGJhY2tcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuY29va2llID1cbiAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RvcmFnZUtleSkgKyBcIj07IGV4cGlyZXM9VGh1LCAwMSBKYW4gMTk3MCAwMDowMDowMCBVVENcIjtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICAgKlxuICAgICAgICogUHVibGljIGxvZ2dlciBBUEkgLSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BpbXRlcnJ5L2xvZ2xldmVsIGZvciBkZXRhaWxzXG4gICAgICAgKlxuICAgICAgICovXG5cbiAgICAgIHNlbGYubmFtZSA9IG5hbWU7XG5cbiAgICAgIHNlbGYubGV2ZWxzID0geyBcIlRSQUNFXCI6IDAsIFwiREVCVUdcIjogMSwgXCJJTkZPXCI6IDIsIFwiV0FSTlwiOiAzLFxuICAgICAgICAgIFwiRVJST1JcIjogNCwgXCJTSUxFTlRcIjogNX07XG5cbiAgICAgIHNlbGYubWV0aG9kRmFjdG9yeSA9IGZhY3RvcnkgfHwgZGVmYXVsdE1ldGhvZEZhY3Rvcnk7XG5cbiAgICAgIHNlbGYuZ2V0TGV2ZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnRMZXZlbDtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuc2V0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwsIHBlcnNpc3QpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGxldmVsID09PSBcInN0cmluZ1wiICYmIHNlbGYubGV2ZWxzW2xldmVsLnRvVXBwZXJDYXNlKCldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgbGV2ZWwgPSBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJudW1iZXJcIiAmJiBsZXZlbCA+PSAwICYmIGxldmVsIDw9IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xuICAgICAgICAgICAgICBjdXJyZW50TGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgICAgICAgaWYgKHBlcnNpc3QgIT09IGZhbHNlKSB7ICAvLyBkZWZhdWx0cyB0byB0cnVlXG4gICAgICAgICAgICAgICAgICBwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlKGxldmVsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbChzZWxmLCBsZXZlbCwgbmFtZSk7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSAmJiBsZXZlbCA8IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiTm8gY29uc29sZSBhdmFpbGFibGUgZm9yIGxvZ2dpbmdcIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IFwibG9nLnNldExldmVsKCkgY2FsbGVkIHdpdGggaW52YWxpZCBsZXZlbDogXCIgKyBsZXZlbDtcbiAgICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLnNldERlZmF1bHRMZXZlbCA9IGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgICAgIGRlZmF1bHRMZXZlbCA9IGxldmVsO1xuICAgICAgICAgIGlmICghZ2V0UGVyc2lzdGVkTGV2ZWwoKSkge1xuICAgICAgICAgICAgICBzZWxmLnNldExldmVsKGxldmVsLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi5yZXNldExldmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNlbGYuc2V0TGV2ZWwoZGVmYXVsdExldmVsLCBmYWxzZSk7XG4gICAgICAgICAgY2xlYXJQZXJzaXN0ZWRMZXZlbCgpO1xuICAgICAgfTtcblxuICAgICAgc2VsZi5lbmFibGVBbGwgPSBmdW5jdGlvbihwZXJzaXN0KSB7XG4gICAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5UUkFDRSwgcGVyc2lzdCk7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLmRpc2FibGVBbGwgPSBmdW5jdGlvbihwZXJzaXN0KSB7XG4gICAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5TSUxFTlQsIHBlcnNpc3QpO1xuICAgICAgfTtcblxuICAgICAgLy8gSW5pdGlhbGl6ZSB3aXRoIHRoZSByaWdodCBsZXZlbFxuICAgICAgdmFyIGluaXRpYWxMZXZlbCA9IGdldFBlcnNpc3RlZExldmVsKCk7XG4gICAgICBpZiAoaW5pdGlhbExldmVsID09IG51bGwpIHtcbiAgICAgICAgICBpbml0aWFsTGV2ZWwgPSBkZWZhdWx0TGV2ZWw7XG4gICAgICB9XG4gICAgICBzZWxmLnNldExldmVsKGluaXRpYWxMZXZlbCwgZmFsc2UpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICpcbiAgICAgKiBUb3AtbGV2ZWwgQVBJXG4gICAgICpcbiAgICAgKi9cblxuICAgIHZhciBkZWZhdWx0TG9nZ2VyID0gbmV3IExvZ2dlcigpO1xuXG4gICAgdmFyIF9sb2dnZXJzQnlOYW1lID0ge307XG4gICAgZGVmYXVsdExvZ2dlci5nZXRMb2dnZXIgPSBmdW5jdGlvbiBnZXRMb2dnZXIobmFtZSkge1xuICAgICAgICBpZiAoKHR5cGVvZiBuYW1lICE9PSBcInN5bWJvbFwiICYmIHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiKSB8fCBuYW1lID09PSBcIlwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIllvdSBtdXN0IHN1cHBseSBhIG5hbWUgd2hlbiBjcmVhdGluZyBhIGxvZ2dlci5cIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9nZ2VyID0gX2xvZ2dlcnNCeU5hbWVbbmFtZV07XG4gICAgICAgIGlmICghbG9nZ2VyKSB7XG4gICAgICAgICAgbG9nZ2VyID0gX2xvZ2dlcnNCeU5hbWVbbmFtZV0gPSBuZXcgTG9nZ2VyKFxuICAgICAgICAgICAgbmFtZSwgZGVmYXVsdExvZ2dlci5nZXRMZXZlbCgpLCBkZWZhdWx0TG9nZ2VyLm1ldGhvZEZhY3RvcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dnZXI7XG4gICAgfTtcblxuICAgIC8vIEdyYWIgdGhlIGN1cnJlbnQgZ2xvYmFsIGxvZyB2YXJpYWJsZSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuICAgIHZhciBfbG9nID0gKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUpID8gd2luZG93LmxvZyA6IHVuZGVmaW5lZDtcbiAgICBkZWZhdWx0TG9nZ2VyLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUgJiZcbiAgICAgICAgICAgICAgIHdpbmRvdy5sb2cgPT09IGRlZmF1bHRMb2dnZXIpIHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2cgPSBfbG9nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRMb2dnZXI7XG4gICAgfTtcblxuICAgIGRlZmF1bHRMb2dnZXIuZ2V0TG9nZ2VycyA9IGZ1bmN0aW9uIGdldExvZ2dlcnMoKSB7XG4gICAgICAgIHJldHVybiBfbG9nZ2Vyc0J5TmFtZTtcbiAgICB9O1xuXG4gICAgLy8gRVM2IGRlZmF1bHQgZXhwb3J0LCBmb3IgY29tcGF0aWJpbGl0eVxuICAgIGRlZmF1bHRMb2dnZXJbJ2RlZmF1bHQnXSA9IGRlZmF1bHRMb2dnZXI7XG5cbiAgICByZXR1cm4gZGVmYXVsdExvZ2dlcjtcbn0pKTtcbiIsImltcG9ydCAqIGFzIGxvZyBmcm9tICdsb2dsZXZlbCc7XG5cbmV4cG9ydCBlbnVtIExvZ0xldmVsIHtcbiAgdHJhY2UgPSAwLFxuICBkZWJ1ZyA9IDEsXG4gIGluZm8gPSAyLFxuICB3YXJuID0gMyxcbiAgZXJyb3IgPSA0LFxuICBzaWxlbnQgPSA1LFxufVxuXG5leHBvcnQgZW51bSBMb2dnZXJOYW1lcyB7XG4gIERlZmF1bHQgPSAnbGl2ZWtpdCcsXG4gIFJvb20gPSAnbGl2ZWtpdC1yb29tJyxcbiAgUGFydGljaXBhbnQgPSAnbGl2ZWtpdC1wYXJ0aWNpcGFudCcsXG4gIFRyYWNrID0gJ2xpdmVraXQtdHJhY2snLFxuICBQdWJsaWNhdGlvbiA9ICdsaXZla2l0LXRyYWNrLXB1YmxpY2F0aW9uJyxcbiAgRW5naW5lID0gJ2xpdmVraXQtZW5naW5lJyxcbiAgU2lnbmFsID0gJ2xpdmVraXQtc2lnbmFsJyxcbiAgUENNYW5hZ2VyID0gJ2xpdmVraXQtcGMtbWFuYWdlcicsXG4gIFBDVHJhbnNwb3J0ID0gJ2xpdmVraXQtcGMtdHJhbnNwb3J0JyxcbiAgRTJFRSA9ICdsay1lMmVlJyxcbn1cblxudHlwZSBMb2dMZXZlbFN0cmluZyA9IGtleW9mIHR5cGVvZiBMb2dMZXZlbDtcblxuZXhwb3J0IHR5cGUgU3RydWN0dXJlZExvZ2dlciA9IHtcbiAgdHJhY2U6IChtc2c6IHN0cmluZywgY29udGV4dD86IG9iamVjdCkgPT4gdm9pZDtcbiAgZGVidWc6IChtc2c6IHN0cmluZywgY29udGV4dD86IG9iamVjdCkgPT4gdm9pZDtcbiAgaW5mbzogKG1zZzogc3RyaW5nLCBjb250ZXh0Pzogb2JqZWN0KSA9PiB2b2lkO1xuICB3YXJuOiAobXNnOiBzdHJpbmcsIGNvbnRleHQ/OiBvYmplY3QpID0+IHZvaWQ7XG4gIGVycm9yOiAobXNnOiBzdHJpbmcsIGNvbnRleHQ/OiBvYmplY3QpID0+IHZvaWQ7XG4gIHNldERlZmF1bHRMZXZlbDogKGxldmVsOiBsb2cuTG9nTGV2ZWxEZXNjKSA9PiB2b2lkO1xufTtcblxubGV0IGxpdmVraXRMb2dnZXIgPSBsb2cuZ2V0TG9nZ2VyKCdsaXZla2l0Jyk7XG5cbmxpdmVraXRMb2dnZXIuc2V0RGVmYXVsdExldmVsKExvZ0xldmVsLmluZm8pO1xuXG5leHBvcnQgZGVmYXVsdCBsaXZla2l0TG9nZ2VyIGFzIFN0cnVjdHVyZWRMb2dnZXI7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRMb2dnZXIobmFtZTogc3RyaW5nKSB7XG4gIGNvbnN0IGxvZ2dlciA9IGxvZy5nZXRMb2dnZXIobmFtZSk7XG4gIGxvZ2dlci5zZXREZWZhdWx0TGV2ZWwobGl2ZWtpdExvZ2dlci5nZXRMZXZlbCgpKTtcbiAgcmV0dXJuIGxvZ2dlciBhcyBTdHJ1Y3R1cmVkTG9nZ2VyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0TG9nTGV2ZWwobGV2ZWw6IExvZ0xldmVsIHwgTG9nTGV2ZWxTdHJpbmcsIGxvZ2dlck5hbWU/OiBMb2dnZXJOYW1lcykge1xuICBpZiAobG9nZ2VyTmFtZSkge1xuICAgIGxvZy5nZXRMb2dnZXIobG9nZ2VyTmFtZSkuc2V0TGV2ZWwobGV2ZWwpO1xuICB9XG4gIGZvciAoY29uc3QgbG9nZ2VyIG9mIE9iamVjdC5lbnRyaWVzKGxvZy5nZXRMb2dnZXJzKCkpXG4gICAgLmZpbHRlcigoW2xvZ3JOYW1lXSkgPT4gbG9nck5hbWUuc3RhcnRzV2l0aCgnbGl2ZWtpdCcpKVxuICAgIC5tYXAoKFssIGxvZ3JdKSA9PiBsb2dyKSkge1xuICAgIGxvZ2dlci5zZXRMZXZlbChsZXZlbCk7XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgTG9nRXh0ZW5zaW9uID0gKGxldmVsOiBMb2dMZXZlbCwgbXNnOiBzdHJpbmcsIGNvbnRleHQ/OiBvYmplY3QpID0+IHZvaWQ7XG5cbi8qKlxuICogdXNlIHRoaXMgdG8gaG9vayBpbnRvIHRoZSBsb2dnaW5nIGZ1bmN0aW9uIHRvIGFsbG93IHNlbmRpbmcgaW50ZXJuYWwgbGl2ZWtpdCBsb2dzIHRvIHRoaXJkIHBhcnR5IHNlcnZpY2VzXG4gKiBpZiBzZXQsIHRoZSBicm93c2VyIGxvZ3Mgd2lsbCBsb3NlIHRoZWlyIHN0YWNrdHJhY2UgaW5mb3JtYXRpb24gKHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWwjd3JpdGluZy1wbHVnaW5zKVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0TG9nRXh0ZW5zaW9uKGV4dGVuc2lvbjogTG9nRXh0ZW5zaW9uLCBsb2dnZXIgPSBsaXZla2l0TG9nZ2VyKSB7XG4gIGNvbnN0IG9yaWdpbmFsRmFjdG9yeSA9IGxvZ2dlci5tZXRob2RGYWN0b3J5O1xuXG4gIGxvZ2dlci5tZXRob2RGYWN0b3J5ID0gKG1ldGhvZE5hbWUsIGNvbmZpZ0xldmVsLCBsb2dnZXJOYW1lKSA9PiB7XG4gICAgY29uc3QgcmF3TWV0aG9kID0gb3JpZ2luYWxGYWN0b3J5KG1ldGhvZE5hbWUsIGNvbmZpZ0xldmVsLCBsb2dnZXJOYW1lKTtcblxuICAgIGNvbnN0IGxvZ0xldmVsID0gTG9nTGV2ZWxbbWV0aG9kTmFtZSBhcyBMb2dMZXZlbFN0cmluZ107XG4gICAgY29uc3QgbmVlZExvZyA9IGxvZ0xldmVsID49IGNvbmZpZ0xldmVsICYmIGxvZ0xldmVsIDwgTG9nTGV2ZWwuc2lsZW50O1xuXG4gICAgcmV0dXJuIChtc2csIGNvbnRleHQ/OiBbbXNnOiBzdHJpbmcsIGNvbnRleHQ6IG9iamVjdF0pID0+IHtcbiAgICAgIGlmIChjb250ZXh0KSByYXdNZXRob2QobXNnLCBjb250ZXh0KTtcbiAgICAgIGVsc2UgcmF3TWV0aG9kKG1zZyk7XG4gICAgICBpZiAobmVlZExvZykge1xuICAgICAgICBleHRlbnNpb24obG9nTGV2ZWwsIG1zZywgY29udGV4dCk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgbG9nZ2VyLnNldExldmVsKGxvZ2dlci5nZXRMZXZlbCgpKTsgLy8gQmUgc3VyZSB0byBjYWxsIHNldExldmVsIG1ldGhvZCBpbiBvcmRlciB0byBhcHBseSBwbHVnaW5cbn1cblxuZXhwb3J0IGNvbnN0IHdvcmtlckxvZ2dlciA9IGxvZy5nZXRMb2dnZXIoJ2xrLWUyZWUnKSBhcyBTdHJ1Y3R1cmVkTG9nZ2VyO1xuIiwiLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQXNzZXJ0IHRoYXQgY29uZGl0aW9uIGlzIHRydXRoeSBvciB0aHJvdyBlcnJvciAod2l0aCBtZXNzYWdlKVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbXNnKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zdHJpY3QtYm9vbGVhbi1leHByZXNzaW9ucyAtLSB3ZSB3YW50IHRoZSBpbXBsaWNpdCBjb252ZXJzaW9uIHRvIGJvb2xlYW5cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICB9XG59XG5jb25zdCBGTE9BVDMyX01BWCA9IDMuNDAyODIzNDY2Mzg1Mjg4NmUzOCwgRkxPQVQzMl9NSU4gPSAtMy40MDI4MjM0NjYzODUyODg2ZTM4LCBVSU5UMzJfTUFYID0gMHhmZmZmZmZmZiwgSU5UMzJfTUFYID0gMHg3ZmZmZmZmZiwgSU5UMzJfTUlOID0gLTB4ODAwMDAwMDA7XG4vKipcbiAqIEFzc2VydCBhIHZhbGlkIHNpZ25lZCBwcm90b2J1ZiAzMi1iaXQgaW50ZWdlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEludDMyKGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnICE9PSBcIm51bWJlclwiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGludCAzMjogXCIgKyB0eXBlb2YgYXJnKTtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoYXJnKSB8fCBhcmcgPiBJTlQzMl9NQVggfHwgYXJnIDwgSU5UMzJfTUlOKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGludCAzMjogXCIgKyBhcmcpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC1wbHVzLW9wZXJhbmRzIC0tIHdlIHdhbnQgdGhlIGltcGxpY2l0IGNvbnZlcnNpb24gdG8gc3RyaW5nXG59XG4vKipcbiAqIEFzc2VydCBhIHZhbGlkIHVuc2lnbmVkIHByb3RvYnVmIDMyLWJpdCBpbnRlZ2VyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0VUludDMyKGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnICE9PSBcIm51bWJlclwiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHVpbnQgMzI6IFwiICsgdHlwZW9mIGFyZyk7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGFyZykgfHwgYXJnID4gVUlOVDMyX01BWCB8fCBhcmcgPCAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHVpbnQgMzI6IFwiICsgYXJnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtcGx1cy1vcGVyYW5kcyAtLSB3ZSB3YW50IHRoZSBpbXBsaWNpdCBjb252ZXJzaW9uIHRvIHN0cmluZ1xufVxuLyoqXG4gKiBBc3NlcnQgYSB2YWxpZCBwcm90b2J1ZiBmbG9hdCB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEZsb2F0MzIoYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09IFwibnVtYmVyXCIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZmxvYXQgMzI6IFwiICsgdHlwZW9mIGFyZyk7XG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoYXJnKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmIChhcmcgPiBGTE9BVDMyX01BWCB8fCBhcmcgPCBGTE9BVDMyX01JTilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBmbG9hdCAzMjogXCIgKyBhcmcpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC1wbHVzLW9wZXJhbmRzIC0tIHdlIHdhbnQgdGhlIGltcGxpY2l0IGNvbnZlcnNpb24gdG8gc3RyaW5nXG59XG4iLCIvLyBDb3B5cmlnaHQgMjAyMS0yMDIzIEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSBcIi4vYXNzZXJ0LmpzXCI7XG5jb25zdCBlbnVtVHlwZVN5bWJvbCA9IFN5bWJvbChcIkBidWZidWlsZC9wcm90b2J1Zi9lbnVtLXR5cGVcIik7XG4vKipcbiAqIEdldCByZWZsZWN0aW9uIGluZm9ybWF0aW9uIGZyb20gYSBnZW5lcmF0ZWQgZW51bS5cbiAqIElmIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIHNvbWV0aGluZyBvdGhlciB0aGFuIGEgZ2VuZXJhdGVkXG4gKiBlbnVtLCBpdCByYWlzZXMgYW4gZXJyb3IuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRFbnVtVHlwZShlbnVtT2JqZWN0KSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcyxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQsQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGNvbnN0IHQgPSBlbnVtT2JqZWN0W2VudW1UeXBlU3ltYm9sXTtcbiAgICBhc3NlcnQodCwgXCJtaXNzaW5nIGVudW0gdHlwZSBvbiBlbnVtIG9iamVjdFwiKTtcbiAgICByZXR1cm4gdDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVyblxufVxuLyoqXG4gKiBTZXRzIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24gb24gYSBnZW5lcmF0ZWQgZW51bS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldEVudW1UeXBlKGVudW1PYmplY3QsIHR5cGVOYW1lLCB2YWx1ZXMsIG9wdCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MsIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBlbnVtT2JqZWN0W2VudW1UeXBlU3ltYm9sXSA9IG1ha2VFbnVtVHlwZSh0eXBlTmFtZSwgdmFsdWVzLm1hcCgodikgPT4gKHtcbiAgICAgICAgbm86IHYubm8sXG4gICAgICAgIG5hbWU6IHYubmFtZSxcbiAgICAgICAgbG9jYWxOYW1lOiBlbnVtT2JqZWN0W3Yubm9dLFxuICAgIH0pKSwgb3B0KTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgbmV3IEVudW1UeXBlIHdpdGggdGhlIGdpdmVuIHZhbHVlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VFbnVtVHlwZSh0eXBlTmFtZSwgdmFsdWVzLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbl9vcHQpIHtcbiAgICBjb25zdCBuYW1lcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgY29uc3QgbnVtYmVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgY29uc3Qgbm9ybWFsVmFsdWVzID0gW107XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgICAgLy8gV2UgZG8gbm90IHN1cmZhY2Ugb3B0aW9ucyBhdCB0aGlzIHRpbWVcbiAgICAgICAgLy8gY29uc3QgdmFsdWU6IEVudW1WYWx1ZUluZm8gPSB7Li4udiwgb3B0aW9uczogdi5vcHRpb25zID8/IGVtcHR5UmVhZG9ubHlPYmplY3R9O1xuICAgICAgICBjb25zdCBuID0gbm9ybWFsaXplRW51bVZhbHVlKHZhbHVlKTtcbiAgICAgICAgbm9ybWFsVmFsdWVzLnB1c2gobik7XG4gICAgICAgIG5hbWVzW3ZhbHVlLm5hbWVdID0gbjtcbiAgICAgICAgbnVtYmVyc1t2YWx1ZS5ub10gPSBuO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlTmFtZSxcbiAgICAgICAgdmFsdWVzOiBub3JtYWxWYWx1ZXMsXG4gICAgICAgIC8vIFdlIGRvIG5vdCBzdXJmYWNlIG9wdGlvbnMgYXQgdGhpcyB0aW1lXG4gICAgICAgIC8vIG9wdGlvbnM6IG9wdD8ub3B0aW9ucyA/PyBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICBmaW5kTmFtZShuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gbmFtZXNbbmFtZV07XG4gICAgICAgIH0sXG4gICAgICAgIGZpbmROdW1iZXIobm8pIHtcbiAgICAgICAgICAgIHJldHVybiBudW1iZXJzW25vXTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgZW51bSBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzLlxuICogU2V0cyByZWZsZWN0aW9uIGluZm9ybWF0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZUVudW0odHlwZU5hbWUsIHZhbHVlcywgb3B0KSB7XG4gICAgY29uc3QgZW51bU9iamVjdCA9IHt9O1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICAgIGNvbnN0IG4gPSBub3JtYWxpemVFbnVtVmFsdWUodmFsdWUpO1xuICAgICAgICBlbnVtT2JqZWN0W24ubG9jYWxOYW1lXSA9IG4ubm87XG4gICAgICAgIGVudW1PYmplY3Rbbi5ub10gPSBuLmxvY2FsTmFtZTtcbiAgICB9XG4gICAgc2V0RW51bVR5cGUoZW51bU9iamVjdCwgdHlwZU5hbWUsIHZhbHVlcywgb3B0KTtcbiAgICByZXR1cm4gZW51bU9iamVjdDtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUVudW1WYWx1ZSh2YWx1ZSkge1xuICAgIGlmIChcImxvY2FsTmFtZVwiIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdmFsdWUpLCB7IGxvY2FsTmFtZTogdmFsdWUubmFtZSB9KTtcbn1cbiIsIi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIE1lc3NhZ2UgaXMgdGhlIGJhc2UgY2xhc3Mgb2YgZXZlcnkgbWVzc2FnZSwgZ2VuZXJhdGVkLCBvciBjcmVhdGVkIGF0XG4gKiBydW50aW1lLlxuICpcbiAqIEl0IGlzIF9ub3RfIHNhZmUgdG8gZXh0ZW5kIHRoaXMgY2xhc3MuIElmIHlvdSB3YW50IHRvIGNyZWF0ZSBhIG1lc3NhZ2UgYXRcbiAqIHJ1biB0aW1lLCB1c2UgcHJvdG8zLm1ha2VNZXNzYWdlVHlwZSgpLlxuICovXG5leHBvcnQgY2xhc3MgTWVzc2FnZSB7XG4gICAgLyoqXG4gICAgICogQ29tcGFyZSB3aXRoIGEgbWVzc2FnZSBvZiB0aGUgc2FtZSB0eXBlLlxuICAgICAqL1xuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRUeXBlKCkucnVudGltZS51dGlsLmVxdWFscyh0aGlzLmdldFR5cGUoKSwgdGhpcywgb3RoZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBkZWVwIGNvcHkuXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFR5cGUoKS5ydW50aW1lLnV0aWwuY2xvbmUodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlIGZyb20gYmluYXJ5IGRhdGEsIG1lcmdpbmcgZmllbGRzLlxuICAgICAqXG4gICAgICogUmVwZWF0ZWQgZmllbGRzIGFyZSBhcHBlbmRlZC4gTWFwIGVudHJpZXMgYXJlIGFkZGVkLCBvdmVyd3JpdGluZ1xuICAgICAqIGV4aXN0aW5nIGtleXMuXG4gICAgICpcbiAgICAgKiBJZiBhIG1lc3NhZ2UgZmllbGQgaXMgYWxyZWFkeSBwcmVzZW50LCBpdCB3aWxsIGJlIG1lcmdlZCB3aXRoIHRoZVxuICAgICAqIG5ldyBkYXRhLlxuICAgICAqL1xuICAgIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IHRoaXMuZ2V0VHlwZSgpLCBmb3JtYXQgPSB0eXBlLnJ1bnRpbWUuYmluLCBvcHQgPSBmb3JtYXQubWFrZVJlYWRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICBmb3JtYXQucmVhZE1lc3NhZ2UodGhpcywgb3B0LnJlYWRlckZhY3RvcnkoYnl0ZXMpLCBieXRlcy5ieXRlTGVuZ3RoLCBvcHQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2UgYSBtZXNzYWdlIGZyb20gYSBKU09OIHZhbHVlLlxuICAgICAqL1xuICAgIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB0eXBlID0gdGhpcy5nZXRUeXBlKCksIGZvcm1hdCA9IHR5cGUucnVudGltZS5qc29uLCBvcHQgPSBmb3JtYXQubWFrZVJlYWRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICBmb3JtYXQucmVhZE1lc3NhZ2UodHlwZSwganNvblZhbHVlLCBvcHQsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2UgYSBtZXNzYWdlIGZyb20gYSBKU09OIHN0cmluZy5cbiAgICAgKi9cbiAgICBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgICAgIGxldCBqc29uO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAganNvbiA9IEpTT04ucGFyc2UoanNvblN0cmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IGRlY29kZSAke3RoaXMuZ2V0VHlwZSgpLnR5cGVOYW1lfSBmcm9tIEpTT046ICR7ZSBpbnN0YW5jZW9mIEVycm9yID8gZS5tZXNzYWdlIDogU3RyaW5nKGUpfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmZyb21Kc29uKGpzb24sIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemUgdGhlIG1lc3NhZ2UgdG8gYmluYXJ5IGRhdGEuXG4gICAgICovXG4gICAgdG9CaW5hcnkob3B0aW9ucykge1xuICAgICAgICBjb25zdCB0eXBlID0gdGhpcy5nZXRUeXBlKCksIGJpbiA9IHR5cGUucnVudGltZS5iaW4sIG9wdCA9IGJpbi5tYWtlV3JpdGVPcHRpb25zKG9wdGlvbnMpLCB3cml0ZXIgPSBvcHQud3JpdGVyRmFjdG9yeSgpO1xuICAgICAgICBiaW4ud3JpdGVNZXNzYWdlKHRoaXMsIHdyaXRlciwgb3B0KTtcbiAgICAgICAgcmV0dXJuIHdyaXRlci5maW5pc2goKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplIHRoZSBtZXNzYWdlIHRvIGEgSlNPTiB2YWx1ZSwgYSBKYXZhU2NyaXB0IHZhbHVlIHRoYXQgY2FuIGJlXG4gICAgICogcGFzc2VkIHRvIEpTT04uc3RyaW5naWZ5KCkuXG4gICAgICovXG4gICAgdG9Kc29uKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IHRoaXMuZ2V0VHlwZSgpLCBqc29uID0gdHlwZS5ydW50aW1lLmpzb24sIG9wdCA9IGpzb24ubWFrZVdyaXRlT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIGpzb24ud3JpdGVNZXNzYWdlKHRoaXMsIG9wdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZSB0aGUgbWVzc2FnZSB0byBhIEpTT04gc3RyaW5nLlxuICAgICAqL1xuICAgIHRvSnNvblN0cmluZyhvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnRvSnNvbihvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlLCBudWxsLCAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucHJldHR5U3BhY2VzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgZm9yIHNlcmlhbGl6YXRpb24gYmVoYXZpb3IuIFRoaXMgd2lsbCBiZSBpbnZva2VkIHdoZW4gY2FsbGluZ1xuICAgICAqIEpTT04uc3RyaW5naWZ5IG9uIHRoaXMgbWVzc2FnZSAoaS5lLiBKU09OLnN0cmluZ2lmeShtc2cpKS5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB0aGlzIHdpbGwgbm90IHNlcmlhbGl6ZSBnb29nbGUucHJvdG9idWYuQW55IHdpdGggYSBwYWNrZWRcbiAgICAgKiBtZXNzYWdlIGJlY2F1c2UgdGhlIHByb3RvYnVmIEpTT04gZm9ybWF0IHNwZWNpZmllcyB0aGF0IGl0IG5lZWRzIHRvIGJlXG4gICAgICogdW5wYWNrZWQsIGFuZCB0aGlzIGlzIG9ubHkgcG9zc2libGUgd2l0aCBhIHR5cGUgcmVnaXN0cnkgdG8gbG9vayB1cCB0aGVcbiAgICAgKiBtZXNzYWdlIHR5cGUuICBBcyBhIHJlc3VsdCwgYXR0ZW1wdGluZyB0byBzZXJpYWxpemUgYSBtZXNzYWdlIHdpdGggdGhpc1xuICAgICAqIHR5cGUgd2lsbCB0aHJvdyBhbiBFcnJvci5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHByb3RlY3RlZCBiZWNhdXNlIHlvdSBzaG91bGQgbm90IG5lZWQgdG8gaW52b2tlIGl0XG4gICAgICogZGlyZWN0bHkgLS0gaW5zdGVhZCB1c2UgSlNPTi5zdHJpbmdpZnkgb3IgdG9Kc29uU3RyaW5nIGZvclxuICAgICAqIHN0cmluZ2lmaWVkIEpTT04uICBBbHRlcm5hdGl2ZWx5LCBpZiBhY3R1YWwgSlNPTiBpcyBkZXNpcmVkLCB5b3Ugc2hvdWxkXG4gICAgICogdXNlIHRvSnNvbi5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvSnNvbih7XG4gICAgICAgICAgICBlbWl0RGVmYXVsdFZhbHVlczogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSBNZXNzYWdlVHlwZSBvZiB0aGlzIG1lc3NhZ2UgLSBhIHNpbmdsZXRvbiB0aGF0IHJlcHJlc2VudHNcbiAgICAgKiB0aGUgcHJvdG9idWYgbWVzc2FnZSBkZWNsYXJhdGlvbiBhbmQgcHJvdmlkZXMgbWV0YWRhdGEgZm9yIHJlZmxlY3Rpb24tXG4gICAgICogYmFzZWQgb3BlcmF0aW9ucy5cbiAgICAgKi9cbiAgICBnZXRUeXBlKCkge1xuICAgICAgICAvLyBBbnkgY2xhc3MgdGhhdCBleHRlbmRzIE1lc3NhZ2UgX211c3RfIHByb3ZpZGUgYSBjb21wbGV0ZSBzdGF0aWNcbiAgICAgICAgLy8gaW1wbGVtZW50YXRpb24gb2YgTWVzc2FnZVR5cGUuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm5cbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcbiAgICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgMjAyMS0yMDIzIEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuaW1wb3J0IHsgTWVzc2FnZSB9IGZyb20gXCIuLi9tZXNzYWdlLmpzXCI7XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBtZXNzYWdlIHR5cGUgdXNpbmcgdGhlIGdpdmVuIHJ1bnRpbWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlTWVzc2FnZVR5cGUocnVudGltZSwgdHlwZU5hbWUsIGZpZWxkcywgb3B0KSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGxvY2FsTmFtZSA9IChfYSA9IG9wdCA9PT0gbnVsbCB8fCBvcHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdC5sb2NhbE5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHR5cGVOYW1lLnN1YnN0cmluZyh0eXBlTmFtZS5sYXN0SW5kZXhPZihcIi5cIikgKyAxKTtcbiAgICBjb25zdCB0eXBlID0ge1xuICAgICAgICBbbG9jYWxOYW1lXTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHJ1bnRpbWUudXRpbC5pbml0RmllbGRzKHRoaXMpO1xuICAgICAgICAgICAgcnVudGltZS51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICAgICAgICB9LFxuICAgIH1bbG9jYWxOYW1lXTtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodHlwZS5wcm90b3R5cGUsIG5ldyBNZXNzYWdlKCkpO1xuICAgIE9iamVjdC5hc3NpZ24odHlwZSwge1xuICAgICAgICBydW50aW1lLFxuICAgICAgICB0eXBlTmFtZSxcbiAgICAgICAgZmllbGRzOiBydW50aW1lLnV0aWwubmV3RmllbGRMaXN0KGZpZWxkcyksXG4gICAgICAgIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgdHlwZSgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICAgICAgICB9LFxuICAgICAgICBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgdHlwZSgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgIH0sXG4gICAgICAgIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgdHlwZSgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICAgICAgICB9LFxuICAgICAgICBlcXVhbHMoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIHJ1bnRpbWUudXRpbC5lcXVhbHModHlwZSwgYSwgYik7XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIHR5cGU7XG59XG4iLCIvLyBDb3B5cmlnaHQgMjAyMS0yMDIzIEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuaW1wb3J0IHsgZ2V0RW51bVR5cGUsIG1ha2VFbnVtLCBtYWtlRW51bVR5cGUgfSBmcm9tIFwiLi9lbnVtLmpzXCI7XG5pbXBvcnQgeyBtYWtlTWVzc2FnZVR5cGUgfSBmcm9tIFwiLi9tZXNzYWdlLXR5cGUuanNcIjtcbmV4cG9ydCBmdW5jdGlvbiBtYWtlUHJvdG9SdW50aW1lKHN5bnRheCwganNvbiwgYmluLCB1dGlsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3ludGF4LFxuICAgICAgICBqc29uLFxuICAgICAgICBiaW4sXG4gICAgICAgIHV0aWwsXG4gICAgICAgIG1ha2VNZXNzYWdlVHlwZSh0eXBlTmFtZSwgZmllbGRzLCBvcHQpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlTWVzc2FnZVR5cGUodGhpcywgdHlwZU5hbWUsIGZpZWxkcywgb3B0KTtcbiAgICAgICAgfSxcbiAgICAgICAgbWFrZUVudW0sXG4gICAgICAgIG1ha2VFbnVtVHlwZSxcbiAgICAgICAgZ2V0RW51bVR5cGUsXG4gICAgfTtcbn1cbiIsIi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIFNjYWxhciB2YWx1ZSB0eXBlcy4gVGhpcyBpcyBhIHN1YnNldCBvZiBmaWVsZCB0eXBlcyBkZWNsYXJlZCBieSBwcm90b2J1ZlxuICogZW51bSBnb29nbGUucHJvdG9idWYuRmllbGREZXNjcmlwdG9yUHJvdG8uVHlwZSBUaGUgdHlwZXMgR1JPVVAgYW5kIE1FU1NBR0VcbiAqIGFyZSBvbWl0dGVkLCBidXQgdGhlIG51bWVyaWNhbCB2YWx1ZXMgYXJlIGlkZW50aWNhbC5cbiAqL1xuZXhwb3J0IHZhciBTY2FsYXJUeXBlO1xuKGZ1bmN0aW9uIChTY2FsYXJUeXBlKSB7XG4gICAgLy8gMCBpcyByZXNlcnZlZCBmb3IgZXJyb3JzLlxuICAgIC8vIE9yZGVyIGlzIHdlaXJkIGZvciBoaXN0b3JpY2FsIHJlYXNvbnMuXG4gICAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiRE9VQkxFXCJdID0gMV0gPSBcIkRPVUJMRVwiO1xuICAgIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIkZMT0FUXCJdID0gMl0gPSBcIkZMT0FUXCI7XG4gICAgLy8gTm90IFppZ1phZyBlbmNvZGVkLiAgTmVnYXRpdmUgbnVtYmVycyB0YWtlIDEwIGJ5dGVzLiAgVXNlIFRZUEVfU0lOVDY0IGlmXG4gICAgLy8gbmVnYXRpdmUgdmFsdWVzIGFyZSBsaWtlbHkuXG4gICAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiSU5UNjRcIl0gPSAzXSA9IFwiSU5UNjRcIjtcbiAgICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJVSU5UNjRcIl0gPSA0XSA9IFwiVUlOVDY0XCI7XG4gICAgLy8gTm90IFppZ1phZyBlbmNvZGVkLiAgTmVnYXRpdmUgbnVtYmVycyB0YWtlIDEwIGJ5dGVzLiAgVXNlIFRZUEVfU0lOVDMyIGlmXG4gICAgLy8gbmVnYXRpdmUgdmFsdWVzIGFyZSBsaWtlbHkuXG4gICAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiSU5UMzJcIl0gPSA1XSA9IFwiSU5UMzJcIjtcbiAgICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJGSVhFRDY0XCJdID0gNl0gPSBcIkZJWEVENjRcIjtcbiAgICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJGSVhFRDMyXCJdID0gN10gPSBcIkZJWEVEMzJcIjtcbiAgICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJCT09MXCJdID0gOF0gPSBcIkJPT0xcIjtcbiAgICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJTVFJJTkdcIl0gPSA5XSA9IFwiU1RSSU5HXCI7XG4gICAgLy8gVGFnLWRlbGltaXRlZCBhZ2dyZWdhdGUuXG4gICAgLy8gR3JvdXAgdHlwZSBpcyBkZXByZWNhdGVkIGFuZCBub3Qgc3VwcG9ydGVkIGluIHByb3RvMy4gSG93ZXZlciwgUHJvdG8zXG4gICAgLy8gaW1wbGVtZW50YXRpb25zIHNob3VsZCBzdGlsbCBiZSBhYmxlIHRvIHBhcnNlIHRoZSBncm91cCB3aXJlIGZvcm1hdCBhbmRcbiAgICAvLyB0cmVhdCBncm91cCBmaWVsZHMgYXMgdW5rbm93biBmaWVsZHMuXG4gICAgLy8gVFlQRV9HUk9VUCA9IDEwLFxuICAgIC8vIFRZUEVfTUVTU0FHRSA9IDExLCAgLy8gTGVuZ3RoLWRlbGltaXRlZCBhZ2dyZWdhdGUuXG4gICAgLy8gTmV3IGluIHZlcnNpb24gMi5cbiAgICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJCWVRFU1wiXSA9IDEyXSA9IFwiQllURVNcIjtcbiAgICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJVSU5UMzJcIl0gPSAxM10gPSBcIlVJTlQzMlwiO1xuICAgIC8vIFRZUEVfRU5VTSA9IDE0LFxuICAgIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIlNGSVhFRDMyXCJdID0gMTVdID0gXCJTRklYRUQzMlwiO1xuICAgIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIlNGSVhFRDY0XCJdID0gMTZdID0gXCJTRklYRUQ2NFwiO1xuICAgIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIlNJTlQzMlwiXSA9IDE3XSA9IFwiU0lOVDMyXCI7XG4gICAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiU0lOVDY0XCJdID0gMThdID0gXCJTSU5UNjRcIjtcbn0pKFNjYWxhclR5cGUgfHwgKFNjYWxhclR5cGUgPSB7fSkpO1xuLyoqXG4gKiBKYXZhU2NyaXB0IHJlcHJlc2VudGF0aW9uIG9mIGZpZWxkcyB3aXRoIDY0IGJpdCBpbnRlZ3JhbCB0eXBlcyAoaW50NjQsIHVpbnQ2NCxcbiAqIHNpbnQ2NCwgZml4ZWQ2NCwgc2ZpeGVkNjQpLlxuICpcbiAqIFRoaXMgaXMgYSBzdWJzZXQgb2YgZ29vZ2xlLnByb3RvYnVmLkZpZWxkT3B0aW9ucy5KU1R5cGUsIHdoaWNoIGRlZmluZXMgSlNfTk9STUFMLFxuICogSlNfU1RSSU5HLCBhbmQgSlNfTlVNQkVSLiBQcm90b2J1Zi1FUyB1c2VzIEJpZ0ludCBieSBkZWZhdWx0LCBidXQgd2lsbCB1c2VcbiAqIFN0cmluZyBpZiBgW2pzdHlwZSA9IEpTX1NUUklOR11gIGlzIHNwZWNpZmllZC5cbiAqXG4gKiBgYGBwcm90b2J1ZlxuICogdWludDY0IGZpZWxkX2EgPSAxOyAvLyBCaWdJbnRcbiAqIHVpbnQ2NCBmaWVsZF9iID0gMiBbanN0eXBlID0gSlNfTk9STUFMXTsgLy8gQmlnSW50XG4gKiB1aW50NjQgZmllbGRfYiA9IDIgW2pzdHlwZSA9IEpTX05VTUJFUl07IC8vIEJpZ0ludFxuICogdWludDY0IGZpZWxkX2IgPSAyIFtqc3R5cGUgPSBKU19TVFJJTkddOyAvLyBTdHJpbmdcbiAqIGBgYFxuICovXG5leHBvcnQgdmFyIExvbmdUeXBlO1xuKGZ1bmN0aW9uIChMb25nVHlwZSkge1xuICAgIC8qKlxuICAgICAqIFVzZSBKYXZhU2NyaXB0IEJpZ0ludC5cbiAgICAgKi9cbiAgICBMb25nVHlwZVtMb25nVHlwZVtcIkJJR0lOVFwiXSA9IDBdID0gXCJCSUdJTlRcIjtcbiAgICAvKipcbiAgICAgKiBVc2UgSmF2YVNjcmlwdCBTdHJpbmcuXG4gICAgICpcbiAgICAgKiBGaWVsZCBvcHRpb24gYFtqc3R5cGUgPSBKU19TVFJJTkddYC5cbiAgICAgKi9cbiAgICBMb25nVHlwZVtMb25nVHlwZVtcIlNUUklOR1wiXSA9IDFdID0gXCJTVFJJTkdcIjtcbn0pKExvbmdUeXBlIHx8IChMb25nVHlwZSA9IHt9KSk7XG4iLCIvLyBDb3B5cmlnaHQgMjAwOCBHb29nbGUgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vXG4vLyBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbi8vIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbi8vIG1ldDpcbi8vXG4vLyAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4vLyBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4vLyAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbi8vIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXJcbi8vIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGVcbi8vIGRpc3RyaWJ1dGlvbi5cbi8vICogTmVpdGhlciB0aGUgbmFtZSBvZiBHb29nbGUgSW5jLiBub3IgdGhlIG5hbWVzIG9mIGl0c1xuLy8gY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb21cbi8vIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4vL1xuLy8gVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuLy8gXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuLy8gTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4vLyBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuLy8gT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4vLyBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXG4vLyBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSxcbi8vIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuLy8gVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuLy8gKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXG4vLyBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuLy9cbi8vIENvZGUgZ2VuZXJhdGVkIGJ5IHRoZSBQcm90b2NvbCBCdWZmZXIgY29tcGlsZXIgaXMgb3duZWQgYnkgdGhlIG93bmVyXG4vLyBvZiB0aGUgaW5wdXQgZmlsZSB1c2VkIHdoZW4gZ2VuZXJhdGluZyBpdC4gIFRoaXMgY29kZSBpcyBub3Rcbi8vIHN0YW5kYWxvbmUgYW5kIHJlcXVpcmVzIGEgc3VwcG9ydCBsaWJyYXJ5IHRvIGJlIGxpbmtlZCB3aXRoIGl0LiAgVGhpc1xuLy8gc3VwcG9ydCBsaWJyYXJ5IGlzIGl0c2VsZiBjb3ZlcmVkIGJ5IHRoZSBhYm92ZSBsaWNlbnNlLlxuLyogZXNsaW50LWRpc2FibGUgcHJlZmVyLWNvbnN0LEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC1wbHVzLW9wZXJhbmRzICovXG4vKipcbiAqIFJlYWQgYSA2NCBiaXQgdmFyaW50IGFzIHR3byBKUyBudW1iZXJzLlxuICpcbiAqIFJldHVybnMgdHVwbGU6XG4gKiBbMF06IGxvdyBiaXRzXG4gKiBbMV06IGhpZ2ggYml0c1xuICpcbiAqIENvcHlyaWdodCAyMDA4IEdvb2dsZSBJbmMuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJvdG9jb2xidWZmZXJzL3Byb3RvYnVmL2Jsb2IvOGE3MTkyN2Q3NGE0Y2UzNGVmZTJkODc2OWZkYTE5OGY1MmQyMGQxMi9qcy9leHBlcmltZW50YWwvcnVudGltZS9rZXJuZWwvYnVmZmVyX2RlY29kZXIuanMjTDE3NVxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFyaW50NjRyZWFkKCkge1xuICAgIGxldCBsb3dCaXRzID0gMDtcbiAgICBsZXQgaGlnaEJpdHMgPSAwO1xuICAgIGZvciAobGV0IHNoaWZ0ID0gMDsgc2hpZnQgPCAyODsgc2hpZnQgKz0gNykge1xuICAgICAgICBsZXQgYiA9IHRoaXMuYnVmW3RoaXMucG9zKytdO1xuICAgICAgICBsb3dCaXRzIHw9IChiICYgMHg3ZikgPDwgc2hpZnQ7XG4gICAgICAgIGlmICgoYiAmIDB4ODApID09IDApIHtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgICAgICAgICByZXR1cm4gW2xvd0JpdHMsIGhpZ2hCaXRzXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgbWlkZGxlQnl0ZSA9IHRoaXMuYnVmW3RoaXMucG9zKytdO1xuICAgIC8vIGxhc3QgZm91ciBiaXRzIG9mIHRoZSBmaXJzdCAzMiBiaXQgbnVtYmVyXG4gICAgbG93Qml0cyB8PSAobWlkZGxlQnl0ZSAmIDB4MGYpIDw8IDI4O1xuICAgIC8vIDMgdXBwZXIgYml0cyBhcmUgcGFydCBvZiB0aGUgbmV4dCAzMiBiaXQgbnVtYmVyXG4gICAgaGlnaEJpdHMgPSAobWlkZGxlQnl0ZSAmIDB4NzApID4+IDQ7XG4gICAgaWYgKChtaWRkbGVCeXRlICYgMHg4MCkgPT0gMCkge1xuICAgICAgICB0aGlzLmFzc2VydEJvdW5kcygpO1xuICAgICAgICByZXR1cm4gW2xvd0JpdHMsIGhpZ2hCaXRzXTtcbiAgICB9XG4gICAgZm9yIChsZXQgc2hpZnQgPSAzOyBzaGlmdCA8PSAzMTsgc2hpZnQgKz0gNykge1xuICAgICAgICBsZXQgYiA9IHRoaXMuYnVmW3RoaXMucG9zKytdO1xuICAgICAgICBoaWdoQml0cyB8PSAoYiAmIDB4N2YpIDw8IHNoaWZ0O1xuICAgICAgICBpZiAoKGIgJiAweDgwKSA9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmFzc2VydEJvdW5kcygpO1xuICAgICAgICAgICAgcmV0dXJuIFtsb3dCaXRzLCBoaWdoQml0c107XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB2YXJpbnRcIik7XG59XG4vKipcbiAqIFdyaXRlIGEgNjQgYml0IHZhcmludCwgZ2l2ZW4gYXMgdHdvIEpTIG51bWJlcnMsIHRvIHRoZSBnaXZlbiBieXRlcyBhcnJheS5cbiAqXG4gKiBDb3B5cmlnaHQgMjAwOCBHb29nbGUgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Byb3RvY29sYnVmZmVycy9wcm90b2J1Zi9ibG9iLzhhNzE5MjdkNzRhNGNlMzRlZmUyZDg3NjlmZGExOThmNTJkMjBkMTIvanMvZXhwZXJpbWVudGFsL3J1bnRpbWUva2VybmVsL3dyaXRlci5qcyNMMzQ0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YXJpbnQ2NHdyaXRlKGxvLCBoaSwgYnl0ZXMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI4OyBpID0gaSArIDcpIHtcbiAgICAgICAgY29uc3Qgc2hpZnQgPSBsbyA+Pj4gaTtcbiAgICAgICAgY29uc3QgaGFzTmV4dCA9ICEoc2hpZnQgPj4+IDcgPT0gMCAmJiBoaSA9PSAwKTtcbiAgICAgICAgY29uc3QgYnl0ZSA9IChoYXNOZXh0ID8gc2hpZnQgfCAweDgwIDogc2hpZnQpICYgMHhmZjtcbiAgICAgICAgYnl0ZXMucHVzaChieXRlKTtcbiAgICAgICAgaWYgKCFoYXNOZXh0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgc3BsaXRCaXRzID0gKChsbyA+Pj4gMjgpICYgMHgwZikgfCAoKGhpICYgMHgwNykgPDwgNCk7XG4gICAgY29uc3QgaGFzTW9yZUJpdHMgPSAhKGhpID4+IDMgPT0gMCk7XG4gICAgYnl0ZXMucHVzaCgoaGFzTW9yZUJpdHMgPyBzcGxpdEJpdHMgfCAweDgwIDogc3BsaXRCaXRzKSAmIDB4ZmYpO1xuICAgIGlmICghaGFzTW9yZUJpdHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMzsgaSA8IDMxOyBpID0gaSArIDcpIHtcbiAgICAgICAgY29uc3Qgc2hpZnQgPSBoaSA+Pj4gaTtcbiAgICAgICAgY29uc3QgaGFzTmV4dCA9ICEoc2hpZnQgPj4+IDcgPT0gMCk7XG4gICAgICAgIGNvbnN0IGJ5dGUgPSAoaGFzTmV4dCA/IHNoaWZ0IHwgMHg4MCA6IHNoaWZ0KSAmIDB4ZmY7XG4gICAgICAgIGJ5dGVzLnB1c2goYnl0ZSk7XG4gICAgICAgIGlmICghaGFzTmV4dCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJ5dGVzLnB1c2goKGhpID4+PiAzMSkgJiAweDAxKTtcbn1cbi8vIGNvbnN0YW50cyBmb3IgYmluYXJ5IG1hdGhcbmNvbnN0IFRXT19QV1JfMzJfREJMID0gMHgxMDAwMDAwMDA7XG4vKipcbiAqIFBhcnNlIGRlY2ltYWwgc3RyaW5nIG9mIDY0IGJpdCBpbnRlZ2VyIHZhbHVlIGFzIHR3byBKUyBudW1iZXJzLlxuICpcbiAqIENvcHlyaWdodCAyMDA4IEdvb2dsZSBJbmMuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJvdG9jb2xidWZmZXJzL3Byb3RvYnVmLWphdmFzY3JpcHQvYmxvYi9hNDI4YzU4MjczYWJhZDA3YzY2MDcxZDk3NTNiYzRkMTI4OWRlNDI2L2V4cGVyaW1lbnRhbC9ydW50aW1lL2ludDY0LmpzI0wxMFxuICovXG5leHBvcnQgZnVuY3Rpb24gaW50NjRGcm9tU3RyaW5nKGRlYykge1xuICAgIC8vIENoZWNrIGZvciBtaW51cyBzaWduLlxuICAgIGNvbnN0IG1pbnVzID0gZGVjWzBdID09PSBcIi1cIjtcbiAgICBpZiAobWludXMpIHtcbiAgICAgICAgZGVjID0gZGVjLnNsaWNlKDEpO1xuICAgIH1cbiAgICAvLyBXb3JrIDYgZGVjaW1hbCBkaWdpdHMgYXQgYSB0aW1lLCBhY3RpbmcgbGlrZSB3ZSdyZSBjb252ZXJ0aW5nIGJhc2UgMWU2XG4gICAgLy8gZGlnaXRzIHRvIGJpbmFyeS4gVGhpcyBpcyBzYWZlIHRvIGRvIHdpdGggZmxvYXRpbmcgcG9pbnQgbWF0aCBiZWNhdXNlXG4gICAgLy8gTnVtYmVyLmlzU2FmZUludGVnZXIoQUxMXzMyX0JJVFMgKiAxZTYpID09IHRydWUuXG4gICAgY29uc3QgYmFzZSA9IDFlNjtcbiAgICBsZXQgbG93Qml0cyA9IDA7XG4gICAgbGV0IGhpZ2hCaXRzID0gMDtcbiAgICBmdW5jdGlvbiBhZGQxZTZkaWdpdChiZWdpbiwgZW5kKSB7XG4gICAgICAgIC8vIE5vdGU6IE51bWJlcignJykgaXMgMC5cbiAgICAgICAgY29uc3QgZGlnaXQxZTYgPSBOdW1iZXIoZGVjLnNsaWNlKGJlZ2luLCBlbmQpKTtcbiAgICAgICAgaGlnaEJpdHMgKj0gYmFzZTtcbiAgICAgICAgbG93Qml0cyA9IGxvd0JpdHMgKiBiYXNlICsgZGlnaXQxZTY7XG4gICAgICAgIC8vIENhcnJ5IGJpdHMgZnJvbSBsb3dCaXRzIHRvXG4gICAgICAgIGlmIChsb3dCaXRzID49IFRXT19QV1JfMzJfREJMKSB7XG4gICAgICAgICAgICBoaWdoQml0cyA9IGhpZ2hCaXRzICsgKChsb3dCaXRzIC8gVFdPX1BXUl8zMl9EQkwpIHwgMCk7XG4gICAgICAgICAgICBsb3dCaXRzID0gbG93Qml0cyAlIFRXT19QV1JfMzJfREJMO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZDFlNmRpZ2l0KC0yNCwgLTE4KTtcbiAgICBhZGQxZTZkaWdpdCgtMTgsIC0xMik7XG4gICAgYWRkMWU2ZGlnaXQoLTEyLCAtNik7XG4gICAgYWRkMWU2ZGlnaXQoLTYpO1xuICAgIHJldHVybiBtaW51cyA/IG5lZ2F0ZShsb3dCaXRzLCBoaWdoQml0cykgOiBuZXdCaXRzKGxvd0JpdHMsIGhpZ2hCaXRzKTtcbn1cbi8qKlxuICogTG9zc2xlc3NseSBjb252ZXJ0cyBhIDY0LWJpdCBzaWduZWQgaW50ZWdlciBpbiAzMjozMiBzcGxpdCByZXByZXNlbnRhdGlvblxuICogaW50byBhIGRlY2ltYWwgc3RyaW5nLlxuICpcbiAqIENvcHlyaWdodCAyMDA4IEdvb2dsZSBJbmMuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJvdG9jb2xidWZmZXJzL3Byb3RvYnVmLWphdmFzY3JpcHQvYmxvYi9hNDI4YzU4MjczYWJhZDA3YzY2MDcxZDk3NTNiYzRkMTI4OWRlNDI2L2V4cGVyaW1lbnRhbC9ydW50aW1lL2ludDY0LmpzI0wxMFxuICovXG5leHBvcnQgZnVuY3Rpb24gaW50NjRUb1N0cmluZyhsbywgaGkpIHtcbiAgICBsZXQgYml0cyA9IG5ld0JpdHMobG8sIGhpKTtcbiAgICAvLyBJZiB3ZSdyZSB0cmVhdGluZyB0aGUgaW5wdXQgYXMgYSBzaWduZWQgdmFsdWUgYW5kIHRoZSBoaWdoIGJpdCBpcyBzZXQsIGRvXG4gICAgLy8gYSBtYW51YWwgdHdvJ3MgY29tcGxlbWVudCBjb252ZXJzaW9uIGJlZm9yZSB0aGUgZGVjaW1hbCBjb252ZXJzaW9uLlxuICAgIGNvbnN0IG5lZ2F0aXZlID0gKGJpdHMuaGkgJiAweDgwMDAwMDAwKTtcbiAgICBpZiAobmVnYXRpdmUpIHtcbiAgICAgICAgYml0cyA9IG5lZ2F0ZShiaXRzLmxvLCBiaXRzLmhpKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gdUludDY0VG9TdHJpbmcoYml0cy5sbywgYml0cy5oaSk7XG4gICAgcmV0dXJuIG5lZ2F0aXZlID8gXCItXCIgKyByZXN1bHQgOiByZXN1bHQ7XG59XG4vKipcbiAqIExvc3NsZXNzbHkgY29udmVydHMgYSA2NC1iaXQgdW5zaWduZWQgaW50ZWdlciBpbiAzMjozMiBzcGxpdCByZXByZXNlbnRhdGlvblxuICogaW50byBhIGRlY2ltYWwgc3RyaW5nLlxuICpcbiAqIENvcHlyaWdodCAyMDA4IEdvb2dsZSBJbmMuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJvdG9jb2xidWZmZXJzL3Byb3RvYnVmLWphdmFzY3JpcHQvYmxvYi9hNDI4YzU4MjczYWJhZDA3YzY2MDcxZDk3NTNiYzRkMTI4OWRlNDI2L2V4cGVyaW1lbnRhbC9ydW50aW1lL2ludDY0LmpzI0wxMFxuICovXG5leHBvcnQgZnVuY3Rpb24gdUludDY0VG9TdHJpbmcobG8sIGhpKSB7XG4gICAgKHsgbG8sIGhpIH0gPSB0b1Vuc2lnbmVkKGxvLCBoaSkpO1xuICAgIC8vIFNraXAgdGhlIGV4cGVuc2l2ZSBjb252ZXJzaW9uIGlmIHRoZSBudW1iZXIgaXMgc21hbGwgZW5vdWdoIHRvIHVzZSB0aGVcbiAgICAvLyBidWlsdC1pbiBjb252ZXJzaW9ucy5cbiAgICAvLyBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiA9IDB4MDAxRkZGRkYgRkZGRkZGRkYsIHRodXMgYW55IG51bWJlciB3aXRoXG4gICAgLy8gaGlnaEJpdHMgPD0gMHgxRkZGRkYgY2FuIGJlIHNhZmVseSBleHByZXNzZWQgd2l0aCBhIGRvdWJsZSBhbmQgcmV0YWluXG4gICAgLy8gaW50ZWdlciBwcmVjaXNpb24uXG4gICAgLy8gUHJvdmVuIGJ5OiBOdW1iZXIuaXNTYWZlSW50ZWdlcigweDFGRkZGRiAqIDIqKjMyICsgMHhGRkZGRkZGRikgPT0gdHJ1ZS5cbiAgICBpZiAoaGkgPD0gMHgxRkZGRkYpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyhUV09fUFdSXzMyX0RCTCAqIGhpICsgbG8pO1xuICAgIH1cbiAgICAvLyBXaGF0IHRoaXMgY29kZSBpcyBkb2luZyBpcyBlc3NlbnRpYWxseSBjb252ZXJ0aW5nIHRoZSBpbnB1dCBudW1iZXIgZnJvbVxuICAgIC8vIGJhc2UtMiB0byBiYXNlLTFlNywgd2hpY2ggYWxsb3dzIHVzIHRvIHJlcHJlc2VudCB0aGUgNjQtYml0IHJhbmdlIHdpdGhcbiAgICAvLyBvbmx5IDMgKHZlcnkgbGFyZ2UpIGRpZ2l0cy4gVGhvc2UgZGlnaXRzIGFyZSB0aGVuIHRyaXZpYWwgdG8gY29udmVydCB0b1xuICAgIC8vIGEgYmFzZS0xMCBzdHJpbmcuXG4gICAgLy8gVGhlIG1hZ2ljIG51bWJlcnMgdXNlZCBoZXJlIGFyZSAtXG4gICAgLy8gMl4yNCA9IDE2Nzc3MjE2ID0gKDEsNjc3NzIxNikgaW4gYmFzZS0xZTcuXG4gICAgLy8gMl40OCA9IDI4MTQ3NDk3NjcxMDY1NiA9ICgyLDgxNDc0OTcsNjcxMDY1NikgaW4gYmFzZS0xZTcuXG4gICAgLy8gU3BsaXQgMzI6MzIgcmVwcmVzZW50YXRpb24gaW50byAxNjoyNDoyNCByZXByZXNlbnRhdGlvbiBzbyBvdXJcbiAgICAvLyBpbnRlcm1lZGlhdGUgZGlnaXRzIGRvbid0IG92ZXJmbG93LlxuICAgIGNvbnN0IGxvdyA9IGxvICYgMHhGRkZGRkY7XG4gICAgY29uc3QgbWlkID0gKChsbyA+Pj4gMjQpIHwgKGhpIDw8IDgpKSAmIDB4RkZGRkZGO1xuICAgIGNvbnN0IGhpZ2ggPSAoaGkgPj4gMTYpICYgMHhGRkZGO1xuICAgIC8vIEFzc2VtYmxlIG91ciB0aHJlZSBiYXNlLTFlNyBkaWdpdHMsIGlnbm9yaW5nIGNhcnJpZXMuIFRoZSBtYXhpbXVtXG4gICAgLy8gdmFsdWUgaW4gYSBkaWdpdCBhdCB0aGlzIHN0ZXAgaXMgcmVwcmVzZW50YWJsZSBhcyBhIDQ4LWJpdCBpbnRlZ2VyLCB3aGljaFxuICAgIC8vIGNhbiBiZSBzdG9yZWQgaW4gYSA2NC1iaXQgZmxvYXRpbmcgcG9pbnQgbnVtYmVyLlxuICAgIGxldCBkaWdpdEEgPSBsb3cgKyAobWlkICogNjc3NzIxNikgKyAoaGlnaCAqIDY3MTA2NTYpO1xuICAgIGxldCBkaWdpdEIgPSBtaWQgKyAoaGlnaCAqIDgxNDc0OTcpO1xuICAgIGxldCBkaWdpdEMgPSAoaGlnaCAqIDIpO1xuICAgIC8vIEFwcGx5IGNhcnJpZXMgZnJvbSBBIHRvIEIgYW5kIGZyb20gQiB0byBDLlxuICAgIGNvbnN0IGJhc2UgPSAxMDAwMDAwMDtcbiAgICBpZiAoZGlnaXRBID49IGJhc2UpIHtcbiAgICAgICAgZGlnaXRCICs9IE1hdGguZmxvb3IoZGlnaXRBIC8gYmFzZSk7XG4gICAgICAgIGRpZ2l0QSAlPSBiYXNlO1xuICAgIH1cbiAgICBpZiAoZGlnaXRCID49IGJhc2UpIHtcbiAgICAgICAgZGlnaXRDICs9IE1hdGguZmxvb3IoZGlnaXRCIC8gYmFzZSk7XG4gICAgICAgIGRpZ2l0QiAlPSBiYXNlO1xuICAgIH1cbiAgICAvLyBJZiBkaWdpdEMgaXMgMCwgdGhlbiB3ZSBzaG91bGQgaGF2ZSByZXR1cm5lZCBpbiB0aGUgdHJpdmlhbCBjb2RlIHBhdGhcbiAgICAvLyBhdCB0aGUgdG9wIGZvciBub24tc2FmZSBpbnRlZ2Vycy4gR2l2ZW4gdGhpcywgd2UgY2FuIGFzc3VtZSBib3RoIGRpZ2l0QlxuICAgIC8vIGFuZCBkaWdpdEEgbmVlZCBsZWFkaW5nIHplcm9zLlxuICAgIHJldHVybiBkaWdpdEMudG9TdHJpbmcoKSArIGRlY2ltYWxGcm9tMWU3V2l0aExlYWRpbmdaZXJvcyhkaWdpdEIpICtcbiAgICAgICAgZGVjaW1hbEZyb20xZTdXaXRoTGVhZGluZ1plcm9zKGRpZ2l0QSk7XG59XG5mdW5jdGlvbiB0b1Vuc2lnbmVkKGxvLCBoaSkge1xuICAgIHJldHVybiB7IGxvOiBsbyA+Pj4gMCwgaGk6IGhpID4+PiAwIH07XG59XG5mdW5jdGlvbiBuZXdCaXRzKGxvLCBoaSkge1xuICAgIHJldHVybiB7IGxvOiBsbyB8IDAsIGhpOiBoaSB8IDAgfTtcbn1cbi8qKlxuICogUmV0dXJucyB0d28ncyBjb21wbGltZW50IG5lZ2F0aW9uIG9mIGlucHV0LlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9PcGVyYXRvcnMvQml0d2lzZV9PcGVyYXRvcnMjU2lnbmVkXzMyLWJpdF9pbnRlZ2Vyc1xuICovXG5mdW5jdGlvbiBuZWdhdGUobG93Qml0cywgaGlnaEJpdHMpIHtcbiAgICBoaWdoQml0cyA9IH5oaWdoQml0cztcbiAgICBpZiAobG93Qml0cykge1xuICAgICAgICBsb3dCaXRzID0gfmxvd0JpdHMgKyAxO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gSWYgbG93Qml0cyBpcyAwLCB0aGVuIGJpdHdpc2Utbm90IGlzIDB4RkZGRkZGRkYsXG4gICAgICAgIC8vIGFkZGluZyAxIHRvIHRoYXQsIHJlc3VsdHMgaW4gMHgxMDAwMDAwMDAsIHdoaWNoIGxlYXZlc1xuICAgICAgICAvLyB0aGUgbG93IGJpdHMgMHgwIGFuZCBzaW1wbHkgYWRkcyBvbmUgdG8gdGhlIGhpZ2ggYml0cy5cbiAgICAgICAgaGlnaEJpdHMgKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0JpdHMobG93Qml0cywgaGlnaEJpdHMpO1xufVxuLyoqXG4gKiBSZXR1cm5zIGRlY2ltYWwgcmVwcmVzZW50YXRpb24gb2YgZGlnaXQxZTcgd2l0aCBsZWFkaW5nIHplcm9zLlxuICovXG5jb25zdCBkZWNpbWFsRnJvbTFlN1dpdGhMZWFkaW5nWmVyb3MgPSAoZGlnaXQxZTcpID0+IHtcbiAgICBjb25zdCBwYXJ0aWFsID0gU3RyaW5nKGRpZ2l0MWU3KTtcbiAgICByZXR1cm4gXCIwMDAwMDAwXCIuc2xpY2UocGFydGlhbC5sZW5ndGgpICsgcGFydGlhbDtcbn07XG4vKipcbiAqIFdyaXRlIGEgMzIgYml0IHZhcmludCwgc2lnbmVkIG9yIHVuc2lnbmVkLiBTYW1lIGFzIGB2YXJpbnQ2NHdyaXRlKDAsIHZhbHVlLCBieXRlcylgXG4gKlxuICogQ29weXJpZ2h0IDIwMDggR29vZ2xlIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcm90b2NvbGJ1ZmZlcnMvcHJvdG9idWYvYmxvYi8xYjE4ODMzZjRmMmEyZjY4MWY0ZTRhMjVjZGYzYjBhNDMxMTVlYzI2L2pzL2JpbmFyeS9lbmNvZGVyLmpzI0wxNDRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhcmludDMyd3JpdGUodmFsdWUsIGJ5dGVzKSB7XG4gICAgaWYgKHZhbHVlID49IDApIHtcbiAgICAgICAgLy8gd3JpdGUgdmFsdWUgYXMgdmFyaW50IDMyXG4gICAgICAgIHdoaWxlICh2YWx1ZSA+IDB4N2YpIHtcbiAgICAgICAgICAgIGJ5dGVzLnB1c2goKHZhbHVlICYgMHg3ZikgfCAweDgwKTtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgPj4+IDc7XG4gICAgICAgIH1cbiAgICAgICAgYnl0ZXMucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDk7IGkrKykge1xuICAgICAgICAgICAgYnl0ZXMucHVzaCgodmFsdWUgJiAxMjcpIHwgMTI4KTtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgPj4gNztcbiAgICAgICAgfVxuICAgICAgICBieXRlcy5wdXNoKDEpO1xuICAgIH1cbn1cbi8qKlxuICogUmVhZCBhbiB1bnNpZ25lZCAzMiBiaXQgdmFyaW50LlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJvdG9jb2xidWZmZXJzL3Byb3RvYnVmL2Jsb2IvOGE3MTkyN2Q3NGE0Y2UzNGVmZTJkODc2OWZkYTE5OGY1MmQyMGQxMi9qcy9leHBlcmltZW50YWwvcnVudGltZS9rZXJuZWwvYnVmZmVyX2RlY29kZXIuanMjTDIyMFxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFyaW50MzJyZWFkKCkge1xuICAgIGxldCBiID0gdGhpcy5idWZbdGhpcy5wb3MrK107XG4gICAgbGV0IHJlc3VsdCA9IGIgJiAweDdmO1xuICAgIGlmICgoYiAmIDB4ODApID09IDApIHtcbiAgICAgICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYiA9IHRoaXMuYnVmW3RoaXMucG9zKytdO1xuICAgIHJlc3VsdCB8PSAoYiAmIDB4N2YpIDw8IDc7XG4gICAgaWYgKChiICYgMHg4MCkgPT0gMCkge1xuICAgICAgICB0aGlzLmFzc2VydEJvdW5kcygpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBiID0gdGhpcy5idWZbdGhpcy5wb3MrK107XG4gICAgcmVzdWx0IHw9IChiICYgMHg3ZikgPDwgMTQ7XG4gICAgaWYgKChiICYgMHg4MCkgPT0gMCkge1xuICAgICAgICB0aGlzLmFzc2VydEJvdW5kcygpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBiID0gdGhpcy5idWZbdGhpcy5wb3MrK107XG4gICAgcmVzdWx0IHw9IChiICYgMHg3ZikgPDwgMjE7XG4gICAgaWYgKChiICYgMHg4MCkgPT0gMCkge1xuICAgICAgICB0aGlzLmFzc2VydEJvdW5kcygpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyBFeHRyYWN0IG9ubHkgbGFzdCA0IGJpdHNcbiAgICBiID0gdGhpcy5idWZbdGhpcy5wb3MrK107XG4gICAgcmVzdWx0IHw9IChiICYgMHgwZikgPDwgMjg7XG4gICAgZm9yIChsZXQgcmVhZEJ5dGVzID0gNTsgKGIgJiAweDgwKSAhPT0gMCAmJiByZWFkQnl0ZXMgPCAxMDsgcmVhZEJ5dGVzKyspXG4gICAgICAgIGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgICBpZiAoKGIgJiAweDgwKSAhPSAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHZhcmludFwiKTtcbiAgICB0aGlzLmFzc2VydEJvdW5kcygpO1xuICAgIC8vIFJlc3VsdCBjYW4gaGF2ZSAzMiBiaXRzLCBjb252ZXJ0IGl0IHRvIHVuc2lnbmVkXG4gICAgcmV0dXJuIHJlc3VsdCA+Pj4gMDtcbn1cbiIsIi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tIFwiLi9wcml2YXRlL2Fzc2VydC5qc1wiO1xuaW1wb3J0IHsgaW50NjRGcm9tU3RyaW5nLCBpbnQ2NFRvU3RyaW5nLCB1SW50NjRUb1N0cmluZywgfSBmcm9tIFwiLi9nb29nbGUvdmFyaW50LmpzXCI7XG5mdW5jdGlvbiBtYWtlSW50NjRTdXBwb3J0KCkge1xuICAgIGNvbnN0IGR2ID0gbmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcig4KSk7XG4gICAgLy8gbm90ZSB0aGF0IFNhZmFyaSAxNCBpbXBsZW1lbnRzIEJpZ0ludCwgYnV0IG5vdCB0aGUgRGF0YVZpZXcgbWV0aG9kc1xuICAgIGNvbnN0IG9rID0gdHlwZW9mIEJpZ0ludCA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgIHR5cGVvZiBkdi5nZXRCaWdJbnQ2NCA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgIHR5cGVvZiBkdi5nZXRCaWdVaW50NjQgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICB0eXBlb2YgZHYuc2V0QmlnSW50NjQgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICB0eXBlb2YgZHYuc2V0QmlnVWludDY0ID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgKHR5cGVvZiBwcm9jZXNzICE9IFwib2JqZWN0XCIgfHxcbiAgICAgICAgICAgIHR5cGVvZiBwcm9jZXNzLmVudiAhPSBcIm9iamVjdFwiIHx8XG4gICAgICAgICAgICBwcm9jZXNzLmVudi5CVUZfQklHSU5UX0RJU0FCTEUgIT09IFwiMVwiKTtcbiAgICBpZiAob2spIHtcbiAgICAgICAgY29uc3QgTUlOID0gQmlnSW50KFwiLTkyMjMzNzIwMzY4NTQ3NzU4MDhcIiksIE1BWCA9IEJpZ0ludChcIjkyMjMzNzIwMzY4NTQ3NzU4MDdcIiksIFVNSU4gPSBCaWdJbnQoXCIwXCIpLCBVTUFYID0gQmlnSW50KFwiMTg0NDY3NDQwNzM3MDk1NTE2MTVcIik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB6ZXJvOiBCaWdJbnQoMCksXG4gICAgICAgICAgICBzdXBwb3J0ZWQ6IHRydWUsXG4gICAgICAgICAgICBwYXJzZSh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJpID0gdHlwZW9mIHZhbHVlID09IFwiYmlnaW50XCIgPyB2YWx1ZSA6IEJpZ0ludCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGJpID4gTUFYIHx8IGJpIDwgTUlOKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW50NjQgaW52YWxpZDogJHt2YWx1ZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVQYXJzZSh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJpID0gdHlwZW9mIHZhbHVlID09IFwiYmlnaW50XCIgPyB2YWx1ZSA6IEJpZ0ludCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGJpID4gVU1BWCB8fCBiaSA8IFVNSU4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1aW50NjQgaW52YWxpZDogJHt2YWx1ZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVuYyh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGR2LnNldEJpZ0ludDY0KDAsIHRoaXMucGFyc2UodmFsdWUpLCB0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBsbzogZHYuZ2V0SW50MzIoMCwgdHJ1ZSksXG4gICAgICAgICAgICAgICAgICAgIGhpOiBkdi5nZXRJbnQzMig0LCB0cnVlKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVFbmModmFsdWUpIHtcbiAgICAgICAgICAgICAgICBkdi5zZXRCaWdJbnQ2NCgwLCB0aGlzLnVQYXJzZSh2YWx1ZSksIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGxvOiBkdi5nZXRJbnQzMigwLCB0cnVlKSxcbiAgICAgICAgICAgICAgICAgICAgaGk6IGR2LmdldEludDMyKDQsIHRydWUpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVjKGxvLCBoaSkge1xuICAgICAgICAgICAgICAgIGR2LnNldEludDMyKDAsIGxvLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBkdi5zZXRJbnQzMig0LCBoaSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGR2LmdldEJpZ0ludDY0KDAsIHRydWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVEZWMobG8sIGhpKSB7XG4gICAgICAgICAgICAgICAgZHYuc2V0SW50MzIoMCwgbG8sIHRydWUpO1xuICAgICAgICAgICAgICAgIGR2LnNldEludDMyKDQsIGhpLCB0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZHYuZ2V0QmlnVWludDY0KDAsIHRydWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgYXNzZXJ0SW50NjRTdHJpbmcgPSAodmFsdWUpID0+IGFzc2VydCgvXi0/WzAtOV0rJC8udGVzdCh2YWx1ZSksIGBpbnQ2NCBpbnZhbGlkOiAke3ZhbHVlfWApO1xuICAgIGNvbnN0IGFzc2VydFVJbnQ2NFN0cmluZyA9ICh2YWx1ZSkgPT4gYXNzZXJ0KC9eWzAtOV0rJC8udGVzdCh2YWx1ZSksIGB1aW50NjQgaW52YWxpZDogJHt2YWx1ZX1gKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB6ZXJvOiBcIjBcIixcbiAgICAgICAgc3VwcG9ydGVkOiBmYWxzZSxcbiAgICAgICAgcGFyc2UodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydEludDY0U3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgdVBhcnNlKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnRVSW50NjRTdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbmModmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydEludDY0U3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBpbnQ2NEZyb21TdHJpbmcodmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICB1RW5jKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnRVSW50NjRTdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIGludDY0RnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlYyhsbywgaGkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnQ2NFRvU3RyaW5nKGxvLCBoaSk7XG4gICAgICAgIH0sXG4gICAgICAgIHVEZWMobG8sIGhpKSB7XG4gICAgICAgICAgICByZXR1cm4gdUludDY0VG9TdHJpbmcobG8sIGhpKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZXhwb3J0IGNvbnN0IHByb3RvSW50NjQgPSBtYWtlSW50NjRTdXBwb3J0KCk7XG4iLCIvLyBDb3B5cmlnaHQgMjAyMS0yMDIzIEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuaW1wb3J0IHsgdmFyaW50MzJyZWFkLCB2YXJpbnQzMndyaXRlLCB2YXJpbnQ2NHJlYWQsIHZhcmludDY0d3JpdGUsIH0gZnJvbSBcIi4vZ29vZ2xlL3ZhcmludC5qc1wiO1xuaW1wb3J0IHsgYXNzZXJ0RmxvYXQzMiwgYXNzZXJ0SW50MzIsIGFzc2VydFVJbnQzMiB9IGZyb20gXCIuL3ByaXZhdGUvYXNzZXJ0LmpzXCI7XG5pbXBvcnQgeyBwcm90b0ludDY0IH0gZnJvbSBcIi4vcHJvdG8taW50NjQuanNcIjtcbi8qIGVzbGludC1kaXNhYmxlIHByZWZlci1jb25zdCxuby1jYXNlLWRlY2xhcmF0aW9ucyxAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtcGx1cy1vcGVyYW5kcyAqL1xuLyoqXG4gKiBQcm90b2J1ZiBiaW5hcnkgZm9ybWF0IHdpcmUgdHlwZXMuXG4gKlxuICogQSB3aXJlIHR5cGUgcHJvdmlkZXMganVzdCBlbm91Z2ggaW5mb3JtYXRpb24gdG8gZmluZCB0aGUgbGVuZ3RoIG9mIHRoZVxuICogZm9sbG93aW5nIHZhbHVlLlxuICpcbiAqIFNlZSBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9wcm90b2NvbC1idWZmZXJzL2RvY3MvZW5jb2Rpbmcjc3RydWN0dXJlXG4gKi9cbmV4cG9ydCB2YXIgV2lyZVR5cGU7XG4oZnVuY3Rpb24gKFdpcmVUeXBlKSB7XG4gICAgLyoqXG4gICAgICogVXNlZCBmb3IgaW50MzIsIGludDY0LCB1aW50MzIsIHVpbnQ2NCwgc2ludDMyLCBzaW50NjQsIGJvb2wsIGVudW1cbiAgICAgKi9cbiAgICBXaXJlVHlwZVtXaXJlVHlwZVtcIlZhcmludFwiXSA9IDBdID0gXCJWYXJpbnRcIjtcbiAgICAvKipcbiAgICAgKiBVc2VkIGZvciBmaXhlZDY0LCBzZml4ZWQ2NCwgZG91YmxlLlxuICAgICAqIEFsd2F5cyA4IGJ5dGVzIHdpdGggbGl0dGxlLWVuZGlhbiBieXRlIG9yZGVyLlxuICAgICAqL1xuICAgIFdpcmVUeXBlW1dpcmVUeXBlW1wiQml0NjRcIl0gPSAxXSA9IFwiQml0NjRcIjtcbiAgICAvKipcbiAgICAgKiBVc2VkIGZvciBzdHJpbmcsIGJ5dGVzLCBlbWJlZGRlZCBtZXNzYWdlcywgcGFja2VkIHJlcGVhdGVkIGZpZWxkc1xuICAgICAqXG4gICAgICogT25seSByZXBlYXRlZCBudW1lcmljIHR5cGVzICh0eXBlcyB3aGljaCB1c2UgdGhlIHZhcmludCwgMzItYml0LFxuICAgICAqIG9yIDY0LWJpdCB3aXJlIHR5cGVzKSBjYW4gYmUgcGFja2VkLiBJbiBwcm90bzMsIHN1Y2ggZmllbGRzIGFyZVxuICAgICAqIHBhY2tlZCBieSBkZWZhdWx0LlxuICAgICAqL1xuICAgIFdpcmVUeXBlW1dpcmVUeXBlW1wiTGVuZ3RoRGVsaW1pdGVkXCJdID0gMl0gPSBcIkxlbmd0aERlbGltaXRlZFwiO1xuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIGdyb3Vwc1xuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgV2lyZVR5cGVbV2lyZVR5cGVbXCJTdGFydEdyb3VwXCJdID0gM10gPSBcIlN0YXJ0R3JvdXBcIjtcbiAgICAvKipcbiAgICAgKiBVc2VkIGZvciBncm91cHNcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIFdpcmVUeXBlW1dpcmVUeXBlW1wiRW5kR3JvdXBcIl0gPSA0XSA9IFwiRW5kR3JvdXBcIjtcbiAgICAvKipcbiAgICAgKiBVc2VkIGZvciBmaXhlZDMyLCBzZml4ZWQzMiwgZmxvYXQuXG4gICAgICogQWx3YXlzIDQgYnl0ZXMgd2l0aCBsaXR0bGUtZW5kaWFuIGJ5dGUgb3JkZXIuXG4gICAgICovXG4gICAgV2lyZVR5cGVbV2lyZVR5cGVbXCJCaXQzMlwiXSA9IDVdID0gXCJCaXQzMlwiO1xufSkoV2lyZVR5cGUgfHwgKFdpcmVUeXBlID0ge30pKTtcbmV4cG9ydCBjbGFzcyBCaW5hcnlXcml0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHRleHRFbmNvZGVyKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcmV2aW91cyBmb3JrIHN0YXRlcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgICAgICAgdGhpcy50ZXh0RW5jb2RlciA9IHRleHRFbmNvZGVyICE9PSBudWxsICYmIHRleHRFbmNvZGVyICE9PSB2b2lkIDAgPyB0ZXh0RW5jb2RlciA6IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgICAgICB0aGlzLmNodW5rcyA9IFtdO1xuICAgICAgICB0aGlzLmJ1ZiA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYWxsIGJ5dGVzIHdyaXR0ZW4gYW5kIHJlc2V0IHRoaXMgd3JpdGVyLlxuICAgICAqL1xuICAgIGZpbmlzaCgpIHtcbiAgICAgICAgdGhpcy5jaHVua3MucHVzaChuZXcgVWludDhBcnJheSh0aGlzLmJ1ZikpOyAvLyBmbHVzaCB0aGUgYnVmZmVyXG4gICAgICAgIGxldCBsZW4gPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2h1bmtzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgbGVuICs9IHRoaXMuY2h1bmtzW2ldLmxlbmd0aDtcbiAgICAgICAgbGV0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobGVuKTtcbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaHVua3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGJ5dGVzLnNldCh0aGlzLmNodW5rc1tpXSwgb2Zmc2V0KTtcbiAgICAgICAgICAgIG9mZnNldCArPSB0aGlzLmNodW5rc1tpXS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaHVua3MgPSBbXTtcbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydCBhIG5ldyBmb3JrIGZvciBsZW5ndGgtZGVsaW1pdGVkIGRhdGEgbGlrZSBhIG1lc3NhZ2VcbiAgICAgKiBvciBhIHBhY2tlZCByZXBlYXRlZCBmaWVsZC5cbiAgICAgKlxuICAgICAqIE11c3QgYmUgam9pbmVkIGxhdGVyIHdpdGggYGpvaW4oKWAuXG4gICAgICovXG4gICAgZm9yaygpIHtcbiAgICAgICAgdGhpcy5zdGFjay5wdXNoKHsgY2h1bmtzOiB0aGlzLmNodW5rcywgYnVmOiB0aGlzLmJ1ZiB9KTtcbiAgICAgICAgdGhpcy5jaHVua3MgPSBbXTtcbiAgICAgICAgdGhpcy5idWYgPSBbXTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEpvaW4gdGhlIGxhc3QgZm9yay4gV3JpdGUgaXRzIGxlbmd0aCBhbmQgYnl0ZXMsIHRoZW5cbiAgICAgKiByZXR1cm4gdG8gdGhlIHByZXZpb3VzIHN0YXRlLlxuICAgICAqL1xuICAgIGpvaW4oKSB7XG4gICAgICAgIC8vIGdldCBjaHVuayBvZiBmb3JrXG4gICAgICAgIGxldCBjaHVuayA9IHRoaXMuZmluaXNoKCk7XG4gICAgICAgIC8vIHJlc3RvcmUgcHJldmlvdXMgc3RhdGVcbiAgICAgICAgbGV0IHByZXYgPSB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgICBpZiAoIXByZXYpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHN0YXRlLCBmb3JrIHN0YWNrIGVtcHR5XCIpO1xuICAgICAgICB0aGlzLmNodW5rcyA9IHByZXYuY2h1bmtzO1xuICAgICAgICB0aGlzLmJ1ZiA9IHByZXYuYnVmO1xuICAgICAgICAvLyB3cml0ZSBsZW5ndGggb2YgY2h1bmsgYXMgdmFyaW50XG4gICAgICAgIHRoaXMudWludDMyKGNodW5rLmJ5dGVMZW5ndGgpO1xuICAgICAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYSB0YWcgKGZpZWxkIG51bWJlciBhbmQgd2lyZSB0eXBlKS5cbiAgICAgKlxuICAgICAqIEVxdWl2YWxlbnQgdG8gYHVpbnQzMiggKGZpZWxkTm8gPDwgMyB8IHR5cGUpID4+PiAwIClgLlxuICAgICAqXG4gICAgICogR2VuZXJhdGVkIGNvZGUgc2hvdWxkIGNvbXB1dGUgdGhlIHRhZyBhaGVhZCBvZiB0aW1lIGFuZCBjYWxsIGB1aW50MzIoKWAuXG4gICAgICovXG4gICAgdGFnKGZpZWxkTm8sIHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudWludDMyKCgoZmllbGRObyA8PCAzKSB8IHR5cGUpID4+PiAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYSBjaHVuayBvZiByYXcgYnl0ZXMuXG4gICAgICovXG4gICAgcmF3KGNodW5rKSB7XG4gICAgICAgIGlmICh0aGlzLmJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuY2h1bmtzLnB1c2gobmV3IFVpbnQ4QXJyYXkodGhpcy5idWYpKTtcbiAgICAgICAgICAgIHRoaXMuYnVmID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaHVua3MucHVzaChjaHVuayk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGB1aW50MzJgIHZhbHVlLCBhbiB1bnNpZ25lZCAzMiBiaXQgdmFyaW50LlxuICAgICAqL1xuICAgIHVpbnQzMih2YWx1ZSkge1xuICAgICAgICBhc3NlcnRVSW50MzIodmFsdWUpO1xuICAgICAgICAvLyB3cml0ZSB2YWx1ZSBhcyB2YXJpbnQgMzIsIGlubGluZWQgZm9yIHNwZWVkXG4gICAgICAgIHdoaWxlICh2YWx1ZSA+IDB4N2YpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmLnB1c2goKHZhbHVlICYgMHg3ZikgfCAweDgwKTtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgPj4+IDc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWYucHVzaCh2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGBpbnQzMmAgdmFsdWUsIGEgc2lnbmVkIDMyIGJpdCB2YXJpbnQuXG4gICAgICovXG4gICAgaW50MzIodmFsdWUpIHtcbiAgICAgICAgYXNzZXJ0SW50MzIodmFsdWUpO1xuICAgICAgICB2YXJpbnQzMndyaXRlKHZhbHVlLCB0aGlzLmJ1Zik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGBib29sYCB2YWx1ZSwgYSB2YXJpYW50LlxuICAgICAqL1xuICAgIGJvb2wodmFsdWUpIHtcbiAgICAgICAgdGhpcy5idWYucHVzaCh2YWx1ZSA/IDEgOiAwKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIGEgYGJ5dGVzYCB2YWx1ZSwgbGVuZ3RoLWRlbGltaXRlZCBhcmJpdHJhcnkgZGF0YS5cbiAgICAgKi9cbiAgICBieXRlcyh2YWx1ZSkge1xuICAgICAgICB0aGlzLnVpbnQzMih2YWx1ZS5ieXRlTGVuZ3RoKTsgLy8gd3JpdGUgbGVuZ3RoIG9mIGNodW5rIGFzIHZhcmludFxuICAgICAgICByZXR1cm4gdGhpcy5yYXcodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGBzdHJpbmdgIHZhbHVlLCBsZW5ndGgtZGVsaW1pdGVkIGRhdGEgY29udmVydGVkIHRvIFVURi04IHRleHQuXG4gICAgICovXG4gICAgc3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIGxldCBjaHVuayA9IHRoaXMudGV4dEVuY29kZXIuZW5jb2RlKHZhbHVlKTtcbiAgICAgICAgdGhpcy51aW50MzIoY2h1bmsuYnl0ZUxlbmd0aCk7IC8vIHdyaXRlIGxlbmd0aCBvZiBjaHVuayBhcyB2YXJpbnRcbiAgICAgICAgcmV0dXJuIHRoaXMucmF3KGNodW5rKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYSBgZmxvYXRgIHZhbHVlLCAzMi1iaXQgZmxvYXRpbmcgcG9pbnQgbnVtYmVyLlxuICAgICAqL1xuICAgIGZsb2F0KHZhbHVlKSB7XG4gICAgICAgIGFzc2VydEZsb2F0MzIodmFsdWUpO1xuICAgICAgICBsZXQgY2h1bmsgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICAgICAgbmV3IERhdGFWaWV3KGNodW5rLmJ1ZmZlcikuc2V0RmxvYXQzMigwLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnJhdyhjaHVuayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIGEgYGRvdWJsZWAgdmFsdWUsIGEgNjQtYml0IGZsb2F0aW5nIHBvaW50IG51bWJlci5cbiAgICAgKi9cbiAgICBkb3VibGUodmFsdWUpIHtcbiAgICAgICAgbGV0IGNodW5rID0gbmV3IFVpbnQ4QXJyYXkoOCk7XG4gICAgICAgIG5ldyBEYXRhVmlldyhjaHVuay5idWZmZXIpLnNldEZsb2F0NjQoMCwgdmFsdWUsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGBmaXhlZDMyYCB2YWx1ZSwgYW4gdW5zaWduZWQsIGZpeGVkLWxlbmd0aCAzMi1iaXQgaW50ZWdlci5cbiAgICAgKi9cbiAgICBmaXhlZDMyKHZhbHVlKSB7XG4gICAgICAgIGFzc2VydFVJbnQzMih2YWx1ZSk7XG4gICAgICAgIGxldCBjaHVuayA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgICAgICBuZXcgRGF0YVZpZXcoY2h1bmsuYnVmZmVyKS5zZXRVaW50MzIoMCwgdmFsdWUsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGBzZml4ZWQzMmAgdmFsdWUsIGEgc2lnbmVkLCBmaXhlZC1sZW5ndGggMzItYml0IGludGVnZXIuXG4gICAgICovXG4gICAgc2ZpeGVkMzIodmFsdWUpIHtcbiAgICAgICAgYXNzZXJ0SW50MzIodmFsdWUpO1xuICAgICAgICBsZXQgY2h1bmsgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICAgICAgbmV3IERhdGFWaWV3KGNodW5rLmJ1ZmZlcikuc2V0SW50MzIoMCwgdmFsdWUsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGBzaW50MzJgIHZhbHVlLCBhIHNpZ25lZCwgemlnemFnLWVuY29kZWQgMzItYml0IHZhcmludC5cbiAgICAgKi9cbiAgICBzaW50MzIodmFsdWUpIHtcbiAgICAgICAgYXNzZXJ0SW50MzIodmFsdWUpO1xuICAgICAgICAvLyB6aWd6YWcgZW5jb2RlXG4gICAgICAgIHZhbHVlID0gKCh2YWx1ZSA8PCAxKSBeICh2YWx1ZSA+PiAzMSkpID4+PiAwO1xuICAgICAgICB2YXJpbnQzMndyaXRlKHZhbHVlLCB0aGlzLmJ1Zik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGBmaXhlZDY0YCB2YWx1ZSwgYSBzaWduZWQsIGZpeGVkLWxlbmd0aCA2NC1iaXQgaW50ZWdlci5cbiAgICAgKi9cbiAgICBzZml4ZWQ2NCh2YWx1ZSkge1xuICAgICAgICBsZXQgY2h1bmsgPSBuZXcgVWludDhBcnJheSg4KSwgdmlldyA9IG5ldyBEYXRhVmlldyhjaHVuay5idWZmZXIpLCB0YyA9IHByb3RvSW50NjQuZW5jKHZhbHVlKTtcbiAgICAgICAgdmlldy5zZXRJbnQzMigwLCB0Yy5sbywgdHJ1ZSk7XG4gICAgICAgIHZpZXcuc2V0SW50MzIoNCwgdGMuaGksIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGBmaXhlZDY0YCB2YWx1ZSwgYW4gdW5zaWduZWQsIGZpeGVkLWxlbmd0aCA2NCBiaXQgaW50ZWdlci5cbiAgICAgKi9cbiAgICBmaXhlZDY0KHZhbHVlKSB7XG4gICAgICAgIGxldCBjaHVuayA9IG5ldyBVaW50OEFycmF5KDgpLCB2aWV3ID0gbmV3IERhdGFWaWV3KGNodW5rLmJ1ZmZlciksIHRjID0gcHJvdG9JbnQ2NC51RW5jKHZhbHVlKTtcbiAgICAgICAgdmlldy5zZXRJbnQzMigwLCB0Yy5sbywgdHJ1ZSk7XG4gICAgICAgIHZpZXcuc2V0SW50MzIoNCwgdGMuaGksIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGBpbnQ2NGAgdmFsdWUsIGEgc2lnbmVkIDY0LWJpdCB2YXJpbnQuXG4gICAgICovXG4gICAgaW50NjQodmFsdWUpIHtcbiAgICAgICAgbGV0IHRjID0gcHJvdG9JbnQ2NC5lbmModmFsdWUpO1xuICAgICAgICB2YXJpbnQ2NHdyaXRlKHRjLmxvLCB0Yy5oaSwgdGhpcy5idWYpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYSBgc2ludDY0YCB2YWx1ZSwgYSBzaWduZWQsIHppZy16YWctZW5jb2RlZCA2NC1iaXQgdmFyaW50LlxuICAgICAqL1xuICAgIHNpbnQ2NCh2YWx1ZSkge1xuICAgICAgICBsZXQgdGMgPSBwcm90b0ludDY0LmVuYyh2YWx1ZSksIFxuICAgICAgICAvLyB6aWd6YWcgZW5jb2RlXG4gICAgICAgIHNpZ24gPSB0Yy5oaSA+PiAzMSwgbG8gPSAodGMubG8gPDwgMSkgXiBzaWduLCBoaSA9ICgodGMuaGkgPDwgMSkgfCAodGMubG8gPj4+IDMxKSkgXiBzaWduO1xuICAgICAgICB2YXJpbnQ2NHdyaXRlKGxvLCBoaSwgdGhpcy5idWYpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYSBgdWludDY0YCB2YWx1ZSwgYW4gdW5zaWduZWQgNjQtYml0IHZhcmludC5cbiAgICAgKi9cbiAgICB1aW50NjQodmFsdWUpIHtcbiAgICAgICAgbGV0IHRjID0gcHJvdG9JbnQ2NC51RW5jKHZhbHVlKTtcbiAgICAgICAgdmFyaW50NjR3cml0ZSh0Yy5sbywgdGMuaGksIHRoaXMuYnVmKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEJpbmFyeVJlYWRlciB7XG4gICAgY29uc3RydWN0b3IoYnVmLCB0ZXh0RGVjb2Rlcikge1xuICAgICAgICB0aGlzLnZhcmludDY0ID0gdmFyaW50NjRyZWFkOyAvLyBkaXJ0eSBjYXN0IGZvciBgdGhpc2BcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlYWQgYSBgdWludDMyYCBmaWVsZCwgYW4gdW5zaWduZWQgMzIgYml0IHZhcmludC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudWludDMyID0gdmFyaW50MzJyZWFkOyAvLyBkaXJ0eSBjYXN0IGZvciBgdGhpc2AgYW5kIGFjY2VzcyB0byBwcm90ZWN0ZWQgYGJ1ZmBcbiAgICAgICAgdGhpcy5idWYgPSBidWY7XG4gICAgICAgIHRoaXMubGVuID0gYnVmLmxlbmd0aDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmLmJ1ZmZlciwgYnVmLmJ5dGVPZmZzZXQsIGJ1Zi5ieXRlTGVuZ3RoKTtcbiAgICAgICAgdGhpcy50ZXh0RGVjb2RlciA9IHRleHREZWNvZGVyICE9PSBudWxsICYmIHRleHREZWNvZGVyICE9PSB2b2lkIDAgPyB0ZXh0RGVjb2RlciA6IG5ldyBUZXh0RGVjb2RlcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkcyBhIHRhZyAtIGZpZWxkIG51bWJlciBhbmQgd2lyZSB0eXBlLlxuICAgICAqL1xuICAgIHRhZygpIHtcbiAgICAgICAgbGV0IHRhZyA9IHRoaXMudWludDMyKCksIGZpZWxkTm8gPSB0YWcgPj4+IDMsIHdpcmVUeXBlID0gdGFnICYgNztcbiAgICAgICAgaWYgKGZpZWxkTm8gPD0gMCB8fCB3aXJlVHlwZSA8IDAgfHwgd2lyZVR5cGUgPiA1KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCB0YWc6IGZpZWxkIG5vIFwiICsgZmllbGRObyArIFwiIHdpcmUgdHlwZSBcIiArIHdpcmVUeXBlKTtcbiAgICAgICAgcmV0dXJuIFtmaWVsZE5vLCB3aXJlVHlwZV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNraXAgb25lIGVsZW1lbnQgb24gdGhlIHdpcmUgYW5kIHJldHVybiB0aGUgc2tpcHBlZCBkYXRhLlxuICAgICAqIFN1cHBvcnRzIFdpcmVUeXBlLlN0YXJ0R3JvdXAgc2luY2UgdjIuMC4wLWFscGhhLjIzLlxuICAgICAqL1xuICAgIHNraXAod2lyZVR5cGUpIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICAgIHN3aXRjaCAod2lyZVR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgV2lyZVR5cGUuVmFyaW50OlxuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSAmIDB4ODApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlIFRTNzAyOTogRmFsbHRocm91Z2ggY2FzZSBpbiBzd2l0Y2hcbiAgICAgICAgICAgIGNhc2UgV2lyZVR5cGUuQml0NjQ6XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgKz0gNDtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBUUzcwMjk6IEZhbGx0aHJvdWdoIGNhc2UgaW4gc3dpdGNoXG4gICAgICAgICAgICBjYXNlIFdpcmVUeXBlLkJpdDMyOlxuICAgICAgICAgICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZDpcbiAgICAgICAgICAgICAgICBsZXQgbGVuID0gdGhpcy51aW50MzIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyArPSBsZW47XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFdpcmVUeXBlLlN0YXJ0R3JvdXA6XG4gICAgICAgICAgICAgICAgLy8gRnJvbSBkZXNjcmlwdG9yLnByb3RvOiBHcm91cCB0eXBlIGlzIGRlcHJlY2F0ZWQsIG5vdCBzdXBwb3J0ZWQgaW4gcHJvdG8zLlxuICAgICAgICAgICAgICAgIC8vIEJ1dCB3ZSBtdXN0IHN0aWxsIGJlIGFibGUgdG8gcGFyc2UgYW5kIHRyZWF0IGFzIHVua25vd24uXG4gICAgICAgICAgICAgICAgbGV0IHQ7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCh0ID0gdGhpcy50YWcoKVsxXSkgIT09IFdpcmVUeXBlLkVuZEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2tpcCh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbnQgc2tpcCB3aXJlIHR5cGUgXCIgKyB3aXJlVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmLnN1YmFycmF5KHN0YXJ0LCB0aGlzLnBvcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRocm93cyBlcnJvciBpZiBwb3NpdGlvbiBpbiBieXRlIGFycmF5IGlzIG91dCBvZiByYW5nZS5cbiAgICAgKi9cbiAgICBhc3NlcnRCb3VuZHMoKSB7XG4gICAgICAgIGlmICh0aGlzLnBvcyA+IHRoaXMubGVuKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJwcmVtYXR1cmUgRU9GXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgYGludDMyYCBmaWVsZCwgYSBzaWduZWQgMzIgYml0IHZhcmludC5cbiAgICAgKi9cbiAgICBpbnQzMigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudWludDMyKCkgfCAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgYHNpbnQzMmAgZmllbGQsIGEgc2lnbmVkLCB6aWd6YWctZW5jb2RlZCAzMi1iaXQgdmFyaW50LlxuICAgICAqL1xuICAgIHNpbnQzMigpIHtcbiAgICAgICAgbGV0IHp6ZSA9IHRoaXMudWludDMyKCk7XG4gICAgICAgIC8vIGRlY29kZSB6aWd6YWdcbiAgICAgICAgcmV0dXJuICh6emUgPj4+IDEpIF4gLSh6emUgJiAxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBhIGBpbnQ2NGAgZmllbGQsIGEgc2lnbmVkIDY0LWJpdCB2YXJpbnQuXG4gICAgICovXG4gICAgaW50NjQoKSB7XG4gICAgICAgIHJldHVybiBwcm90b0ludDY0LmRlYyguLi50aGlzLnZhcmludDY0KCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgYHVpbnQ2NGAgZmllbGQsIGFuIHVuc2lnbmVkIDY0LWJpdCB2YXJpbnQuXG4gICAgICovXG4gICAgdWludDY0KCkge1xuICAgICAgICByZXR1cm4gcHJvdG9JbnQ2NC51RGVjKC4uLnRoaXMudmFyaW50NjQoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYSBgc2ludDY0YCBmaWVsZCwgYSBzaWduZWQsIHppZy16YWctZW5jb2RlZCA2NC1iaXQgdmFyaW50LlxuICAgICAqL1xuICAgIHNpbnQ2NCgpIHtcbiAgICAgICAgbGV0IFtsbywgaGldID0gdGhpcy52YXJpbnQ2NCgpO1xuICAgICAgICAvLyBkZWNvZGUgemlnIHphZ1xuICAgICAgICBsZXQgcyA9IC0obG8gJiAxKTtcbiAgICAgICAgbG8gPSAoKGxvID4+PiAxKSB8ICgoaGkgJiAxKSA8PCAzMSkpIF4gcztcbiAgICAgICAgaGkgPSAoaGkgPj4+IDEpIF4gcztcbiAgICAgICAgcmV0dXJuIHByb3RvSW50NjQuZGVjKGxvLCBoaSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYSBgYm9vbGAgZmllbGQsIGEgdmFyaWFudC5cbiAgICAgKi9cbiAgICBib29sKCkge1xuICAgICAgICBsZXQgW2xvLCBoaV0gPSB0aGlzLnZhcmludDY0KCk7XG4gICAgICAgIHJldHVybiBsbyAhPT0gMCB8fCBoaSAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBhIGBmaXhlZDMyYCBmaWVsZCwgYW4gdW5zaWduZWQsIGZpeGVkLWxlbmd0aCAzMi1iaXQgaW50ZWdlci5cbiAgICAgKi9cbiAgICBmaXhlZDMyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3LmdldFVpbnQzMigodGhpcy5wb3MgKz0gNCkgLSA0LCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBhIGBzZml4ZWQzMmAgZmllbGQsIGEgc2lnbmVkLCBmaXhlZC1sZW5ndGggMzItYml0IGludGVnZXIuXG4gICAgICovXG4gICAgc2ZpeGVkMzIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcuZ2V0SW50MzIoKHRoaXMucG9zICs9IDQpIC0gNCwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYSBgZml4ZWQ2NGAgZmllbGQsIGFuIHVuc2lnbmVkLCBmaXhlZC1sZW5ndGggNjQgYml0IGludGVnZXIuXG4gICAgICovXG4gICAgZml4ZWQ2NCgpIHtcbiAgICAgICAgcmV0dXJuIHByb3RvSW50NjQudURlYyh0aGlzLnNmaXhlZDMyKCksIHRoaXMuc2ZpeGVkMzIoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYSBgZml4ZWQ2NGAgZmllbGQsIGEgc2lnbmVkLCBmaXhlZC1sZW5ndGggNjQtYml0IGludGVnZXIuXG4gICAgICovXG4gICAgc2ZpeGVkNjQoKSB7XG4gICAgICAgIHJldHVybiBwcm90b0ludDY0LmRlYyh0aGlzLnNmaXhlZDMyKCksIHRoaXMuc2ZpeGVkMzIoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYSBgZmxvYXRgIGZpZWxkLCAzMi1iaXQgZmxvYXRpbmcgcG9pbnQgbnVtYmVyLlxuICAgICAqL1xuICAgIGZsb2F0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3LmdldEZsb2F0MzIoKHRoaXMucG9zICs9IDQpIC0gNCwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYSBgZG91YmxlYCBmaWVsZCwgYSA2NC1iaXQgZmxvYXRpbmcgcG9pbnQgbnVtYmVyLlxuICAgICAqL1xuICAgIGRvdWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy5nZXRGbG9hdDY0KCh0aGlzLnBvcyArPSA4KSAtIDgsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgYGJ5dGVzYCBmaWVsZCwgbGVuZ3RoLWRlbGltaXRlZCBhcmJpdHJhcnkgZGF0YS5cbiAgICAgKi9cbiAgICBieXRlcygpIHtcbiAgICAgICAgbGV0IGxlbiA9IHRoaXMudWludDMyKCksIHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICAgIHRoaXMucG9zICs9IGxlbjtcbiAgICAgICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYSBgc3RyaW5nYCBmaWVsZCwgbGVuZ3RoLWRlbGltaXRlZCBkYXRhIGNvbnZlcnRlZCB0byBVVEYtOCB0ZXh0LlxuICAgICAqL1xuICAgIHN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dERlY29kZXIuZGVjb2RlKHRoaXMuYnl0ZXMoKSk7XG4gICAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbmltcG9ydCB7IE1lc3NhZ2UgfSBmcm9tIFwiLi4vbWVzc2FnZS5qc1wiO1xuaW1wb3J0IHsgU2NhbGFyVHlwZSB9IGZyb20gXCIuLi9maWVsZC5qc1wiO1xuLyoqXG4gKiBXcmFwIGEgcHJpbWl0aXZlIG1lc3NhZ2UgZmllbGQgdmFsdWUgaW4gaXRzIGNvcnJlc3BvbmRpbmcgd3JhcHBlclxuICogbWVzc2FnZS4gVGhpcyBmdW5jdGlvbiBpcyBpZGVtcG90ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gd3JhcEZpZWxkKHR5cGUsIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWVzc2FnZSB8fCAhdHlwZS5maWVsZFdyYXBwZXIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZS5maWVsZFdyYXBwZXIud3JhcEZpZWxkKHZhbHVlKTtcbn1cbi8qKlxuICogSWYgdGhlIGdpdmVuIGZpZWxkIHVzZXMgb25lIG9mIHRoZSB3ZWxsLWtub3duIHdyYXBwZXIgdHlwZXMsIHJldHVyblxuICogdGhlIHByaW1pdGl2ZSB0eXBlIGl0IHdyYXBzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VW53cmFwcGVkRmllbGRUeXBlKGZpZWxkKSB7XG4gICAgaWYgKGZpZWxkLmZpZWxkS2luZCAhPT0gXCJtZXNzYWdlXCIpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKGZpZWxkLnJlcGVhdGVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChmaWVsZC5vbmVvZiAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHdrdFdyYXBwZXJUb1NjYWxhclR5cGVbZmllbGQubWVzc2FnZS50eXBlTmFtZV07XG59XG5jb25zdCB3a3RXcmFwcGVyVG9TY2FsYXJUeXBlID0ge1xuICAgIFwiZ29vZ2xlLnByb3RvYnVmLkRvdWJsZVZhbHVlXCI6IFNjYWxhclR5cGUuRE9VQkxFLFxuICAgIFwiZ29vZ2xlLnByb3RvYnVmLkZsb2F0VmFsdWVcIjogU2NhbGFyVHlwZS5GTE9BVCxcbiAgICBcImdvb2dsZS5wcm90b2J1Zi5JbnQ2NFZhbHVlXCI6IFNjYWxhclR5cGUuSU5UNjQsXG4gICAgXCJnb29nbGUucHJvdG9idWYuVUludDY0VmFsdWVcIjogU2NhbGFyVHlwZS5VSU5UNjQsXG4gICAgXCJnb29nbGUucHJvdG9idWYuSW50MzJWYWx1ZVwiOiBTY2FsYXJUeXBlLklOVDMyLFxuICAgIFwiZ29vZ2xlLnByb3RvYnVmLlVJbnQzMlZhbHVlXCI6IFNjYWxhclR5cGUuVUlOVDMyLFxuICAgIFwiZ29vZ2xlLnByb3RvYnVmLkJvb2xWYWx1ZVwiOiBTY2FsYXJUeXBlLkJPT0wsXG4gICAgXCJnb29nbGUucHJvdG9idWYuU3RyaW5nVmFsdWVcIjogU2NhbGFyVHlwZS5TVFJJTkcsXG4gICAgXCJnb29nbGUucHJvdG9idWYuQnl0ZXNWYWx1ZVwiOiBTY2FsYXJUeXBlLkJZVEVTLFxufTtcbiIsIi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5pbXBvcnQgeyBMb25nVHlwZSwgU2NhbGFyVHlwZSB9IGZyb20gXCIuLi9maWVsZC5qc1wiO1xuaW1wb3J0IHsgV2lyZVR5cGUgfSBmcm9tIFwiLi4vYmluYXJ5LWVuY29kaW5nLmpzXCI7XG5pbXBvcnQgeyBwcm90b0ludDY0IH0gZnJvbSBcIi4uL3Byb3RvLWludDY0LmpzXCI7XG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBib3RoIHNjYWxhciB2YWx1ZXMgYXJlIGVxdWFsLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2NhbGFyRXF1YWxzKHR5cGUsIGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICAvLyBUaGlzIGNvcnJlY3RseSBtYXRjaGVzIGVxdWFsIHZhbHVlcyBleGNlcHQgQllURVMgYW5kIChwb3NzaWJseSkgNjQtYml0IGludGVnZXJzLlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gU3BlY2lhbCBjYXNlIEJZVEVTIC0gd2UgbmVlZCB0byBjb21wYXJlIGVhY2ggYnl0ZSBpbmRpdmlkdWFsbHlcbiAgICBpZiAodHlwZSA9PSBTY2FsYXJUeXBlLkJZVEVTKSB7XG4gICAgICAgIGlmICghKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB8fCAhKGIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBTcGVjaWFsIGNhc2UgNjQtYml0IGludGVnZXJzIC0gd2Ugc3VwcG9ydCBudW1iZXIsIHN0cmluZyBhbmQgYmlnaW50IHJlcHJlc2VudGF0aW9uLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3dpdGNoLWV4aGF1c3RpdmVuZXNzLWNoZWNrXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5VSU5UNjQ6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDY0OlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuSU5UNjQ6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TRklYRUQ2NDpcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNJTlQ2NDpcbiAgICAgICAgICAgIC8vIExvb3NlIGNvbXBhcmlzb24gd2lsbCBtYXRjaCBiZXR3ZWVuIDBuLCAwIGFuZCBcIjBcIi5cbiAgICAgICAgICAgIHJldHVybiBhID09IGI7XG4gICAgfVxuICAgIC8vIEFueXRoaW5nIHRoYXQgaGFzbid0IGJlZW4gY2F1Z2h0IGJ5IHN0cmljdCBjb21wYXJpc29uIG9yIHNwZWNpYWwgY2FzZWRcbiAgICAvLyBCWVRFUyBhbmQgNjQtYml0IGludGVnZXJzIGlzIG5vdCBlcXVhbC5cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWUgZm9yIHRoZSBnaXZlbiBzY2FsYXIgdHlwZSwgZm9sbG93aW5nXG4gKiBwcm90bzMgc2VtYW50aWNzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2NhbGFyRGVmYXVsdFZhbHVlKHR5cGUsIGxvbmdUeXBlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5CT09MOlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDY0OlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQ2NDpcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLklOVDY0OlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVENjQ6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UNjQ6XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1lbnVtLWNvbXBhcmlzb24gLS0gYWNjZXB0YWJsZSBzaW5jZSBpdCdzIGNvdmVyZWQgYnkgdGVzdHNcbiAgICAgICAgICAgIHJldHVybiBsb25nVHlwZSA9PSAwID8gcHJvdG9JbnQ2NC56ZXJvIDogXCIwXCI7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5ET1VCTEU6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5GTE9BVDpcbiAgICAgICAgICAgIHJldHVybiAwLjA7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5CWVRFUzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgwKTtcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNUUklORzpcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gSGFuZGxlcyBJTlQzMiwgVUlOVDMyLCBTSU5UMzIsIEZJWEVEMzIsIFNGSVhFRDMyLlxuICAgICAgICAgICAgLy8gV2UgZG8gbm90IHVzZSBpbmRpdmlkdWFsIGNhc2VzIHRvIHNhdmUgYSBmZXcgYnl0ZXMgY29kZSBzaXplLlxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxufVxuLyoqXG4gKiBHZXQgaW5mb3JtYXRpb24gZm9yIHdyaXRpbmcgYSBzY2FsYXIgdmFsdWUuXG4gKlxuICogUmV0dXJucyB0dXBsZTpcbiAqIFswXTogYXBwcm9wcmlhdGUgV2lyZVR5cGVcbiAqIFsxXTogbmFtZSBvZiB0aGUgYXBwcm9wcmlhdGUgbWV0aG9kIG9mIElCaW5hcnlXcml0ZXJcbiAqIFsyXTogd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBkZWZhdWx0IHZhbHVlIGZvciBwcm90bzMgc2VtYW50aWNzXG4gKlxuICogSWYgYXJndW1lbnQgYHZhbHVlYCBpcyBvbWl0dGVkLCBbMl0gaXMgYWx3YXlzIGZhbHNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2NhbGFyVHlwZUluZm8odHlwZSwgdmFsdWUpIHtcbiAgICBjb25zdCBpc1VuZGVmaW5lZCA9IHZhbHVlID09PSB1bmRlZmluZWQ7XG4gICAgbGV0IHdpcmVUeXBlID0gV2lyZVR5cGUuVmFyaW50O1xuICAgIGxldCBpc0ludHJpbnNpY0RlZmF1bHQgPSB2YWx1ZSA9PT0gMDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N3aXRjaC1leGhhdXN0aXZlbmVzcy1jaGVjayAtLSBJTlQzMiwgVUlOVDMyLCBTSU5UMzIgYXJlIGNvdmVyZWQgYnkgdGhlIGRlZmF1bHRzXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TVFJJTkc6XG4gICAgICAgICAgICBpc0ludHJpbnNpY0RlZmF1bHQgPSBpc1VuZGVmaW5lZCB8fCAhdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgd2lyZVR5cGUgPSBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkJPT0w6XG4gICAgICAgICAgICBpc0ludHJpbnNpY0RlZmF1bHQgPSB2YWx1ZSA9PT0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkRPVUJMRTpcbiAgICAgICAgICAgIHdpcmVUeXBlID0gV2lyZVR5cGUuQml0NjQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkZMT0FUOlxuICAgICAgICAgICAgd2lyZVR5cGUgPSBXaXJlVHlwZS5CaXQzMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuSU5UNjQ6XG4gICAgICAgICAgICBpc0ludHJpbnNpY0RlZmF1bHQgPSBpc1VuZGVmaW5lZCB8fCB2YWx1ZSA9PSAwOyAvLyBMb29zZSBjb21wYXJpc29uIG1hdGNoZXMgMG4sIDAgYW5kIFwiMFwiXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQ2NDpcbiAgICAgICAgICAgIGlzSW50cmluc2ljRGVmYXVsdCA9IGlzVW5kZWZpbmVkIHx8IHZhbHVlID09IDA7IC8vIExvb3NlIGNvbXBhcmlzb24gbWF0Y2hlcyAwbiwgMCBhbmQgXCIwXCJcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQ2NDpcbiAgICAgICAgICAgIGlzSW50cmluc2ljRGVmYXVsdCA9IGlzVW5kZWZpbmVkIHx8IHZhbHVlID09IDA7IC8vIExvb3NlIGNvbXBhcmlzb24gbWF0Y2hlcyAwbiwgMCBhbmQgXCIwXCJcbiAgICAgICAgICAgIHdpcmVUeXBlID0gV2lyZVR5cGUuQml0NjQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkJZVEVTOlxuICAgICAgICAgICAgaXNJbnRyaW5zaWNEZWZhdWx0ID0gaXNVbmRlZmluZWQgfHwgIXZhbHVlLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICB3aXJlVHlwZSA9IFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQzMjpcbiAgICAgICAgICAgIHdpcmVUeXBlID0gV2lyZVR5cGUuQml0MzI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDMyOlxuICAgICAgICAgICAgd2lyZVR5cGUgPSBXaXJlVHlwZS5CaXQzMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVENjQ6XG4gICAgICAgICAgICBpc0ludHJpbnNpY0RlZmF1bHQgPSBpc1VuZGVmaW5lZCB8fCB2YWx1ZSA9PSAwO1xuICAgICAgICAgICAgd2lyZVR5cGUgPSBXaXJlVHlwZS5CaXQ2NDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0lOVDY0OlxuICAgICAgICAgICAgaXNJbnRyaW5zaWNEZWZhdWx0ID0gaXNVbmRlZmluZWQgfHwgdmFsdWUgPT0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBtZXRob2QgPSBTY2FsYXJUeXBlW3R5cGVdLnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIFt3aXJlVHlwZSwgbWV0aG9kLCBpc1VuZGVmaW5lZCB8fCBpc0ludHJpbnNpY0RlZmF1bHRdO1xufVxuIiwiLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbmltcG9ydCB7IEJpbmFyeVJlYWRlciwgQmluYXJ5V3JpdGVyLCBXaXJlVHlwZSB9IGZyb20gXCIuLi9iaW5hcnktZW5jb2RpbmcuanNcIjtcbmltcG9ydCB7IE1lc3NhZ2UgfSBmcm9tIFwiLi4vbWVzc2FnZS5qc1wiO1xuaW1wb3J0IHsgTG9uZ1R5cGUsIFNjYWxhclR5cGUgfSBmcm9tIFwiLi4vZmllbGQuanNcIjtcbmltcG9ydCB7IHdyYXBGaWVsZCB9IGZyb20gXCIuL2ZpZWxkLXdyYXBwZXIuanNcIjtcbmltcG9ydCB7IHNjYWxhckRlZmF1bHRWYWx1ZSwgc2NhbGFyVHlwZUluZm8gfSBmcm9tIFwiLi9zY2FsYXJzLmpzXCI7XG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tIFwiLi9hc3NlcnQuanNcIjtcbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MsIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnksIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnQsIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCwgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1jYWxsLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uLCBuby1jYXNlLWRlY2xhcmF0aW9ucywgcHJlZmVyLWNvbnN0ICovXG5jb25zdCB1bmtub3duRmllbGRzU3ltYm9sID0gU3ltYm9sKFwiQGJ1ZmJ1aWxkL3Byb3RvYnVmL3Vua25vd24tZmllbGRzXCIpO1xuLy8gRGVmYXVsdCBvcHRpb25zIGZvciBwYXJzaW5nIGJpbmFyeSBkYXRhLlxuY29uc3QgcmVhZERlZmF1bHRzID0ge1xuICAgIHJlYWRVbmtub3duRmllbGRzOiB0cnVlLFxuICAgIHJlYWRlckZhY3Rvcnk6IChieXRlcykgPT4gbmV3IEJpbmFyeVJlYWRlcihieXRlcyksXG59O1xuLy8gRGVmYXVsdCBvcHRpb25zIGZvciBzZXJpYWxpemluZyBiaW5hcnkgZGF0YS5cbmNvbnN0IHdyaXRlRGVmYXVsdHMgPSB7XG4gICAgd3JpdGVVbmtub3duRmllbGRzOiB0cnVlLFxuICAgIHdyaXRlckZhY3Rvcnk6ICgpID0+IG5ldyBCaW5hcnlXcml0ZXIoKSxcbn07XG5mdW5jdGlvbiBtYWtlUmVhZE9wdGlvbnMob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZWFkRGVmYXVsdHMpLCBvcHRpb25zKSA6IHJlYWREZWZhdWx0cztcbn1cbmZ1bmN0aW9uIG1ha2VXcml0ZU9wdGlvbnMob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB3cml0ZURlZmF1bHRzKSwgb3B0aW9ucykgOiB3cml0ZURlZmF1bHRzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VCaW5hcnlGb3JtYXRDb21tb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWFrZVJlYWRPcHRpb25zLFxuICAgICAgICBtYWtlV3JpdGVPcHRpb25zLFxuICAgICAgICBsaXN0VW5rbm93bkZpZWxkcyhtZXNzYWdlKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICByZXR1cm4gKF9hID0gbWVzc2FnZVt1bmtub3duRmllbGRzU3ltYm9sXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XG4gICAgICAgIH0sXG4gICAgICAgIGRpc2NhcmRVbmtub3duRmllbGRzKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBtZXNzYWdlW3Vua25vd25GaWVsZHNTeW1ib2xdO1xuICAgICAgICB9LFxuICAgICAgICB3cml0ZVVua25vd25GaWVsZHMobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICBjb25zdCBtID0gbWVzc2FnZTtcbiAgICAgICAgICAgIGNvbnN0IGMgPSBtW3Vua25vd25GaWVsZHNTeW1ib2xdO1xuICAgICAgICAgICAgaWYgKGMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGYgb2YgYykge1xuICAgICAgICAgICAgICAgICAgICB3cml0ZXIudGFnKGYubm8sIGYud2lyZVR5cGUpLnJhdyhmLmRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25Vbmtub3duRmllbGQobWVzc2FnZSwgbm8sIHdpcmVUeXBlLCBkYXRhKSB7XG4gICAgICAgICAgICBjb25zdCBtID0gbWVzc2FnZTtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtW3Vua25vd25GaWVsZHNTeW1ib2xdKSkge1xuICAgICAgICAgICAgICAgIG1bdW5rbm93bkZpZWxkc1N5bWJvbF0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1bdW5rbm93bkZpZWxkc1N5bWJvbF0ucHVzaCh7IG5vLCB3aXJlVHlwZSwgZGF0YSB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVhZE1lc3NhZ2UobWVzc2FnZSwgcmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBtZXNzYWdlLmdldFR5cGUoKTtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCksIGZpZWxkID0gdHlwZS5maWVsZHMuZmluZChmaWVsZE5vKTtcbiAgICAgICAgICAgICAgICBpZiAoIWZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnJlYWRVbmtub3duRmllbGRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uVW5rbm93bkZpZWxkKG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHRhcmdldCA9IG1lc3NhZ2UsIHJlcGVhdGVkID0gZmllbGQucmVwZWF0ZWQsIGxvY2FsTmFtZSA9IGZpZWxkLmxvY2FsTmFtZTtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQub25lb2YpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0W2ZpZWxkLm9uZW9mLmxvY2FsTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuY2FzZSAhPSBsb2NhbE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0YXJnZXQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmNhc2UgPSBsb2NhbE5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsTmFtZSA9IFwidmFsdWVcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3dpdGNoIChmaWVsZC5raW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNjYWxhclR5cGUgPSBmaWVsZC5raW5kID09IFwiZW51bVwiID8gU2NhbGFyVHlwZS5JTlQzMiA6IGZpZWxkLlQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVhZCA9IHJlYWRTY2FsYXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1lbnVtLWNvbXBhcmlzb24gLS0gYWNjZXB0YWJsZSBzaW5jZSBpdCdzIGNvdmVyZWQgYnkgdGVzdHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZC5raW5kID09IFwic2NhbGFyXCIgJiYgZmllbGQuTCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkID0gcmVhZFNjYWxhckxUU3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcGVhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGFyciA9IHRhcmdldFtsb2NhbE5hbWVdOyAvLyBzYWZlIHRvIGFzc3VtZSBwcmVzZW5jZSBvZiBhcnJheSwgb25lb2YgY2Fubm90IGNvbnRhaW4gcmVwZWF0ZWQgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdpcmVUeXBlID09IFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2FsYXJUeXBlICE9IFNjYWxhclR5cGUuU1RSSU5HICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxhclR5cGUgIT0gU2NhbGFyVHlwZS5CWVRFUykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZSA9IHJlYWRlci51aW50MzIoKSArIHJlYWRlci5wb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyLnB1c2gocmVhZChyZWFkZXIsIHNjYWxhclR5cGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyLnB1c2gocmVhZChyZWFkZXIsIHNjYWxhclR5cGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IHJlYWQocmVhZGVyLCBzY2FsYXJUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZVR5cGUgPSBmaWVsZC5UO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcGVhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2FmZSB0byBhc3N1bWUgcHJlc2VuY2Ugb2YgYXJyYXksIG9uZW9mIGNhbm5vdCBjb250YWluIHJlcGVhdGVkIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtsb2NhbE5hbWVdLnB1c2gocmVhZE1lc3NhZ2VGaWVsZChyZWFkZXIsIG5ldyBtZXNzYWdlVHlwZSgpLCBvcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0W2xvY2FsTmFtZV0gaW5zdGFuY2VvZiBNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRNZXNzYWdlRmllbGQocmVhZGVyLCB0YXJnZXRbbG9jYWxOYW1lXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IHJlYWRNZXNzYWdlRmllbGQocmVhZGVyLCBuZXcgbWVzc2FnZVR5cGUoKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlVHlwZS5maWVsZFdyYXBwZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICFmaWVsZC5vbmVvZiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWZpZWxkLnJlcGVhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IG1lc3NhZ2VUeXBlLmZpZWxkV3JhcHBlci51bndyYXBGaWVsZCh0YXJnZXRbbG9jYWxOYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1hcFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IFttYXBLZXksIG1hcFZhbF0gPSByZWFkTWFwRW50cnkoZmllbGQsIHJlYWRlciwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzYWZlIHRvIGFzc3VtZSBwcmVzZW5jZSBvZiBtYXAgb2JqZWN0LCBvbmVvZiBjYW5ub3QgY29udGFpbiByZXBlYXRlZCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtsb2NhbE5hbWVdW21hcEtleV0gPSBtYXBWYWw7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8vIFJlYWQgYSBtZXNzYWdlLCBhdm9pZGluZyBNZXNzYWdlVHlwZS5mcm9tQmluYXJ5KCkgdG8gcmUtdXNlIHRoZVxuLy8gQmluYXJ5UmVhZE9wdGlvbnMgYW5kIHRoZSBJQmluYXJ5UmVhZGVyLlxuZnVuY3Rpb24gcmVhZE1lc3NhZ2VGaWVsZChyZWFkZXIsIG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBmb3JtYXQgPSBtZXNzYWdlLmdldFR5cGUoKS5ydW50aW1lLmJpbjtcbiAgICBmb3JtYXQucmVhZE1lc3NhZ2UobWVzc2FnZSwgcmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMpO1xuICAgIHJldHVybiBtZXNzYWdlO1xufVxuLy8gUmVhZCBhIG1hcCBmaWVsZCwgZXhwZWN0aW5nIGtleSBmaWVsZCA9IDEsIHZhbHVlIGZpZWxkID0gMlxuZnVuY3Rpb24gcmVhZE1hcEVudHJ5KGZpZWxkLCByZWFkZXIsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBsZW5ndGggPSByZWFkZXIudWludDMyKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgbGV0IGtleSwgdmFsO1xuICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgIGxldCBbZmllbGROb10gPSByZWFkZXIudGFnKCk7XG4gICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGtleSA9IHJlYWRTY2FsYXIocmVhZGVyLCBmaWVsZC5LKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGZpZWxkLlYua2luZCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSByZWFkU2NhbGFyKHJlYWRlciwgZmllbGQuVi5UKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IHJlYWRNZXNzYWdlRmllbGQocmVhZGVyLCBuZXcgZmllbGQuVi5UKCksIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQga2V5UmF3ID0gc2NhbGFyRGVmYXVsdFZhbHVlKGZpZWxkLkssIExvbmdUeXBlLkJJR0lOVCk7XG4gICAgICAgIGtleSA9XG4gICAgICAgICAgICBmaWVsZC5LID09IFNjYWxhclR5cGUuQk9PTFxuICAgICAgICAgICAgICAgID8ga2V5UmF3LnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgICA6IGtleVJhdztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBrZXkgIT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Yga2V5ICE9IFwibnVtYmVyXCIpIHtcbiAgICAgICAga2V5ID0ga2V5LnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzd2l0Y2ggKGZpZWxkLlYua2luZCkge1xuICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICAgIHZhbCA9IHNjYWxhckRlZmF1bHRWYWx1ZShmaWVsZC5WLlQsIExvbmdUeXBlLkJJR0lOVCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgIHZhbCA9IDA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgIHZhbCA9IG5ldyBmaWVsZC5WLlQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW2tleSwgdmFsXTtcbn1cbi8vIFJlYWQgYSBzY2FsYXIgdmFsdWUsIGJ1dCByZXR1cm4gNjQgYml0IGludGVncmFsIHR5cGVzIChpbnQ2NCwgdWludDY0LFxuLy8gc2ludDY0LCBmaXhlZDY0LCBzZml4ZWQ2NCkgYXMgc3RyaW5nIGluc3RlYWQgb2YgYmlnaW50LlxuZXhwb3J0IGZ1bmN0aW9uIHJlYWRTY2FsYXJMVFN0cmluZyhyZWFkZXIsIHR5cGUpIHtcbiAgICBjb25zdCB2ID0gcmVhZFNjYWxhcihyZWFkZXIsIHR5cGUpO1xuICAgIHJldHVybiB0eXBlb2YgdiA9PSBcImJpZ2ludFwiID8gdi50b1N0cmluZygpIDogdjtcbn1cbi8vIERvZXMgbm90IHVzZSBzY2FsYXJUeXBlSW5mbygpIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuXG5mdW5jdGlvbiByZWFkU2NhbGFyKHJlYWRlciwgdHlwZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuU1RSSU5HOlxuICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkJPT0w6XG4gICAgICAgICAgICByZXR1cm4gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkRPVUJMRTpcbiAgICAgICAgICAgIHJldHVybiByZWFkZXIuZG91YmxlKCk7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5GTE9BVDpcbiAgICAgICAgICAgIHJldHVybiByZWFkZXIuZmxvYXQoKTtcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLklOVDMyOlxuICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5pbnQzMigpO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuSU5UNjQ6XG4gICAgICAgICAgICByZXR1cm4gcmVhZGVyLmludDY0KCk7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5VSU5UNjQ6XG4gICAgICAgICAgICByZXR1cm4gcmVhZGVyLnVpbnQ2NCgpO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQ2NDpcbiAgICAgICAgICAgIHJldHVybiByZWFkZXIuZml4ZWQ2NCgpO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuQllURVM6XG4gICAgICAgICAgICByZXR1cm4gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDMyOlxuICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5maXhlZDMyKCk7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TRklYRUQzMjpcbiAgICAgICAgICAgIHJldHVybiByZWFkZXIuc2ZpeGVkMzIoKTtcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDY0OlxuICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5zZml4ZWQ2NCgpO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0lOVDY0OlxuICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5zaW50NjQoKTtcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQzMjpcbiAgICAgICAgICAgIHJldHVybiByZWFkZXIudWludDMyKCk7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UMzI6XG4gICAgICAgICAgICByZXR1cm4gcmVhZGVyLnNpbnQzMigpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiB3cml0ZU1hcEVudHJ5KHdyaXRlciwgb3B0aW9ucywgZmllbGQsIGtleSwgdmFsdWUpIHtcbiAgICB3cml0ZXIudGFnKGZpZWxkLm5vLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpO1xuICAgIHdyaXRlci5mb3JrKCk7XG4gICAgLy8gamF2YXNjcmlwdCBvbmx5IGFsbG93cyBudW1iZXIgb3Igc3RyaW5nIGZvciBvYmplY3QgcHJvcGVydGllc1xuICAgIC8vIHdlIGNvbnZlcnQgZnJvbSBvdXIgcmVwcmVzZW50YXRpb24gdG8gdGhlIHByb3RvYnVmIHR5cGVcbiAgICBsZXQga2V5VmFsdWUgPSBrZXk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zd2l0Y2gtZXhoYXVzdGl2ZW5lc3MtY2hlY2sgLS0gd2UgZGVsaWJlcmF0ZWx5IGhhbmRsZSBqdXN0IHRoZSBzcGVjaWFsIGNhc2VzIGZvciBtYXAga2V5c1xuICAgIHN3aXRjaCAoZmllbGQuSykge1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuSU5UMzI6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDMyOlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDMyOlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVEMzI6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UMzI6XG4gICAgICAgICAgICBrZXlWYWx1ZSA9IE51bWJlci5wYXJzZUludChrZXkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5CT09MOlxuICAgICAgICAgICAgYXNzZXJ0KGtleSA9PSBcInRydWVcIiB8fCBrZXkgPT0gXCJmYWxzZVwiKTtcbiAgICAgICAgICAgIGtleVZhbHVlID0ga2V5ID09IFwidHJ1ZVwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIHdyaXRlIGtleSwgZXhwZWN0aW5nIGtleSBmaWVsZCBudW1iZXIgPSAxXG4gICAgd3JpdGVTY2FsYXIod3JpdGVyLCBmaWVsZC5LLCAxLCBrZXlWYWx1ZSwgdHJ1ZSk7XG4gICAgLy8gd3JpdGUgdmFsdWUsIGV4cGVjdGluZyB2YWx1ZSBmaWVsZCBudW1iZXIgPSAyXG4gICAgc3dpdGNoIChmaWVsZC5WLmtpbmQpIHtcbiAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgd3JpdGVTY2FsYXIod3JpdGVyLCBmaWVsZC5WLlQsIDIsIHZhbHVlLCB0cnVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgd3JpdGVTY2FsYXIod3JpdGVyLCBTY2FsYXJUeXBlLklOVDMyLCAyLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgIHdyaXRlTWVzc2FnZUZpZWxkKHdyaXRlciwgb3B0aW9ucywgZmllbGQuVi5ULCAyLCB2YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgd3JpdGVyLmpvaW4oKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cml0ZU1lc3NhZ2VGaWVsZCh3cml0ZXIsIG9wdGlvbnMsIHR5cGUsIGZpZWxkTm8sIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IHdyYXBGaWVsZCh0eXBlLCB2YWx1ZSk7XG4gICAgICAgIHdyaXRlclxuICAgICAgICAgICAgLnRhZyhmaWVsZE5vLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpXG4gICAgICAgICAgICAuYnl0ZXMobWVzc2FnZS50b0JpbmFyeShvcHRpb25zKSk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHdyaXRlU2NhbGFyKHdyaXRlciwgdHlwZSwgZmllbGRObywgdmFsdWUsIGVtaXRJbnRyaW5zaWNEZWZhdWx0KSB7XG4gICAgbGV0IFt3aXJlVHlwZSwgbWV0aG9kLCBpc0ludHJpbnNpY0RlZmF1bHRdID0gc2NhbGFyVHlwZUluZm8odHlwZSwgdmFsdWUpO1xuICAgIGlmICghaXNJbnRyaW5zaWNEZWZhdWx0IHx8IGVtaXRJbnRyaW5zaWNEZWZhdWx0KSB7XG4gICAgICAgIHdyaXRlci50YWcoZmllbGRObywgd2lyZVR5cGUpW21ldGhvZF0odmFsdWUpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiB3cml0ZVBhY2tlZCh3cml0ZXIsIHR5cGUsIGZpZWxkTm8sIHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB3cml0ZXIudGFnKGZpZWxkTm8sIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpO1xuICAgIGxldCBbLCBtZXRob2RdID0gc2NhbGFyVHlwZUluZm8odHlwZSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB3cml0ZXJbbWV0aG9kXSh2YWx1ZVtpXSk7XG4gICAgfVxuICAgIHdyaXRlci5qb2luKCk7XG59XG4iLCIvLyBDb3B5cmlnaHQgMjAyMS0yMDIzIEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuaW1wb3J0IHsgU2NhbGFyVHlwZSB9IGZyb20gXCIuLi9maWVsZC5qc1wiO1xuaW1wb3J0IHsgbWFrZUJpbmFyeUZvcm1hdENvbW1vbiwgd3JpdGVNYXBFbnRyeSwgd3JpdGVNZXNzYWdlRmllbGQsIHdyaXRlUGFja2VkLCB3cml0ZVNjYWxhciwgfSBmcm9tIFwiLi9iaW5hcnktZm9ybWF0LWNvbW1vbi5qc1wiO1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50LCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQsIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb24sIEB0eXBlc2NyaXB0LWVzbGludC9zdHJpY3QtYm9vbGVhbi1leHByZXNzaW9ucywgcHJlZmVyLWNvbnN0LCBuby1jYXNlLWRlY2xhcmF0aW9ucyAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VCaW5hcnlGb3JtYXRQcm90bzMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbWFrZUJpbmFyeUZvcm1hdENvbW1vbigpKSwgeyB3cml0ZU1lc3NhZ2UobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gbWVzc2FnZS5nZXRUeXBlKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIHR5cGUuZmllbGRzLmJ5TnVtYmVyKCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUsIC8vIHRoaXMgd2lsbCBiZSBvdXIgZmllbGQgdmFsdWUsIHdoZXRoZXIgaXQgaXMgbWVtYmVyIG9mIGEgb25lb2Ygb3IgcmVndWxhciBmaWVsZFxuICAgICAgICAgICAgICAgIHJlcGVhdGVkID0gZmllbGQucmVwZWF0ZWQsIGxvY2FsTmFtZSA9IGZpZWxkLmxvY2FsTmFtZTtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQub25lb2YpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb25lb2YgPSBtZXNzYWdlW2ZpZWxkLm9uZW9mLmxvY2FsTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbmVvZi5jYXNlICE9PSBsb2NhbE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBmaWVsZCBpcyBub3Qgc2VsZWN0ZWQsIHNraXBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG9uZW9mLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBtZXNzYWdlW2xvY2FsTmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN3aXRjaCAoZmllbGQua2luZCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc2NhbGFyVHlwZSA9IGZpZWxkLmtpbmQgPT0gXCJlbnVtXCIgPyBTY2FsYXJUeXBlLklOVDMyIDogZmllbGQuVDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXBlYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZC5wYWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVQYWNrZWQod3JpdGVyLCBzY2FsYXJUeXBlLCBmaWVsZC5ubywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cml0ZVNjYWxhcih3cml0ZXIsIHNjYWxhclR5cGUsIGZpZWxkLm5vLCBpdGVtLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlU2NhbGFyKHdyaXRlciwgc2NhbGFyVHlwZSwgZmllbGQubm8sIHZhbHVlLCAhIWZpZWxkLm9uZW9mIHx8IGZpZWxkLm9wdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVwZWF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVNZXNzYWdlRmllbGQod3JpdGVyLCBvcHRpb25zLCBmaWVsZC5ULCBmaWVsZC5ubywgaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVNZXNzYWdlRmllbGQod3JpdGVyLCBvcHRpb25zLCBmaWVsZC5ULCBmaWVsZC5ubywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtYXBcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsXSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cml0ZU1hcEVudHJ5KHdyaXRlciwgb3B0aW9ucywgZmllbGQsIGtleSwgdmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcykge1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVVbmtub3duRmllbGRzKG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9IH0pO1xufVxuIiwiLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudCwgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvbiwgcHJlZmVyLWNvbnN0ICovXG4vLyBsb29rdXAgdGFibGUgZnJvbSBiYXNlNjQgY2hhcmFjdGVyIHRvIGJ5dGVcbmxldCBlbmNUYWJsZSA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiLnNwbGl0KFwiXCIpO1xuLy8gbG9va3VwIHRhYmxlIGZyb20gYmFzZTY0IGNoYXJhY3RlciAqY29kZSogdG8gYnl0ZSBiZWNhdXNlIGxvb2t1cCBieSBudW1iZXIgaXMgZmFzdFxubGV0IGRlY1RhYmxlID0gW107XG5mb3IgKGxldCBpID0gMDsgaSA8IGVuY1RhYmxlLmxlbmd0aDsgaSsrKVxuICAgIGRlY1RhYmxlW2VuY1RhYmxlW2ldLmNoYXJDb2RlQXQoMCldID0gaTtcbi8vIHN1cHBvcnQgYmFzZTY0dXJsIHZhcmlhbnRzXG5kZWNUYWJsZVtcIi1cIi5jaGFyQ29kZUF0KDApXSA9IGVuY1RhYmxlLmluZGV4T2YoXCIrXCIpO1xuZGVjVGFibGVbXCJfXCIuY2hhckNvZGVBdCgwKV0gPSBlbmNUYWJsZS5pbmRleE9mKFwiL1wiKTtcbmV4cG9ydCBjb25zdCBwcm90b0Jhc2U2NCA9IHtcbiAgICAvKipcbiAgICAgKiBEZWNvZGVzIGEgYmFzZTY0IHN0cmluZyB0byBhIGJ5dGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiAtIGlnbm9yZXMgd2hpdGUtc3BhY2UsIGluY2x1ZGluZyBsaW5lIGJyZWFrcyBhbmQgdGFic1xuICAgICAqIC0gYWxsb3dzIGlubmVyIHBhZGRpbmcgKGNhbiBkZWNvZGUgY29uY2F0ZW5hdGVkIGJhc2U2NCBzdHJpbmdzKVxuICAgICAqIC0gZG9lcyBub3QgcmVxdWlyZSBwYWRkaW5nXG4gICAgICogLSB1bmRlcnN0YW5kcyBiYXNlNjR1cmwgZW5jb2Rpbmc6XG4gICAgICogICBcIi1cIiBpbnN0ZWFkIG9mIFwiK1wiLFxuICAgICAqICAgXCJfXCIgaW5zdGVhZCBvZiBcIi9cIixcbiAgICAgKiAgIG5vIHBhZGRpbmdcbiAgICAgKi9cbiAgICBkZWMoYmFzZTY0U3RyKSB7XG4gICAgICAgIC8vIGVzdGltYXRlIGJ5dGUgc2l6ZSwgbm90IGFjY291bnRpbmcgZm9yIGlubmVyIHBhZGRpbmcgYW5kIHdoaXRlc3BhY2VcbiAgICAgICAgbGV0IGVzID0gKGJhc2U2NFN0ci5sZW5ndGggKiAzKSAvIDQ7XG4gICAgICAgIGlmIChiYXNlNjRTdHJbYmFzZTY0U3RyLmxlbmd0aCAtIDJdID09IFwiPVwiKVxuICAgICAgICAgICAgZXMgLT0gMjtcbiAgICAgICAgZWxzZSBpZiAoYmFzZTY0U3RyW2Jhc2U2NFN0ci5sZW5ndGggLSAxXSA9PSBcIj1cIilcbiAgICAgICAgICAgIGVzIC09IDE7XG4gICAgICAgIGxldCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGVzKSwgYnl0ZVBvcyA9IDAsIC8vIHBvc2l0aW9uIGluIGJ5dGUgYXJyYXlcbiAgICAgICAgZ3JvdXBQb3MgPSAwLCAvLyBwb3NpdGlvbiBpbiBiYXNlNjQgZ3JvdXBcbiAgICAgICAgYiwgLy8gY3VycmVudCBieXRlXG4gICAgICAgIHAgPSAwOyAvLyBwcmV2aW91cyBieXRlXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmFzZTY0U3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBiID0gZGVjVGFibGVbYmFzZTY0U3RyLmNoYXJDb2RlQXQoaSldO1xuICAgICAgICAgICAgaWYgKGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoYmFzZTY0U3RyW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgVFM3MDI5OiBGYWxsdGhyb3VnaCBjYXNlIGluIHN3aXRjaFxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiPVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBQb3MgPSAwOyAvLyByZXNldCBzdGF0ZSB3aGVuIHBhZGRpbmcgZm91bmRcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBUUzcwMjk6IEZhbGx0aHJvdWdoIGNhc2UgaW4gc3dpdGNoXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJcXG5cIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlxcclwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiXFx0XCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCIgXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gc2tpcCB3aGl0ZS1zcGFjZSwgYW5kIHBhZGRpbmdcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaW52YWxpZCBiYXNlNjQgc3RyaW5nLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKGdyb3VwUG9zKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBwID0gYjtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBQb3MgPSAxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzW2J5dGVQb3MrK10gPSAocCA8PCAyKSB8ICgoYiAmIDQ4KSA+PiA0KTtcbiAgICAgICAgICAgICAgICAgICAgcCA9IGI7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwUG9zID0gMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBieXRlc1tieXRlUG9zKytdID0gKChwICYgMTUpIDw8IDQpIHwgKChiICYgNjApID4+IDIpO1xuICAgICAgICAgICAgICAgICAgICBwID0gYjtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBQb3MgPSAzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzW2J5dGVQb3MrK10gPSAoKHAgJiAzKSA8PCA2KSB8IGI7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwUG9zID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwUG9zID09IDEpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcImludmFsaWQgYmFzZTY0IHN0cmluZy5cIik7XG4gICAgICAgIHJldHVybiBieXRlcy5zdWJhcnJheSgwLCBieXRlUG9zKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEVuY29kZSBhIGJ5dGUgYXJyYXkgdG8gYSBiYXNlNjQgc3RyaW5nLlxuICAgICAqL1xuICAgIGVuYyhieXRlcykge1xuICAgICAgICBsZXQgYmFzZTY0ID0gXCJcIiwgZ3JvdXBQb3MgPSAwLCAvLyBwb3NpdGlvbiBpbiBiYXNlNjQgZ3JvdXBcbiAgICAgICAgYiwgLy8gY3VycmVudCBieXRlXG4gICAgICAgIHAgPSAwOyAvLyBjYXJyeSBvdmVyIGZyb20gcHJldmlvdXMgYnl0ZVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBiID0gYnl0ZXNbaV07XG4gICAgICAgICAgICBzd2l0Y2ggKGdyb3VwUG9zKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBiYXNlNjQgKz0gZW5jVGFibGVbYiA+PiAyXTtcbiAgICAgICAgICAgICAgICAgICAgcCA9IChiICYgMykgPDwgNDtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBQb3MgPSAxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGJhc2U2NCArPSBlbmNUYWJsZVtwIHwgKGIgPj4gNCldO1xuICAgICAgICAgICAgICAgICAgICBwID0gKGIgJiAxNSkgPDwgMjtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBQb3MgPSAyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGJhc2U2NCArPSBlbmNUYWJsZVtwIHwgKGIgPj4gNildO1xuICAgICAgICAgICAgICAgICAgICBiYXNlNjQgKz0gZW5jVGFibGVbYiAmIDYzXTtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBQb3MgPSAwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBhZGQgb3V0cHV0IHBhZGRpbmdcbiAgICAgICAgaWYgKGdyb3VwUG9zKSB7XG4gICAgICAgICAgICBiYXNlNjQgKz0gZW5jVGFibGVbcF07XG4gICAgICAgICAgICBiYXNlNjQgKz0gXCI9XCI7XG4gICAgICAgICAgICBpZiAoZ3JvdXBQb3MgPT0gMSlcbiAgICAgICAgICAgICAgICBiYXNlNjQgKz0gXCI9XCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2U2NDtcbiAgICB9LFxufTtcbiIsIi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5pbXBvcnQgeyBNZXNzYWdlIH0gZnJvbSBcIi4uL21lc3NhZ2UuanNcIjtcbmltcG9ydCB7IExvbmdUeXBlLCBTY2FsYXJUeXBlIH0gZnJvbSBcIi4uL2ZpZWxkLmpzXCI7XG5pbXBvcnQgeyBhc3NlcnQsIGFzc2VydEZsb2F0MzIsIGFzc2VydEludDMyLCBhc3NlcnRVSW50MzIgfSBmcm9tIFwiLi9hc3NlcnQuanNcIjtcbmltcG9ydCB7IHByb3RvSW50NjQgfSBmcm9tIFwiLi4vcHJvdG8taW50NjQuanNcIjtcbmltcG9ydCB7IHByb3RvQmFzZTY0IH0gZnJvbSBcIi4uL3Byb3RvLWJhc2U2NC5qc1wiO1xuLyogZXNsaW50LWRpc2FibGUgbm8tY2FzZS1kZWNsYXJhdGlvbnMsIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC1wbHVzLW9wZXJhbmRzLEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnksQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50LEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtY2FsbCxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudCAqL1xuLy8gRGVmYXVsdCBvcHRpb25zIGZvciBwYXJzaW5nIEpTT04uXG5jb25zdCBqc29uUmVhZERlZmF1bHRzID0ge1xuICAgIGlnbm9yZVVua25vd25GaWVsZHM6IGZhbHNlLFxufTtcbi8vIERlZmF1bHQgb3B0aW9ucyBmb3Igc2VyaWFsaXppbmcgdG8gSlNPTi5cbmNvbnN0IGpzb25Xcml0ZURlZmF1bHRzID0ge1xuICAgIGVtaXREZWZhdWx0VmFsdWVzOiBmYWxzZSxcbiAgICBlbnVtQXNJbnRlZ2VyOiBmYWxzZSxcbiAgICB1c2VQcm90b0ZpZWxkTmFtZTogZmFsc2UsXG4gICAgcHJldHR5U3BhY2VzOiAwLFxufTtcbmZ1bmN0aW9uIG1ha2VSZWFkT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGpzb25SZWFkRGVmYXVsdHMpLCBvcHRpb25zKSA6IGpzb25SZWFkRGVmYXVsdHM7XG59XG5mdW5jdGlvbiBtYWtlV3JpdGVPcHRpb25zKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucyA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwganNvbldyaXRlRGVmYXVsdHMpLCBvcHRpb25zKSA6IGpzb25Xcml0ZURlZmF1bHRzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VKc29uRm9ybWF0Q29tbW9uKG1ha2VXcml0ZUZpZWxkKSB7XG4gICAgY29uc3Qgd3JpdGVGaWVsZCA9IG1ha2VXcml0ZUZpZWxkKHdyaXRlRW51bSwgd3JpdGVTY2FsYXIpO1xuICAgIHJldHVybiB7XG4gICAgICAgIG1ha2VSZWFkT3B0aW9ucyxcbiAgICAgICAgbWFrZVdyaXRlT3B0aW9ucyxcbiAgICAgICAgcmVhZE1lc3NhZ2UodHlwZSwganNvbiwgb3B0aW9ucywgbWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKGpzb24gPT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KGpzb24pIHx8IHR5cGVvZiBqc29uICE9IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBkZWNvZGUgbWVzc2FnZSAke3R5cGUudHlwZU5hbWV9IGZyb20gSlNPTjogJHt0aGlzLmRlYnVnKGpzb24pfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2UgIT09IG51bGwgJiYgbWVzc2FnZSAhPT0gdm9pZCAwID8gbWVzc2FnZSA6IG5ldyB0eXBlKCk7XG4gICAgICAgICAgICBjb25zdCBvbmVvZlNlZW4gPSB7fTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2pzb25LZXksIGpzb25WYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoanNvbikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZCA9IHR5cGUuZmllbGRzLmZpbmRKc29uTmFtZShqc29uS2V5KTtcbiAgICAgICAgICAgICAgICBpZiAoIWZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5pZ25vcmVVbmtub3duRmllbGRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBkZWNvZGUgbWVzc2FnZSAke3R5cGUudHlwZU5hbWV9IGZyb20gSlNPTjoga2V5IFwiJHtqc29uS2V5fVwiIGlzIHVua25vd25gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGxvY2FsTmFtZSA9IGZpZWxkLmxvY2FsTmFtZTtcbiAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0ID0gbWVzc2FnZTtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQub25lb2YpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGpzb25WYWx1ZSA9PT0gbnVsbCAmJiBmaWVsZC5raW5kID09IFwic2NhbGFyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlZSBjb25mb3JtYW5jZSB0ZXN0IFJlcXVpcmVkLlByb3RvMy5Kc29uSW5wdXQuT25lb2ZGaWVsZE51bGx7Rmlyc3QsU2Vjb25kfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VlbiA9IG9uZW9mU2VlbltmaWVsZC5vbmVvZi5sb2NhbE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2Vlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgZGVjb2RlIG1lc3NhZ2UgJHt0eXBlLnR5cGVOYW1lfSBmcm9tIEpTT046IG11bHRpcGxlIGtleXMgZm9yIG9uZW9mIFwiJHtmaWVsZC5vbmVvZi5uYW1lfVwiIHByZXNlbnQ6IFwiJHtzZWVufVwiLCBcIiR7anNvbktleX1cImApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG9uZW9mU2VlbltmaWVsZC5vbmVvZi5sb2NhbE5hbWVdID0ganNvbktleTtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0W2ZpZWxkLm9uZW9mLmxvY2FsTmFtZV0gPSB7IGNhc2U6IGxvY2FsTmFtZSB9O1xuICAgICAgICAgICAgICAgICAgICBsb2NhbE5hbWUgPSBcInZhbHVlXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmaWVsZC5yZXBlYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoanNvblZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoanNvblZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgZGVjb2RlIGZpZWxkICR7dHlwZS50eXBlTmFtZX0uJHtmaWVsZC5uYW1lfSBmcm9tIEpTT046ICR7dGhpcy5kZWJ1Zyhqc29uVmFsdWUpfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldEFycmF5ID0gdGFyZ2V0W2xvY2FsTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QganNvbkl0ZW0gb2YganNvblZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoanNvbkl0ZW0gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBkZWNvZGUgZmllbGQgJHt0eXBlLnR5cGVOYW1lfS4ke2ZpZWxkLm5hbWV9IGZyb20gSlNPTjogJHt0aGlzLmRlYnVnKGpzb25JdGVtKX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N3aXRjaC1leGhhdXN0aXZlbmVzcy1jaGVjayAtLSBcIm1hcFwiIGlzIGludmFsaWQgZm9yIHJlcGVhdGVkIGZpZWxkc1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChmaWVsZC5raW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gZmllbGQuVC5mcm9tSnNvbihqc29uSXRlbSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IHJlYWRFbnVtKGZpZWxkLlQsIGpzb25JdGVtLCBvcHRpb25zLmlnbm9yZVVua25vd25GaWVsZHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gcmVhZFNjYWxhcihmaWVsZC5ULCBqc29uSXRlbSwgZmllbGQuTCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtID0gYGNhbm5vdCBkZWNvZGUgZmllbGQgJHt0eXBlLnR5cGVOYW1lfS4ke2ZpZWxkLm5hbWV9IGZyb20gSlNPTjogJHt0aGlzLmRlYnVnKGpzb25JdGVtKX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm1lc3NhZ2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0gKz0gYDogJHtlLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEFycmF5LnB1c2godmFsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmaWVsZC5raW5kID09IFwibWFwXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGpzb25WYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoanNvblZhbHVlKSB8fCB0eXBlb2YganNvblZhbHVlICE9IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IGRlY29kZSBmaWVsZCAke3R5cGUudHlwZU5hbWV9LiR7ZmllbGQubmFtZX0gZnJvbSBKU09OOiAke3RoaXMuZGVidWcoanNvblZhbHVlKX1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRNYXAgPSB0YXJnZXRbbG9jYWxOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBbanNvbk1hcEtleSwganNvbk1hcFZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhqc29uVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoanNvbk1hcFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgZGVjb2RlIGZpZWxkICR7dHlwZS50eXBlTmFtZX0uJHtmaWVsZC5uYW1lfSBmcm9tIEpTT046IG1hcCB2YWx1ZSBudWxsYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChmaWVsZC5WLmtpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBmaWVsZC5WLlQuZnJvbUpzb24oanNvbk1hcFZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gcmVhZEVudW0oZmllbGQuVi5ULCBqc29uTWFwVmFsdWUsIG9wdGlvbnMuaWdub3JlVW5rbm93bkZpZWxkcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSByZWFkU2NhbGFyKGZpZWxkLlYuVCwganNvbk1hcFZhbHVlLCBMb25nVHlwZS5CSUdJTlQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbSA9IGBjYW5ub3QgZGVjb2RlIG1hcCB2YWx1ZSBmb3IgZmllbGQgJHt0eXBlLnR5cGVOYW1lfS4ke2ZpZWxkLm5hbWV9IGZyb20gSlNPTjogJHt0aGlzLmRlYnVnKGpzb25WYWx1ZSl9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IgJiYgZS5tZXNzYWdlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtICs9IGA6ICR7ZS5tZXNzYWdlfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldE1hcFtyZWFkU2NhbGFyKGZpZWxkLkssIGZpZWxkLksgPT0gU2NhbGFyVHlwZS5CT09MXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8ganNvbk1hcEtleSA9PSBcInRydWVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGpzb25NYXBLZXkgPT0gXCJmYWxzZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDoganNvbk1hcEtleVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGpzb25NYXBLZXksIExvbmdUeXBlLkJJR0lOVCkudG9TdHJpbmcoKV0gPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtID0gYGNhbm5vdCBkZWNvZGUgbWFwIGtleSBmb3IgZmllbGQgJHt0eXBlLnR5cGVOYW1lfS4ke2ZpZWxkLm5hbWV9IGZyb20gSlNPTjogJHt0aGlzLmRlYnVnKGpzb25WYWx1ZSl9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubWVzc2FnZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0gKz0gYDogJHtlLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGZpZWxkLmtpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZVR5cGUgPSBmaWVsZC5UO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqc29uVmFsdWUgPT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVR5cGUudHlwZU5hbWUgIT0gXCJnb29nbGUucHJvdG9idWYuVmFsdWVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGQub25lb2YpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IGRlY29kZSBmaWVsZCAke3R5cGUudHlwZU5hbWV9LiR7ZmllbGQubmFtZX0gZnJvbSBKU09OOiBudWxsIGlzIGludmFsaWQgZm9yIG9uZW9mIGZpZWxkIFwiJHtqc29uS2V5fVwiYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRbbG9jYWxOYW1lXSBpbnN0YW5jZW9mIE1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV0uZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtsb2NhbE5hbWVdID0gbWVzc2FnZVR5cGUuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2VUeXBlLmZpZWxkV3JhcHBlciAmJiAhZmllbGQub25lb2YpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtsb2NhbE5hbWVdID0gbWVzc2FnZVR5cGUuZmllbGRXcmFwcGVyLnVud3JhcEZpZWxkKHRhcmdldFtsb2NhbE5hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZW51bVZhbHVlID0gcmVhZEVudW0oZmllbGQuVCwganNvblZhbHVlLCBvcHRpb25zLmlnbm9yZVVua25vd25GaWVsZHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbnVtVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IGVudW1WYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV0gPSByZWFkU2NhbGFyKGZpZWxkLlQsIGpzb25WYWx1ZSwgZmllbGQuTCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtID0gYGNhbm5vdCBkZWNvZGUgZmllbGQgJHt0eXBlLnR5cGVOYW1lfS4ke2ZpZWxkLm5hbWV9IGZyb20gSlNPTjogJHt0aGlzLmRlYnVnKGpzb25WYWx1ZSl9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm1lc3NhZ2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbSArPSBgOiAke2UubWVzc2FnZX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfSxcbiAgICAgICAgd3JpdGVNZXNzYWdlKG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBtZXNzYWdlLmdldFR5cGUoKTtcbiAgICAgICAgICAgIGNvbnN0IGpzb24gPSB7fTtcbiAgICAgICAgICAgIGxldCBmaWVsZDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBtZW1iZXIgb2YgdHlwZS5maWVsZHMuYnlNZW1iZXIoKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQganNvblZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWVtYmVyLmtpbmQgPT0gXCJvbmVvZlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvbmVvZiA9IG1lc3NhZ2VbbWVtYmVyLmxvY2FsTmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob25lb2YudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQgPSBtZW1iZXIuZmluZEZpZWxkKG9uZW9mLmNhc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFwib25lb2YgY2FzZSBub3QgZm91bmQ6IFwiICsgb25lb2YuY2FzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb25WYWx1ZSA9IHdyaXRlRmllbGQoZmllbGQsIG9uZW9mLnZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkID0gbWVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAganNvblZhbHVlID0gd3JpdGVGaWVsZChmaWVsZCwgbWVzc2FnZVtmaWVsZC5sb2NhbE5hbWVdLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoanNvblZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb25bb3B0aW9ucy51c2VQcm90b0ZpZWxkTmFtZSA/IGZpZWxkLm5hbWUgOiBmaWVsZC5qc29uTmFtZV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb25WYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbSA9IGZpZWxkXG4gICAgICAgICAgICAgICAgICAgID8gYGNhbm5vdCBlbmNvZGUgZmllbGQgJHt0eXBlLnR5cGVOYW1lfS4ke2ZpZWxkLm5hbWV9IHRvIEpTT05gXG4gICAgICAgICAgICAgICAgICAgIDogYGNhbm5vdCBlbmNvZGUgbWVzc2FnZSAke3R5cGUudHlwZU5hbWV9IHRvIEpTT05gO1xuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSBlIGluc3RhbmNlb2YgRXJyb3IgPyBlLm1lc3NhZ2UgOiBTdHJpbmcoZSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG0gKyAoci5sZW5ndGggPiAwID8gYDogJHtyfWAgOiBcIlwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ganNvbjtcbiAgICAgICAgfSxcbiAgICAgICAgcmVhZFNjYWxhcixcbiAgICAgICAgd3JpdGVTY2FsYXIsXG4gICAgICAgIGRlYnVnOiBkZWJ1Z0pzb25WYWx1ZSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZGVidWdKc29uVmFsdWUoanNvbikge1xuICAgIGlmIChqc29uID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICB9XG4gICAgc3dpdGNoICh0eXBlb2YganNvbikge1xuICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShqc29uKSA/IFwiYXJyYXlcIiA6IFwib2JqZWN0XCI7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHJldHVybiBqc29uLmxlbmd0aCA+IDEwMCA/IFwic3RyaW5nXCIgOiBgXCIke2pzb24uc3BsaXQoJ1wiJykuam9pbignXFxcXFwiJyl9XCJgO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyhqc29uKTtcbiAgICB9XG59XG4vLyBNYXkgdGhyb3cgYW4gZXJyb3IuIElmIHRoZSBlcnJvciBtZXNzYWdlIGlzIG5vbi1ibGFuaywgaXQgc2hvdWxkIGJlIHNob3duLlxuLy8gSXQgaXMgdXAgdG8gdGhlIGNhbGxlciB0byBwcm92aWRlIGNvbnRleHQuXG5mdW5jdGlvbiByZWFkU2NhbGFyKHR5cGUsIGpzb24sIGxvbmdUeXBlKSB7XG4gICAgLy8gZXZlcnkgdmFsaWQgY2FzZSBpbiB0aGUgc3dpdGNoIGJlbG93IHJldHVybnMsIGFuZCBldmVyeSBmYWxsXG4gICAgLy8gdGhyb3VnaCBpcyByZWdhcmRlZCBhcyBhIGZhaWx1cmUuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIC8vIGZsb2F0LCBkb3VibGU6IEpTT04gdmFsdWUgd2lsbCBiZSBhIG51bWJlciBvciBvbmUgb2YgdGhlIHNwZWNpYWwgc3RyaW5nIHZhbHVlcyBcIk5hTlwiLCBcIkluZmluaXR5XCIsIGFuZCBcIi1JbmZpbml0eVwiLlxuICAgICAgICAvLyBFaXRoZXIgbnVtYmVycyBvciBzdHJpbmdzIGFyZSBhY2NlcHRlZC4gRXhwb25lbnQgbm90YXRpb24gaXMgYWxzbyBhY2NlcHRlZC5cbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkRPVUJMRTpcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkZMT0FUOlxuICAgICAgICAgICAgaWYgKGpzb24gPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDAuMDtcbiAgICAgICAgICAgIGlmIChqc29uID09PSBcIk5hTlwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBOdW1iZXIuTmFOO1xuICAgICAgICAgICAgaWYgKGpzb24gPT09IFwiSW5maW5pdHlcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgICAgICAgaWYgKGpzb24gPT09IFwiLUluZmluaXR5XCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICAgICAgICAgIGlmIChqc29uID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgLy8gZW1wdHkgc3RyaW5nIGlzIG5vdCBhIG51bWJlclxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBqc29uID09IFwic3RyaW5nXCIgJiYganNvbi50cmltKCkubGVuZ3RoICE9PSBqc29uLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIGV4dHJhIHdoaXRlc3BhY2VcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YganNvbiAhPSBcInN0cmluZ1wiICYmIHR5cGVvZiBqc29uICE9IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZsb2F0ID0gTnVtYmVyKGpzb24pO1xuICAgICAgICAgICAgaWYgKE51bWJlci5pc05hTihmbG9hdCkpIHtcbiAgICAgICAgICAgICAgICAvLyBub3QgYSBudW1iZXJcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGZsb2F0KSkge1xuICAgICAgICAgICAgICAgIC8vIGluZmluaXR5IGFuZCAtaW5maW5pdHkgYXJlIGhhbmRsZWQgYnkgc3RyaW5nIHJlcHJlc2VudGF0aW9uIGFib3ZlLCBzbyB0aGlzIGlzIGFuIGVycm9yXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZSA9PSBTY2FsYXJUeXBlLkZMT0FUKVxuICAgICAgICAgICAgICAgIGFzc2VydEZsb2F0MzIoZmxvYXQpO1xuICAgICAgICAgICAgcmV0dXJuIGZsb2F0O1xuICAgICAgICAvLyBpbnQzMiwgZml4ZWQzMiwgdWludDMyOiBKU09OIHZhbHVlIHdpbGwgYmUgYSBkZWNpbWFsIG51bWJlci4gRWl0aGVyIG51bWJlcnMgb3Igc3RyaW5ncyBhcmUgYWNjZXB0ZWQuXG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQzMjpcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVEMzI6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TRklYRUQzMjpcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNJTlQzMjpcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQzMjpcbiAgICAgICAgICAgIGlmIChqc29uID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgbGV0IGludDMyO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBqc29uID09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgaW50MzIgPSBqc29uO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGpzb24gPT0gXCJzdHJpbmdcIiAmJiBqc29uLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoanNvbi50cmltKCkubGVuZ3RoID09PSBqc29uLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgaW50MzIgPSBOdW1iZXIoanNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW50MzIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmICh0eXBlID09IFNjYWxhclR5cGUuVUlOVDMyKVxuICAgICAgICAgICAgICAgIGFzc2VydFVJbnQzMihpbnQzMik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYXNzZXJ0SW50MzIoaW50MzIpO1xuICAgICAgICAgICAgcmV0dXJuIGludDMyO1xuICAgICAgICAvLyBpbnQ2NCwgZml4ZWQ2NCwgdWludDY0OiBKU09OIHZhbHVlIHdpbGwgYmUgYSBkZWNpbWFsIHN0cmluZy4gRWl0aGVyIG51bWJlcnMgb3Igc3RyaW5ncyBhcmUgYWNjZXB0ZWQuXG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQ2NDpcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDY0OlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0lOVDY0OlxuICAgICAgICAgICAgaWYgKGpzb24gPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3RvSW50NjQuemVybztcbiAgICAgICAgICAgIGlmICh0eXBlb2YganNvbiAhPSBcIm51bWJlclwiICYmIHR5cGVvZiBqc29uICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjb25zdCBsb25nID0gcHJvdG9JbnQ2NC5wYXJzZShqc29uKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3RyaWN0LWJvb2xlYW4tZXhwcmVzc2lvbnNcbiAgICAgICAgICAgIHJldHVybiBsb25nVHlwZSA/IGxvbmcudG9TdHJpbmcoKSA6IGxvbmc7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDY0OlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDY0OlxuICAgICAgICAgICAgaWYgKGpzb24gPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3RvSW50NjQuemVybztcbiAgICAgICAgICAgIGlmICh0eXBlb2YganNvbiAhPSBcIm51bWJlclwiICYmIHR5cGVvZiBqc29uICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjb25zdCB1TG9uZyA9IHByb3RvSW50NjQudVBhcnNlKGpzb24pO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zdHJpY3QtYm9vbGVhbi1leHByZXNzaW9uc1xuICAgICAgICAgICAgcmV0dXJuIGxvbmdUeXBlID8gdUxvbmcudG9TdHJpbmcoKSA6IHVMb25nO1xuICAgICAgICAvLyBib29sOlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuQk9PTDpcbiAgICAgICAgICAgIGlmIChqc29uID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YganNvbiAhPT0gXCJib29sZWFuXCIpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICByZXR1cm4ganNvbjtcbiAgICAgICAgLy8gc3RyaW5nOlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuU1RSSU5HOlxuICAgICAgICAgICAgaWYgKGpzb24gPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGpzb24gIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEEgc3RyaW5nIG11c3QgYWx3YXlzIGNvbnRhaW4gVVRGLTggZW5jb2RlZCBvciA3LWJpdCBBU0NJSS5cbiAgICAgICAgICAgIC8vIFdlIHZhbGlkYXRlIHdpdGggZW5jb2RlVVJJQ29tcG9uZW50LCB3aGljaCBhcHBlYXJzIHRvIGJlIHRoZSBmYXN0ZXN0IHdpZGVseSBhdmFpbGFibGUgb3B0aW9uLlxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoanNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVVRGOFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBqc29uO1xuICAgICAgICAvLyBieXRlczogSlNPTiB2YWx1ZSB3aWxsIGJlIHRoZSBkYXRhIGVuY29kZWQgYXMgYSBzdHJpbmcgdXNpbmcgc3RhbmRhcmQgYmFzZTY0IGVuY29kaW5nIHdpdGggcGFkZGluZ3MuXG4gICAgICAgIC8vIEVpdGhlciBzdGFuZGFyZCBvciBVUkwtc2FmZSBiYXNlNjQgZW5jb2Rpbmcgd2l0aC93aXRob3V0IHBhZGRpbmdzIGFyZSBhY2NlcHRlZC5cbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkJZVEVTOlxuICAgICAgICAgICAgaWYgKGpzb24gPT09IG51bGwgfHwganNvbiA9PT0gXCJcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGpzb24gIT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICByZXR1cm4gcHJvdG9CYXNlNjQuZGVjKGpzb24pO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbn1cbmZ1bmN0aW9uIHJlYWRFbnVtKHR5cGUsIGpzb24sIGlnbm9yZVVua25vd25GaWVsZHMpIHtcbiAgICBpZiAoanNvbiA9PT0gbnVsbCkge1xuICAgICAgICAvLyBwcm90bzMgcmVxdWlyZXMgMCB0byBiZSBkZWZhdWx0IHZhbHVlIGZvciBhbGwgZW51bXNcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3dpdGNoLWV4aGF1c3RpdmVuZXNzLWNoZWNrXG4gICAgc3dpdGNoICh0eXBlb2YganNvbikge1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihqc29uKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBqc29uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdHlwZS5maW5kTmFtZShqc29uKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcHJlZmVyLW51bGxpc2gtY29hbGVzY2luZ1xuICAgICAgICAgICAgaWYgKHZhbHVlIHx8IGlnbm9yZVVua25vd25GaWVsZHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbHVlLm5vO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IGRlY29kZSBlbnVtICR7dHlwZS50eXBlTmFtZX0gZnJvbSBKU09OOiAke2RlYnVnSnNvblZhbHVlKGpzb24pfWApO1xufVxuZnVuY3Rpb24gd3JpdGVFbnVtKHR5cGUsIHZhbHVlLCBlbWl0SW50cmluc2ljRGVmYXVsdCwgZW51bUFzSW50ZWdlcikge1xuICAgIHZhciBfYTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gMCAmJiAhZW1pdEludHJpbnNpY0RlZmF1bHQpIHtcbiAgICAgICAgLy8gcHJvdG8zIHJlcXVpcmVzIDAgdG8gYmUgZGVmYXVsdCB2YWx1ZSBmb3IgYWxsIGVudW1zXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChlbnVtQXNJbnRlZ2VyKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGUudHlwZU5hbWUgPT0gXCJnb29nbGUucHJvdG9idWYuTnVsbFZhbHVlXCIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHZhbCA9IHR5cGUuZmluZE51bWJlcih2YWx1ZSk7XG4gICAgcmV0dXJuIChfYSA9IHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbC5uYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB2YWx1ZTsgLy8gaWYgd2UgZG9uJ3Qga25vdyB0aGUgZW51bSB2YWx1ZSwganVzdCByZXR1cm4gdGhlIG51bWJlclxufVxuZnVuY3Rpb24gd3JpdGVTY2FsYXIodHlwZSwgdmFsdWUsIGVtaXRJbnRyaW5zaWNEZWZhdWx0KSB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIC8vIGludDMyLCBmaXhlZDMyLCB1aW50MzI6IEpTT04gdmFsdWUgd2lsbCBiZSBhIGRlY2ltYWwgbnVtYmVyLiBFaXRoZXIgbnVtYmVycyBvciBzdHJpbmdzIGFyZSBhY2NlcHRlZC5cbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLklOVDMyOlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVEMzI6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UMzI6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDMyOlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDMyOlxuICAgICAgICAgICAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PSBcIm51bWJlclwiKTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPSAwIHx8IGVtaXRJbnRyaW5zaWNEZWZhdWx0ID8gdmFsdWUgOiB1bmRlZmluZWQ7XG4gICAgICAgIC8vIGZsb2F0LCBkb3VibGU6IEpTT04gdmFsdWUgd2lsbCBiZSBhIG51bWJlciBvciBvbmUgb2YgdGhlIHNwZWNpYWwgc3RyaW5nIHZhbHVlcyBcIk5hTlwiLCBcIkluZmluaXR5XCIsIGFuZCBcIi1JbmZpbml0eVwiLlxuICAgICAgICAvLyBFaXRoZXIgbnVtYmVycyBvciBzdHJpbmdzIGFyZSBhY2NlcHRlZC4gRXhwb25lbnQgbm90YXRpb24gaXMgYWxzbyBhY2NlcHRlZC5cbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkZMT0FUOlxuICAgICAgICAvLyBhc3NlcnRGbG9hdDMyKHZhbHVlKTtcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkRPVUJMRTogLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgICAgICAgICAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PSBcIm51bWJlclwiKTtcbiAgICAgICAgICAgIGlmIChOdW1iZXIuaXNOYU4odmFsdWUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBcIk5hTlwiO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiSW5maW5pdHlcIjtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKVxuICAgICAgICAgICAgICAgIHJldHVybiBcIi1JbmZpbml0eVwiO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9PSAwIHx8IGVtaXRJbnRyaW5zaWNEZWZhdWx0ID8gdmFsdWUgOiB1bmRlZmluZWQ7XG4gICAgICAgIC8vIHN0cmluZzpcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNUUklORzpcbiAgICAgICAgICAgIGFzc2VydCh0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIik7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUubGVuZ3RoID4gMCB8fCBlbWl0SW50cmluc2ljRGVmYXVsdCA/IHZhbHVlIDogdW5kZWZpbmVkO1xuICAgICAgICAvLyBib29sOlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuQk9PTDpcbiAgICAgICAgICAgIGFzc2VydCh0eXBlb2YgdmFsdWUgPT0gXCJib29sZWFuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlIHx8IGVtaXRJbnRyaW5zaWNEZWZhdWx0ID8gdmFsdWUgOiB1bmRlZmluZWQ7XG4gICAgICAgIC8vIEpTT04gdmFsdWUgd2lsbCBiZSBhIGRlY2ltYWwgc3RyaW5nLiBFaXRoZXIgbnVtYmVycyBvciBzdHJpbmdzIGFyZSBhY2NlcHRlZC5cbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQ2NDpcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVENjQ6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQ2NDpcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDY0OlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0lOVDY0OlxuICAgICAgICAgICAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PSBcImJpZ2ludFwiIHx8XG4gICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIgfHxcbiAgICAgICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIik7XG4gICAgICAgICAgICAvLyBXZSB1c2UgaW1wbGljaXQgY29udmVyc2lvbiB3aXRoIGB2YWx1ZSAhPSAwYCB0byBjYXRjaCBib3RoIDBuIGFuZCBcIjBcIlxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgcmV0dXJuIGVtaXRJbnRyaW5zaWNEZWZhdWx0IHx8IHZhbHVlICE9IDBcbiAgICAgICAgICAgICAgICA/IHZhbHVlLnRvU3RyaW5nKDEwKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAvLyBieXRlczogSlNPTiB2YWx1ZSB3aWxsIGJlIHRoZSBkYXRhIGVuY29kZWQgYXMgYSBzdHJpbmcgdXNpbmcgc3RhbmRhcmQgYmFzZTY0IGVuY29kaW5nIHdpdGggcGFkZGluZ3MuXG4gICAgICAgIC8vIEVpdGhlciBzdGFuZGFyZCBvciBVUkwtc2FmZSBiYXNlNjQgZW5jb2Rpbmcgd2l0aC93aXRob3V0IHBhZGRpbmdzIGFyZSBhY2NlcHRlZC5cbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkJZVEVTOlxuICAgICAgICAgICAgYXNzZXJ0KHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSk7XG4gICAgICAgICAgICByZXR1cm4gZW1pdEludHJpbnNpY0RlZmF1bHQgfHwgdmFsdWUuYnl0ZUxlbmd0aCA+IDBcbiAgICAgICAgICAgICAgICA/IHByb3RvQmFzZTY0LmVuYyh2YWx1ZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgMjAyMS0yMDIzIEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuaW1wb3J0IHsgd3JhcEZpZWxkIH0gZnJvbSBcIi4vZmllbGQtd3JhcHBlci5qc1wiO1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSBcIi4vYXNzZXJ0LmpzXCI7XG5pbXBvcnQgeyBtYWtlSnNvbkZvcm1hdENvbW1vbiB9IGZyb20gXCIuL2pzb24tZm9ybWF0LWNvbW1vbi5qc1wiO1xuLyogZXNsaW50LWRpc2FibGUgbm8tY2FzZS1kZWNsYXJhdGlvbnMsIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC1wbHVzLW9wZXJhbmRzLEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnksQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm4sQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50LEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtY2FsbCxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudCAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VKc29uRm9ybWF0UHJvdG8zKCkge1xuICAgIHJldHVybiBtYWtlSnNvbkZvcm1hdENvbW1vbigod3JpdGVFbnVtLCB3cml0ZVNjYWxhcikgPT4ge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gd3JpdGVGaWVsZChmaWVsZCwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChmaWVsZC5raW5kID09IFwibWFwXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBqc29uT2JqID0ge307XG4gICAgICAgICAgICAgICAgc3dpdGNoIChmaWVsZC5WLmtpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBbZW50cnlLZXksIGVudHJ5VmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IHdyaXRlU2NhbGFyKGZpZWxkLlYuVCwgZW50cnlWYWx1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KHZhbCAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uT2JqW2VudHJ5S2V5LnRvU3RyaW5nKCldID0gdmFsOyAvLyBKU09OIHN0YW5kYXJkIGFsbG93cyBvbmx5IChkb3VibGUgcXVvdGVkKSBzdHJpbmcgYXMgcHJvcGVydHkga2V5XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2VudHJ5S2V5LCBlbnRyeVZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBKU09OIHN0YW5kYXJkIGFsbG93cyBvbmx5IChkb3VibGUgcXVvdGVkKSBzdHJpbmcgYXMgcHJvcGVydHkga2V5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbk9ialtlbnRyeUtleS50b1N0cmluZygpXSA9IGVudHJ5VmFsdWUudG9Kc29uKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbnVtVHlwZSA9IGZpZWxkLlYuVDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2VudHJ5S2V5LCBlbnRyeVZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQoZW50cnlWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBlbnRyeVZhbHVlID09IFwibnVtYmVyXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IHdyaXRlRW51bShlbnVtVHlwZSwgZW50cnlWYWx1ZSwgdHJ1ZSwgb3B0aW9ucy5lbnVtQXNJbnRlZ2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQodmFsICE9PSB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb25PYmpbZW50cnlLZXkudG9TdHJpbmcoKV0gPSB2YWw7IC8vIEpTT04gc3RhbmRhcmQgYWxsb3dzIG9ubHkgKGRvdWJsZSBxdW90ZWQpIHN0cmluZyBhcyBwcm9wZXJ0eSBrZXlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5lbWl0RGVmYXVsdFZhbHVlcyB8fCBPYmplY3Qua2V5cyhqc29uT2JqKS5sZW5ndGggPiAwXG4gICAgICAgICAgICAgICAgICAgID8ganNvbk9ialxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkLnJlcGVhdGVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QganNvbkFyciA9IFtdO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZmllbGQua2luZCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbkFyci5wdXNoKHdyaXRlU2NhbGFyKGZpZWxkLlQsIHZhbHVlW2ldLCB0cnVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uQXJyLnB1c2god3JpdGVFbnVtKGZpZWxkLlQsIHZhbHVlW2ldLCB0cnVlLCBvcHRpb25zLmVudW1Bc0ludGVnZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb25BcnIucHVzaCh3cmFwRmllbGQoZmllbGQuVCwgdmFsdWVbaV0pLnRvSnNvbihvcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuZW1pdERlZmF1bHRWYWx1ZXMgfHwganNvbkFyci5sZW5ndGggPiAwXG4gICAgICAgICAgICAgICAgICAgID8ganNvbkFyclxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZmllbGQua2luZCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd3JpdGVTY2FsYXIoZmllbGQuVCwgdmFsdWUsICEhZmllbGQub25lb2YgfHwgZmllbGQub3B0IHx8IG9wdGlvbnMuZW1pdERlZmF1bHRWYWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdyaXRlRW51bShmaWVsZC5ULCB2YWx1ZSwgISFmaWVsZC5vbmVvZiB8fCBmaWVsZC5vcHQgfHwgb3B0aW9ucy5lbWl0RGVmYXVsdFZhbHVlcywgb3B0aW9ucy5lbnVtQXNJbnRlZ2VyKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB3cmFwRmllbGQoZmllbGQuVCwgdmFsdWUpLnRvSnNvbihvcHRpb25zKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcbn1cbiIsIi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5pbXBvcnQgeyBzZXRFbnVtVHlwZSB9IGZyb20gXCIuL2VudW0uanNcIjtcbmltcG9ydCB7IE1lc3NhZ2UgfSBmcm9tIFwiLi4vbWVzc2FnZS5qc1wiO1xuaW1wb3J0IHsgU2NhbGFyVHlwZSB9IGZyb20gXCIuLi9maWVsZC5qc1wiO1xuaW1wb3J0IHsgc2NhbGFyRXF1YWxzIH0gZnJvbSBcIi4vc2NhbGFycy5qc1wiO1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzLEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuLEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnQsbm8tY2FzZS1kZWNsYXJhdGlvbnMgKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlVXRpbENvbW1vbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzZXRFbnVtVHlwZSxcbiAgICAgICAgaW5pdFBhcnRpYWwoc291cmNlLCB0YXJnZXQpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSB0YXJnZXQuZ2V0VHlwZSgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBtZW1iZXIgb2YgdHlwZS5maWVsZHMuYnlNZW1iZXIoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsTmFtZSA9IG1lbWJlci5sb2NhbE5hbWUsIHQgPSB0YXJnZXQsIHMgPSBzb3VyY2U7XG4gICAgICAgICAgICAgICAgaWYgKHNbbG9jYWxOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG1lbWJlci5raW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJvbmVvZlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2sgPSBzW2xvY2FsTmFtZV0uY2FzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2VGaWVsZCA9IG1lbWJlci5maW5kRmllbGQoc2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbCA9IHNbbG9jYWxOYW1lXS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2VGaWVsZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUZpZWxkLmtpbmQgPT0gXCJtZXNzYWdlXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhKHZhbCBpbnN0YW5jZW9mIHNvdXJjZUZpZWxkLlQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gbmV3IHNvdXJjZUZpZWxkLlQodmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNvdXJjZUZpZWxkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlRmllbGQua2luZCA9PT0gXCJzY2FsYXJcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUZpZWxkLlQgPT09IFNjYWxhclR5cGUuQllURVMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSB0b1U4QXJyKHZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0W2xvY2FsTmFtZV0gPSB7IGNhc2U6IHNrLCB2YWx1ZTogdmFsIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvcHkgPSBzW2xvY2FsTmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVtYmVyLlQgPT09IFNjYWxhclR5cGUuQllURVMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5ID0gbWVtYmVyLnJlcGVhdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gY29weS5tYXAodG9VOEFycilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0b1U4QXJyKGNvcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdFtsb2NhbE5hbWVdID0gY29weTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWFwXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG1lbWJlci5WLmtpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lbWJlci5WLlQgPT09IFNjYWxhclR5cGUuQllURVMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKHNbbG9jYWxOYW1lXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0W2xvY2FsTmFtZV1ba10gPSB0b1U4QXJyKHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0W2xvY2FsTmFtZV0sIHNbbG9jYWxOYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZVR5cGUgPSBtZW1iZXIuVi5UO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGsgb2YgT2JqZWN0LmtleXMoc1tsb2NhbE5hbWVdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbCA9IHNbbG9jYWxOYW1lXVtrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWVzc2FnZVR5cGUuZmllbGRXcmFwcGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2Ugb25seSB0YWtlIHBhcnRpYWwgaW5wdXQgZm9yIG1lc3NhZ2VzIHRoYXQgYXJlIG5vdCBhIHdyYXBwZXIgdHlwZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGb3IgdGhvc2UgbWVzc2FnZXMsIHdlIHJlY3Vyc2l2ZWx5IG5vcm1hbGl6ZSB0aGUgcGFydGlhbCBpbnB1dC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBuZXcgbWVzc2FnZVR5cGUodmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRbbG9jYWxOYW1lXVtrXSA9IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbXQgPSBtZW1iZXIuVDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZW1iZXIucmVwZWF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0W2xvY2FsTmFtZV0gPSBzW2xvY2FsTmFtZV0ubWFwKCh2YWwpID0+IHZhbCBpbnN0YW5jZW9mIG10ID8gdmFsIDogbmV3IG10KHZhbCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc1tsb2NhbE5hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSBzW2xvY2FsTmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG10LmZpZWxkV3JhcHBlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGNhbid0IHVzZSBCeXRlc1ZhbHVlLnR5cGVOYW1lIGFzIHRoYXQgd2lsbCBjcmVhdGUgYSBjaXJjdWxhciBpbXBvcnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXQudHlwZU5hbWUgPT09IFwiZ29vZ2xlLnByb3RvYnVmLkJ5dGVzVmFsdWVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdFtsb2NhbE5hbWVdID0gdG9VOEFycih2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdFtsb2NhbE5hbWVdID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0W2xvY2FsTmFtZV0gPSB2YWwgaW5zdGFuY2VvZiBtdCA/IHZhbCA6IG5ldyBtdCh2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZXF1YWxzKHR5cGUsIGEsIGIpIHtcbiAgICAgICAgICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWEgfHwgIWIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHlwZS5maWVsZHMuYnlNZW1iZXIoKS5ldmVyeSgobSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhID0gYVttLmxvY2FsTmFtZV07XG4gICAgICAgICAgICAgICAgY29uc3QgdmIgPSBiW20ubG9jYWxOYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAobS5yZXBlYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmEubGVuZ3RoICE9PSB2Yi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N3aXRjaC1leGhhdXN0aXZlbmVzcy1jaGVjayAtLSByZXBlYXRlZCBmaWVsZHMgYXJlIG5ldmVyIFwibWFwXCJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChtLmtpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhLmV2ZXJ5KChhLCBpKSA9PiBtLlQuZXF1YWxzKGEsIHZiW2ldKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhLmV2ZXJ5KChhLCBpKSA9PiBzY2FsYXJFcXVhbHMobS5ULCBhLCB2YltpXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmEuZXZlcnkoKGEsIGkpID0+IHNjYWxhckVxdWFscyhTY2FsYXJUeXBlLklOVDMyLCBhLCB2YltpXSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcmVwZWF0ZWQgY2Fubm90IGNvbnRhaW4gJHttLmtpbmR9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN3aXRjaCAobS5raW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbS5ULmVxdWFscyh2YSwgdmIpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjYWxhckVxdWFscyhTY2FsYXJUeXBlLklOVDMyLCB2YSwgdmIpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NhbGFyRXF1YWxzKG0uVCwgdmEsIHZiKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm9uZW9mXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmEuY2FzZSAhPT0gdmIuY2FzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBtLmZpbmRGaWVsZCh2YS5jYXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3dpdGNoLWV4aGF1c3RpdmVuZXNzLWNoZWNrIC0tIG9uZW9mIGZpZWxkcyBhcmUgbmV2ZXIgXCJtYXBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzLmtpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcy5ULmVxdWFscyh2YS52YWx1ZSwgdmIudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzY2FsYXJFcXVhbHMoU2NhbGFyVHlwZS5JTlQzMiwgdmEudmFsdWUsIHZiLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzY2FsYXJFcXVhbHMocy5ULCB2YS52YWx1ZSwgdmIudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBvbmVvZiBjYW5ub3QgY29udGFpbiAke3Mua2luZH1gKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1hcFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHZhKS5jb25jYXQoT2JqZWN0LmtleXModmIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobS5WLmtpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlVHlwZSA9IG0uVi5UO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5cy5ldmVyeSgoaykgPT4gbWVzc2FnZVR5cGUuZXF1YWxzKHZhW2tdLCB2YltrXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXlzLmV2ZXJ5KChrKSA9PiBzY2FsYXJFcXVhbHMoU2NhbGFyVHlwZS5JTlQzMiwgdmFba10sIHZiW2tdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzY2FsYXJUeXBlID0gbS5WLlQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXlzLmV2ZXJ5KChrKSA9PiBzY2FsYXJFcXVhbHMoc2NhbGFyVHlwZSwgdmFba10sIHZiW2tdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xvbmUobWVzc2FnZSkge1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IG1lc3NhZ2UuZ2V0VHlwZSgpLCB0YXJnZXQgPSBuZXcgdHlwZSgpLCBhbnkgPSB0YXJnZXQ7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG1lbWJlciBvZiB0eXBlLmZpZWxkcy5ieU1lbWJlcigpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc291cmNlID0gbWVzc2FnZVttZW1iZXIubG9jYWxOYW1lXTtcbiAgICAgICAgICAgICAgICBsZXQgY29weTtcbiAgICAgICAgICAgICAgICBpZiAobWVtYmVyLnJlcGVhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvcHkgPSBzb3VyY2UubWFwKGNsb25lU2luZ3VsYXJGaWVsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1lbWJlci5raW5kID09IFwibWFwXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29weSA9IGFueVttZW1iZXIubG9jYWxOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2XSBvZiBPYmplY3QuZW50cmllcyhzb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3B5W2tleV0gPSBjbG9uZVNpbmd1bGFyRmllbGQodik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWVtYmVyLmtpbmQgPT0gXCJvbmVvZlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGYgPSBtZW1iZXIuZmluZEZpZWxkKHNvdXJjZS5jYXNlKTtcbiAgICAgICAgICAgICAgICAgICAgY29weSA9IGZcbiAgICAgICAgICAgICAgICAgICAgICAgID8geyBjYXNlOiBzb3VyY2UuY2FzZSwgdmFsdWU6IGNsb25lU2luZ3VsYXJGaWVsZChzb3VyY2UudmFsdWUpIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogeyBjYXNlOiB1bmRlZmluZWQgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvcHkgPSBjbG9uZVNpbmd1bGFyRmllbGQoc291cmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYW55W21lbWJlci5sb2NhbE5hbWVdID0gY29weTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8vIGNsb25lIGEgc2luZ2xlIGZpZWxkIHZhbHVlIC0gaS5lLiB0aGUgZWxlbWVudCB0eXBlIG9mIHJlcGVhdGVkIGZpZWxkcywgdGhlIHZhbHVlIHR5cGUgb2YgbWFwc1xuZnVuY3Rpb24gY2xvbmVTaW5ndWxhckZpZWxkKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBNZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5jbG9uZSgpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIGNvbnN0IGMgPSBuZXcgVWludDhBcnJheSh2YWx1ZS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgYy5zZXQodmFsdWUpO1xuICAgICAgICByZXR1cm4gYztcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuLy8gY29udmVydHMgYW55IEFycmF5TGlrZTxudW1iZXI+IHRvIFVpbnQ4QXJyYXkgaWYgbmVjZXNzYXJ5LlxuZnVuY3Rpb24gdG9VOEFycihpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyBpbnB1dCA6IG5ldyBVaW50OEFycmF5KGlucHV0KTtcbn1cbiIsIi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5leHBvcnQgY2xhc3MgSW50ZXJuYWxGaWVsZExpc3Qge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcywgbm9ybWFsaXplcikge1xuICAgICAgICB0aGlzLl9maWVsZHMgPSBmaWVsZHM7XG4gICAgICAgIHRoaXMuX25vcm1hbGl6ZXIgPSBub3JtYWxpemVyO1xuICAgIH1cbiAgICBmaW5kSnNvbk5hbWUoanNvbk5hbWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmpzb25OYW1lcykge1xuICAgICAgICAgICAgY29uc3QgdCA9IHt9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBmIG9mIHRoaXMubGlzdCgpKSB7XG4gICAgICAgICAgICAgICAgdFtmLmpzb25OYW1lXSA9IHRbZi5uYW1lXSA9IGY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmpzb25OYW1lcyA9IHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuanNvbk5hbWVzW2pzb25OYW1lXTtcbiAgICB9XG4gICAgZmluZChmaWVsZE5vKSB7XG4gICAgICAgIGlmICghdGhpcy5udW1iZXJzKSB7XG4gICAgICAgICAgICBjb25zdCB0ID0ge307XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGYgb2YgdGhpcy5saXN0KCkpIHtcbiAgICAgICAgICAgICAgICB0W2Yubm9dID0gZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubnVtYmVycyA9IHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubnVtYmVyc1tmaWVsZE5vXTtcbiAgICB9XG4gICAgbGlzdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFsbCkge1xuICAgICAgICAgICAgdGhpcy5hbGwgPSB0aGlzLl9ub3JtYWxpemVyKHRoaXMuX2ZpZWxkcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYWxsO1xuICAgIH1cbiAgICBieU51bWJlcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLm51bWJlcnNBc2MpIHtcbiAgICAgICAgICAgIHRoaXMubnVtYmVyc0FzYyA9IHRoaXMubGlzdCgpXG4gICAgICAgICAgICAgICAgLmNvbmNhdCgpXG4gICAgICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGEubm8gLSBiLm5vKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5udW1iZXJzQXNjO1xuICAgIH1cbiAgICBieU1lbWJlcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1lbWJlcnMpIHtcbiAgICAgICAgICAgIHRoaXMubWVtYmVycyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgYSA9IHRoaXMubWVtYmVycztcbiAgICAgICAgICAgIGxldCBvO1xuICAgICAgICAgICAgZm9yIChjb25zdCBmIG9mIHRoaXMubGlzdCgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGYub25lb2YpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGYub25lb2YgIT09IG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG8gPSBmLm9uZW9mO1xuICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKG8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhLnB1c2goZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm1lbWJlcnM7XG4gICAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogUmV0dXJucyB0aGUgbmFtZSBvZiBhIHByb3RvYnVmIGVsZW1lbnQgaW4gZ2VuZXJhdGVkIGNvZGUuXG4gKlxuICogRmllbGQgbmFtZXMgLSBpbmNsdWRpbmcgb25lb2ZzIC0gYXJlIGNvbnZlcnRlZCB0byBsb3dlckNhbWVsQ2FzZS4gRm9yXG4gKiBtZXNzYWdlcywgZW51bWVyYXRpb25zIGFuZCBzZXJ2aWNlcywgdGhlIHBhY2thZ2UgbmFtZSBpcyBzdHJpcHBlZCBmcm9tXG4gKiB0aGUgdHlwZSBuYW1lLiBGb3IgbmVzdGVkIG1lc3NhZ2VzIGFuZCBlbnVtZXJhdGlvbnMsIHRoZSBuYW1lcyBhcmUgam9pbmVkXG4gKiB3aXRoIGFuIHVuZGVyc2NvcmUuIEZvciBtZXRob2RzLCB0aGUgZmlyc3QgY2hhcmFjdGVyIGlzIG1hZGUgbG93ZXJjYXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbG9jYWxOYW1lKGRlc2MpIHtcbiAgICBzd2l0Y2ggKGRlc2Mua2luZCkge1xuICAgICAgICBjYXNlIFwiZmllbGRcIjpcbiAgICAgICAgICAgIHJldHVybiBsb2NhbEZpZWxkTmFtZShkZXNjLm5hbWUsIGRlc2Mub25lb2YgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgIGNhc2UgXCJvbmVvZlwiOlxuICAgICAgICAgICAgcmV0dXJuIGxvY2FsT25lb2ZOYW1lKGRlc2MubmFtZSk7XG4gICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgIGNhc2UgXCJzZXJ2aWNlXCI6IHtcbiAgICAgICAgICAgIGNvbnN0IHBrZyA9IGRlc2MuZmlsZS5wcm90by5wYWNrYWdlO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gcGtnID09PSB1bmRlZmluZWQgPyAwIDogcGtnLmxlbmd0aCArIDE7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gZGVzYy50eXBlTmFtZS5zdWJzdHJpbmcob2Zmc2V0KS5yZXBsYWNlKC9cXC4vZywgXCJfXCIpO1xuICAgICAgICAgICAgLy8gRm9yIHNlcnZpY2VzLCB3ZSBvbmx5IGNhcmUgYWJvdXQgc2FmZSBpZGVudGlmaWVycywgbm90IHNhZmUgb2JqZWN0IHByb3BlcnRpZXMsXG4gICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBzaGlwcGVkIHYxIHdpdGggYSBidWcgdGhhdCByZXNwZWN0ZWQgb2JqZWN0IHByb3BlcnRpZXMsIGFuZCB3ZVxuICAgICAgICAgICAgLy8gZG8gbm90IHdhbnQgdG8gaW50cm9kdWNlIGEgYnJlYWtpbmcgY2hhbmdlLCBzbyB3ZSBjb250aW51ZSB0byBlc2NhcGUgZm9yXG4gICAgICAgICAgICAvLyBzYWZlIG9iamVjdCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9idWZidWlsZC9wcm90b2J1Zi1lcy9wdWxsLzM5MVxuICAgICAgICAgICAgcmV0dXJuIHNhZmVPYmplY3RQcm9wZXJ0eShzYWZlSWRlbnRpZmllcihuYW1lKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImVudW1fdmFsdWVcIjoge1xuICAgICAgICAgICAgY29uc3Qgc2hhcmVkUHJlZml4ID0gZGVzYy5wYXJlbnQuc2hhcmVkUHJlZml4O1xuICAgICAgICAgICAgaWYgKHNoYXJlZFByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlc2MubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBkZXNjLm5hbWUuc3Vic3RyaW5nKHNoYXJlZFByZWZpeC5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIHNhZmVPYmplY3RQcm9wZXJ0eShuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwicnBjXCI6IHtcbiAgICAgICAgICAgIGxldCBuYW1lID0gZGVzYy5uYW1lO1xuICAgICAgICAgICAgaWYgKG5hbWUubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5hbWUgPSBuYW1lWzBdLnRvTG93ZXJDYXNlKCkgKyBuYW1lLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgIHJldHVybiBzYWZlT2JqZWN0UHJvcGVydHkobmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIFJldHVybnMgdGhlIG5hbWUgb2YgYSBmaWVsZCBpbiBnZW5lcmF0ZWQgY29kZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxvY2FsRmllbGROYW1lKHByb3RvTmFtZSwgaW5PbmVvZikge1xuICAgIGNvbnN0IG5hbWUgPSBwcm90b0NhbWVsQ2FzZShwcm90b05hbWUpO1xuICAgIGlmIChpbk9uZW9mKSB7XG4gICAgICAgIC8vIG9uZW9mIG1lbWJlciBuYW1lcyBhcmUgbm90IHByb3BlcnRpZXMsIGJ1dCB2YWx1ZXMgb2YgdGhlIGBjYXNlYCBwcm9wZXJ0eS5cbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICAgIHJldHVybiBzYWZlT2JqZWN0UHJvcGVydHkoc2FmZU1lc3NhZ2VQcm9wZXJ0eShuYW1lKSk7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIG5hbWUgb2YgYSBvbmVvZiBncm91cCBpbiBnZW5lcmF0ZWQgY29kZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxvY2FsT25lb2ZOYW1lKHByb3RvTmFtZSkge1xuICAgIHJldHVybiBsb2NhbEZpZWxkTmFtZShwcm90b05hbWUsIGZhbHNlKTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgSlNPTiBuYW1lIGZvciBhIHByb3RvYnVmIGZpZWxkLCBleGFjdGx5IGxpa2UgcHJvdG9jIGRvZXMuXG4gKi9cbmV4cG9ydCBjb25zdCBmaWVsZEpzb25OYW1lID0gcHJvdG9DYW1lbENhc2U7XG4vKipcbiAqIEZpbmRzIGEgcHJlZml4IHNoYXJlZCBieSBlbnVtIHZhbHVlcywgZm9yIGV4YW1wbGUgYE1ZX0VOVU1fYCBmb3JcbiAqIGBlbnVtIE15RW51bSB7TVlfRU5VTV9BPTA7IE1ZX0VOVU1fQj0xO31gLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZEVudW1TaGFyZWRQcmVmaXgoZW51bU5hbWUsIHZhbHVlTmFtZXMpIHtcbiAgICBjb25zdCBwcmVmaXggPSBjYW1lbFRvU25ha2VDYXNlKGVudW1OYW1lKSArIFwiX1wiO1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiB2YWx1ZU5hbWVzKSB7XG4gICAgICAgIGlmICghbmFtZS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgocHJlZml4KSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaG9ydE5hbWUgPSBuYW1lLnN1YnN0cmluZyhwcmVmaXgubGVuZ3RoKTtcbiAgICAgICAgaWYgKHNob3J0TmFtZS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoL15cXGQvLnRlc3Qoc2hvcnROYW1lKSkge1xuICAgICAgICAgICAgLy8gaWRlbnRpZmllcnMgbXVzdCBub3Qgc3RhcnQgd2l0aCBudW1iZXJzXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcmVmaXg7XG59XG4vKipcbiAqIENvbnZlcnRzIGxvd2VyQ2FtZWxDYXNlIG9yIFVwcGVyQ2FtZWxDYXNlIGludG8gbG93ZXJfc25ha2VfY2FzZS5cbiAqIFRoaXMgaXMgdXNlZCB0byBmaW5kIHNoYXJlZCBwcmVmaXhlcyBpbiBhbiBlbnVtLlxuICovXG5mdW5jdGlvbiBjYW1lbFRvU25ha2VDYXNlKGNhbWVsKSB7XG4gICAgcmV0dXJuIChjYW1lbC5zdWJzdHJpbmcoMCwgMSkgKyBjYW1lbC5zdWJzdHJpbmcoMSkucmVwbGFjZSgvW0EtWl0vZywgKGMpID0+IFwiX1wiICsgYykpLnRvTG93ZXJDYXNlKCk7XG59XG4vKipcbiAqIENvbnZlcnRzIHNuYWtlX2Nhc2UgdG8gcHJvdG9DYW1lbENhc2UgYWNjb3JkaW5nIHRvIHRoZSBjb252ZW50aW9uXG4gKiB1c2VkIGJ5IHByb3RvYyB0byBjb252ZXJ0IGEgZmllbGQgbmFtZSB0byBhIEpTT04gbmFtZS5cbiAqL1xuZnVuY3Rpb24gcHJvdG9DYW1lbENhc2Uoc25ha2VDYXNlKSB7XG4gICAgbGV0IGNhcE5leHQgPSBmYWxzZTtcbiAgICBjb25zdCBiID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbmFrZUNhc2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGMgPSBzbmFrZUNhc2UuY2hhckF0KGkpO1xuICAgICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgICAgIGNhc2UgXCJfXCI6XG4gICAgICAgICAgICAgICAgY2FwTmV4dCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiMFwiOlxuICAgICAgICAgICAgY2FzZSBcIjFcIjpcbiAgICAgICAgICAgIGNhc2UgXCIyXCI6XG4gICAgICAgICAgICBjYXNlIFwiM1wiOlxuICAgICAgICAgICAgY2FzZSBcIjRcIjpcbiAgICAgICAgICAgIGNhc2UgXCI1XCI6XG4gICAgICAgICAgICBjYXNlIFwiNlwiOlxuICAgICAgICAgICAgY2FzZSBcIjdcIjpcbiAgICAgICAgICAgIGNhc2UgXCI4XCI6XG4gICAgICAgICAgICBjYXNlIFwiOVwiOlxuICAgICAgICAgICAgICAgIGIucHVzaChjKTtcbiAgICAgICAgICAgICAgICBjYXBOZXh0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmIChjYXBOZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhcE5leHQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYyA9IGMudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYi5wdXNoKGMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBiLmpvaW4oXCJcIik7XG59XG4vKipcbiAqIE5hbWVzIHRoYXQgY2Fubm90IGJlIHVzZWQgZm9yIGlkZW50aWZpZXJzLCBzdWNoIGFzIGNsYXNzIG5hbWVzLFxuICogYnV0IF9jYW5fIGJlIHVzZWQgZm9yIG9iamVjdCBwcm9wZXJ0aWVzLlxuICovXG5jb25zdCByZXNlcnZlZElkZW50aWZpZXJzID0gbmV3IFNldChbXG4gICAgLy8gRUNNQVNjcmlwdCAyMDE1IGtleXdvcmRzXG4gICAgXCJicmVha1wiLFxuICAgIFwiY2FzZVwiLFxuICAgIFwiY2F0Y2hcIixcbiAgICBcImNsYXNzXCIsXG4gICAgXCJjb25zdFwiLFxuICAgIFwiY29udGludWVcIixcbiAgICBcImRlYnVnZ2VyXCIsXG4gICAgXCJkZWZhdWx0XCIsXG4gICAgXCJkZWxldGVcIixcbiAgICBcImRvXCIsXG4gICAgXCJlbHNlXCIsXG4gICAgXCJleHBvcnRcIixcbiAgICBcImV4dGVuZHNcIixcbiAgICBcImZhbHNlXCIsXG4gICAgXCJmaW5hbGx5XCIsXG4gICAgXCJmb3JcIixcbiAgICBcImZ1bmN0aW9uXCIsXG4gICAgXCJpZlwiLFxuICAgIFwiaW1wb3J0XCIsXG4gICAgXCJpblwiLFxuICAgIFwiaW5zdGFuY2VvZlwiLFxuICAgIFwibmV3XCIsXG4gICAgXCJudWxsXCIsXG4gICAgXCJyZXR1cm5cIixcbiAgICBcInN1cGVyXCIsXG4gICAgXCJzd2l0Y2hcIixcbiAgICBcInRoaXNcIixcbiAgICBcInRocm93XCIsXG4gICAgXCJ0cnVlXCIsXG4gICAgXCJ0cnlcIixcbiAgICBcInR5cGVvZlwiLFxuICAgIFwidmFyXCIsXG4gICAgXCJ2b2lkXCIsXG4gICAgXCJ3aGlsZVwiLFxuICAgIFwid2l0aFwiLFxuICAgIFwieWllbGRcIixcbiAgICAvLyBFQ01BU2NyaXB0IDIwMTUgZnV0dXJlIHJlc2VydmVkIGtleXdvcmRzXG4gICAgXCJlbnVtXCIsXG4gICAgXCJpbXBsZW1lbnRzXCIsXG4gICAgXCJpbnRlcmZhY2VcIixcbiAgICBcImxldFwiLFxuICAgIFwicGFja2FnZVwiLFxuICAgIFwicHJpdmF0ZVwiLFxuICAgIFwicHJvdGVjdGVkXCIsXG4gICAgXCJwdWJsaWNcIixcbiAgICBcInN0YXRpY1wiLFxuICAgIC8vIENsYXNzIG5hbWUgY2Fubm90IGJlICdPYmplY3QnIHdoZW4gdGFyZ2V0aW5nIEVTNSB3aXRoIG1vZHVsZSBDb21tb25KU1xuICAgIFwiT2JqZWN0XCIsXG4gICAgLy8gVHlwZVNjcmlwdCBrZXl3b3JkcyB0aGF0IGNhbm5vdCBiZSB1c2VkIGZvciB0eXBlcyAoYXMgb3Bwb3NlZCB0byB2YXJpYWJsZXMpXG4gICAgXCJiaWdpbnRcIixcbiAgICBcIm51bWJlclwiLFxuICAgIFwiYm9vbGVhblwiLFxuICAgIFwic3RyaW5nXCIsXG4gICAgXCJvYmplY3RcIixcbiAgICAvLyBJZGVudGlmaWVycyByZXNlcnZlZCBmb3IgdGhlIHJ1bnRpbWUsIHNvIHdlIGNhbiBnZW5lcmF0ZSBsZWdpYmxlIGNvZGVcbiAgICBcImdsb2JhbFRoaXNcIixcbiAgICBcIlVpbnQ4QXJyYXlcIixcbiAgICBcIlBhcnRpYWxcIixcbl0pO1xuLyoqXG4gKiBOYW1lcyB0aGF0IGNhbm5vdCBiZSB1c2VkIGZvciBvYmplY3QgcHJvcGVydGllcyBiZWNhdXNlIHRoZXkgYXJlIHJlc2VydmVkXG4gKiBieSBidWlsdC1pbiBKYXZhU2NyaXB0IHByb3BlcnRpZXMuXG4gKi9cbmNvbnN0IHJlc2VydmVkT2JqZWN0UHJvcGVydGllcyA9IG5ldyBTZXQoW1xuICAgIC8vIG5hbWVzIHJlc2VydmVkIGJ5IEphdmFTY3JpcHRcbiAgICBcImNvbnN0cnVjdG9yXCIsXG4gICAgXCJ0b1N0cmluZ1wiLFxuICAgIFwidG9KU09OXCIsXG4gICAgXCJ2YWx1ZU9mXCIsXG5dKTtcbi8qKlxuICogTmFtZXMgdGhhdCBjYW5ub3QgYmUgdXNlZCBmb3Igb2JqZWN0IHByb3BlcnRpZXMgYmVjYXVzZSB0aGV5IGFyZSByZXNlcnZlZFxuICogYnkgdGhlIHJ1bnRpbWUuXG4gKi9cbmNvbnN0IHJlc2VydmVkTWVzc2FnZVByb3BlcnRpZXMgPSBuZXcgU2V0KFtcbiAgICAvLyBuYW1lcyByZXNlcnZlZCBieSB0aGUgcnVudGltZVxuICAgIFwiZ2V0VHlwZVwiLFxuICAgIFwiY2xvbmVcIixcbiAgICBcImVxdWFsc1wiLFxuICAgIFwiZnJvbUJpbmFyeVwiLFxuICAgIFwiZnJvbUpzb25cIixcbiAgICBcImZyb21Kc29uU3RyaW5nXCIsXG4gICAgXCJ0b0JpbmFyeVwiLFxuICAgIFwidG9Kc29uXCIsXG4gICAgXCJ0b0pzb25TdHJpbmdcIixcbiAgICAvLyBuYW1lcyByZXNlcnZlZCBieSB0aGUgcnVudGltZSBmb3IgdGhlIGZ1dHVyZVxuICAgIFwidG9PYmplY3RcIixcbl0pO1xuY29uc3QgZmFsbGJhY2sgPSAobmFtZSkgPT4gYCR7bmFtZX0kYDtcbi8qKlxuICogV2lsbCB3cmFwIG5hbWVzIHRoYXQgYXJlIE9iamVjdCBwcm90b3R5cGUgcHJvcGVydGllcyBvciBuYW1lcyByZXNlcnZlZFxuICogZm9yIGBNZXNzYWdlYHMuXG4gKi9cbmNvbnN0IHNhZmVNZXNzYWdlUHJvcGVydHkgPSAobmFtZSkgPT4ge1xuICAgIGlmIChyZXNlcnZlZE1lc3NhZ2VQcm9wZXJ0aWVzLmhhcyhuYW1lKSkge1xuICAgICAgICByZXR1cm4gZmFsbGJhY2sobmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBuYW1lO1xufTtcbi8qKlxuICogTmFtZXMgdGhhdCBjYW5ub3QgYmUgdXNlZCBmb3Igb2JqZWN0IHByb3BlcnRpZXMgYmVjYXVzZSB0aGV5IGFyZSByZXNlcnZlZFxuICogYnkgYnVpbHQtaW4gSmF2YVNjcmlwdCBwcm9wZXJ0aWVzLlxuICovXG5leHBvcnQgY29uc3Qgc2FmZU9iamVjdFByb3BlcnR5ID0gKG5hbWUpID0+IHtcbiAgICBpZiAocmVzZXJ2ZWRPYmplY3RQcm9wZXJ0aWVzLmhhcyhuYW1lKSkge1xuICAgICAgICByZXR1cm4gZmFsbGJhY2sobmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBuYW1lO1xufTtcbi8qKlxuICogTmFtZXMgdGhhdCBjYW4gYmUgdXNlZCBmb3IgaWRlbnRpZmllcnMgb3IgY2xhc3MgcHJvcGVydGllc1xuICovXG5leHBvcnQgY29uc3Qgc2FmZUlkZW50aWZpZXIgPSAobmFtZSkgPT4ge1xuICAgIGlmIChyZXNlcnZlZElkZW50aWZpZXJzLmhhcyhuYW1lKSkge1xuICAgICAgICByZXR1cm4gZmFsbGJhY2sobmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBuYW1lO1xufTtcbiIsIi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5pbXBvcnQgeyBsb2NhbE9uZW9mTmFtZSB9IGZyb20gXCIuL25hbWVzLmpzXCI7XG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tIFwiLi9hc3NlcnQuanNcIjtcbmV4cG9ydCBjbGFzcyBJbnRlcm5hbE9uZW9mSW5mbyB7XG4gICAgY29uc3RydWN0b3IobmFtZSkge1xuICAgICAgICB0aGlzLmtpbmQgPSBcIm9uZW9mXCI7XG4gICAgICAgIHRoaXMucmVwZWF0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wYWNrZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vcHQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZWZhdWx0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmZpZWxkcyA9IFtdO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmxvY2FsTmFtZSA9IGxvY2FsT25lb2ZOYW1lKG5hbWUpO1xuICAgIH1cbiAgICBhZGRGaWVsZChmaWVsZCkge1xuICAgICAgICBhc3NlcnQoZmllbGQub25lb2YgPT09IHRoaXMsIGBmaWVsZCAke2ZpZWxkLm5hbWV9IG5vdCBvbmUgb2YgJHt0aGlzLm5hbWV9YCk7XG4gICAgICAgIHRoaXMuZmllbGRzLnB1c2goZmllbGQpO1xuICAgIH1cbiAgICBmaW5kRmllbGQobG9jYWxOYW1lKSB7XG4gICAgICAgIGlmICghdGhpcy5fbG9va3VwKSB7XG4gICAgICAgICAgICB0aGlzLl9sb29rdXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvb2t1cFt0aGlzLmZpZWxkc1tpXS5sb2NhbE5hbWVdID0gdGhpcy5maWVsZHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvb2t1cFtsb2NhbE5hbWVdO1xuICAgIH1cbn1cbiIsIi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5pbXBvcnQgeyBtYWtlUHJvdG9SdW50aW1lIH0gZnJvbSBcIi4vcHJpdmF0ZS9wcm90by1ydW50aW1lLmpzXCI7XG5pbXBvcnQgeyBtYWtlQmluYXJ5Rm9ybWF0UHJvdG8zIH0gZnJvbSBcIi4vcHJpdmF0ZS9iaW5hcnktZm9ybWF0LXByb3RvMy5qc1wiO1xuaW1wb3J0IHsgbWFrZUpzb25Gb3JtYXRQcm90bzMgfSBmcm9tIFwiLi9wcml2YXRlL2pzb24tZm9ybWF0LXByb3RvMy5qc1wiO1xuaW1wb3J0IHsgbWFrZVV0aWxDb21tb24gfSBmcm9tIFwiLi9wcml2YXRlL3V0aWwtY29tbW9uLmpzXCI7XG5pbXBvcnQgeyBJbnRlcm5hbEZpZWxkTGlzdCB9IGZyb20gXCIuL3ByaXZhdGUvZmllbGQtbGlzdC5qc1wiO1xuaW1wb3J0IHsgc2NhbGFyRGVmYXVsdFZhbHVlIH0gZnJvbSBcIi4vcHJpdmF0ZS9zY2FsYXJzLmpzXCI7XG5pbXBvcnQgeyBMb25nVHlwZSwgU2NhbGFyVHlwZSB9IGZyb20gXCIuL2ZpZWxkLmpzXCI7XG5pbXBvcnQgeyBJbnRlcm5hbE9uZW9mSW5mbyB9IGZyb20gXCIuL3ByaXZhdGUvZmllbGQuanNcIjtcbmltcG9ydCB7IGxvY2FsRmllbGROYW1lLCBmaWVsZEpzb25OYW1lIH0gZnJvbSBcIi4vcHJpdmF0ZS9uYW1lcy5qc1wiO1xuLyoqXG4gKiBQcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBtZXNzYWdlcyBkZWZpbmVkIHdpdGggdGhlIHByb3RvMyBzeW50YXguXG4gKi9cbmV4cG9ydCBjb25zdCBwcm90bzMgPSBtYWtlUHJvdG9SdW50aW1lKFwicHJvdG8zXCIsIG1ha2VKc29uRm9ybWF0UHJvdG8zKCksIG1ha2VCaW5hcnlGb3JtYXRQcm90bzMoKSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtYWtlVXRpbENvbW1vbigpKSwgeyBuZXdGaWVsZExpc3QoZmllbGRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW50ZXJuYWxGaWVsZExpc3QoZmllbGRzLCBub3JtYWxpemVGaWVsZEluZm9zUHJvdG8zKTtcbiAgICB9LFxuICAgIGluaXRGaWVsZHModGFyZ2V0KSB7XG4gICAgICAgIGZvciAoY29uc3QgbWVtYmVyIG9mIHRhcmdldC5nZXRUeXBlKCkuZmllbGRzLmJ5TWVtYmVyKCkpIHtcbiAgICAgICAgICAgIGlmIChtZW1iZXIub3B0KSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gbWVtYmVyLmxvY2FsTmFtZSwgdCA9IHRhcmdldDtcbiAgICAgICAgICAgIGlmIChtZW1iZXIucmVwZWF0ZWQpIHtcbiAgICAgICAgICAgICAgICB0W25hbWVdID0gW107XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKG1lbWJlci5raW5kKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm9uZW9mXCI6XG4gICAgICAgICAgICAgICAgICAgIHRbbmFtZV0gPSB7IGNhc2U6IHVuZGVmaW5lZCB9O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgICAgICB0W25hbWVdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm1hcFwiOlxuICAgICAgICAgICAgICAgICAgICB0W25hbWVdID0ge307XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICAgICAgdFtuYW1lXSA9IHNjYWxhckRlZmF1bHRWYWx1ZShtZW1iZXIuVCwgbWVtYmVyLkwpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgICAgICAvLyBtZXNzYWdlIGZpZWxkcyBhcmUgYWx3YXlzIG9wdGlvbmFsIGluIHByb3RvM1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gfSkpO1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzLEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnQgKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUZpZWxkSW5mb3NQcm90bzMoZmllbGRJbmZvcykge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICBjb25zdCByID0gW107XG4gICAgbGV0IG87XG4gICAgZm9yIChjb25zdCBmaWVsZCBvZiB0eXBlb2YgZmllbGRJbmZvcyA9PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgPyBmaWVsZEluZm9zKClcbiAgICAgICAgOiBmaWVsZEluZm9zKSB7XG4gICAgICAgIGNvbnN0IGYgPSBmaWVsZDtcbiAgICAgICAgZi5sb2NhbE5hbWUgPSBsb2NhbEZpZWxkTmFtZShmaWVsZC5uYW1lLCBmaWVsZC5vbmVvZiAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgZi5qc29uTmFtZSA9IChfYSA9IGZpZWxkLmpzb25OYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmaWVsZEpzb25OYW1lKGZpZWxkLm5hbWUpO1xuICAgICAgICBmLnJlcGVhdGVkID0gKF9iID0gZmllbGQucmVwZWF0ZWQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZhbHNlO1xuICAgICAgICBpZiAoZmllbGQua2luZCA9PSBcInNjYWxhclwiKSB7XG4gICAgICAgICAgICBmLkwgPSAoX2MgPSBmaWVsZC5MKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBMb25nVHlwZS5CSUdJTlQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRnJvbSB0aGUgcHJvdG8zIGxhbmd1YWdlIGd1aWRlOlxuICAgICAgICAvLyA+IEluIHByb3RvMywgcmVwZWF0ZWQgZmllbGRzIG9mIHNjYWxhciBudW1lcmljIHR5cGVzIGFyZSBwYWNrZWQgYnkgZGVmYXVsdC5cbiAgICAgICAgLy8gVGhpcyBpbmZvcm1hdGlvbiBpcyBpbmNvbXBsZXRlIC0gYWNjb3JkaW5nIHRvIHRoZSBjb25mb3JtYW5jZSB0ZXN0cywgQk9PTFxuICAgICAgICAvLyBhbmQgRU5VTSBhcmUgcGFja2VkIGJ5IGRlZmF1bHQgYXMgd2VsbC4gVGhpcyBtZWFucyBvbmx5IFNUUklORyBhbmQgQllURVNcbiAgICAgICAgLy8gYXJlIG5vdCBwYWNrZWQgYnkgZGVmYXVsdCwgd2hpY2ggbWFrZXMgc2Vuc2UgYmVjYXVzZSB0aGV5IGFyZSBsZW5ndGgtZGVsaW1pdGVkLlxuICAgICAgICBmLnBhY2tlZCA9XG4gICAgICAgICAgICAoX2QgPSBmaWVsZC5wYWNrZWQpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IChmaWVsZC5raW5kID09IFwiZW51bVwiIHx8XG4gICAgICAgICAgICAgICAgKGZpZWxkLmtpbmQgPT0gXCJzY2FsYXJcIiAmJlxuICAgICAgICAgICAgICAgICAgICBmaWVsZC5UICE9IFNjYWxhclR5cGUuQllURVMgJiZcbiAgICAgICAgICAgICAgICAgICAgZmllbGQuVCAhPSBTY2FsYXJUeXBlLlNUUklORykpO1xuICAgICAgICAvLyBXZSBkbyBub3Qgc3VyZmFjZSBvcHRpb25zIGF0IHRoaXMgdGltZVxuICAgICAgICAvLyBmLm9wdGlvbnMgPSBmaWVsZC5vcHRpb25zID8/IGVtcHR5UmVhZG9ubHlPYmplY3Q7XG4gICAgICAgIGlmIChmaWVsZC5vbmVvZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBvb25hbWUgPSB0eXBlb2YgZmllbGQub25lb2YgPT0gXCJzdHJpbmdcIiA/IGZpZWxkLm9uZW9mIDogZmllbGQub25lb2YubmFtZTtcbiAgICAgICAgICAgIGlmICghbyB8fCBvLm5hbWUgIT0gb29uYW1lKSB7XG4gICAgICAgICAgICAgICAgbyA9IG5ldyBJbnRlcm5hbE9uZW9mSW5mbyhvb25hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZi5vbmVvZiA9IG87XG4gICAgICAgICAgICBvLmFkZEZpZWxkKGYpO1xuICAgICAgICB9XG4gICAgICAgIHIucHVzaChmKTtcbiAgICB9XG4gICAgcmV0dXJuIHI7XG59XG4iLCIvLyBDb3B5cmlnaHQgMjAyMS0yMDIzIEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuaW1wb3J0IHsgTWVzc2FnZSB9IGZyb20gXCIuLi8uLi9tZXNzYWdlLmpzXCI7XG5pbXBvcnQgeyBwcm90b0ludDY0IH0gZnJvbSBcIi4uLy4uL3Byb3RvLWludDY0LmpzXCI7XG5pbXBvcnQgeyBwcm90bzMgfSBmcm9tIFwiLi4vLi4vcHJvdG8zLmpzXCI7XG4vKipcbiAqIEEgVGltZXN0YW1wIHJlcHJlc2VudHMgYSBwb2ludCBpbiB0aW1lIGluZGVwZW5kZW50IG9mIGFueSB0aW1lIHpvbmUgb3IgbG9jYWxcbiAqIGNhbGVuZGFyLCBlbmNvZGVkIGFzIGEgY291bnQgb2Ygc2Vjb25kcyBhbmQgZnJhY3Rpb25zIG9mIHNlY29uZHMgYXRcbiAqIG5hbm9zZWNvbmQgcmVzb2x1dGlvbi4gVGhlIGNvdW50IGlzIHJlbGF0aXZlIHRvIGFuIGVwb2NoIGF0IFVUQyBtaWRuaWdodCBvblxuICogSmFudWFyeSAxLCAxOTcwLCBpbiB0aGUgcHJvbGVwdGljIEdyZWdvcmlhbiBjYWxlbmRhciB3aGljaCBleHRlbmRzIHRoZVxuICogR3JlZ29yaWFuIGNhbGVuZGFyIGJhY2t3YXJkcyB0byB5ZWFyIG9uZS5cbiAqXG4gKiBBbGwgbWludXRlcyBhcmUgNjAgc2Vjb25kcyBsb25nLiBMZWFwIHNlY29uZHMgYXJlIFwic21lYXJlZFwiIHNvIHRoYXQgbm8gbGVhcFxuICogc2Vjb25kIHRhYmxlIGlzIG5lZWRlZCBmb3IgaW50ZXJwcmV0YXRpb24sIHVzaW5nIGEgWzI0LWhvdXIgbGluZWFyXG4gKiBzbWVhcl0oaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vdGltZS9zbWVhcikuXG4gKlxuICogVGhlIHJhbmdlIGlzIGZyb20gMDAwMS0wMS0wMVQwMDowMDowMFogdG8gOTk5OS0xMi0zMVQyMzo1OTo1OS45OTk5OTk5OTlaLiBCeVxuICogcmVzdHJpY3RpbmcgdG8gdGhhdCByYW5nZSwgd2UgZW5zdXJlIHRoYXQgd2UgY2FuIGNvbnZlcnQgdG8gYW5kIGZyb20gW1JGQ1xuICogMzMzOV0oaHR0cHM6Ly93d3cuaWV0Zi5vcmcvcmZjL3JmYzMzMzkudHh0KSBkYXRlIHN0cmluZ3MuXG4gKlxuICogIyBFeGFtcGxlc1xuICpcbiAqIEV4YW1wbGUgMTogQ29tcHV0ZSBUaW1lc3RhbXAgZnJvbSBQT1NJWCBgdGltZSgpYC5cbiAqXG4gKiAgICAgVGltZXN0YW1wIHRpbWVzdGFtcDtcbiAqICAgICB0aW1lc3RhbXAuc2V0X3NlY29uZHModGltZShOVUxMKSk7XG4gKiAgICAgdGltZXN0YW1wLnNldF9uYW5vcygwKTtcbiAqXG4gKiBFeGFtcGxlIDI6IENvbXB1dGUgVGltZXN0YW1wIGZyb20gUE9TSVggYGdldHRpbWVvZmRheSgpYC5cbiAqXG4gKiAgICAgc3RydWN0IHRpbWV2YWwgdHY7XG4gKiAgICAgZ2V0dGltZW9mZGF5KCZ0diwgTlVMTCk7XG4gKlxuICogICAgIFRpbWVzdGFtcCB0aW1lc3RhbXA7XG4gKiAgICAgdGltZXN0YW1wLnNldF9zZWNvbmRzKHR2LnR2X3NlYyk7XG4gKiAgICAgdGltZXN0YW1wLnNldF9uYW5vcyh0di50dl91c2VjICogMTAwMCk7XG4gKlxuICogRXhhbXBsZSAzOiBDb21wdXRlIFRpbWVzdGFtcCBmcm9tIFdpbjMyIGBHZXRTeXN0ZW1UaW1lQXNGaWxlVGltZSgpYC5cbiAqXG4gKiAgICAgRklMRVRJTUUgZnQ7XG4gKiAgICAgR2V0U3lzdGVtVGltZUFzRmlsZVRpbWUoJmZ0KTtcbiAqICAgICBVSU5UNjQgdGlja3MgPSAoKChVSU5UNjQpZnQuZHdIaWdoRGF0ZVRpbWUpIDw8IDMyKSB8IGZ0LmR3TG93RGF0ZVRpbWU7XG4gKlxuICogICAgIC8vIEEgV2luZG93cyB0aWNrIGlzIDEwMCBuYW5vc2Vjb25kcy4gV2luZG93cyBlcG9jaCAxNjAxLTAxLTAxVDAwOjAwOjAwWlxuICogICAgIC8vIGlzIDExNjQ0NDczNjAwIHNlY29uZHMgYmVmb3JlIFVuaXggZXBvY2ggMTk3MC0wMS0wMVQwMDowMDowMFouXG4gKiAgICAgVGltZXN0YW1wIHRpbWVzdGFtcDtcbiAqICAgICB0aW1lc3RhbXAuc2V0X3NlY29uZHMoKElOVDY0KSAoKHRpY2tzIC8gMTAwMDAwMDApIC0gMTE2NDQ0NzM2MDBMTCkpO1xuICogICAgIHRpbWVzdGFtcC5zZXRfbmFub3MoKElOVDMyKSAoKHRpY2tzICUgMTAwMDAwMDApICogMTAwKSk7XG4gKlxuICogRXhhbXBsZSA0OiBDb21wdXRlIFRpbWVzdGFtcCBmcm9tIEphdmEgYFN5c3RlbS5jdXJyZW50VGltZU1pbGxpcygpYC5cbiAqXG4gKiAgICAgbG9uZyBtaWxsaXMgPSBTeXN0ZW0uY3VycmVudFRpbWVNaWxsaXMoKTtcbiAqXG4gKiAgICAgVGltZXN0YW1wIHRpbWVzdGFtcCA9IFRpbWVzdGFtcC5uZXdCdWlsZGVyKCkuc2V0U2Vjb25kcyhtaWxsaXMgLyAxMDAwKVxuICogICAgICAgICAuc2V0TmFub3MoKGludCkgKChtaWxsaXMgJSAxMDAwKSAqIDEwMDAwMDApKS5idWlsZCgpO1xuICpcbiAqIEV4YW1wbGUgNTogQ29tcHV0ZSBUaW1lc3RhbXAgZnJvbSBKYXZhIGBJbnN0YW50Lm5vdygpYC5cbiAqXG4gKiAgICAgSW5zdGFudCBub3cgPSBJbnN0YW50Lm5vdygpO1xuICpcbiAqICAgICBUaW1lc3RhbXAgdGltZXN0YW1wID1cbiAqICAgICAgICAgVGltZXN0YW1wLm5ld0J1aWxkZXIoKS5zZXRTZWNvbmRzKG5vdy5nZXRFcG9jaFNlY29uZCgpKVxuICogICAgICAgICAgICAgLnNldE5hbm9zKG5vdy5nZXROYW5vKCkpLmJ1aWxkKCk7XG4gKlxuICogRXhhbXBsZSA2OiBDb21wdXRlIFRpbWVzdGFtcCBmcm9tIGN1cnJlbnQgdGltZSBpbiBQeXRob24uXG4gKlxuICogICAgIHRpbWVzdGFtcCA9IFRpbWVzdGFtcCgpXG4gKiAgICAgdGltZXN0YW1wLkdldEN1cnJlbnRUaW1lKClcbiAqXG4gKiAjIEpTT04gTWFwcGluZ1xuICpcbiAqIEluIEpTT04gZm9ybWF0LCB0aGUgVGltZXN0YW1wIHR5cGUgaXMgZW5jb2RlZCBhcyBhIHN0cmluZyBpbiB0aGVcbiAqIFtSRkMgMzMzOV0oaHR0cHM6Ly93d3cuaWV0Zi5vcmcvcmZjL3JmYzMzMzkudHh0KSBmb3JtYXQuIFRoYXQgaXMsIHRoZVxuICogZm9ybWF0IGlzIFwie3llYXJ9LXttb250aH0te2RheX1Ue2hvdXJ9OnttaW59OntzZWN9Wy57ZnJhY19zZWN9XVpcIlxuICogd2hlcmUge3llYXJ9IGlzIGFsd2F5cyBleHByZXNzZWQgdXNpbmcgZm91ciBkaWdpdHMgd2hpbGUge21vbnRofSwge2RheX0sXG4gKiB7aG91cn0sIHttaW59LCBhbmQge3NlY30gYXJlIHplcm8tcGFkZGVkIHRvIHR3byBkaWdpdHMgZWFjaC4gVGhlIGZyYWN0aW9uYWxcbiAqIHNlY29uZHMsIHdoaWNoIGNhbiBnbyB1cCB0byA5IGRpZ2l0cyAoaS5lLiB1cCB0byAxIG5hbm9zZWNvbmQgcmVzb2x1dGlvbiksXG4gKiBhcmUgb3B0aW9uYWwuIFRoZSBcIlpcIiBzdWZmaXggaW5kaWNhdGVzIHRoZSB0aW1lem9uZSAoXCJVVENcIik7IHRoZSB0aW1lem9uZVxuICogaXMgcmVxdWlyZWQuIEEgcHJvdG8zIEpTT04gc2VyaWFsaXplciBzaG91bGQgYWx3YXlzIHVzZSBVVEMgKGFzIGluZGljYXRlZCBieVxuICogXCJaXCIpIHdoZW4gcHJpbnRpbmcgdGhlIFRpbWVzdGFtcCB0eXBlIGFuZCBhIHByb3RvMyBKU09OIHBhcnNlciBzaG91bGQgYmVcbiAqIGFibGUgdG8gYWNjZXB0IGJvdGggVVRDIGFuZCBvdGhlciB0aW1lem9uZXMgKGFzIGluZGljYXRlZCBieSBhbiBvZmZzZXQpLlxuICpcbiAqIEZvciBleGFtcGxlLCBcIjIwMTctMDEtMTVUMDE6MzA6MTUuMDFaXCIgZW5jb2RlcyAxNS4wMSBzZWNvbmRzIHBhc3RcbiAqIDAxOjMwIFVUQyBvbiBKYW51YXJ5IDE1LCAyMDE3LlxuICpcbiAqIEluIEphdmFTY3JpcHQsIG9uZSBjYW4gY29udmVydCBhIERhdGUgb2JqZWN0IHRvIHRoaXMgZm9ybWF0IHVzaW5nIHRoZVxuICogc3RhbmRhcmRcbiAqIFt0b0lTT1N0cmluZygpXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlL3RvSVNPU3RyaW5nKVxuICogbWV0aG9kLiBJbiBQeXRob24sIGEgc3RhbmRhcmQgYGRhdGV0aW1lLmRhdGV0aW1lYCBvYmplY3QgY2FuIGJlIGNvbnZlcnRlZFxuICogdG8gdGhpcyBmb3JtYXQgdXNpbmdcbiAqIFtgc3RyZnRpbWVgXShodHRwczovL2RvY3MucHl0aG9uLm9yZy8yL2xpYnJhcnkvdGltZS5odG1sI3RpbWUuc3RyZnRpbWUpIHdpdGhcbiAqIHRoZSB0aW1lIGZvcm1hdCBzcGVjICclWS0lbS0lZFQlSDolTTolUy4lZlonLiBMaWtld2lzZSwgaW4gSmF2YSwgb25lIGNhbiB1c2VcbiAqIHRoZSBKb2RhIFRpbWUncyBbYElTT0RhdGVUaW1lRm9ybWF0LmRhdGVUaW1lKClgXShcbiAqIGh0dHA6Ly9qb2RhLXRpbWUuc291cmNlZm9yZ2UubmV0L2FwaWRvY3Mvb3JnL2pvZGEvdGltZS9mb3JtYXQvSVNPRGF0ZVRpbWVGb3JtYXQuaHRtbCNkYXRlVGltZSgpXG4gKiApIHRvIG9idGFpbiBhIGZvcm1hdHRlciBjYXBhYmxlIG9mIGdlbmVyYXRpbmcgdGltZXN0YW1wcyBpbiB0aGlzIGZvcm1hdC5cbiAqXG4gKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcFxuICovXG5leHBvcnQgY2xhc3MgVGltZXN0YW1wIGV4dGVuZHMgTWVzc2FnZSB7XG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVwcmVzZW50cyBzZWNvbmRzIG9mIFVUQyB0aW1lIHNpbmNlIFVuaXggZXBvY2hcbiAgICAgICAgICogMTk3MC0wMS0wMVQwMDowMDowMFouIE11c3QgYmUgZnJvbSAwMDAxLTAxLTAxVDAwOjAwOjAwWiB0b1xuICAgICAgICAgKiA5OTk5LTEyLTMxVDIzOjU5OjU5WiBpbmNsdXNpdmUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogaW50NjQgc2Vjb25kcyA9IDE7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlY29uZHMgPSBwcm90b0ludDY0Lnplcm87XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOb24tbmVnYXRpdmUgZnJhY3Rpb25zIG9mIGEgc2Vjb25kIGF0IG5hbm9zZWNvbmQgcmVzb2x1dGlvbi4gTmVnYXRpdmVcbiAgICAgICAgICogc2Vjb25kIHZhbHVlcyB3aXRoIGZyYWN0aW9ucyBtdXN0IHN0aWxsIGhhdmUgbm9uLW5lZ2F0aXZlIG5hbm9zIHZhbHVlc1xuICAgICAgICAgKiB0aGF0IGNvdW50IGZvcndhcmQgaW4gdGltZS4gTXVzdCBiZSBmcm9tIDAgdG8gOTk5LDk5OSw5OTlcbiAgICAgICAgICogaW5jbHVzaXZlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGludDMyIG5hbm9zID0gMjtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmFub3MgPSAwO1xuICAgICAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgICB9XG4gICAgZnJvbUpzb24oanNvbiwgb3B0aW9ucykge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24gIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IGRlY29kZSBnb29nbGUucHJvdG9idWYuVGltZXN0YW1wIGZyb20gSlNPTjogJHtwcm90bzMuanNvbi5kZWJ1Zyhqc29uKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYXRjaGVzID0ganNvbi5tYXRjaCgvXihbMC05XXs0fSktKFswLTldezJ9KS0oWzAtOV17Mn0pVChbMC05XXsyfSk6KFswLTldezJ9KTooWzAtOV17Mn0pKD86WnxcXC4oWzAtOV17Myw5fSlafChbKy1dWzAtOV1bMC05XTpbMC05XVswLTldKSkkLyk7XG4gICAgICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgZGVjb2RlIGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAgZnJvbSBKU09OOiBpbnZhbGlkIFJGQyAzMzM5IHN0cmluZ2ApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1zID0gRGF0ZS5wYXJzZShtYXRjaGVzWzFdICsgXCItXCIgKyBtYXRjaGVzWzJdICsgXCItXCIgKyBtYXRjaGVzWzNdICsgXCJUXCIgKyBtYXRjaGVzWzRdICsgXCI6XCIgKyBtYXRjaGVzWzVdICsgXCI6XCIgKyBtYXRjaGVzWzZdICsgKG1hdGNoZXNbOF0gPyBtYXRjaGVzWzhdIDogXCJaXCIpKTtcbiAgICAgICAgaWYgKE51bWJlci5pc05hTihtcykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IGRlY29kZSBnb29nbGUucHJvdG9idWYuVGltZXN0YW1wIGZyb20gSlNPTjogaW52YWxpZCBSRkMgMzMzOSBzdHJpbmdgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobXMgPCBEYXRlLnBhcnNlKFwiMDAwMS0wMS0wMVQwMDowMDowMFpcIikgfHwgbXMgPiBEYXRlLnBhcnNlKFwiOTk5OS0xMi0zMVQyMzo1OTo1OVpcIikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IGRlY29kZSBtZXNzYWdlIGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAgZnJvbSBKU09OOiBtdXN0IGJlIGZyb20gMDAwMS0wMS0wMVQwMDowMDowMFogdG8gOTk5OS0xMi0zMVQyMzo1OTo1OVogaW5jbHVzaXZlYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWNvbmRzID0gcHJvdG9JbnQ2NC5wYXJzZShtcyAvIDEwMDApO1xuICAgICAgICB0aGlzLm5hbm9zID0gMDtcbiAgICAgICAgaWYgKG1hdGNoZXNbN10pIHtcbiAgICAgICAgICAgIHRoaXMubmFub3MgPSAocGFyc2VJbnQoXCIxXCIgKyBtYXRjaGVzWzddICsgXCIwXCIucmVwZWF0KDkgLSBtYXRjaGVzWzddLmxlbmd0aCkpIC0gMTAwMDAwMDAwMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRvSnNvbihvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG1zID0gTnVtYmVyKHRoaXMuc2Vjb25kcykgKiAxMDAwO1xuICAgICAgICBpZiAobXMgPCBEYXRlLnBhcnNlKFwiMDAwMS0wMS0wMVQwMDowMDowMFpcIikgfHwgbXMgPiBEYXRlLnBhcnNlKFwiOTk5OS0xMi0zMVQyMzo1OTo1OVpcIikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IGVuY29kZSBnb29nbGUucHJvdG9idWYuVGltZXN0YW1wIHRvIEpTT046IG11c3QgYmUgZnJvbSAwMDAxLTAxLTAxVDAwOjAwOjAwWiB0byA5OTk5LTEyLTMxVDIzOjU5OjU5WiBpbmNsdXNpdmVgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5uYW5vcyA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IGVuY29kZSBnb29nbGUucHJvdG9idWYuVGltZXN0YW1wIHRvIEpTT046IG5hbm9zIG11c3Qgbm90IGJlIG5lZ2F0aXZlYCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHogPSBcIlpcIjtcbiAgICAgICAgaWYgKHRoaXMubmFub3MgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBuYW5vc1N0ciA9ICh0aGlzLm5hbm9zICsgMTAwMDAwMDAwMCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICBpZiAobmFub3NTdHIuc3Vic3RyaW5nKDMpID09PSBcIjAwMDAwMFwiKSB7XG4gICAgICAgICAgICAgICAgeiA9IFwiLlwiICsgbmFub3NTdHIuc3Vic3RyaW5nKDAsIDMpICsgXCJaXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuYW5vc1N0ci5zdWJzdHJpbmcoNikgPT09IFwiMDAwXCIpIHtcbiAgICAgICAgICAgICAgICB6ID0gXCIuXCIgKyBuYW5vc1N0ci5zdWJzdHJpbmcoMCwgNikgKyBcIlpcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHogPSBcIi5cIiArIG5hbm9zU3RyICsgXCJaXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG1zKS50b0lTT1N0cmluZygpLnJlcGxhY2UoXCIuMDAwWlwiLCB6KTtcbiAgICB9XG4gICAgdG9EYXRlKCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoTnVtYmVyKHRoaXMuc2Vjb25kcykgKiAxMDAwICsgTWF0aC5jZWlsKHRoaXMubmFub3MgLyAxMDAwMDAwKSk7XG4gICAgfVxuICAgIHN0YXRpYyBub3coKSB7XG4gICAgICAgIHJldHVybiBUaW1lc3RhbXAuZnJvbURhdGUobmV3IERhdGUoKSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tRGF0ZShkYXRlKSB7XG4gICAgICAgIGNvbnN0IG1zID0gZGF0ZS5nZXRUaW1lKCk7XG4gICAgICAgIHJldHVybiBuZXcgVGltZXN0YW1wKHtcbiAgICAgICAgICAgIHNlY29uZHM6IHByb3RvSW50NjQucGFyc2UoTWF0aC5mbG9vcihtcyAvIDEwMDApKSxcbiAgICAgICAgICAgIG5hbm9zOiAobXMgJSAxMDAwKSAqIDEwMDAwMDAsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IFRpbWVzdGFtcCgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGltZXN0YW1wKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUaW1lc3RhbXAoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoVGltZXN0YW1wLCBhLCBiKTtcbiAgICB9XG59XG5UaW1lc3RhbXAucnVudGltZSA9IHByb3RvMztcblRpbWVzdGFtcC50eXBlTmFtZSA9IFwiZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcFwiO1xuVGltZXN0YW1wLmZpZWxkcyA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJzZWNvbmRzXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDMgLyogU2NhbGFyVHlwZS5JTlQ2NCAqLyB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwibmFub3NcIiwga2luZDogXCJzY2FsYXJcIiwgVDogNSAvKiBTY2FsYXJUeXBlLklOVDMyICovIH0sXG5dKTtcbiIsIi8vIENvcHlyaWdodCAyMDIzIExpdmVLaXQsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbi8vIEBnZW5lcmF0ZWQgYnkgcHJvdG9jLWdlbi1lcyB2MS40LjIgd2l0aCBwYXJhbWV0ZXIgXCJ0YXJnZXQ9dHNcIlxuLy8gQGdlbmVyYXRlZCBmcm9tIGZpbGUgbGl2ZWtpdF9tb2RlbHMucHJvdG8gKHBhY2thZ2UgbGl2ZWtpdCwgc3ludGF4IHByb3RvMylcbi8qIGVzbGludC1kaXNhYmxlICovXG4vLyBAdHMtbm9jaGVja1xuXG5pbXBvcnQgdHlwZSB7IEJpbmFyeVJlYWRPcHRpb25zLCBGaWVsZExpc3QsIEpzb25SZWFkT3B0aW9ucywgSnNvblZhbHVlLCBQYXJ0aWFsTWVzc2FnZSwgUGxhaW5NZXNzYWdlIH0gZnJvbSBcIkBidWZidWlsZC9wcm90b2J1ZlwiO1xuaW1wb3J0IHsgTWVzc2FnZSwgcHJvdG8zLCBwcm90b0ludDY0LCBUaW1lc3RhbXAgfSBmcm9tIFwiQGJ1ZmJ1aWxkL3Byb3RvYnVmXCI7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIGVudW0gbGl2ZWtpdC5BdWRpb0NvZGVjXG4gKi9cbmV4cG9ydCBlbnVtIEF1ZGlvQ29kZWMge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IERFRkFVTFRfQUMgPSAwO1xuICAgKi9cbiAgREVGQVVMVF9BQyA9IDAsXG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBPUFVTID0gMTtcbiAgICovXG4gIE9QVVMgPSAxLFxuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogQUFDID0gMjtcbiAgICovXG4gIEFBQyA9IDIsXG59XG4vLyBSZXRyaWV2ZSBlbnVtIG1ldGFkYXRhIHdpdGg6IHByb3RvMy5nZXRFbnVtVHlwZShBdWRpb0NvZGVjKVxucHJvdG8zLnV0aWwuc2V0RW51bVR5cGUoQXVkaW9Db2RlYywgXCJsaXZla2l0LkF1ZGlvQ29kZWNcIiwgW1xuICB7IG5vOiAwLCBuYW1lOiBcIkRFRkFVTFRfQUNcIiB9LFxuICB7IG5vOiAxLCBuYW1lOiBcIk9QVVNcIiB9LFxuICB7IG5vOiAyLCBuYW1lOiBcIkFBQ1wiIH0sXG5dKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gZW51bSBsaXZla2l0LlZpZGVvQ29kZWNcbiAqL1xuZXhwb3J0IGVudW0gVmlkZW9Db2RlYyB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogREVGQVVMVF9WQyA9IDA7XG4gICAqL1xuICBERUZBVUxUX1ZDID0gMCxcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IEgyNjRfQkFTRUxJTkUgPSAxO1xuICAgKi9cbiAgSDI2NF9CQVNFTElORSA9IDEsXG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBIMjY0X01BSU4gPSAyO1xuICAgKi9cbiAgSDI2NF9NQUlOID0gMixcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IEgyNjRfSElHSCA9IDM7XG4gICAqL1xuICBIMjY0X0hJR0ggPSAzLFxuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogVlA4ID0gNDtcbiAgICovXG4gIFZQOCA9IDQsXG59XG4vLyBSZXRyaWV2ZSBlbnVtIG1ldGFkYXRhIHdpdGg6IHByb3RvMy5nZXRFbnVtVHlwZShWaWRlb0NvZGVjKVxucHJvdG8zLnV0aWwuc2V0RW51bVR5cGUoVmlkZW9Db2RlYywgXCJsaXZla2l0LlZpZGVvQ29kZWNcIiwgW1xuICB7IG5vOiAwLCBuYW1lOiBcIkRFRkFVTFRfVkNcIiB9LFxuICB7IG5vOiAxLCBuYW1lOiBcIkgyNjRfQkFTRUxJTkVcIiB9LFxuICB7IG5vOiAyLCBuYW1lOiBcIkgyNjRfTUFJTlwiIH0sXG4gIHsgbm86IDMsIG5hbWU6IFwiSDI2NF9ISUdIXCIgfSxcbiAgeyBubzogNCwgbmFtZTogXCJWUDhcIiB9LFxuXSk7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIGVudW0gbGl2ZWtpdC5JbWFnZUNvZGVjXG4gKi9cbmV4cG9ydCBlbnVtIEltYWdlQ29kZWMge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IElDX0RFRkFVTFQgPSAwO1xuICAgKi9cbiAgSUNfREVGQVVMVCA9IDAsXG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBJQ19KUEVHID0gMTtcbiAgICovXG4gIElDX0pQRUcgPSAxLFxufVxuLy8gUmV0cmlldmUgZW51bSBtZXRhZGF0YSB3aXRoOiBwcm90bzMuZ2V0RW51bVR5cGUoSW1hZ2VDb2RlYylcbnByb3RvMy51dGlsLnNldEVudW1UeXBlKEltYWdlQ29kZWMsIFwibGl2ZWtpdC5JbWFnZUNvZGVjXCIsIFtcbiAgeyBubzogMCwgbmFtZTogXCJJQ19ERUZBVUxUXCIgfSxcbiAgeyBubzogMSwgbmFtZTogXCJJQ19KUEVHXCIgfSxcbl0pO1xuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIGxpdmVraXQuVHJhY2tUeXBlXG4gKi9cbmV4cG9ydCBlbnVtIFRyYWNrVHlwZSB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogQVVESU8gPSAwO1xuICAgKi9cbiAgQVVESU8gPSAwLFxuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogVklERU8gPSAxO1xuICAgKi9cbiAgVklERU8gPSAxLFxuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogREFUQSA9IDI7XG4gICAqL1xuICBEQVRBID0gMixcbn1cbi8vIFJldHJpZXZlIGVudW0gbWV0YWRhdGEgd2l0aDogcHJvdG8zLmdldEVudW1UeXBlKFRyYWNrVHlwZSlcbnByb3RvMy51dGlsLnNldEVudW1UeXBlKFRyYWNrVHlwZSwgXCJsaXZla2l0LlRyYWNrVHlwZVwiLCBbXG4gIHsgbm86IDAsIG5hbWU6IFwiQVVESU9cIiB9LFxuICB7IG5vOiAxLCBuYW1lOiBcIlZJREVPXCIgfSxcbiAgeyBubzogMiwgbmFtZTogXCJEQVRBXCIgfSxcbl0pO1xuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIGxpdmVraXQuVHJhY2tTb3VyY2VcbiAqL1xuZXhwb3J0IGVudW0gVHJhY2tTb3VyY2Uge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFVOS05PV04gPSAwO1xuICAgKi9cbiAgVU5LTk9XTiA9IDAsXG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBDQU1FUkEgPSAxO1xuICAgKi9cbiAgQ0FNRVJBID0gMSxcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IE1JQ1JPUEhPTkUgPSAyO1xuICAgKi9cbiAgTUlDUk9QSE9ORSA9IDIsXG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBTQ1JFRU5fU0hBUkUgPSAzO1xuICAgKi9cbiAgU0NSRUVOX1NIQVJFID0gMyxcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFNDUkVFTl9TSEFSRV9BVURJTyA9IDQ7XG4gICAqL1xuICBTQ1JFRU5fU0hBUkVfQVVESU8gPSA0LFxufVxuLy8gUmV0cmlldmUgZW51bSBtZXRhZGF0YSB3aXRoOiBwcm90bzMuZ2V0RW51bVR5cGUoVHJhY2tTb3VyY2UpXG5wcm90bzMudXRpbC5zZXRFbnVtVHlwZShUcmFja1NvdXJjZSwgXCJsaXZla2l0LlRyYWNrU291cmNlXCIsIFtcbiAgeyBubzogMCwgbmFtZTogXCJVTktOT1dOXCIgfSxcbiAgeyBubzogMSwgbmFtZTogXCJDQU1FUkFcIiB9LFxuICB7IG5vOiAyLCBuYW1lOiBcIk1JQ1JPUEhPTkVcIiB9LFxuICB7IG5vOiAzLCBuYW1lOiBcIlNDUkVFTl9TSEFSRVwiIH0sXG4gIHsgbm86IDQsIG5hbWU6IFwiU0NSRUVOX1NIQVJFX0FVRElPXCIgfSxcbl0pO1xuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIGxpdmVraXQuVmlkZW9RdWFsaXR5XG4gKi9cbmV4cG9ydCBlbnVtIFZpZGVvUXVhbGl0eSB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogTE9XID0gMDtcbiAgICovXG4gIExPVyA9IDAsXG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBNRURJVU0gPSAxO1xuICAgKi9cbiAgTUVESVVNID0gMSxcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IEhJR0ggPSAyO1xuICAgKi9cbiAgSElHSCA9IDIsXG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBPRkYgPSAzO1xuICAgKi9cbiAgT0ZGID0gMyxcbn1cbi8vIFJldHJpZXZlIGVudW0gbWV0YWRhdGEgd2l0aDogcHJvdG8zLmdldEVudW1UeXBlKFZpZGVvUXVhbGl0eSlcbnByb3RvMy51dGlsLnNldEVudW1UeXBlKFZpZGVvUXVhbGl0eSwgXCJsaXZla2l0LlZpZGVvUXVhbGl0eVwiLCBbXG4gIHsgbm86IDAsIG5hbWU6IFwiTE9XXCIgfSxcbiAgeyBubzogMSwgbmFtZTogXCJNRURJVU1cIiB9LFxuICB7IG5vOiAyLCBuYW1lOiBcIkhJR0hcIiB9LFxuICB7IG5vOiAzLCBuYW1lOiBcIk9GRlwiIH0sXG5dKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gZW51bSBsaXZla2l0LkNvbm5lY3Rpb25RdWFsaXR5XG4gKi9cbmV4cG9ydCBlbnVtIENvbm5lY3Rpb25RdWFsaXR5IHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBQT09SID0gMDtcbiAgICovXG4gIFBPT1IgPSAwLFxuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogR09PRCA9IDE7XG4gICAqL1xuICBHT09EID0gMSxcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IEVYQ0VMTEVOVCA9IDI7XG4gICAqL1xuICBFWENFTExFTlQgPSAyLFxuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogTE9TVCA9IDM7XG4gICAqL1xuICBMT1NUID0gMyxcbn1cbi8vIFJldHJpZXZlIGVudW0gbWV0YWRhdGEgd2l0aDogcHJvdG8zLmdldEVudW1UeXBlKENvbm5lY3Rpb25RdWFsaXR5KVxucHJvdG8zLnV0aWwuc2V0RW51bVR5cGUoQ29ubmVjdGlvblF1YWxpdHksIFwibGl2ZWtpdC5Db25uZWN0aW9uUXVhbGl0eVwiLCBbXG4gIHsgbm86IDAsIG5hbWU6IFwiUE9PUlwiIH0sXG4gIHsgbm86IDEsIG5hbWU6IFwiR09PRFwiIH0sXG4gIHsgbm86IDIsIG5hbWU6IFwiRVhDRUxMRU5UXCIgfSxcbiAgeyBubzogMywgbmFtZTogXCJMT1NUXCIgfSxcbl0pO1xuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIGxpdmVraXQuQ2xpZW50Q29uZmlnU2V0dGluZ1xuICovXG5leHBvcnQgZW51bSBDbGllbnRDb25maWdTZXR0aW5nIHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBVTlNFVCA9IDA7XG4gICAqL1xuICBVTlNFVCA9IDAsXG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBESVNBQkxFRCA9IDE7XG4gICAqL1xuICBESVNBQkxFRCA9IDEsXG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBFTkFCTEVEID0gMjtcbiAgICovXG4gIEVOQUJMRUQgPSAyLFxufVxuLy8gUmV0cmlldmUgZW51bSBtZXRhZGF0YSB3aXRoOiBwcm90bzMuZ2V0RW51bVR5cGUoQ2xpZW50Q29uZmlnU2V0dGluZylcbnByb3RvMy51dGlsLnNldEVudW1UeXBlKENsaWVudENvbmZpZ1NldHRpbmcsIFwibGl2ZWtpdC5DbGllbnRDb25maWdTZXR0aW5nXCIsIFtcbiAgeyBubzogMCwgbmFtZTogXCJVTlNFVFwiIH0sXG4gIHsgbm86IDEsIG5hbWU6IFwiRElTQUJMRURcIiB9LFxuICB7IG5vOiAyLCBuYW1lOiBcIkVOQUJMRURcIiB9LFxuXSk7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIGVudW0gbGl2ZWtpdC5EaXNjb25uZWN0UmVhc29uXG4gKi9cbmV4cG9ydCBlbnVtIERpc2Nvbm5lY3RSZWFzb24ge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFVOS05PV05fUkVBU09OID0gMDtcbiAgICovXG4gIFVOS05PV05fUkVBU09OID0gMCxcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IENMSUVOVF9JTklUSUFURUQgPSAxO1xuICAgKi9cbiAgQ0xJRU5UX0lOSVRJQVRFRCA9IDEsXG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBEVVBMSUNBVEVfSURFTlRJVFkgPSAyO1xuICAgKi9cbiAgRFVQTElDQVRFX0lERU5USVRZID0gMixcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFNFUlZFUl9TSFVURE9XTiA9IDM7XG4gICAqL1xuICBTRVJWRVJfU0hVVERPV04gPSAzLFxuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogUEFSVElDSVBBTlRfUkVNT1ZFRCA9IDQ7XG4gICAqL1xuICBQQVJUSUNJUEFOVF9SRU1PVkVEID0gNCxcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFJPT01fREVMRVRFRCA9IDU7XG4gICAqL1xuICBST09NX0RFTEVURUQgPSA1LFxuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogU1RBVEVfTUlTTUFUQ0ggPSA2O1xuICAgKi9cbiAgU1RBVEVfTUlTTUFUQ0ggPSA2LFxuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogSk9JTl9GQUlMVVJFID0gNztcbiAgICovXG4gIEpPSU5fRkFJTFVSRSA9IDcsXG59XG4vLyBSZXRyaWV2ZSBlbnVtIG1ldGFkYXRhIHdpdGg6IHByb3RvMy5nZXRFbnVtVHlwZShEaXNjb25uZWN0UmVhc29uKVxucHJvdG8zLnV0aWwuc2V0RW51bVR5cGUoRGlzY29ubmVjdFJlYXNvbiwgXCJsaXZla2l0LkRpc2Nvbm5lY3RSZWFzb25cIiwgW1xuICB7IG5vOiAwLCBuYW1lOiBcIlVOS05PV05fUkVBU09OXCIgfSxcbiAgeyBubzogMSwgbmFtZTogXCJDTElFTlRfSU5JVElBVEVEXCIgfSxcbiAgeyBubzogMiwgbmFtZTogXCJEVVBMSUNBVEVfSURFTlRJVFlcIiB9LFxuICB7IG5vOiAzLCBuYW1lOiBcIlNFUlZFUl9TSFVURE9XTlwiIH0sXG4gIHsgbm86IDQsIG5hbWU6IFwiUEFSVElDSVBBTlRfUkVNT1ZFRFwiIH0sXG4gIHsgbm86IDUsIG5hbWU6IFwiUk9PTV9ERUxFVEVEXCIgfSxcbiAgeyBubzogNiwgbmFtZTogXCJTVEFURV9NSVNNQVRDSFwiIH0sXG4gIHsgbm86IDcsIG5hbWU6IFwiSk9JTl9GQUlMVVJFXCIgfSxcbl0pO1xuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIGxpdmVraXQuUmVjb25uZWN0UmVhc29uXG4gKi9cbmV4cG9ydCBlbnVtIFJlY29ubmVjdFJlYXNvbiB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogUlJfVU5LTk9XTiA9IDA7XG4gICAqL1xuICBSUl9VTktOT1dOID0gMCxcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFJSX1NJR05BTF9ESVNDT05ORUNURUQgPSAxO1xuICAgKi9cbiAgUlJfU0lHTkFMX0RJU0NPTk5FQ1RFRCA9IDEsXG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBSUl9QVUJMSVNIRVJfRkFJTEVEID0gMjtcbiAgICovXG4gIFJSX1BVQkxJU0hFUl9GQUlMRUQgPSAyLFxuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogUlJfU1VCU0NSSUJFUl9GQUlMRUQgPSAzO1xuICAgKi9cbiAgUlJfU1VCU0NSSUJFUl9GQUlMRUQgPSAzLFxuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogUlJfU1dJVENIX0NBTkRJREFURSA9IDQ7XG4gICAqL1xuICBSUl9TV0lUQ0hfQ0FORElEQVRFID0gNCxcbn1cbi8vIFJldHJpZXZlIGVudW0gbWV0YWRhdGEgd2l0aDogcHJvdG8zLmdldEVudW1UeXBlKFJlY29ubmVjdFJlYXNvbilcbnByb3RvMy51dGlsLnNldEVudW1UeXBlKFJlY29ubmVjdFJlYXNvbiwgXCJsaXZla2l0LlJlY29ubmVjdFJlYXNvblwiLCBbXG4gIHsgbm86IDAsIG5hbWU6IFwiUlJfVU5LTk9XTlwiIH0sXG4gIHsgbm86IDEsIG5hbWU6IFwiUlJfU0lHTkFMX0RJU0NPTk5FQ1RFRFwiIH0sXG4gIHsgbm86IDIsIG5hbWU6IFwiUlJfUFVCTElTSEVSX0ZBSUxFRFwiIH0sXG4gIHsgbm86IDMsIG5hbWU6IFwiUlJfU1VCU0NSSUJFUl9GQUlMRURcIiB9LFxuICB7IG5vOiA0LCBuYW1lOiBcIlJSX1NXSVRDSF9DQU5ESURBVEVcIiB9LFxuXSk7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIGVudW0gbGl2ZWtpdC5TdWJzY3JpcHRpb25FcnJvclxuICovXG5leHBvcnQgZW51bSBTdWJzY3JpcHRpb25FcnJvciB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogU0VfVU5LTk9XTiA9IDA7XG4gICAqL1xuICBTRV9VTktOT1dOID0gMCxcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFNFX0NPREVDX1VOU1VQUE9SVEVEID0gMTtcbiAgICovXG4gIFNFX0NPREVDX1VOU1VQUE9SVEVEID0gMSxcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFNFX1RSQUNLX05PVEZPVU5EID0gMjtcbiAgICovXG4gIFNFX1RSQUNLX05PVEZPVU5EID0gMixcbn1cbi8vIFJldHJpZXZlIGVudW0gbWV0YWRhdGEgd2l0aDogcHJvdG8zLmdldEVudW1UeXBlKFN1YnNjcmlwdGlvbkVycm9yKVxucHJvdG8zLnV0aWwuc2V0RW51bVR5cGUoU3Vic2NyaXB0aW9uRXJyb3IsIFwibGl2ZWtpdC5TdWJzY3JpcHRpb25FcnJvclwiLCBbXG4gIHsgbm86IDAsIG5hbWU6IFwiU0VfVU5LTk9XTlwiIH0sXG4gIHsgbm86IDEsIG5hbWU6IFwiU0VfQ09ERUNfVU5TVVBQT1JURURcIiB9LFxuICB7IG5vOiAyLCBuYW1lOiBcIlNFX1RSQUNLX05PVEZPVU5EXCIgfSxcbl0pO1xuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuUm9vbVxuICovXG5leHBvcnQgY2xhc3MgUm9vbSBleHRlbmRzIE1lc3NhZ2U8Um9vbT4ge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgc2lkID0gMTtcbiAgICovXG4gIHNpZCA9IFwiXCI7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIG5hbWUgPSAyO1xuICAgKi9cbiAgbmFtZSA9IFwiXCI7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIGVtcHR5X3RpbWVvdXQgPSAzO1xuICAgKi9cbiAgZW1wdHlUaW1lb3V0ID0gMDtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50MzIgbWF4X3BhcnRpY2lwYW50cyA9IDQ7XG4gICAqL1xuICBtYXhQYXJ0aWNpcGFudHMgPSAwO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGludDY0IGNyZWF0aW9uX3RpbWUgPSA1O1xuICAgKi9cbiAgY3JlYXRpb25UaW1lID0gcHJvdG9JbnQ2NC56ZXJvO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyB0dXJuX3Bhc3N3b3JkID0gNjtcbiAgICovXG4gIHR1cm5QYXNzd29yZCA9IFwiXCI7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgbGl2ZWtpdC5Db2RlYyBlbmFibGVkX2NvZGVjcyA9IDc7XG4gICAqL1xuICBlbmFibGVkQ29kZWNzOiBDb2RlY1tdID0gW107XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIG1ldGFkYXRhID0gODtcbiAgICovXG4gIG1ldGFkYXRhID0gXCJcIjtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50MzIgbnVtX3BhcnRpY2lwYW50cyA9IDk7XG4gICAqL1xuICBudW1QYXJ0aWNpcGFudHMgPSAwO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiBudW1fcHVibGlzaGVycyA9IDExO1xuICAgKi9cbiAgbnVtUHVibGlzaGVycyA9IDA7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYm9vbCBhY3RpdmVfcmVjb3JkaW5nID0gMTA7XG4gICAqL1xuICBhY3RpdmVSZWNvcmRpbmcgPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihkYXRhPzogUGFydGlhbE1lc3NhZ2U8Um9vbT4pIHtcbiAgICBzdXBlcigpO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG5cbiAgc3RhdGljIHJlYWRvbmx5IHJ1bnRpbWU6IHR5cGVvZiBwcm90bzMgPSBwcm90bzM7XG4gIHN0YXRpYyByZWFkb25seSB0eXBlTmFtZSA9IFwibGl2ZWtpdC5Sb29tXCI7XG4gIHN0YXRpYyByZWFkb25seSBmaWVsZHM6IEZpZWxkTGlzdCA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJzaWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwibmFtZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJlbXB0eV90aW1lb3V0XCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovIH0sXG4gICAgeyBubzogNCwgbmFtZTogXCJtYXhfcGFydGljaXBhbnRzXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovIH0sXG4gICAgeyBubzogNSwgbmFtZTogXCJjcmVhdGlvbl90aW1lXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDMgLyogU2NhbGFyVHlwZS5JTlQ2NCAqLyB9LFxuICAgIHsgbm86IDYsIG5hbWU6IFwidHVybl9wYXNzd29yZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogNywgbmFtZTogXCJlbmFibGVkX2NvZGVjc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogQ29kZWMsIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAgeyBubzogOCwgbmFtZTogXCJtZXRhZGF0YVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogOSwgbmFtZTogXCJudW1fcGFydGljaXBhbnRzXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovIH0sXG4gICAgeyBubzogMTEsIG5hbWU6IFwibnVtX3B1Ymxpc2hlcnNcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi8gfSxcbiAgICB7IG5vOiAxMCwgbmFtZTogXCJhY3RpdmVfcmVjb3JkaW5nXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovIH0sXG4gIF0pO1xuXG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzOiBVaW50OEFycmF5LCBvcHRpb25zPzogUGFydGlhbDxCaW5hcnlSZWFkT3B0aW9ucz4pOiBSb29tIHtcbiAgICByZXR1cm4gbmV3IFJvb20oKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWU6IEpzb25WYWx1ZSwgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IFJvb20ge1xuICAgIHJldHVybiBuZXcgUm9vbSgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZzogc3RyaW5nLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogUm9vbSB7XG4gICAgcmV0dXJuIG5ldyBSb29tKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZXF1YWxzKGE6IFJvb20gfCBQbGFpbk1lc3NhZ2U8Um9vbT4gfCB1bmRlZmluZWQsIGI6IFJvb20gfCBQbGFpbk1lc3NhZ2U8Um9vbT4gfCB1bmRlZmluZWQpOiBib29sZWFuIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFJvb20sIGEsIGIpO1xuICB9XG59XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5Db2RlY1xuICovXG5leHBvcnQgY2xhc3MgQ29kZWMgZXh0ZW5kcyBNZXNzYWdlPENvZGVjPiB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBtaW1lID0gMTtcbiAgICovXG4gIG1pbWUgPSBcIlwiO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBmbXRwX2xpbmUgPSAyO1xuICAgKi9cbiAgZm10cExpbmUgPSBcIlwiO1xuXG4gIGNvbnN0cnVjdG9yKGRhdGE/OiBQYXJ0aWFsTWVzc2FnZTxDb2RlYz4pIHtcbiAgICBzdXBlcigpO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG5cbiAgc3RhdGljIHJlYWRvbmx5IHJ1bnRpbWU6IHR5cGVvZiBwcm90bzMgPSBwcm90bzM7XG4gIHN0YXRpYyByZWFkb25seSB0eXBlTmFtZSA9IFwibGl2ZWtpdC5Db2RlY1wiO1xuICBzdGF0aWMgcmVhZG9ubHkgZmllbGRzOiBGaWVsZExpc3QgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwibWltZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJmbXRwX2xpbmVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICBdKTtcblxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlczogVWludDhBcnJheSwgb3B0aW9ucz86IFBhcnRpYWw8QmluYXJ5UmVhZE9wdGlvbnM+KTogQ29kZWMge1xuICAgIHJldHVybiBuZXcgQ29kZWMoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWU6IEpzb25WYWx1ZSwgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IENvZGVjIHtcbiAgICByZXR1cm4gbmV3IENvZGVjKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nOiBzdHJpbmcsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBDb2RlYyB7XG4gICAgcmV0dXJuIG5ldyBDb2RlYygpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGVxdWFscyhhOiBDb2RlYyB8IFBsYWluTWVzc2FnZTxDb2RlYz4gfCB1bmRlZmluZWQsIGI6IENvZGVjIHwgUGxhaW5NZXNzYWdlPENvZGVjPiB8IHVuZGVmaW5lZCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoQ29kZWMsIGEsIGIpO1xuICB9XG59XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5QbGF5b3V0RGVsYXlcbiAqL1xuZXhwb3J0IGNsYXNzIFBsYXlvdXREZWxheSBleHRlbmRzIE1lc3NhZ2U8UGxheW91dERlbGF5PiB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGJvb2wgZW5hYmxlZCA9IDE7XG4gICAqL1xuICBlbmFibGVkID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIG1pbiA9IDI7XG4gICAqL1xuICBtaW4gPSAwO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiBtYXggPSAzO1xuICAgKi9cbiAgbWF4ID0gMDtcblxuICBjb25zdHJ1Y3RvcihkYXRhPzogUGFydGlhbE1lc3NhZ2U8UGxheW91dERlbGF5Pikge1xuICAgIHN1cGVyKCk7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cblxuICBzdGF0aWMgcmVhZG9ubHkgcnVudGltZTogdHlwZW9mIHByb3RvMyA9IHByb3RvMztcbiAgc3RhdGljIHJlYWRvbmx5IHR5cGVOYW1lID0gXCJsaXZla2l0LlBsYXlvdXREZWxheVwiO1xuICBzdGF0aWMgcmVhZG9ubHkgZmllbGRzOiBGaWVsZExpc3QgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwiZW5hYmxlZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLyB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwibWluXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJtYXhcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi8gfSxcbiAgXSk7XG5cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXM6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBQYXJ0aWFsPEJpbmFyeVJlYWRPcHRpb25zPik6IFBsYXlvdXREZWxheSB7XG4gICAgcmV0dXJuIG5ldyBQbGF5b3V0RGVsYXkoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWU6IEpzb25WYWx1ZSwgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IFBsYXlvdXREZWxheSB7XG4gICAgcmV0dXJuIG5ldyBQbGF5b3V0RGVsYXkoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmc6IHN0cmluZywgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IFBsYXlvdXREZWxheSB7XG4gICAgcmV0dXJuIG5ldyBQbGF5b3V0RGVsYXkoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBlcXVhbHMoYTogUGxheW91dERlbGF5IHwgUGxhaW5NZXNzYWdlPFBsYXlvdXREZWxheT4gfCB1bmRlZmluZWQsIGI6IFBsYXlvdXREZWxheSB8IFBsYWluTWVzc2FnZTxQbGF5b3V0RGVsYXk+IHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhQbGF5b3V0RGVsYXksIGEsIGIpO1xuICB9XG59XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5QYXJ0aWNpcGFudFBlcm1pc3Npb25cbiAqL1xuZXhwb3J0IGNsYXNzIFBhcnRpY2lwYW50UGVybWlzc2lvbiBleHRlbmRzIE1lc3NhZ2U8UGFydGljaXBhbnRQZXJtaXNzaW9uPiB7XG4gIC8qKlxuICAgKiBhbGxvdyBwYXJ0aWNpcGFudCB0byBzdWJzY3JpYmUgdG8gb3RoZXIgdHJhY2tzIGluIHRoZSByb29tXG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYm9vbCBjYW5fc3Vic2NyaWJlID0gMTtcbiAgICovXG4gIGNhblN1YnNjcmliZSA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBhbGxvdyBwYXJ0aWNpcGFudCB0byBwdWJsaXNoIG5ldyB0cmFja3MgdG8gcm9vbVxuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGJvb2wgY2FuX3B1Ymxpc2ggPSAyO1xuICAgKi9cbiAgY2FuUHVibGlzaCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBhbGxvdyBwYXJ0aWNpcGFudCB0byBwdWJsaXNoIGRhdGFcbiAgICpcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBib29sIGNhbl9wdWJsaXNoX2RhdGEgPSAzO1xuICAgKi9cbiAgY2FuUHVibGlzaERhdGEgPSBmYWxzZTtcblxuICAvKipcbiAgICogc291cmNlcyB0aGF0IGFyZSBhbGxvd2VkIHRvIGJlIHB1Ymxpc2hlZFxuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGxpdmVraXQuVHJhY2tTb3VyY2UgY2FuX3B1Ymxpc2hfc291cmNlcyA9IDk7XG4gICAqL1xuICBjYW5QdWJsaXNoU291cmNlczogVHJhY2tTb3VyY2VbXSA9IFtdO1xuXG4gIC8qKlxuICAgKiBpbmRpY2F0ZXMgdGhhdCBpdCdzIGhpZGRlbiB0byBvdGhlcnNcbiAgICpcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBib29sIGhpZGRlbiA9IDc7XG4gICAqL1xuICBoaWRkZW4gPSBmYWxzZTtcblxuICAvKipcbiAgICogaW5kaWNhdGVzIGl0J3MgYSByZWNvcmRlciBpbnN0YW5jZVxuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGJvb2wgcmVjb3JkZXIgPSA4O1xuICAgKi9cbiAgcmVjb3JkZXIgPSBmYWxzZTtcblxuICAvKipcbiAgICogaW5kaWNhdGVzIHRoYXQgcGFydGljaXBhbnQgY2FuIHVwZGF0ZSBvd24gbWV0YWRhdGFcbiAgICpcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBib29sIGNhbl91cGRhdGVfbWV0YWRhdGEgPSAxMDtcbiAgICovXG4gIGNhblVwZGF0ZU1ldGFkYXRhID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIGluZGljYXRlcyB0aGF0IHBhcnRpY2lwYW50IGlzIGFuIGFnZW50XG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYm9vbCBhZ2VudCA9IDExO1xuICAgKi9cbiAgYWdlbnQgPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihkYXRhPzogUGFydGlhbE1lc3NhZ2U8UGFydGljaXBhbnRQZXJtaXNzaW9uPikge1xuICAgIHN1cGVyKCk7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cblxuICBzdGF0aWMgcmVhZG9ubHkgcnVudGltZTogdHlwZW9mIHByb3RvMyA9IHByb3RvMztcbiAgc3RhdGljIHJlYWRvbmx5IHR5cGVOYW1lID0gXCJsaXZla2l0LlBhcnRpY2lwYW50UGVybWlzc2lvblwiO1xuICBzdGF0aWMgcmVhZG9ubHkgZmllbGRzOiBGaWVsZExpc3QgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwiY2FuX3N1YnNjcmliZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLyB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwiY2FuX3B1Ymxpc2hcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi8gfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcImNhbl9wdWJsaXNoX2RhdGFcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi8gfSxcbiAgICB7IG5vOiA5LCBuYW1lOiBcImNhbl9wdWJsaXNoX3NvdXJjZXNcIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShUcmFja1NvdXJjZSksIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAgeyBubzogNywgbmFtZTogXCJoaWRkZW5cIiwga2luZDogXCJzY2FsYXJcIiwgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi8gfSxcbiAgICB7IG5vOiA4LCBuYW1lOiBcInJlY29yZGVyXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovIH0sXG4gICAgeyBubzogMTAsIG5hbWU6IFwiY2FuX3VwZGF0ZV9tZXRhZGF0YVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLyB9LFxuICAgIHsgbm86IDExLCBuYW1lOiBcImFnZW50XCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovIH0sXG4gIF0pO1xuXG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzOiBVaW50OEFycmF5LCBvcHRpb25zPzogUGFydGlhbDxCaW5hcnlSZWFkT3B0aW9ucz4pOiBQYXJ0aWNpcGFudFBlcm1pc3Npb24ge1xuICAgIHJldHVybiBuZXcgUGFydGljaXBhbnRQZXJtaXNzaW9uKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlOiBKc29uVmFsdWUsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBQYXJ0aWNpcGFudFBlcm1pc3Npb24ge1xuICAgIHJldHVybiBuZXcgUGFydGljaXBhbnRQZXJtaXNzaW9uKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nOiBzdHJpbmcsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBQYXJ0aWNpcGFudFBlcm1pc3Npb24ge1xuICAgIHJldHVybiBuZXcgUGFydGljaXBhbnRQZXJtaXNzaW9uKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZXF1YWxzKGE6IFBhcnRpY2lwYW50UGVybWlzc2lvbiB8IFBsYWluTWVzc2FnZTxQYXJ0aWNpcGFudFBlcm1pc3Npb24+IHwgdW5kZWZpbmVkLCBiOiBQYXJ0aWNpcGFudFBlcm1pc3Npb24gfCBQbGFpbk1lc3NhZ2U8UGFydGljaXBhbnRQZXJtaXNzaW9uPiB8IHVuZGVmaW5lZCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoUGFydGljaXBhbnRQZXJtaXNzaW9uLCBhLCBiKTtcbiAgfVxufVxuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuUGFydGljaXBhbnRJbmZvXG4gKi9cbmV4cG9ydCBjbGFzcyBQYXJ0aWNpcGFudEluZm8gZXh0ZW5kcyBNZXNzYWdlPFBhcnRpY2lwYW50SW5mbz4ge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgc2lkID0gMTtcbiAgICovXG4gIHNpZCA9IFwiXCI7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIGlkZW50aXR5ID0gMjtcbiAgICovXG4gIGlkZW50aXR5ID0gXCJcIjtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LlBhcnRpY2lwYW50SW5mby5TdGF0ZSBzdGF0ZSA9IDM7XG4gICAqL1xuICBzdGF0ZSA9IFBhcnRpY2lwYW50SW5mb19TdGF0ZS5KT0lOSU5HO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGxpdmVraXQuVHJhY2tJbmZvIHRyYWNrcyA9IDQ7XG4gICAqL1xuICB0cmFja3M6IFRyYWNrSW5mb1tdID0gW107XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIG1ldGFkYXRhID0gNTtcbiAgICovXG4gIG1ldGFkYXRhID0gXCJcIjtcblxuICAvKipcbiAgICogdGltZXN0YW1wIHdoZW4gcGFydGljaXBhbnQgam9pbmVkIHJvb20sIGluIHNlY29uZHNcbiAgICpcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBpbnQ2NCBqb2luZWRfYXQgPSA2O1xuICAgKi9cbiAgam9pbmVkQXQgPSBwcm90b0ludDY0Lnplcm87XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIG5hbWUgPSA5O1xuICAgKi9cbiAgbmFtZSA9IFwiXCI7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIHZlcnNpb24gPSAxMDtcbiAgICovXG4gIHZlcnNpb24gPSAwO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuUGFydGljaXBhbnRQZXJtaXNzaW9uIHBlcm1pc3Npb24gPSAxMTtcbiAgICovXG4gIHBlcm1pc3Npb24/OiBQYXJ0aWNpcGFudFBlcm1pc3Npb247XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHJlZ2lvbiA9IDEyO1xuICAgKi9cbiAgcmVnaW9uID0gXCJcIjtcblxuICAvKipcbiAgICogaW5kaWNhdGVzIHRoZSBwYXJ0aWNpcGFudCBoYXMgYW4gYWN0aXZlIHB1Ymxpc2hlciBjb25uZWN0aW9uXG4gICAqIGFuZCBjYW4gcHVibGlzaCB0byB0aGUgc2VydmVyXG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYm9vbCBpc19wdWJsaXNoZXIgPSAxMztcbiAgICovXG4gIGlzUHVibGlzaGVyID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IoZGF0YT86IFBhcnRpYWxNZXNzYWdlPFBhcnRpY2lwYW50SW5mbz4pIHtcbiAgICBzdXBlcigpO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG5cbiAgc3RhdGljIHJlYWRvbmx5IHJ1bnRpbWU6IHR5cGVvZiBwcm90bzMgPSBwcm90bzM7XG4gIHN0YXRpYyByZWFkb25seSB0eXBlTmFtZSA9IFwibGl2ZWtpdC5QYXJ0aWNpcGFudEluZm9cIjtcbiAgc3RhdGljIHJlYWRvbmx5IGZpZWxkczogRmllbGRMaXN0ID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInNpZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJpZGVudGl0eVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJzdGF0ZVwiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLmdldEVudW1UeXBlKFBhcnRpY2lwYW50SW5mb19TdGF0ZSkgfSxcbiAgICB7IG5vOiA0LCBuYW1lOiBcInRyYWNrc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVHJhY2tJbmZvLCByZXBlYXRlZDogdHJ1ZSB9LFxuICAgIHsgbm86IDUsIG5hbWU6IFwibWV0YWRhdGFcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDYsIG5hbWU6IFwiam9pbmVkX2F0XCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDMgLyogU2NhbGFyVHlwZS5JTlQ2NCAqLyB9LFxuICAgIHsgbm86IDksIG5hbWU6IFwibmFtZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMTAsIG5hbWU6IFwidmVyc2lvblwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqLyB9LFxuICAgIHsgbm86IDExLCBuYW1lOiBcInBlcm1pc3Npb25cIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFBhcnRpY2lwYW50UGVybWlzc2lvbiB9LFxuICAgIHsgbm86IDEyLCBuYW1lOiBcInJlZ2lvblwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMTMsIG5hbWU6IFwiaXNfcHVibGlzaGVyXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovIH0sXG4gIF0pO1xuXG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzOiBVaW50OEFycmF5LCBvcHRpb25zPzogUGFydGlhbDxCaW5hcnlSZWFkT3B0aW9ucz4pOiBQYXJ0aWNpcGFudEluZm8ge1xuICAgIHJldHVybiBuZXcgUGFydGljaXBhbnRJbmZvKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlOiBKc29uVmFsdWUsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBQYXJ0aWNpcGFudEluZm8ge1xuICAgIHJldHVybiBuZXcgUGFydGljaXBhbnRJbmZvKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nOiBzdHJpbmcsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBQYXJ0aWNpcGFudEluZm8ge1xuICAgIHJldHVybiBuZXcgUGFydGljaXBhbnRJbmZvKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZXF1YWxzKGE6IFBhcnRpY2lwYW50SW5mbyB8IFBsYWluTWVzc2FnZTxQYXJ0aWNpcGFudEluZm8+IHwgdW5kZWZpbmVkLCBiOiBQYXJ0aWNpcGFudEluZm8gfCBQbGFpbk1lc3NhZ2U8UGFydGljaXBhbnRJbmZvPiB8IHVuZGVmaW5lZCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoUGFydGljaXBhbnRJbmZvLCBhLCBiKTtcbiAgfVxufVxuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIGxpdmVraXQuUGFydGljaXBhbnRJbmZvLlN0YXRlXG4gKi9cbmV4cG9ydCBlbnVtIFBhcnRpY2lwYW50SW5mb19TdGF0ZSB7XG4gIC8qKlxuICAgKiB3ZWJzb2NrZXQnIGNvbm5lY3RlZCwgYnV0IG5vdCBvZmZlcmVkIHlldFxuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogSk9JTklORyA9IDA7XG4gICAqL1xuICBKT0lOSU5HID0gMCxcblxuICAvKipcbiAgICogc2VydmVyIHJlY2VpdmVkIGNsaWVudCBvZmZlclxuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogSk9JTkVEID0gMTtcbiAgICovXG4gIEpPSU5FRCA9IDEsXG5cbiAgLyoqXG4gICAqIElDRSBjb25uZWN0aXZpdHkgZXN0YWJsaXNoZWRcbiAgICpcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IEFDVElWRSA9IDI7XG4gICAqL1xuICBBQ1RJVkUgPSAyLFxuXG4gIC8qKlxuICAgKiBXUyBkaXNjb25uZWN0ZWRcbiAgICpcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IERJU0NPTk5FQ1RFRCA9IDM7XG4gICAqL1xuICBESVNDT05ORUNURUQgPSAzLFxufVxuLy8gUmV0cmlldmUgZW51bSBtZXRhZGF0YSB3aXRoOiBwcm90bzMuZ2V0RW51bVR5cGUoUGFydGljaXBhbnRJbmZvX1N0YXRlKVxucHJvdG8zLnV0aWwuc2V0RW51bVR5cGUoUGFydGljaXBhbnRJbmZvX1N0YXRlLCBcImxpdmVraXQuUGFydGljaXBhbnRJbmZvLlN0YXRlXCIsIFtcbiAgeyBubzogMCwgbmFtZTogXCJKT0lOSU5HXCIgfSxcbiAgeyBubzogMSwgbmFtZTogXCJKT0lORURcIiB9LFxuICB7IG5vOiAyLCBuYW1lOiBcIkFDVElWRVwiIH0sXG4gIHsgbm86IDMsIG5hbWU6IFwiRElTQ09OTkVDVEVEXCIgfSxcbl0pO1xuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuRW5jcnlwdGlvblxuICovXG5leHBvcnQgY2xhc3MgRW5jcnlwdGlvbiBleHRlbmRzIE1lc3NhZ2U8RW5jcnlwdGlvbj4ge1xuICBjb25zdHJ1Y3RvcihkYXRhPzogUGFydGlhbE1lc3NhZ2U8RW5jcnlwdGlvbj4pIHtcbiAgICBzdXBlcigpO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG5cbiAgc3RhdGljIHJlYWRvbmx5IHJ1bnRpbWU6IHR5cGVvZiBwcm90bzMgPSBwcm90bzM7XG4gIHN0YXRpYyByZWFkb25seSB0eXBlTmFtZSA9IFwibGl2ZWtpdC5FbmNyeXB0aW9uXCI7XG4gIHN0YXRpYyByZWFkb25seSBmaWVsZHM6IEZpZWxkTGlzdCA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gIF0pO1xuXG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzOiBVaW50OEFycmF5LCBvcHRpb25zPzogUGFydGlhbDxCaW5hcnlSZWFkT3B0aW9ucz4pOiBFbmNyeXB0aW9uIHtcbiAgICByZXR1cm4gbmV3IEVuY3J5cHRpb24oKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWU6IEpzb25WYWx1ZSwgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IEVuY3J5cHRpb24ge1xuICAgIHJldHVybiBuZXcgRW5jcnlwdGlvbigpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZzogc3RyaW5nLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogRW5jcnlwdGlvbiB7XG4gICAgcmV0dXJuIG5ldyBFbmNyeXB0aW9uKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZXF1YWxzKGE6IEVuY3J5cHRpb24gfCBQbGFpbk1lc3NhZ2U8RW5jcnlwdGlvbj4gfCB1bmRlZmluZWQsIGI6IEVuY3J5cHRpb24gfCBQbGFpbk1lc3NhZ2U8RW5jcnlwdGlvbj4gfCB1bmRlZmluZWQpOiBib29sZWFuIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKEVuY3J5cHRpb24sIGEsIGIpO1xuICB9XG59XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIGVudW0gbGl2ZWtpdC5FbmNyeXB0aW9uLlR5cGVcbiAqL1xuZXhwb3J0IGVudW0gRW5jcnlwdGlvbl9UeXBlIHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBOT05FID0gMDtcbiAgICovXG4gIE5PTkUgPSAwLFxuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogR0NNID0gMTtcbiAgICovXG4gIEdDTSA9IDEsXG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBDVVNUT00gPSAyO1xuICAgKi9cbiAgQ1VTVE9NID0gMixcbn1cbi8vIFJldHJpZXZlIGVudW0gbWV0YWRhdGEgd2l0aDogcHJvdG8zLmdldEVudW1UeXBlKEVuY3J5cHRpb25fVHlwZSlcbnByb3RvMy51dGlsLnNldEVudW1UeXBlKEVuY3J5cHRpb25fVHlwZSwgXCJsaXZla2l0LkVuY3J5cHRpb24uVHlwZVwiLCBbXG4gIHsgbm86IDAsIG5hbWU6IFwiTk9ORVwiIH0sXG4gIHsgbm86IDEsIG5hbWU6IFwiR0NNXCIgfSxcbiAgeyBubzogMiwgbmFtZTogXCJDVVNUT01cIiB9LFxuXSk7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5TaW11bGNhc3RDb2RlY0luZm9cbiAqL1xuZXhwb3J0IGNsYXNzIFNpbXVsY2FzdENvZGVjSW5mbyBleHRlbmRzIE1lc3NhZ2U8U2ltdWxjYXN0Q29kZWNJbmZvPiB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBtaW1lX3R5cGUgPSAxO1xuICAgKi9cbiAgbWltZVR5cGUgPSBcIlwiO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBtaWQgPSAyO1xuICAgKi9cbiAgbWlkID0gXCJcIjtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgY2lkID0gMztcbiAgICovXG4gIGNpZCA9IFwiXCI7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgbGl2ZWtpdC5WaWRlb0xheWVyIGxheWVycyA9IDQ7XG4gICAqL1xuICBsYXllcnM6IFZpZGVvTGF5ZXJbXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKGRhdGE/OiBQYXJ0aWFsTWVzc2FnZTxTaW11bGNhc3RDb2RlY0luZm8+KSB7XG4gICAgc3VwZXIoKTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuXG4gIHN0YXRpYyByZWFkb25seSBydW50aW1lOiB0eXBlb2YgcHJvdG8zID0gcHJvdG8zO1xuICBzdGF0aWMgcmVhZG9ubHkgdHlwZU5hbWUgPSBcImxpdmVraXQuU2ltdWxjYXN0Q29kZWNJbmZvXCI7XG4gIHN0YXRpYyByZWFkb25seSBmaWVsZHM6IEZpZWxkTGlzdCA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJtaW1lX3R5cGVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwibWlkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcImNpZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogNCwgbmFtZTogXCJsYXllcnNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFZpZGVvTGF5ZXIsIHJlcGVhdGVkOiB0cnVlIH0sXG4gIF0pO1xuXG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzOiBVaW50OEFycmF5LCBvcHRpb25zPzogUGFydGlhbDxCaW5hcnlSZWFkT3B0aW9ucz4pOiBTaW11bGNhc3RDb2RlY0luZm8ge1xuICAgIHJldHVybiBuZXcgU2ltdWxjYXN0Q29kZWNJbmZvKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlOiBKc29uVmFsdWUsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBTaW11bGNhc3RDb2RlY0luZm8ge1xuICAgIHJldHVybiBuZXcgU2ltdWxjYXN0Q29kZWNJbmZvKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nOiBzdHJpbmcsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBTaW11bGNhc3RDb2RlY0luZm8ge1xuICAgIHJldHVybiBuZXcgU2ltdWxjYXN0Q29kZWNJbmZvKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZXF1YWxzKGE6IFNpbXVsY2FzdENvZGVjSW5mbyB8IFBsYWluTWVzc2FnZTxTaW11bGNhc3RDb2RlY0luZm8+IHwgdW5kZWZpbmVkLCBiOiBTaW11bGNhc3RDb2RlY0luZm8gfCBQbGFpbk1lc3NhZ2U8U2ltdWxjYXN0Q29kZWNJbmZvPiB8IHVuZGVmaW5lZCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoU2ltdWxjYXN0Q29kZWNJbmZvLCBhLCBiKTtcbiAgfVxufVxuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuVHJhY2tJbmZvXG4gKi9cbmV4cG9ydCBjbGFzcyBUcmFja0luZm8gZXh0ZW5kcyBNZXNzYWdlPFRyYWNrSW5mbz4ge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgc2lkID0gMTtcbiAgICovXG4gIHNpZCA9IFwiXCI7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5UcmFja1R5cGUgdHlwZSA9IDI7XG4gICAqL1xuICB0eXBlID0gVHJhY2tUeXBlLkFVRElPO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBuYW1lID0gMztcbiAgICovXG4gIG5hbWUgPSBcIlwiO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGJvb2wgbXV0ZWQgPSA0O1xuICAgKi9cbiAgbXV0ZWQgPSBmYWxzZTtcblxuICAvKipcbiAgICogb3JpZ2luYWwgd2lkdGggb2YgdmlkZW8gKHVuc2V0IGZvciBhdWRpbylcbiAgICogY2xpZW50cyBtYXkgcmVjZWl2ZSBhIGxvd2VyIHJlc29sdXRpb24gdmVyc2lvbiB3aXRoIHNpbXVsY2FzdFxuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiB3aWR0aCA9IDU7XG4gICAqL1xuICB3aWR0aCA9IDA7XG5cbiAgLyoqXG4gICAqIG9yaWdpbmFsIGhlaWdodCBvZiB2aWRlbyAodW5zZXQgZm9yIGF1ZGlvKVxuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiBoZWlnaHQgPSA2O1xuICAgKi9cbiAgaGVpZ2h0ID0gMDtcblxuICAvKipcbiAgICogdHJ1ZSBpZiB0cmFjayBpcyBzaW11bGNhc3RlZFxuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGJvb2wgc2ltdWxjYXN0ID0gNztcbiAgICovXG4gIHNpbXVsY2FzdCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiB0cnVlIGlmIERUWCAoRGlzY29udGludW91cyBUcmFuc21pc3Npb24pIGlzIGRpc2FibGVkIGZvciBhdWRpb1xuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGJvb2wgZGlzYWJsZV9kdHggPSA4O1xuICAgKi9cbiAgZGlzYWJsZUR0eCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBzb3VyY2Ugb2YgbWVkaWFcbiAgICpcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LlRyYWNrU291cmNlIHNvdXJjZSA9IDk7XG4gICAqL1xuICBzb3VyY2UgPSBUcmFja1NvdXJjZS5VTktOT1dOO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGxpdmVraXQuVmlkZW9MYXllciBsYXllcnMgPSAxMDtcbiAgICovXG4gIGxheWVyczogVmlkZW9MYXllcltdID0gW107XG5cbiAgLyoqXG4gICAqIG1pbWUgdHlwZSBvZiBjb2RlY1xuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBtaW1lX3R5cGUgPSAxMTtcbiAgICovXG4gIG1pbWVUeXBlID0gXCJcIjtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgbWlkID0gMTI7XG4gICAqL1xuICBtaWQgPSBcIlwiO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGxpdmVraXQuU2ltdWxjYXN0Q29kZWNJbmZvIGNvZGVjcyA9IDEzO1xuICAgKi9cbiAgY29kZWNzOiBTaW11bGNhc3RDb2RlY0luZm9bXSA9IFtdO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGJvb2wgc3RlcmVvID0gMTQ7XG4gICAqL1xuICBzdGVyZW8gPSBmYWxzZTtcblxuICAvKipcbiAgICogdHJ1ZSBpZiBSRUQgKFJlZHVuZGFudCBFbmNvZGluZykgaXMgZGlzYWJsZWQgZm9yIGF1ZGlvXG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYm9vbCBkaXNhYmxlX3JlZCA9IDE1O1xuICAgKi9cbiAgZGlzYWJsZVJlZCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuRW5jcnlwdGlvbi5UeXBlIGVuY3J5cHRpb24gPSAxNjtcbiAgICovXG4gIGVuY3J5cHRpb24gPSBFbmNyeXB0aW9uX1R5cGUuTk9ORTtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgc3RyZWFtID0gMTc7XG4gICAqL1xuICBzdHJlYW0gPSBcIlwiO1xuXG4gIGNvbnN0cnVjdG9yKGRhdGE/OiBQYXJ0aWFsTWVzc2FnZTxUcmFja0luZm8+KSB7XG4gICAgc3VwZXIoKTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuXG4gIHN0YXRpYyByZWFkb25seSBydW50aW1lOiB0eXBlb2YgcHJvdG8zID0gcHJvdG8zO1xuICBzdGF0aWMgcmVhZG9ubHkgdHlwZU5hbWUgPSBcImxpdmVraXQuVHJhY2tJbmZvXCI7XG4gIHN0YXRpYyByZWFkb25seSBmaWVsZHM6IEZpZWxkTGlzdCA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJzaWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwidHlwZVwiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLmdldEVudW1UeXBlKFRyYWNrVHlwZSkgfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcIm5hbWVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwibXV0ZWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi8gfSxcbiAgICB7IG5vOiA1LCBuYW1lOiBcIndpZHRoXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovIH0sXG4gICAgeyBubzogNiwgbmFtZTogXCJoZWlnaHRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi8gfSxcbiAgICB7IG5vOiA3LCBuYW1lOiBcInNpbXVsY2FzdFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLyB9LFxuICAgIHsgbm86IDgsIG5hbWU6IFwiZGlzYWJsZV9kdHhcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi8gfSxcbiAgICB7IG5vOiA5LCBuYW1lOiBcInNvdXJjZVwiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLmdldEVudW1UeXBlKFRyYWNrU291cmNlKSB9LFxuICAgIHsgbm86IDEwLCBuYW1lOiBcImxheWVyc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVmlkZW9MYXllciwgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgICB7IG5vOiAxMSwgbmFtZTogXCJtaW1lX3R5cGVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDEyLCBuYW1lOiBcIm1pZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMTMsIG5hbWU6IFwiY29kZWNzXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBTaW11bGNhc3RDb2RlY0luZm8sIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAgeyBubzogMTQsIG5hbWU6IFwic3RlcmVvXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovIH0sXG4gICAgeyBubzogMTUsIG5hbWU6IFwiZGlzYWJsZV9yZWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi8gfSxcbiAgICB7IG5vOiAxNiwgbmFtZTogXCJlbmNyeXB0aW9uXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoRW5jcnlwdGlvbl9UeXBlKSB9LFxuICAgIHsgbm86IDE3LCBuYW1lOiBcInN0cmVhbVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gIF0pO1xuXG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzOiBVaW50OEFycmF5LCBvcHRpb25zPzogUGFydGlhbDxCaW5hcnlSZWFkT3B0aW9ucz4pOiBUcmFja0luZm8ge1xuICAgIHJldHVybiBuZXcgVHJhY2tJbmZvKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlOiBKc29uVmFsdWUsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBUcmFja0luZm8ge1xuICAgIHJldHVybiBuZXcgVHJhY2tJbmZvKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nOiBzdHJpbmcsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBUcmFja0luZm8ge1xuICAgIHJldHVybiBuZXcgVHJhY2tJbmZvKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZXF1YWxzKGE6IFRyYWNrSW5mbyB8IFBsYWluTWVzc2FnZTxUcmFja0luZm8+IHwgdW5kZWZpbmVkLCBiOiBUcmFja0luZm8gfCBQbGFpbk1lc3NhZ2U8VHJhY2tJbmZvPiB8IHVuZGVmaW5lZCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoVHJhY2tJbmZvLCBhLCBiKTtcbiAgfVxufVxuXG4vKipcbiAqIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgYXZhaWxhYmxlIHNwYXRpYWwgbGF5ZXJzXG4gKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5WaWRlb0xheWVyXG4gKi9cbmV4cG9ydCBjbGFzcyBWaWRlb0xheWVyIGV4dGVuZHMgTWVzc2FnZTxWaWRlb0xheWVyPiB7XG4gIC8qKlxuICAgKiBmb3IgdHJhY2tzIHdpdGggYSBzaW5nbGUgbGF5ZXIsIHRoaXMgc2hvdWxkIGJlIEhJR0hcbiAgICpcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LlZpZGVvUXVhbGl0eSBxdWFsaXR5ID0gMTtcbiAgICovXG4gIHF1YWxpdHkgPSBWaWRlb1F1YWxpdHkuTE9XO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiB3aWR0aCA9IDI7XG4gICAqL1xuICB3aWR0aCA9IDA7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIGhlaWdodCA9IDM7XG4gICAqL1xuICBoZWlnaHQgPSAwO1xuXG4gIC8qKlxuICAgKiB0YXJnZXQgYml0cmF0ZSBpbiBiaXQgcGVyIHNlY29uZCAoYnBzKSwgc2VydmVyIHdpbGwgbWVhc3VyZSBhY3R1YWxcbiAgICpcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50MzIgYml0cmF0ZSA9IDQ7XG4gICAqL1xuICBiaXRyYXRlID0gMDtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50MzIgc3NyYyA9IDU7XG4gICAqL1xuICBzc3JjID0gMDtcblxuICBjb25zdHJ1Y3RvcihkYXRhPzogUGFydGlhbE1lc3NhZ2U8VmlkZW9MYXllcj4pIHtcbiAgICBzdXBlcigpO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG5cbiAgc3RhdGljIHJlYWRvbmx5IHJ1bnRpbWU6IHR5cGVvZiBwcm90bzMgPSBwcm90bzM7XG4gIHN0YXRpYyByZWFkb25seSB0eXBlTmFtZSA9IFwibGl2ZWtpdC5WaWRlb0xheWVyXCI7XG4gIHN0YXRpYyByZWFkb25seSBmaWVsZHM6IEZpZWxkTGlzdCA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJxdWFsaXR5XCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoVmlkZW9RdWFsaXR5KSB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwid2lkdGhcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi8gfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcImhlaWdodFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqLyB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwiYml0cmF0ZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqLyB9LFxuICAgIHsgbm86IDUsIG5hbWU6IFwic3NyY1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqLyB9LFxuICBdKTtcblxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlczogVWludDhBcnJheSwgb3B0aW9ucz86IFBhcnRpYWw8QmluYXJ5UmVhZE9wdGlvbnM+KTogVmlkZW9MYXllciB7XG4gICAgcmV0dXJuIG5ldyBWaWRlb0xheWVyKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlOiBKc29uVmFsdWUsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBWaWRlb0xheWVyIHtcbiAgICByZXR1cm4gbmV3IFZpZGVvTGF5ZXIoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmc6IHN0cmluZywgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IFZpZGVvTGF5ZXIge1xuICAgIHJldHVybiBuZXcgVmlkZW9MYXllcigpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGVxdWFscyhhOiBWaWRlb0xheWVyIHwgUGxhaW5NZXNzYWdlPFZpZGVvTGF5ZXI+IHwgdW5kZWZpbmVkLCBiOiBWaWRlb0xheWVyIHwgUGxhaW5NZXNzYWdlPFZpZGVvTGF5ZXI+IHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhWaWRlb0xheWVyLCBhLCBiKTtcbiAgfVxufVxuXG4vKipcbiAqIG5ldyBEYXRhUGFja2V0IEFQSVxuICpcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuRGF0YVBhY2tldFxuICovXG5leHBvcnQgY2xhc3MgRGF0YVBhY2tldCBleHRlbmRzIE1lc3NhZ2U8RGF0YVBhY2tldD4ge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LkRhdGFQYWNrZXQuS2luZCBraW5kID0gMTtcbiAgICovXG4gIGtpbmQgPSBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEU7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBvbmVvZiBsaXZla2l0LkRhdGFQYWNrZXQudmFsdWVcbiAgICovXG4gIHZhbHVlOiB7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LlVzZXJQYWNrZXQgdXNlciA9IDI7XG4gICAgICovXG4gICAgdmFsdWU6IFVzZXJQYWNrZXQ7XG4gICAgY2FzZTogXCJ1c2VyXCI7XG4gIH0gfCB7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LkFjdGl2ZVNwZWFrZXJVcGRhdGUgc3BlYWtlciA9IDM7XG4gICAgICovXG4gICAgdmFsdWU6IEFjdGl2ZVNwZWFrZXJVcGRhdGU7XG4gICAgY2FzZTogXCJzcGVha2VyXCI7XG4gIH0gfCB7IGNhc2U6IHVuZGVmaW5lZDsgdmFsdWU/OiB1bmRlZmluZWQgfSA9IHsgY2FzZTogdW5kZWZpbmVkIH07XG5cbiAgY29uc3RydWN0b3IoZGF0YT86IFBhcnRpYWxNZXNzYWdlPERhdGFQYWNrZXQ+KSB7XG4gICAgc3VwZXIoKTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuXG4gIHN0YXRpYyByZWFkb25seSBydW50aW1lOiB0eXBlb2YgcHJvdG8zID0gcHJvdG8zO1xuICBzdGF0aWMgcmVhZG9ubHkgdHlwZU5hbWUgPSBcImxpdmVraXQuRGF0YVBhY2tldFwiO1xuICBzdGF0aWMgcmVhZG9ubHkgZmllbGRzOiBGaWVsZExpc3QgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwia2luZFwiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLmdldEVudW1UeXBlKERhdGFQYWNrZXRfS2luZCkgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcInVzZXJcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFVzZXJQYWNrZXQsIG9uZW9mOiBcInZhbHVlXCIgfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcInNwZWFrZXJcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IEFjdGl2ZVNwZWFrZXJVcGRhdGUsIG9uZW9mOiBcInZhbHVlXCIgfSxcbiAgXSk7XG5cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXM6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBQYXJ0aWFsPEJpbmFyeVJlYWRPcHRpb25zPik6IERhdGFQYWNrZXQge1xuICAgIHJldHVybiBuZXcgRGF0YVBhY2tldCgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZTogSnNvblZhbHVlLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogRGF0YVBhY2tldCB7XG4gICAgcmV0dXJuIG5ldyBEYXRhUGFja2V0KCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nOiBzdHJpbmcsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBEYXRhUGFja2V0IHtcbiAgICByZXR1cm4gbmV3IERhdGFQYWNrZXQoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBlcXVhbHMoYTogRGF0YVBhY2tldCB8IFBsYWluTWVzc2FnZTxEYXRhUGFja2V0PiB8IHVuZGVmaW5lZCwgYjogRGF0YVBhY2tldCB8IFBsYWluTWVzc2FnZTxEYXRhUGFja2V0PiB8IHVuZGVmaW5lZCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoRGF0YVBhY2tldCwgYSwgYik7XG4gIH1cbn1cblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gZW51bSBsaXZla2l0LkRhdGFQYWNrZXQuS2luZFxuICovXG5leHBvcnQgZW51bSBEYXRhUGFja2V0X0tpbmQge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFJFTElBQkxFID0gMDtcbiAgICovXG4gIFJFTElBQkxFID0gMCxcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IExPU1NZID0gMTtcbiAgICovXG4gIExPU1NZID0gMSxcbn1cbi8vIFJldHJpZXZlIGVudW0gbWV0YWRhdGEgd2l0aDogcHJvdG8zLmdldEVudW1UeXBlKERhdGFQYWNrZXRfS2luZClcbnByb3RvMy51dGlsLnNldEVudW1UeXBlKERhdGFQYWNrZXRfS2luZCwgXCJsaXZla2l0LkRhdGFQYWNrZXQuS2luZFwiLCBbXG4gIHsgbm86IDAsIG5hbWU6IFwiUkVMSUFCTEVcIiB9LFxuICB7IG5vOiAxLCBuYW1lOiBcIkxPU1NZXCIgfSxcbl0pO1xuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuQWN0aXZlU3BlYWtlclVwZGF0ZVxuICovXG5leHBvcnQgY2xhc3MgQWN0aXZlU3BlYWtlclVwZGF0ZSBleHRlbmRzIE1lc3NhZ2U8QWN0aXZlU3BlYWtlclVwZGF0ZT4ge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBsaXZla2l0LlNwZWFrZXJJbmZvIHNwZWFrZXJzID0gMTtcbiAgICovXG4gIHNwZWFrZXJzOiBTcGVha2VySW5mb1tdID0gW107XG5cbiAgY29uc3RydWN0b3IoZGF0YT86IFBhcnRpYWxNZXNzYWdlPEFjdGl2ZVNwZWFrZXJVcGRhdGU+KSB7XG4gICAgc3VwZXIoKTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuXG4gIHN0YXRpYyByZWFkb25seSBydW50aW1lOiB0eXBlb2YgcHJvdG8zID0gcHJvdG8zO1xuICBzdGF0aWMgcmVhZG9ubHkgdHlwZU5hbWUgPSBcImxpdmVraXQuQWN0aXZlU3BlYWtlclVwZGF0ZVwiO1xuICBzdGF0aWMgcmVhZG9ubHkgZmllbGRzOiBGaWVsZExpc3QgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwic3BlYWtlcnNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFNwZWFrZXJJbmZvLCByZXBlYXRlZDogdHJ1ZSB9LFxuICBdKTtcblxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlczogVWludDhBcnJheSwgb3B0aW9ucz86IFBhcnRpYWw8QmluYXJ5UmVhZE9wdGlvbnM+KTogQWN0aXZlU3BlYWtlclVwZGF0ZSB7XG4gICAgcmV0dXJuIG5ldyBBY3RpdmVTcGVha2VyVXBkYXRlKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlOiBKc29uVmFsdWUsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBBY3RpdmVTcGVha2VyVXBkYXRlIHtcbiAgICByZXR1cm4gbmV3IEFjdGl2ZVNwZWFrZXJVcGRhdGUoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmc6IHN0cmluZywgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IEFjdGl2ZVNwZWFrZXJVcGRhdGUge1xuICAgIHJldHVybiBuZXcgQWN0aXZlU3BlYWtlclVwZGF0ZSgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGVxdWFscyhhOiBBY3RpdmVTcGVha2VyVXBkYXRlIHwgUGxhaW5NZXNzYWdlPEFjdGl2ZVNwZWFrZXJVcGRhdGU+IHwgdW5kZWZpbmVkLCBiOiBBY3RpdmVTcGVha2VyVXBkYXRlIHwgUGxhaW5NZXNzYWdlPEFjdGl2ZVNwZWFrZXJVcGRhdGU+IHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhBY3RpdmVTcGVha2VyVXBkYXRlLCBhLCBiKTtcbiAgfVxufVxuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuU3BlYWtlckluZm9cbiAqL1xuZXhwb3J0IGNsYXNzIFNwZWFrZXJJbmZvIGV4dGVuZHMgTWVzc2FnZTxTcGVha2VySW5mbz4ge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgc2lkID0gMTtcbiAgICovXG4gIHNpZCA9IFwiXCI7XG5cbiAgLyoqXG4gICAqIGF1ZGlvIGxldmVsLCAwLTEuMCwgMSBpcyBsb3VkZXN0XG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogZmxvYXQgbGV2ZWwgPSAyO1xuICAgKi9cbiAgbGV2ZWwgPSAwO1xuXG4gIC8qKlxuICAgKiB0cnVlIGlmIHNwZWFrZXIgaXMgY3VycmVudGx5IGFjdGl2ZVxuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGJvb2wgYWN0aXZlID0gMztcbiAgICovXG4gIGFjdGl2ZSA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKGRhdGE/OiBQYXJ0aWFsTWVzc2FnZTxTcGVha2VySW5mbz4pIHtcbiAgICBzdXBlcigpO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG5cbiAgc3RhdGljIHJlYWRvbmx5IHJ1bnRpbWU6IHR5cGVvZiBwcm90bzMgPSBwcm90bzM7XG4gIHN0YXRpYyByZWFkb25seSB0eXBlTmFtZSA9IFwibGl2ZWtpdC5TcGVha2VySW5mb1wiO1xuICBzdGF0aWMgcmVhZG9ubHkgZmllbGRzOiBGaWVsZExpc3QgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwic2lkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcImxldmVsXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDIgLyogU2NhbGFyVHlwZS5GTE9BVCAqLyB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwiYWN0aXZlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovIH0sXG4gIF0pO1xuXG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzOiBVaW50OEFycmF5LCBvcHRpb25zPzogUGFydGlhbDxCaW5hcnlSZWFkT3B0aW9ucz4pOiBTcGVha2VySW5mbyB7XG4gICAgcmV0dXJuIG5ldyBTcGVha2VySW5mbygpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZTogSnNvblZhbHVlLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogU3BlYWtlckluZm8ge1xuICAgIHJldHVybiBuZXcgU3BlYWtlckluZm8oKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmc6IHN0cmluZywgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IFNwZWFrZXJJbmZvIHtcbiAgICByZXR1cm4gbmV3IFNwZWFrZXJJbmZvKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZXF1YWxzKGE6IFNwZWFrZXJJbmZvIHwgUGxhaW5NZXNzYWdlPFNwZWFrZXJJbmZvPiB8IHVuZGVmaW5lZCwgYjogU3BlYWtlckluZm8gfCBQbGFpbk1lc3NhZ2U8U3BlYWtlckluZm8+IHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhTcGVha2VySW5mbywgYSwgYik7XG4gIH1cbn1cblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlVzZXJQYWNrZXRcbiAqL1xuZXhwb3J0IGNsYXNzIFVzZXJQYWNrZXQgZXh0ZW5kcyBNZXNzYWdlPFVzZXJQYWNrZXQ+IHtcbiAgLyoqXG4gICAqIHBhcnRpY2lwYW50IElEIG9mIHVzZXIgdGhhdCBzZW50IHRoZSBtZXNzYWdlXG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHBhcnRpY2lwYW50X3NpZCA9IDE7XG4gICAqL1xuICBwYXJ0aWNpcGFudFNpZCA9IFwiXCI7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHBhcnRpY2lwYW50X2lkZW50aXR5ID0gNTtcbiAgICovXG4gIHBhcnRpY2lwYW50SWRlbnRpdHkgPSBcIlwiO1xuXG4gIC8qKlxuICAgKiB1c2VyIGRlZmluZWQgcGF5bG9hZFxuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGJ5dGVzIHBheWxvYWQgPSAyO1xuICAgKi9cbiAgcGF5bG9hZCA9IG5ldyBVaW50OEFycmF5KDApO1xuXG4gIC8qKlxuICAgKiB0aGUgSUQgb2YgdGhlIHBhcnRpY2lwYW50cyB3aG8gd2lsbCByZWNlaXZlIHRoZSBtZXNzYWdlIChzZW50IHRvIGFsbCBieSBkZWZhdWx0KVxuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIHN0cmluZyBkZXN0aW5hdGlvbl9zaWRzID0gMztcbiAgICovXG4gIGRlc3RpbmF0aW9uU2lkczogc3RyaW5nW10gPSBbXTtcblxuICAvKipcbiAgICogaWRlbnRpdGllcyBvZiBwYXJ0aWNpcGFudHMgd2hvIHdpbGwgcmVjZWl2ZSB0aGUgbWVzc2FnZSAoc2VudCB0byBhbGwgYnkgZGVmYXVsdClcbiAgICpcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBzdHJpbmcgZGVzdGluYXRpb25faWRlbnRpdGllcyA9IDY7XG4gICAqL1xuICBkZXN0aW5hdGlvbklkZW50aXRpZXM6IHN0cmluZ1tdID0gW107XG5cbiAgLyoqXG4gICAqIHRvcGljIHVuZGVyIHdoaWNoIHRoZSBtZXNzYWdlIHdhcyBwdWJsaXNoZWRcbiAgICpcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBvcHRpb25hbCBzdHJpbmcgdG9waWMgPSA0O1xuICAgKi9cbiAgdG9waWM/OiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoZGF0YT86IFBhcnRpYWxNZXNzYWdlPFVzZXJQYWNrZXQ+KSB7XG4gICAgc3VwZXIoKTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuXG4gIHN0YXRpYyByZWFkb25seSBydW50aW1lOiB0eXBlb2YgcHJvdG8zID0gcHJvdG8zO1xuICBzdGF0aWMgcmVhZG9ubHkgdHlwZU5hbWUgPSBcImxpdmVraXQuVXNlclBhY2tldFwiO1xuICBzdGF0aWMgcmVhZG9ubHkgZmllbGRzOiBGaWVsZExpc3QgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwicGFydGljaXBhbnRfc2lkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiA1LCBuYW1lOiBcInBhcnRpY2lwYW50X2lkZW50aXR5XCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcInBheWxvYWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMTIgLyogU2NhbGFyVHlwZS5CWVRFUyAqLyB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwiZGVzdGluYXRpb25fc2lkc1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovLCByZXBlYXRlZDogdHJ1ZSB9LFxuICAgIHsgbm86IDYsIG5hbWU6IFwiZGVzdGluYXRpb25faWRlbnRpdGllc1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovLCByZXBlYXRlZDogdHJ1ZSB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwidG9waWNcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLywgb3B0OiB0cnVlIH0sXG4gIF0pO1xuXG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzOiBVaW50OEFycmF5LCBvcHRpb25zPzogUGFydGlhbDxCaW5hcnlSZWFkT3B0aW9ucz4pOiBVc2VyUGFja2V0IHtcbiAgICByZXR1cm4gbmV3IFVzZXJQYWNrZXQoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWU6IEpzb25WYWx1ZSwgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IFVzZXJQYWNrZXQge1xuICAgIHJldHVybiBuZXcgVXNlclBhY2tldCgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZzogc3RyaW5nLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogVXNlclBhY2tldCB7XG4gICAgcmV0dXJuIG5ldyBVc2VyUGFja2V0KCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZXF1YWxzKGE6IFVzZXJQYWNrZXQgfCBQbGFpbk1lc3NhZ2U8VXNlclBhY2tldD4gfCB1bmRlZmluZWQsIGI6IFVzZXJQYWNrZXQgfCBQbGFpbk1lc3NhZ2U8VXNlclBhY2tldD4gfCB1bmRlZmluZWQpOiBib29sZWFuIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFVzZXJQYWNrZXQsIGEsIGIpO1xuICB9XG59XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5QYXJ0aWNpcGFudFRyYWNrc1xuICovXG5leHBvcnQgY2xhc3MgUGFydGljaXBhbnRUcmFja3MgZXh0ZW5kcyBNZXNzYWdlPFBhcnRpY2lwYW50VHJhY2tzPiB7XG4gIC8qKlxuICAgKiBwYXJ0aWNpcGFudCBJRCBvZiBwYXJ0aWNpcGFudCB0byB3aG9tIHRoZSB0cmFja3MgYmVsb25nXG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHBhcnRpY2lwYW50X3NpZCA9IDE7XG4gICAqL1xuICBwYXJ0aWNpcGFudFNpZCA9IFwiXCI7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgc3RyaW5nIHRyYWNrX3NpZHMgPSAyO1xuICAgKi9cbiAgdHJhY2tTaWRzOiBzdHJpbmdbXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKGRhdGE/OiBQYXJ0aWFsTWVzc2FnZTxQYXJ0aWNpcGFudFRyYWNrcz4pIHtcbiAgICBzdXBlcigpO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG5cbiAgc3RhdGljIHJlYWRvbmx5IHJ1bnRpbWU6IHR5cGVvZiBwcm90bzMgPSBwcm90bzM7XG4gIHN0YXRpYyByZWFkb25seSB0eXBlTmFtZSA9IFwibGl2ZWtpdC5QYXJ0aWNpcGFudFRyYWNrc1wiO1xuICBzdGF0aWMgcmVhZG9ubHkgZmllbGRzOiBGaWVsZExpc3QgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwicGFydGljaXBhbnRfc2lkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcInRyYWNrX3NpZHNcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLywgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgXSk7XG5cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXM6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBQYXJ0aWFsPEJpbmFyeVJlYWRPcHRpb25zPik6IFBhcnRpY2lwYW50VHJhY2tzIHtcbiAgICByZXR1cm4gbmV3IFBhcnRpY2lwYW50VHJhY2tzKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlOiBKc29uVmFsdWUsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBQYXJ0aWNpcGFudFRyYWNrcyB7XG4gICAgcmV0dXJuIG5ldyBQYXJ0aWNpcGFudFRyYWNrcygpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZzogc3RyaW5nLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogUGFydGljaXBhbnRUcmFja3Mge1xuICAgIHJldHVybiBuZXcgUGFydGljaXBhbnRUcmFja3MoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBlcXVhbHMoYTogUGFydGljaXBhbnRUcmFja3MgfCBQbGFpbk1lc3NhZ2U8UGFydGljaXBhbnRUcmFja3M+IHwgdW5kZWZpbmVkLCBiOiBQYXJ0aWNpcGFudFRyYWNrcyB8IFBsYWluTWVzc2FnZTxQYXJ0aWNpcGFudFRyYWNrcz4gfCB1bmRlZmluZWQpOiBib29sZWFuIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFBhcnRpY2lwYW50VHJhY2tzLCBhLCBiKTtcbiAgfVxufVxuXG4vKipcbiAqIGRldGFpbHMgYWJvdXQgdGhlIHNlcnZlclxuICpcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuU2VydmVySW5mb1xuICovXG5leHBvcnQgY2xhc3MgU2VydmVySW5mbyBleHRlbmRzIE1lc3NhZ2U8U2VydmVySW5mbz4ge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LlNlcnZlckluZm8uRWRpdGlvbiBlZGl0aW9uID0gMTtcbiAgICovXG4gIGVkaXRpb24gPSBTZXJ2ZXJJbmZvX0VkaXRpb24uU3RhbmRhcmQ7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHZlcnNpb24gPSAyO1xuICAgKi9cbiAgdmVyc2lvbiA9IFwiXCI7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogaW50MzIgcHJvdG9jb2wgPSAzO1xuICAgKi9cbiAgcHJvdG9jb2wgPSAwO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyByZWdpb24gPSA0O1xuICAgKi9cbiAgcmVnaW9uID0gXCJcIjtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgbm9kZV9pZCA9IDU7XG4gICAqL1xuICBub2RlSWQgPSBcIlwiO1xuXG4gIC8qKlxuICAgKiBhZGRpdGlvbmFsIGRlYnVnZ2luZyBpbmZvcm1hdGlvbi4gc2VudCBvbmx5IGlmIHNlcnZlciBpcyBpbiBkZXZlbG9wbWVudCBtb2RlXG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIGRlYnVnX2luZm8gPSA2O1xuICAgKi9cbiAgZGVidWdJbmZvID0gXCJcIjtcblxuICBjb25zdHJ1Y3RvcihkYXRhPzogUGFydGlhbE1lc3NhZ2U8U2VydmVySW5mbz4pIHtcbiAgICBzdXBlcigpO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG5cbiAgc3RhdGljIHJlYWRvbmx5IHJ1bnRpbWU6IHR5cGVvZiBwcm90bzMgPSBwcm90bzM7XG4gIHN0YXRpYyByZWFkb25seSB0eXBlTmFtZSA9IFwibGl2ZWtpdC5TZXJ2ZXJJbmZvXCI7XG4gIHN0YXRpYyByZWFkb25seSBmaWVsZHM6IEZpZWxkTGlzdCA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJlZGl0aW9uXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoU2VydmVySW5mb19FZGl0aW9uKSB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwidmVyc2lvblwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJwcm90b2NvbFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA1IC8qIFNjYWxhclR5cGUuSU5UMzIgKi8gfSxcbiAgICB7IG5vOiA0LCBuYW1lOiBcInJlZ2lvblwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogNSwgbmFtZTogXCJub2RlX2lkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiA2LCBuYW1lOiBcImRlYnVnX2luZm9cIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICBdKTtcblxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlczogVWludDhBcnJheSwgb3B0aW9ucz86IFBhcnRpYWw8QmluYXJ5UmVhZE9wdGlvbnM+KTogU2VydmVySW5mbyB7XG4gICAgcmV0dXJuIG5ldyBTZXJ2ZXJJbmZvKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlOiBKc29uVmFsdWUsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBTZXJ2ZXJJbmZvIHtcbiAgICByZXR1cm4gbmV3IFNlcnZlckluZm8oKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmc6IHN0cmluZywgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IFNlcnZlckluZm8ge1xuICAgIHJldHVybiBuZXcgU2VydmVySW5mbygpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGVxdWFscyhhOiBTZXJ2ZXJJbmZvIHwgUGxhaW5NZXNzYWdlPFNlcnZlckluZm8+IHwgdW5kZWZpbmVkLCBiOiBTZXJ2ZXJJbmZvIHwgUGxhaW5NZXNzYWdlPFNlcnZlckluZm8+IHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhTZXJ2ZXJJbmZvLCBhLCBiKTtcbiAgfVxufVxuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIGxpdmVraXQuU2VydmVySW5mby5FZGl0aW9uXG4gKi9cbmV4cG9ydCBlbnVtIFNlcnZlckluZm9fRWRpdGlvbiB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogU3RhbmRhcmQgPSAwO1xuICAgKi9cbiAgU3RhbmRhcmQgPSAwLFxuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogQ2xvdWQgPSAxO1xuICAgKi9cbiAgQ2xvdWQgPSAxLFxufVxuLy8gUmV0cmlldmUgZW51bSBtZXRhZGF0YSB3aXRoOiBwcm90bzMuZ2V0RW51bVR5cGUoU2VydmVySW5mb19FZGl0aW9uKVxucHJvdG8zLnV0aWwuc2V0RW51bVR5cGUoU2VydmVySW5mb19FZGl0aW9uLCBcImxpdmVraXQuU2VydmVySW5mby5FZGl0aW9uXCIsIFtcbiAgeyBubzogMCwgbmFtZTogXCJTdGFuZGFyZFwiIH0sXG4gIHsgbm86IDEsIG5hbWU6IFwiQ2xvdWRcIiB9LFxuXSk7XG5cbi8qKlxuICogZGV0YWlscyBhYm91dCB0aGUgY2xpZW50XG4gKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5DbGllbnRJbmZvXG4gKi9cbmV4cG9ydCBjbGFzcyBDbGllbnRJbmZvIGV4dGVuZHMgTWVzc2FnZTxDbGllbnRJbmZvPiB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuQ2xpZW50SW5mby5TREsgc2RrID0gMTtcbiAgICovXG4gIHNkayA9IENsaWVudEluZm9fU0RLLlVOS05PV047XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHZlcnNpb24gPSAyO1xuICAgKi9cbiAgdmVyc2lvbiA9IFwiXCI7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogaW50MzIgcHJvdG9jb2wgPSAzO1xuICAgKi9cbiAgcHJvdG9jb2wgPSAwO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBvcyA9IDQ7XG4gICAqL1xuICBvcyA9IFwiXCI7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIG9zX3ZlcnNpb24gPSA1O1xuICAgKi9cbiAgb3NWZXJzaW9uID0gXCJcIjtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgZGV2aWNlX21vZGVsID0gNjtcbiAgICovXG4gIGRldmljZU1vZGVsID0gXCJcIjtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgYnJvd3NlciA9IDc7XG4gICAqL1xuICBicm93c2VyID0gXCJcIjtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgYnJvd3Nlcl92ZXJzaW9uID0gODtcbiAgICovXG4gIGJyb3dzZXJWZXJzaW9uID0gXCJcIjtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgYWRkcmVzcyA9IDk7XG4gICAqL1xuICBhZGRyZXNzID0gXCJcIjtcblxuICAvKipcbiAgICogd2lmaSwgd2lyZWQsIGNlbGx1bGFyLCB2cG4sIGVtcHR5IGlmIG5vdCBrbm93blxuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBuZXR3b3JrID0gMTA7XG4gICAqL1xuICBuZXR3b3JrID0gXCJcIjtcblxuICBjb25zdHJ1Y3RvcihkYXRhPzogUGFydGlhbE1lc3NhZ2U8Q2xpZW50SW5mbz4pIHtcbiAgICBzdXBlcigpO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG5cbiAgc3RhdGljIHJlYWRvbmx5IHJ1bnRpbWU6IHR5cGVvZiBwcm90bzMgPSBwcm90bzM7XG4gIHN0YXRpYyByZWFkb25seSB0eXBlTmFtZSA9IFwibGl2ZWtpdC5DbGllbnRJbmZvXCI7XG4gIHN0YXRpYyByZWFkb25seSBmaWVsZHM6IEZpZWxkTGlzdCA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJzZGtcIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShDbGllbnRJbmZvX1NESykgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcInZlcnNpb25cIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwicHJvdG9jb2xcIiwga2luZDogXCJzY2FsYXJcIiwgVDogNSAvKiBTY2FsYXJUeXBlLklOVDMyICovIH0sXG4gICAgeyBubzogNCwgbmFtZTogXCJvc1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogNSwgbmFtZTogXCJvc192ZXJzaW9uXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiA2LCBuYW1lOiBcImRldmljZV9tb2RlbFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogNywgbmFtZTogXCJicm93c2VyXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiA4LCBuYW1lOiBcImJyb3dzZXJfdmVyc2lvblwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogOSwgbmFtZTogXCJhZGRyZXNzXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAxMCwgbmFtZTogXCJuZXR3b3JrXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgXSk7XG5cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXM6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBQYXJ0aWFsPEJpbmFyeVJlYWRPcHRpb25zPik6IENsaWVudEluZm8ge1xuICAgIHJldHVybiBuZXcgQ2xpZW50SW5mbygpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZTogSnNvblZhbHVlLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogQ2xpZW50SW5mbyB7XG4gICAgcmV0dXJuIG5ldyBDbGllbnRJbmZvKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nOiBzdHJpbmcsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBDbGllbnRJbmZvIHtcbiAgICByZXR1cm4gbmV3IENsaWVudEluZm8oKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBlcXVhbHMoYTogQ2xpZW50SW5mbyB8IFBsYWluTWVzc2FnZTxDbGllbnRJbmZvPiB8IHVuZGVmaW5lZCwgYjogQ2xpZW50SW5mbyB8IFBsYWluTWVzc2FnZTxDbGllbnRJbmZvPiB8IHVuZGVmaW5lZCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoQ2xpZW50SW5mbywgYSwgYik7XG4gIH1cbn1cblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gZW51bSBsaXZla2l0LkNsaWVudEluZm8uU0RLXG4gKi9cbmV4cG9ydCBlbnVtIENsaWVudEluZm9fU0RLIHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBVTktOT1dOID0gMDtcbiAgICovXG4gIFVOS05PV04gPSAwLFxuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogSlMgPSAxO1xuICAgKi9cbiAgSlMgPSAxLFxuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogU1dJRlQgPSAyO1xuICAgKi9cbiAgU1dJRlQgPSAyLFxuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogQU5EUk9JRCA9IDM7XG4gICAqL1xuICBBTkRST0lEID0gMyxcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IEZMVVRURVIgPSA0O1xuICAgKi9cbiAgRkxVVFRFUiA9IDQsXG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBHTyA9IDU7XG4gICAqL1xuICBHTyA9IDUsXG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBVTklUWSA9IDY7XG4gICAqL1xuICBVTklUWSA9IDYsXG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBSRUFDVF9OQVRJVkUgPSA3O1xuICAgKi9cbiAgUkVBQ1RfTkFUSVZFID0gNyxcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFJVU1QgPSA4O1xuICAgKi9cbiAgUlVTVCA9IDgsXG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBQWVRIT04gPSA5O1xuICAgKi9cbiAgUFlUSE9OID0gOSxcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IENQUCA9IDEwO1xuICAgKi9cbiAgQ1BQID0gMTAsXG59XG4vLyBSZXRyaWV2ZSBlbnVtIG1ldGFkYXRhIHdpdGg6IHByb3RvMy5nZXRFbnVtVHlwZShDbGllbnRJbmZvX1NESylcbnByb3RvMy51dGlsLnNldEVudW1UeXBlKENsaWVudEluZm9fU0RLLCBcImxpdmVraXQuQ2xpZW50SW5mby5TREtcIiwgW1xuICB7IG5vOiAwLCBuYW1lOiBcIlVOS05PV05cIiB9LFxuICB7IG5vOiAxLCBuYW1lOiBcIkpTXCIgfSxcbiAgeyBubzogMiwgbmFtZTogXCJTV0lGVFwiIH0sXG4gIHsgbm86IDMsIG5hbWU6IFwiQU5EUk9JRFwiIH0sXG4gIHsgbm86IDQsIG5hbWU6IFwiRkxVVFRFUlwiIH0sXG4gIHsgbm86IDUsIG5hbWU6IFwiR09cIiB9LFxuICB7IG5vOiA2LCBuYW1lOiBcIlVOSVRZXCIgfSxcbiAgeyBubzogNywgbmFtZTogXCJSRUFDVF9OQVRJVkVcIiB9LFxuICB7IG5vOiA4LCBuYW1lOiBcIlJVU1RcIiB9LFxuICB7IG5vOiA5LCBuYW1lOiBcIlBZVEhPTlwiIH0sXG4gIHsgbm86IDEwLCBuYW1lOiBcIkNQUFwiIH0sXG5dKTtcblxuLyoqXG4gKiBzZXJ2ZXIgcHJvdmlkZWQgY2xpZW50IGNvbmZpZ3VyYXRpb25cbiAqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LkNsaWVudENvbmZpZ3VyYXRpb25cbiAqL1xuZXhwb3J0IGNsYXNzIENsaWVudENvbmZpZ3VyYXRpb24gZXh0ZW5kcyBNZXNzYWdlPENsaWVudENvbmZpZ3VyYXRpb24+IHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5WaWRlb0NvbmZpZ3VyYXRpb24gdmlkZW8gPSAxO1xuICAgKi9cbiAgdmlkZW8/OiBWaWRlb0NvbmZpZ3VyYXRpb247XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5WaWRlb0NvbmZpZ3VyYXRpb24gc2NyZWVuID0gMjtcbiAgICovXG4gIHNjcmVlbj86IFZpZGVvQ29uZmlndXJhdGlvbjtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LkNsaWVudENvbmZpZ1NldHRpbmcgcmVzdW1lX2Nvbm5lY3Rpb24gPSAzO1xuICAgKi9cbiAgcmVzdW1lQ29ubmVjdGlvbiA9IENsaWVudENvbmZpZ1NldHRpbmcuVU5TRVQ7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5EaXNhYmxlZENvZGVjcyBkaXNhYmxlZF9jb2RlY3MgPSA0O1xuICAgKi9cbiAgZGlzYWJsZWRDb2RlY3M/OiBEaXNhYmxlZENvZGVjcztcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LkNsaWVudENvbmZpZ1NldHRpbmcgZm9yY2VfcmVsYXkgPSA1O1xuICAgKi9cbiAgZm9yY2VSZWxheSA9IENsaWVudENvbmZpZ1NldHRpbmcuVU5TRVQ7XG5cbiAgY29uc3RydWN0b3IoZGF0YT86IFBhcnRpYWxNZXNzYWdlPENsaWVudENvbmZpZ3VyYXRpb24+KSB7XG4gICAgc3VwZXIoKTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuXG4gIHN0YXRpYyByZWFkb25seSBydW50aW1lOiB0eXBlb2YgcHJvdG8zID0gcHJvdG8zO1xuICBzdGF0aWMgcmVhZG9ubHkgdHlwZU5hbWUgPSBcImxpdmVraXQuQ2xpZW50Q29uZmlndXJhdGlvblwiO1xuICBzdGF0aWMgcmVhZG9ubHkgZmllbGRzOiBGaWVsZExpc3QgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwidmlkZW9cIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFZpZGVvQ29uZmlndXJhdGlvbiB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwic2NyZWVuXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBWaWRlb0NvbmZpZ3VyYXRpb24gfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcInJlc3VtZV9jb25uZWN0aW9uXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoQ2xpZW50Q29uZmlnU2V0dGluZykgfSxcbiAgICB7IG5vOiA0LCBuYW1lOiBcImRpc2FibGVkX2NvZGVjc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogRGlzYWJsZWRDb2RlY3MgfSxcbiAgICB7IG5vOiA1LCBuYW1lOiBcImZvcmNlX3JlbGF5XCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoQ2xpZW50Q29uZmlnU2V0dGluZykgfSxcbiAgXSk7XG5cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXM6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBQYXJ0aWFsPEJpbmFyeVJlYWRPcHRpb25zPik6IENsaWVudENvbmZpZ3VyYXRpb24ge1xuICAgIHJldHVybiBuZXcgQ2xpZW50Q29uZmlndXJhdGlvbigpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZTogSnNvblZhbHVlLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogQ2xpZW50Q29uZmlndXJhdGlvbiB7XG4gICAgcmV0dXJuIG5ldyBDbGllbnRDb25maWd1cmF0aW9uKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nOiBzdHJpbmcsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBDbGllbnRDb25maWd1cmF0aW9uIHtcbiAgICByZXR1cm4gbmV3IENsaWVudENvbmZpZ3VyYXRpb24oKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBlcXVhbHMoYTogQ2xpZW50Q29uZmlndXJhdGlvbiB8IFBsYWluTWVzc2FnZTxDbGllbnRDb25maWd1cmF0aW9uPiB8IHVuZGVmaW5lZCwgYjogQ2xpZW50Q29uZmlndXJhdGlvbiB8IFBsYWluTWVzc2FnZTxDbGllbnRDb25maWd1cmF0aW9uPiB8IHVuZGVmaW5lZCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoQ2xpZW50Q29uZmlndXJhdGlvbiwgYSwgYik7XG4gIH1cbn1cblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlZpZGVvQ29uZmlndXJhdGlvblxuICovXG5leHBvcnQgY2xhc3MgVmlkZW9Db25maWd1cmF0aW9uIGV4dGVuZHMgTWVzc2FnZTxWaWRlb0NvbmZpZ3VyYXRpb24+IHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5DbGllbnRDb25maWdTZXR0aW5nIGhhcmR3YXJlX2VuY29kZXIgPSAxO1xuICAgKi9cbiAgaGFyZHdhcmVFbmNvZGVyID0gQ2xpZW50Q29uZmlnU2V0dGluZy5VTlNFVDtcblxuICBjb25zdHJ1Y3RvcihkYXRhPzogUGFydGlhbE1lc3NhZ2U8VmlkZW9Db25maWd1cmF0aW9uPikge1xuICAgIHN1cGVyKCk7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cblxuICBzdGF0aWMgcmVhZG9ubHkgcnVudGltZTogdHlwZW9mIHByb3RvMyA9IHByb3RvMztcbiAgc3RhdGljIHJlYWRvbmx5IHR5cGVOYW1lID0gXCJsaXZla2l0LlZpZGVvQ29uZmlndXJhdGlvblwiO1xuICBzdGF0aWMgcmVhZG9ubHkgZmllbGRzOiBGaWVsZExpc3QgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwiaGFyZHdhcmVfZW5jb2RlclwiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLmdldEVudW1UeXBlKENsaWVudENvbmZpZ1NldHRpbmcpIH0sXG4gIF0pO1xuXG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzOiBVaW50OEFycmF5LCBvcHRpb25zPzogUGFydGlhbDxCaW5hcnlSZWFkT3B0aW9ucz4pOiBWaWRlb0NvbmZpZ3VyYXRpb24ge1xuICAgIHJldHVybiBuZXcgVmlkZW9Db25maWd1cmF0aW9uKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlOiBKc29uVmFsdWUsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBWaWRlb0NvbmZpZ3VyYXRpb24ge1xuICAgIHJldHVybiBuZXcgVmlkZW9Db25maWd1cmF0aW9uKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nOiBzdHJpbmcsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBWaWRlb0NvbmZpZ3VyYXRpb24ge1xuICAgIHJldHVybiBuZXcgVmlkZW9Db25maWd1cmF0aW9uKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZXF1YWxzKGE6IFZpZGVvQ29uZmlndXJhdGlvbiB8IFBsYWluTWVzc2FnZTxWaWRlb0NvbmZpZ3VyYXRpb24+IHwgdW5kZWZpbmVkLCBiOiBWaWRlb0NvbmZpZ3VyYXRpb24gfCBQbGFpbk1lc3NhZ2U8VmlkZW9Db25maWd1cmF0aW9uPiB8IHVuZGVmaW5lZCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoVmlkZW9Db25maWd1cmF0aW9uLCBhLCBiKTtcbiAgfVxufVxuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuRGlzYWJsZWRDb2RlY3NcbiAqL1xuZXhwb3J0IGNsYXNzIERpc2FibGVkQ29kZWNzIGV4dGVuZHMgTWVzc2FnZTxEaXNhYmxlZENvZGVjcz4ge1xuICAvKipcbiAgICogZGlzYWJsZWQgZm9yIGJvdGggcHVibGlzaCBhbmQgc3Vic2NyaWJlXG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgbGl2ZWtpdC5Db2RlYyBjb2RlY3MgPSAxO1xuICAgKi9cbiAgY29kZWNzOiBDb2RlY1tdID0gW107XG5cbiAgLyoqXG4gICAqIG9ubHkgZGlzYWJsZSBmb3IgcHVibGlzaFxuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGxpdmVraXQuQ29kZWMgcHVibGlzaCA9IDI7XG4gICAqL1xuICBwdWJsaXNoOiBDb2RlY1tdID0gW107XG5cbiAgY29uc3RydWN0b3IoZGF0YT86IFBhcnRpYWxNZXNzYWdlPERpc2FibGVkQ29kZWNzPikge1xuICAgIHN1cGVyKCk7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cblxuICBzdGF0aWMgcmVhZG9ubHkgcnVudGltZTogdHlwZW9mIHByb3RvMyA9IHByb3RvMztcbiAgc3RhdGljIHJlYWRvbmx5IHR5cGVOYW1lID0gXCJsaXZla2l0LkRpc2FibGVkQ29kZWNzXCI7XG4gIHN0YXRpYyByZWFkb25seSBmaWVsZHM6IEZpZWxkTGlzdCA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJjb2RlY3NcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IENvZGVjLCByZXBlYXRlZDogdHJ1ZSB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwicHVibGlzaFwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogQ29kZWMsIHJlcGVhdGVkOiB0cnVlIH0sXG4gIF0pO1xuXG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzOiBVaW50OEFycmF5LCBvcHRpb25zPzogUGFydGlhbDxCaW5hcnlSZWFkT3B0aW9ucz4pOiBEaXNhYmxlZENvZGVjcyB7XG4gICAgcmV0dXJuIG5ldyBEaXNhYmxlZENvZGVjcygpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZTogSnNvblZhbHVlLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogRGlzYWJsZWRDb2RlY3Mge1xuICAgIHJldHVybiBuZXcgRGlzYWJsZWRDb2RlY3MoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmc6IHN0cmluZywgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IERpc2FibGVkQ29kZWNzIHtcbiAgICByZXR1cm4gbmV3IERpc2FibGVkQ29kZWNzKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZXF1YWxzKGE6IERpc2FibGVkQ29kZWNzIHwgUGxhaW5NZXNzYWdlPERpc2FibGVkQ29kZWNzPiB8IHVuZGVmaW5lZCwgYjogRGlzYWJsZWRDb2RlY3MgfCBQbGFpbk1lc3NhZ2U8RGlzYWJsZWRDb2RlY3M+IHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhEaXNhYmxlZENvZGVjcywgYSwgYik7XG4gIH1cbn1cblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlJUUERyaWZ0XG4gKi9cbmV4cG9ydCBjbGFzcyBSVFBEcmlmdCBleHRlbmRzIE1lc3NhZ2U8UlRQRHJpZnQ+IHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCBzdGFydF90aW1lID0gMTtcbiAgICovXG4gIHN0YXJ0VGltZT86IFRpbWVzdGFtcDtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBnb29nbGUucHJvdG9idWYuVGltZXN0YW1wIGVuZF90aW1lID0gMjtcbiAgICovXG4gIGVuZFRpbWU/OiBUaW1lc3RhbXA7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogZG91YmxlIGR1cmF0aW9uID0gMztcbiAgICovXG4gIGR1cmF0aW9uID0gMDtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50NjQgc3RhcnRfdGltZXN0YW1wID0gNDtcbiAgICovXG4gIHN0YXJ0VGltZXN0YW1wID0gcHJvdG9JbnQ2NC56ZXJvO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQ2NCBlbmRfdGltZXN0YW1wID0gNTtcbiAgICovXG4gIGVuZFRpbWVzdGFtcCA9IHByb3RvSW50NjQuemVybztcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50NjQgcnRwX2Nsb2NrX3RpY2tzID0gNjtcbiAgICovXG4gIHJ0cENsb2NrVGlja3MgPSBwcm90b0ludDY0Lnplcm87XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogaW50NjQgZHJpZnRfc2FtcGxlcyA9IDc7XG4gICAqL1xuICBkcmlmdFNhbXBsZXMgPSBwcm90b0ludDY0Lnplcm87XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogZG91YmxlIGRyaWZ0X21zID0gODtcbiAgICovXG4gIGRyaWZ0TXMgPSAwO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGRvdWJsZSBjbG9ja19yYXRlID0gOTtcbiAgICovXG4gIGNsb2NrUmF0ZSA9IDA7XG5cbiAgY29uc3RydWN0b3IoZGF0YT86IFBhcnRpYWxNZXNzYWdlPFJUUERyaWZ0Pikge1xuICAgIHN1cGVyKCk7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cblxuICBzdGF0aWMgcmVhZG9ubHkgcnVudGltZTogdHlwZW9mIHByb3RvMyA9IHByb3RvMztcbiAgc3RhdGljIHJlYWRvbmx5IHR5cGVOYW1lID0gXCJsaXZla2l0LlJUUERyaWZ0XCI7XG4gIHN0YXRpYyByZWFkb25seSBmaWVsZHM6IEZpZWxkTGlzdCA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJzdGFydF90aW1lXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBUaW1lc3RhbXAgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcImVuZF90aW1lXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBUaW1lc3RhbXAgfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcImR1cmF0aW9uXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEgLyogU2NhbGFyVHlwZS5ET1VCTEUgKi8gfSxcbiAgICB7IG5vOiA0LCBuYW1lOiBcInN0YXJ0X3RpbWVzdGFtcFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA0IC8qIFNjYWxhclR5cGUuVUlOVDY0ICovIH0sXG4gICAgeyBubzogNSwgbmFtZTogXCJlbmRfdGltZXN0YW1wXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDQgLyogU2NhbGFyVHlwZS5VSU5UNjQgKi8gfSxcbiAgICB7IG5vOiA2LCBuYW1lOiBcInJ0cF9jbG9ja190aWNrc1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiA0IC8qIFNjYWxhclR5cGUuVUlOVDY0ICovIH0sXG4gICAgeyBubzogNywgbmFtZTogXCJkcmlmdF9zYW1wbGVzXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDMgLyogU2NhbGFyVHlwZS5JTlQ2NCAqLyB9LFxuICAgIHsgbm86IDgsIG5hbWU6IFwiZHJpZnRfbXNcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMSAvKiBTY2FsYXJUeXBlLkRPVUJMRSAqLyB9LFxuICAgIHsgbm86IDksIG5hbWU6IFwiY2xvY2tfcmF0ZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxIC8qIFNjYWxhclR5cGUuRE9VQkxFICovIH0sXG4gIF0pO1xuXG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzOiBVaW50OEFycmF5LCBvcHRpb25zPzogUGFydGlhbDxCaW5hcnlSZWFkT3B0aW9ucz4pOiBSVFBEcmlmdCB7XG4gICAgcmV0dXJuIG5ldyBSVFBEcmlmdCgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZTogSnNvblZhbHVlLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogUlRQRHJpZnQge1xuICAgIHJldHVybiBuZXcgUlRQRHJpZnQoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmc6IHN0cmluZywgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IFJUUERyaWZ0IHtcbiAgICByZXR1cm4gbmV3IFJUUERyaWZ0KCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZXF1YWxzKGE6IFJUUERyaWZ0IHwgUGxhaW5NZXNzYWdlPFJUUERyaWZ0PiB8IHVuZGVmaW5lZCwgYjogUlRQRHJpZnQgfCBQbGFpbk1lc3NhZ2U8UlRQRHJpZnQ+IHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhSVFBEcmlmdCwgYSwgYik7XG4gIH1cbn1cblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlJUUFN0YXRzXG4gKi9cbmV4cG9ydCBjbGFzcyBSVFBTdGF0cyBleHRlbmRzIE1lc3NhZ2U8UlRQU3RhdHM+IHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCBzdGFydF90aW1lID0gMTtcbiAgICovXG4gIHN0YXJ0VGltZT86IFRpbWVzdGFtcDtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBnb29nbGUucHJvdG9idWYuVGltZXN0YW1wIGVuZF90aW1lID0gMjtcbiAgICovXG4gIGVuZFRpbWU/OiBUaW1lc3RhbXA7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogZG91YmxlIGR1cmF0aW9uID0gMztcbiAgICovXG4gIGR1cmF0aW9uID0gMDtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50MzIgcGFja2V0cyA9IDQ7XG4gICAqL1xuICBwYWNrZXRzID0gMDtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBkb3VibGUgcGFja2V0X3JhdGUgPSA1O1xuICAgKi9cbiAgcGFja2V0UmF0ZSA9IDA7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDY0IGJ5dGVzID0gNjtcbiAgICovXG4gIGJ5dGVzID0gcHJvdG9JbnQ2NC56ZXJvO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQ2NCBoZWFkZXJfYnl0ZXMgPSAzOTtcbiAgICovXG4gIGhlYWRlckJ5dGVzID0gcHJvdG9JbnQ2NC56ZXJvO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGRvdWJsZSBiaXRyYXRlID0gNztcbiAgICovXG4gIGJpdHJhdGUgPSAwO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiBwYWNrZXRzX2xvc3QgPSA4O1xuICAgKi9cbiAgcGFja2V0c0xvc3QgPSAwO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGRvdWJsZSBwYWNrZXRfbG9zc19yYXRlID0gOTtcbiAgICovXG4gIHBhY2tldExvc3NSYXRlID0gMDtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBmbG9hdCBwYWNrZXRfbG9zc19wZXJjZW50YWdlID0gMTA7XG4gICAqL1xuICBwYWNrZXRMb3NzUGVyY2VudGFnZSA9IDA7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIHBhY2tldHNfZHVwbGljYXRlID0gMTE7XG4gICAqL1xuICBwYWNrZXRzRHVwbGljYXRlID0gMDtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBkb3VibGUgcGFja2V0X2R1cGxpY2F0ZV9yYXRlID0gMTI7XG4gICAqL1xuICBwYWNrZXREdXBsaWNhdGVSYXRlID0gMDtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50NjQgYnl0ZXNfZHVwbGljYXRlID0gMTM7XG4gICAqL1xuICBieXRlc0R1cGxpY2F0ZSA9IHByb3RvSW50NjQuemVybztcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50NjQgaGVhZGVyX2J5dGVzX2R1cGxpY2F0ZSA9IDQwO1xuICAgKi9cbiAgaGVhZGVyQnl0ZXNEdXBsaWNhdGUgPSBwcm90b0ludDY0Lnplcm87XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogZG91YmxlIGJpdHJhdGVfZHVwbGljYXRlID0gMTQ7XG4gICAqL1xuICBiaXRyYXRlRHVwbGljYXRlID0gMDtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50MzIgcGFja2V0c19wYWRkaW5nID0gMTU7XG4gICAqL1xuICBwYWNrZXRzUGFkZGluZyA9IDA7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogZG91YmxlIHBhY2tldF9wYWRkaW5nX3JhdGUgPSAxNjtcbiAgICovXG4gIHBhY2tldFBhZGRpbmdSYXRlID0gMDtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50NjQgYnl0ZXNfcGFkZGluZyA9IDE3O1xuICAgKi9cbiAgYnl0ZXNQYWRkaW5nID0gcHJvdG9JbnQ2NC56ZXJvO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQ2NCBoZWFkZXJfYnl0ZXNfcGFkZGluZyA9IDQxO1xuICAgKi9cbiAgaGVhZGVyQnl0ZXNQYWRkaW5nID0gcHJvdG9JbnQ2NC56ZXJvO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGRvdWJsZSBiaXRyYXRlX3BhZGRpbmcgPSAxODtcbiAgICovXG4gIGJpdHJhdGVQYWRkaW5nID0gMDtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50MzIgcGFja2V0c19vdXRfb2Zfb3JkZXIgPSAxOTtcbiAgICovXG4gIHBhY2tldHNPdXRPZk9yZGVyID0gMDtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50MzIgZnJhbWVzID0gMjA7XG4gICAqL1xuICBmcmFtZXMgPSAwO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGRvdWJsZSBmcmFtZV9yYXRlID0gMjE7XG4gICAqL1xuICBmcmFtZVJhdGUgPSAwO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGRvdWJsZSBqaXR0ZXJfY3VycmVudCA9IDIyO1xuICAgKi9cbiAgaml0dGVyQ3VycmVudCA9IDA7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogZG91YmxlIGppdHRlcl9tYXggPSAyMztcbiAgICovXG4gIGppdHRlck1heCA9IDA7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbWFwPGludDMyLCB1aW50MzI+IGdhcF9oaXN0b2dyYW0gPSAyNDtcbiAgICovXG4gIGdhcEhpc3RvZ3JhbTogeyBba2V5OiBudW1iZXJdOiBudW1iZXIgfSA9IHt9O1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiBuYWNrcyA9IDI1O1xuICAgKi9cbiAgbmFja3MgPSAwO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiBuYWNrX2Fja3MgPSAzNztcbiAgICovXG4gIG5hY2tBY2tzID0gMDtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50MzIgbmFja19taXNzZXMgPSAyNjtcbiAgICovXG4gIG5hY2tNaXNzZXMgPSAwO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiBuYWNrX3JlcGVhdGVkID0gMzg7XG4gICAqL1xuICBuYWNrUmVwZWF0ZWQgPSAwO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiBwbGlzID0gMjc7XG4gICAqL1xuICBwbGlzID0gMDtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBnb29nbGUucHJvdG9idWYuVGltZXN0YW1wIGxhc3RfcGxpID0gMjg7XG4gICAqL1xuICBsYXN0UGxpPzogVGltZXN0YW1wO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiBmaXJzID0gMjk7XG4gICAqL1xuICBmaXJzID0gMDtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBnb29nbGUucHJvdG9idWYuVGltZXN0YW1wIGxhc3RfZmlyID0gMzA7XG4gICAqL1xuICBsYXN0RmlyPzogVGltZXN0YW1wO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiBydHRfY3VycmVudCA9IDMxO1xuICAgKi9cbiAgcnR0Q3VycmVudCA9IDA7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIHJ0dF9tYXggPSAzMjtcbiAgICovXG4gIHJ0dE1heCA9IDA7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIGtleV9mcmFtZXMgPSAzMztcbiAgICovXG4gIGtleUZyYW1lcyA9IDA7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCBsYXN0X2tleV9mcmFtZSA9IDM0O1xuICAgKi9cbiAgbGFzdEtleUZyYW1lPzogVGltZXN0YW1wO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiBsYXllcl9sb2NrX3BsaXMgPSAzNTtcbiAgICovXG4gIGxheWVyTG9ja1BsaXMgPSAwO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAgbGFzdF9sYXllcl9sb2NrX3BsaSA9IDM2O1xuICAgKi9cbiAgbGFzdExheWVyTG9ja1BsaT86IFRpbWVzdGFtcDtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LlJUUERyaWZ0IHBhY2tldF9kcmlmdCA9IDQ0O1xuICAgKi9cbiAgcGFja2V0RHJpZnQ/OiBSVFBEcmlmdDtcblxuICAvKipcbiAgICogTkVYVF9JRDogNDZcbiAgICpcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LlJUUERyaWZ0IHJlcG9ydF9kcmlmdCA9IDQ1O1xuICAgKi9cbiAgcmVwb3J0RHJpZnQ/OiBSVFBEcmlmdDtcblxuICBjb25zdHJ1Y3RvcihkYXRhPzogUGFydGlhbE1lc3NhZ2U8UlRQU3RhdHM+KSB7XG4gICAgc3VwZXIoKTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuXG4gIHN0YXRpYyByZWFkb25seSBydW50aW1lOiB0eXBlb2YgcHJvdG8zID0gcHJvdG8zO1xuICBzdGF0aWMgcmVhZG9ubHkgdHlwZU5hbWUgPSBcImxpdmVraXQuUlRQU3RhdHNcIjtcbiAgc3RhdGljIHJlYWRvbmx5IGZpZWxkczogRmllbGRMaXN0ID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInN0YXJ0X3RpbWVcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFRpbWVzdGFtcCB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwiZW5kX3RpbWVcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFRpbWVzdGFtcCB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwiZHVyYXRpb25cIiwga2luZDogXCJzY2FsYXJcIiwgVDogMSAvKiBTY2FsYXJUeXBlLkRPVUJMRSAqLyB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwicGFja2V0c1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqLyB9LFxuICAgIHsgbm86IDUsIG5hbWU6IFwicGFja2V0X3JhdGVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMSAvKiBTY2FsYXJUeXBlLkRPVUJMRSAqLyB9LFxuICAgIHsgbm86IDYsIG5hbWU6IFwiYnl0ZXNcIiwga2luZDogXCJzY2FsYXJcIiwgVDogNCAvKiBTY2FsYXJUeXBlLlVJTlQ2NCAqLyB9LFxuICAgIHsgbm86IDM5LCBuYW1lOiBcImhlYWRlcl9ieXRlc1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiA0IC8qIFNjYWxhclR5cGUuVUlOVDY0ICovIH0sXG4gICAgeyBubzogNywgbmFtZTogXCJiaXRyYXRlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEgLyogU2NhbGFyVHlwZS5ET1VCTEUgKi8gfSxcbiAgICB7IG5vOiA4LCBuYW1lOiBcInBhY2tldHNfbG9zdFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqLyB9LFxuICAgIHsgbm86IDksIG5hbWU6IFwicGFja2V0X2xvc3NfcmF0ZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxIC8qIFNjYWxhclR5cGUuRE9VQkxFICovIH0sXG4gICAgeyBubzogMTAsIG5hbWU6IFwicGFja2V0X2xvc3NfcGVyY2VudGFnZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAyIC8qIFNjYWxhclR5cGUuRkxPQVQgKi8gfSxcbiAgICB7IG5vOiAxMSwgbmFtZTogXCJwYWNrZXRzX2R1cGxpY2F0ZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqLyB9LFxuICAgIHsgbm86IDEyLCBuYW1lOiBcInBhY2tldF9kdXBsaWNhdGVfcmF0ZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxIC8qIFNjYWxhclR5cGUuRE9VQkxFICovIH0sXG4gICAgeyBubzogMTMsIG5hbWU6IFwiYnl0ZXNfZHVwbGljYXRlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDQgLyogU2NhbGFyVHlwZS5VSU5UNjQgKi8gfSxcbiAgICB7IG5vOiA0MCwgbmFtZTogXCJoZWFkZXJfYnl0ZXNfZHVwbGljYXRlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDQgLyogU2NhbGFyVHlwZS5VSU5UNjQgKi8gfSxcbiAgICB7IG5vOiAxNCwgbmFtZTogXCJiaXRyYXRlX2R1cGxpY2F0ZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxIC8qIFNjYWxhclR5cGUuRE9VQkxFICovIH0sXG4gICAgeyBubzogMTUsIG5hbWU6IFwicGFja2V0c19wYWRkaW5nXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovIH0sXG4gICAgeyBubzogMTYsIG5hbWU6IFwicGFja2V0X3BhZGRpbmdfcmF0ZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxIC8qIFNjYWxhclR5cGUuRE9VQkxFICovIH0sXG4gICAgeyBubzogMTcsIG5hbWU6IFwiYnl0ZXNfcGFkZGluZ1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiA0IC8qIFNjYWxhclR5cGUuVUlOVDY0ICovIH0sXG4gICAgeyBubzogNDEsIG5hbWU6IFwiaGVhZGVyX2J5dGVzX3BhZGRpbmdcIiwga2luZDogXCJzY2FsYXJcIiwgVDogNCAvKiBTY2FsYXJUeXBlLlVJTlQ2NCAqLyB9LFxuICAgIHsgbm86IDE4LCBuYW1lOiBcImJpdHJhdGVfcGFkZGluZ1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxIC8qIFNjYWxhclR5cGUuRE9VQkxFICovIH0sXG4gICAgeyBubzogMTksIG5hbWU6IFwicGFja2V0c19vdXRfb2Zfb3JkZXJcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi8gfSxcbiAgICB7IG5vOiAyMCwgbmFtZTogXCJmcmFtZXNcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi8gfSxcbiAgICB7IG5vOiAyMSwgbmFtZTogXCJmcmFtZV9yYXRlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEgLyogU2NhbGFyVHlwZS5ET1VCTEUgKi8gfSxcbiAgICB7IG5vOiAyMiwgbmFtZTogXCJqaXR0ZXJfY3VycmVudFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxIC8qIFNjYWxhclR5cGUuRE9VQkxFICovIH0sXG4gICAgeyBubzogMjMsIG5hbWU6IFwiaml0dGVyX21heFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxIC8qIFNjYWxhclR5cGUuRE9VQkxFICovIH0sXG4gICAgeyBubzogMjQsIG5hbWU6IFwiZ2FwX2hpc3RvZ3JhbVwiLCBraW5kOiBcIm1hcFwiLCBLOiA1IC8qIFNjYWxhclR5cGUuSU5UMzIgKi8sIFY6IHtraW5kOiBcInNjYWxhclwiLCBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL30gfSxcbiAgICB7IG5vOiAyNSwgbmFtZTogXCJuYWNrc1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqLyB9LFxuICAgIHsgbm86IDM3LCBuYW1lOiBcIm5hY2tfYWNrc1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqLyB9LFxuICAgIHsgbm86IDI2LCBuYW1lOiBcIm5hY2tfbWlzc2VzXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovIH0sXG4gICAgeyBubzogMzgsIG5hbWU6IFwibmFja19yZXBlYXRlZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqLyB9LFxuICAgIHsgbm86IDI3LCBuYW1lOiBcInBsaXNcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi8gfSxcbiAgICB7IG5vOiAyOCwgbmFtZTogXCJsYXN0X3BsaVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVGltZXN0YW1wIH0sXG4gICAgeyBubzogMjksIG5hbWU6IFwiZmlyc1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqLyB9LFxuICAgIHsgbm86IDMwLCBuYW1lOiBcImxhc3RfZmlyXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBUaW1lc3RhbXAgfSxcbiAgICB7IG5vOiAzMSwgbmFtZTogXCJydHRfY3VycmVudFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqLyB9LFxuICAgIHsgbm86IDMyLCBuYW1lOiBcInJ0dF9tYXhcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi8gfSxcbiAgICB7IG5vOiAzMywgbmFtZTogXCJrZXlfZnJhbWVzXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovIH0sXG4gICAgeyBubzogMzQsIG5hbWU6IFwibGFzdF9rZXlfZnJhbWVcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFRpbWVzdGFtcCB9LFxuICAgIHsgbm86IDM1LCBuYW1lOiBcImxheWVyX2xvY2tfcGxpc1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqLyB9LFxuICAgIHsgbm86IDM2LCBuYW1lOiBcImxhc3RfbGF5ZXJfbG9ja19wbGlcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFRpbWVzdGFtcCB9LFxuICAgIHsgbm86IDQ0LCBuYW1lOiBcInBhY2tldF9kcmlmdFwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogUlRQRHJpZnQgfSxcbiAgICB7IG5vOiA0NSwgbmFtZTogXCJyZXBvcnRfZHJpZnRcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFJUUERyaWZ0IH0sXG4gIF0pO1xuXG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzOiBVaW50OEFycmF5LCBvcHRpb25zPzogUGFydGlhbDxCaW5hcnlSZWFkT3B0aW9ucz4pOiBSVFBTdGF0cyB7XG4gICAgcmV0dXJuIG5ldyBSVFBTdGF0cygpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZTogSnNvblZhbHVlLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogUlRQU3RhdHMge1xuICAgIHJldHVybiBuZXcgUlRQU3RhdHMoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmc6IHN0cmluZywgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IFJUUFN0YXRzIHtcbiAgICByZXR1cm4gbmV3IFJUUFN0YXRzKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZXF1YWxzKGE6IFJUUFN0YXRzIHwgUGxhaW5NZXNzYWdlPFJUUFN0YXRzPiB8IHVuZGVmaW5lZCwgYjogUlRQU3RhdHMgfCBQbGFpbk1lc3NhZ2U8UlRQU3RhdHM+IHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhSVFBTdGF0cywgYSwgYik7XG4gIH1cbn1cblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlRpbWVkVmVyc2lvblxuICovXG5leHBvcnQgY2xhc3MgVGltZWRWZXJzaW9uIGV4dGVuZHMgTWVzc2FnZTxUaW1lZFZlcnNpb24+IHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogaW50NjQgdW5peF9taWNybyA9IDE7XG4gICAqL1xuICB1bml4TWljcm8gPSBwcm90b0ludDY0Lnplcm87XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogaW50MzIgdGlja3MgPSAyO1xuICAgKi9cbiAgdGlja3MgPSAwO1xuXG4gIGNvbnN0cnVjdG9yKGRhdGE/OiBQYXJ0aWFsTWVzc2FnZTxUaW1lZFZlcnNpb24+KSB7XG4gICAgc3VwZXIoKTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuXG4gIHN0YXRpYyByZWFkb25seSBydW50aW1lOiB0eXBlb2YgcHJvdG8zID0gcHJvdG8zO1xuICBzdGF0aWMgcmVhZG9ubHkgdHlwZU5hbWUgPSBcImxpdmVraXQuVGltZWRWZXJzaW9uXCI7XG4gIHN0YXRpYyByZWFkb25seSBmaWVsZHM6IEZpZWxkTGlzdCA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJ1bml4X21pY3JvXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDMgLyogU2NhbGFyVHlwZS5JTlQ2NCAqLyB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwidGlja3NcIiwga2luZDogXCJzY2FsYXJcIiwgVDogNSAvKiBTY2FsYXJUeXBlLklOVDMyICovIH0sXG4gIF0pO1xuXG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzOiBVaW50OEFycmF5LCBvcHRpb25zPzogUGFydGlhbDxCaW5hcnlSZWFkT3B0aW9ucz4pOiBUaW1lZFZlcnNpb24ge1xuICAgIHJldHVybiBuZXcgVGltZWRWZXJzaW9uKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlOiBKc29uVmFsdWUsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBUaW1lZFZlcnNpb24ge1xuICAgIHJldHVybiBuZXcgVGltZWRWZXJzaW9uKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nOiBzdHJpbmcsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBUaW1lZFZlcnNpb24ge1xuICAgIHJldHVybiBuZXcgVGltZWRWZXJzaW9uKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZXF1YWxzKGE6IFRpbWVkVmVyc2lvbiB8IFBsYWluTWVzc2FnZTxUaW1lZFZlcnNpb24+IHwgdW5kZWZpbmVkLCBiOiBUaW1lZFZlcnNpb24gfCBQbGFpbk1lc3NhZ2U8VGltZWRWZXJzaW9uPiB8IHVuZGVmaW5lZCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoVGltZWRWZXJzaW9uLCBhLCBiKTtcbiAgfVxufVxuXG4iLCJpbXBvcnQgdHlwZSB7IFJlY29ubmVjdENvbnRleHQsIFJlY29ubmVjdFBvbGljeSB9IGZyb20gJy4vUmVjb25uZWN0UG9saWN5JztcblxuY29uc3QgbWF4UmV0cnlEZWxheSA9IDcwMDA7XG5cbmNvbnN0IERFRkFVTFRfUkVUUllfREVMQVlTX0lOX01TID0gW1xuICAwLFxuICAzMDAsXG4gIDIgKiAyICogMzAwLFxuICAzICogMyAqIDMwMCxcbiAgNCAqIDQgKiAzMDAsXG4gIG1heFJldHJ5RGVsYXksXG4gIG1heFJldHJ5RGVsYXksXG4gIG1heFJldHJ5RGVsYXksXG4gIG1heFJldHJ5RGVsYXksXG4gIG1heFJldHJ5RGVsYXksXG5dO1xuXG5jbGFzcyBEZWZhdWx0UmVjb25uZWN0UG9saWN5IGltcGxlbWVudHMgUmVjb25uZWN0UG9saWN5IHtcbiAgcHJpdmF0ZSByZWFkb25seSBfcmV0cnlEZWxheXM6IG51bWJlcltdO1xuXG4gIGNvbnN0cnVjdG9yKHJldHJ5RGVsYXlzPzogbnVtYmVyW10pIHtcbiAgICB0aGlzLl9yZXRyeURlbGF5cyA9IHJldHJ5RGVsYXlzICE9PSB1bmRlZmluZWQgPyBbLi4ucmV0cnlEZWxheXNdIDogREVGQVVMVF9SRVRSWV9ERUxBWVNfSU5fTVM7XG4gIH1cblxuICBwdWJsaWMgbmV4dFJldHJ5RGVsYXlJbk1zKGNvbnRleHQ6IFJlY29ubmVjdENvbnRleHQpOiBudW1iZXIgfCBudWxsIHtcbiAgICBpZiAoY29udGV4dC5yZXRyeUNvdW50ID49IHRoaXMuX3JldHJ5RGVsYXlzLmxlbmd0aCkgcmV0dXJuIG51bGw7XG5cbiAgICBjb25zdCByZXRyeURlbGF5ID0gdGhpcy5fcmV0cnlEZWxheXNbY29udGV4dC5yZXRyeUNvdW50XTtcbiAgICBpZiAoY29udGV4dC5yZXRyeUNvdW50IDw9IDEpIHJldHVybiByZXRyeURlbGF5O1xuXG4gICAgcmV0dXJuIHJldHJ5RGVsYXkgKyBNYXRoLnJhbmRvbSgpICogMV8wMDA7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRGVmYXVsdFJlY29ubmVjdFBvbGljeTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSID0gdHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnID8gUmVmbGVjdCA6IG51bGxcbnZhciBSZWZsZWN0QXBwbHkgPSBSICYmIHR5cGVvZiBSLmFwcGx5ID09PSAnZnVuY3Rpb24nXG4gID8gUi5hcHBseVxuICA6IGZ1bmN0aW9uIFJlZmxlY3RBcHBseSh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpO1xuICB9XG5cbnZhciBSZWZsZWN0T3duS2V5c1xuaWYgKFIgJiYgdHlwZW9mIFIub3duS2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWZsZWN0T3duS2V5cyA9IFIub3duS2V5c1xufSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldClcbiAgICAgIC5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKTtcbiAgfTtcbn0gZWxzZSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFByb2Nlc3NFbWl0V2FybmluZyh3YXJuaW5nKSB7XG4gIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2FybikgY29uc29sZS53YXJuKHdhcm5pbmcpO1xufVxuXG52YXIgTnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gTnVtYmVySXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBFdmVudEVtaXR0ZXIuaW5pdC5jYWxsKHRoaXMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5tb2R1bGUuZXhwb3J0cy5vbmNlID0gb25jZTtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHNDb3VudCA9IDA7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbnZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbmZ1bmN0aW9uIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEVtaXR0ZXIsICdkZWZhdWx0TWF4TGlzdGVuZXJzJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkZWZhdWx0TWF4TGlzdGVuZXJzO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnICE9PSAnbnVtYmVyJyB8fCBhcmcgPCAwIHx8IE51bWJlcklzTmFOKGFyZykpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIGFyZyArICcuJyk7XG4gICAgfVxuICAgIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBhcmc7XG4gIH1cbn0pO1xuXG5FdmVudEVtaXR0ZXIuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXG4gIGlmICh0aGlzLl9ldmVudHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgdGhpcy5fZXZlbnRzID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuX2V2ZW50cykge1xuICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn07XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgTnVtYmVySXNOYU4obikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiblwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBuICsgJy4nKTtcbiAgfVxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIF9nZXRNYXhMaXN0ZW5lcnModGhhdCkge1xuICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuIF9nZXRNYXhMaXN0ZW5lcnModGhpcyk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICB2YXIgZG9FcnJvciA9ICh0eXBlID09PSAnZXJyb3InKTtcblxuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpXG4gICAgZG9FcnJvciA9IChkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PT0gdW5kZWZpbmVkKTtcbiAgZWxzZSBpZiAoIWRvRXJyb3IpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKGRvRXJyb3IpIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMClcbiAgICAgIGVyID0gYXJnc1swXTtcbiAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgLy8gTm90ZTogVGhlIGNvbW1lbnRzIG9uIHRoZSBgdGhyb3dgIGxpbmVzIGFyZSBpbnRlbnRpb25hbCwgdGhleSBzaG93XG4gICAgICAvLyB1cCBpbiBOb2RlJ3Mgb3V0cHV0IGlmIHRoaXMgcmVzdWx0cyBpbiBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uLlxuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgfVxuICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmhhbmRsZWQgZXJyb3IuJyArIChlciA/ICcgKCcgKyBlci5tZXNzYWdlICsgJyknIDogJycpKTtcbiAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgIHRocm93IGVycjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgfVxuXG4gIHZhciBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFJlZmxlY3RBcHBseShoYW5kbGVyLCB0aGlzLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgUmVmbGVjdEFwcGx5KGxpc3RlbmVyc1tpXSwgdGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gIHZhciBtO1xuICB2YXIgZXZlbnRzO1xuICB2YXIgZXhpc3Rpbmc7XG5cbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRhcmdldC5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gICAgICAvLyBSZS1hc3NpZ24gYGV2ZW50c2AgYmVjYXVzZSBhIG5ld0xpc3RlbmVyIGhhbmRsZXIgY291bGQgaGF2ZSBjYXVzZWQgdGhlXG4gICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XG4gICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgICB9XG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07XG4gIH1cblxuICBpZiAoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgKyt0YXJnZXQuX2V2ZW50c0NvdW50O1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPVxuICAgICAgICBwcmVwZW5kID8gW2xpc3RlbmVyLCBleGlzdGluZ10gOiBbZXhpc3RpbmcsIGxpc3RlbmVyXTtcbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB9IGVsc2UgaWYgKHByZXBlbmQpIHtcbiAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIG0gPSBfZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XG4gICAgaWYgKG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0gJiYgIWV4aXN0aW5nLndhcm5lZCkge1xuICAgICAgZXhpc3Rpbmcud2FybmVkID0gdHJ1ZTtcbiAgICAgIC8vIE5vIGVycm9yIGNvZGUgZm9yIHRoaXMgc2luY2UgaXQgaXMgYSBXYXJuaW5nXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5sZW5ndGggKyAnICcgKyBTdHJpbmcodHlwZSkgKyAnIGxpc3RlbmVycyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2luY3JlYXNlIGxpbWl0Jyk7XG4gICAgICB3Lm5hbWUgPSAnTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nJztcbiAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcbiAgICAgIHcudHlwZSA9IHR5cGU7XG4gICAgICB3LmNvdW50ID0gZXhpc3RpbmcubGVuZ3RoO1xuICAgICAgUHJvY2Vzc0VtaXRXYXJuaW5nKHcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcblxuZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gIGlmICghdGhpcy5maXJlZCkge1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xuICAgIHRoaXMuZmlyZWQgPSB0cnVlO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCk7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuYXBwbHkodGhpcy50YXJnZXQsIGFyZ3VtZW50cyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHN0YXRlID0geyBmaXJlZDogZmFsc2UsIHdyYXBGbjogdW5kZWZpbmVkLCB0YXJnZXQ6IHRhcmdldCwgdHlwZTogdHlwZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH07XG4gIHZhciB3cmFwcGVkID0gb25jZVdyYXBwZXIuYmluZChzdGF0ZSk7XG4gIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgICBpZiAobGlzdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwb3NpdGlvbiA9IC0xO1xuXG4gICAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHwgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAocG9zaXRpb24gPT09IDApXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKVxuICAgICAgICAgIGV2ZW50c1t0eXBlXSA9IGxpc3RbMF07XG5cbiAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMsIGV2ZW50cywgaTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV2ZW50cyk7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gTElGTyBvcmRlclxuICAgICAgICBmb3IgKGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuZnVuY3Rpb24gX2xpc3RlbmVycyh0YXJnZXQsIHR5cGUsIHVud3JhcCkge1xuICB2YXIgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKGV2bGlzdGVuZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKVxuICAgIHJldHVybiB1bndyYXAgPyBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXSA6IFtldmxpc3RlbmVyXTtcblxuICByZXR1cm4gdW53cmFwID9cbiAgICB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcikgOiBhcnJheUNsb25lKGV2bGlzdGVuZXIsIGV2bGlzdGVuZXIubGVuZ3RoKTtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCB0cnVlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG5cbiAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0T3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107XG59O1xuXG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKDsgaW5kZXggKyAxIDwgbGlzdC5sZW5ndGg7IGluZGV4KyspXG4gICAgbGlzdFtpbmRleF0gPSBsaXN0W2luZGV4ICsgMV07XG4gIGxpc3QucG9wKCk7XG59XG5cbmZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIG9uY2UoZW1pdHRlciwgbmFtZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGZ1bmN0aW9uIGVycm9yTGlzdGVuZXIoZXJyKSB7XG4gICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKG5hbWUsIHJlc29sdmVyKTtcbiAgICAgIHJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc29sdmVyKCkge1xuICAgICAgaWYgKHR5cGVvZiBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgfTtcblxuICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCByZXNvbHZlciwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIGlmIChuYW1lICE9PSAnZXJyb3InKSB7XG4gICAgICBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBlcnJvckxpc3RlbmVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkRXJyb3JIYW5kbGVySWZFdmVudEVtaXR0ZXIoZW1pdHRlciwgaGFuZGxlciwgZmxhZ3MpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsICdlcnJvcicsIGhhbmRsZXIsIGZsYWdzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgbmFtZSwgbGlzdGVuZXIsIGZsYWdzKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5vbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICBlbWl0dGVyLm9uY2UobmFtZSwgbGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbWl0dGVyLm9uKG5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIEV2ZW50VGFyZ2V0IGRvZXMgbm90IGhhdmUgYGVycm9yYCBldmVudCBzZW1hbnRpY3MgbGlrZSBOb2RlXG4gICAgLy8gRXZlbnRFbWl0dGVycywgd2UgZG8gbm90IGxpc3RlbiBmb3IgYGVycm9yYCBldmVudHMgaGVyZS5cbiAgICBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgZnVuY3Rpb24gd3JhcExpc3RlbmVyKGFyZykge1xuICAgICAgLy8gSUUgZG9lcyBub3QgaGF2ZSBidWlsdGluIGB7IG9uY2U6IHRydWUgfWAgc3VwcG9ydCBzbyB3ZVxuICAgICAgLy8gaGF2ZSB0byBkbyBpdCBtYW51YWxseS5cbiAgICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCB3cmFwTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgbGlzdGVuZXIoYXJnKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJlbWl0dGVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEV2ZW50RW1pdHRlci4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGVtaXR0ZXIpO1xuICB9XG59XG4iLCIvKlxuICogIENvcHlyaWdodCAoYykgMjAxNiBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbi8qIGVzbGludC1lbnYgbm9kZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5sZXQgbG9nRGlzYWJsZWRfID0gdHJ1ZTtcbmxldCBkZXByZWNhdGlvbldhcm5pbmdzXyA9IHRydWU7XG5cbi8qKlxuICogRXh0cmFjdCBicm93c2VyIHZlcnNpb24gb3V0IG9mIHRoZSBwcm92aWRlZCB1c2VyIGFnZW50IHN0cmluZy5cbiAqXG4gKiBAcGFyYW0geyFzdHJpbmd9IHVhc3RyaW5nIHVzZXJBZ2VudCBzdHJpbmcuXG4gKiBAcGFyYW0geyFzdHJpbmd9IGV4cHIgUmVndWxhciBleHByZXNzaW9uIHVzZWQgYXMgbWF0Y2ggY3JpdGVyaWEuXG4gKiBAcGFyYW0geyFudW1iZXJ9IHBvcyBwb3NpdGlvbiBpbiB0aGUgdmVyc2lvbiBzdHJpbmcgdG8gYmUgcmV0dXJuZWQuXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBicm93c2VyIHZlcnNpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0VmVyc2lvbih1YXN0cmluZywgZXhwciwgcG9zKSB7XG4gIGNvbnN0IG1hdGNoID0gdWFzdHJpbmcubWF0Y2goZXhwcik7XG4gIHJldHVybiBtYXRjaCAmJiBtYXRjaC5sZW5ndGggPj0gcG9zICYmIHBhcnNlSW50KG1hdGNoW3Bvc10sIDEwKTtcbn1cblxuLy8gV3JhcHMgdGhlIHBlZXJjb25uZWN0aW9uIGV2ZW50IGV2ZW50TmFtZVRvV3JhcCBpbiBhIGZ1bmN0aW9uXG4vLyB3aGljaCByZXR1cm5zIHRoZSBtb2RpZmllZCBldmVudCBvYmplY3QgKG9yIGZhbHNlIHRvIHByZXZlbnRcbi8vIHRoZSBldmVudCkuXG5leHBvcnQgZnVuY3Rpb24gd3JhcFBlZXJDb25uZWN0aW9uRXZlbnQod2luZG93LCBldmVudE5hbWVUb1dyYXAsIHdyYXBwZXIpIHtcbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcHJvdG8gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlO1xuICBjb25zdCBuYXRpdmVBZGRFdmVudExpc3RlbmVyID0gcHJvdG8uYWRkRXZlbnRMaXN0ZW5lcjtcbiAgcHJvdG8uYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKG5hdGl2ZUV2ZW50TmFtZSwgY2IpIHtcbiAgICBpZiAobmF0aXZlRXZlbnROYW1lICE9PSBldmVudE5hbWVUb1dyYXApIHtcbiAgICAgIHJldHVybiBuYXRpdmVBZGRFdmVudExpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIGNvbnN0IHdyYXBwZWRDYWxsYmFjayA9IChlKSA9PiB7XG4gICAgICBjb25zdCBtb2RpZmllZEV2ZW50ID0gd3JhcHBlcihlKTtcbiAgICAgIGlmIChtb2RpZmllZEV2ZW50KSB7XG4gICAgICAgIGlmIChjYi5oYW5kbGVFdmVudCkge1xuICAgICAgICAgIGNiLmhhbmRsZUV2ZW50KG1vZGlmaWVkRXZlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNiKG1vZGlmaWVkRXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl9ldmVudE1hcCA9IHRoaXMuX2V2ZW50TWFwIHx8IHt9O1xuICAgIGlmICghdGhpcy5fZXZlbnRNYXBbZXZlbnROYW1lVG9XcmFwXSkge1xuICAgICAgdGhpcy5fZXZlbnRNYXBbZXZlbnROYW1lVG9XcmFwXSA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgdGhpcy5fZXZlbnRNYXBbZXZlbnROYW1lVG9XcmFwXS5zZXQoY2IsIHdyYXBwZWRDYWxsYmFjayk7XG4gICAgcmV0dXJuIG5hdGl2ZUFkZEV2ZW50TGlzdGVuZXIuYXBwbHkodGhpcywgW25hdGl2ZUV2ZW50TmFtZSxcbiAgICAgIHdyYXBwZWRDYWxsYmFja10pO1xuICB9O1xuXG4gIGNvbnN0IG5hdGl2ZVJlbW92ZUV2ZW50TGlzdGVuZXIgPSBwcm90by5yZW1vdmVFdmVudExpc3RlbmVyO1xuICBwcm90by5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24obmF0aXZlRXZlbnROYW1lLCBjYikge1xuICAgIGlmIChuYXRpdmVFdmVudE5hbWUgIT09IGV2ZW50TmFtZVRvV3JhcCB8fCAhdGhpcy5fZXZlbnRNYXBcbiAgICAgICAgfHwgIXRoaXMuX2V2ZW50TWFwW2V2ZW50TmFtZVRvV3JhcF0pIHtcbiAgICAgIHJldHVybiBuYXRpdmVSZW1vdmVFdmVudExpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIGlmICghdGhpcy5fZXZlbnRNYXBbZXZlbnROYW1lVG9XcmFwXS5oYXMoY2IpKSB7XG4gICAgICByZXR1cm4gbmF0aXZlUmVtb3ZlRXZlbnRMaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBjb25zdCB1bndyYXBwZWRDYiA9IHRoaXMuX2V2ZW50TWFwW2V2ZW50TmFtZVRvV3JhcF0uZ2V0KGNiKTtcbiAgICB0aGlzLl9ldmVudE1hcFtldmVudE5hbWVUb1dyYXBdLmRlbGV0ZShjYik7XG4gICAgaWYgKHRoaXMuX2V2ZW50TWFwW2V2ZW50TmFtZVRvV3JhcF0uc2l6ZSA9PT0gMCkge1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50TWFwW2V2ZW50TmFtZVRvV3JhcF07XG4gICAgfVxuICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLl9ldmVudE1hcCkubGVuZ3RoID09PSAwKSB7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRNYXA7XG4gICAgfVxuICAgIHJldHVybiBuYXRpdmVSZW1vdmVFdmVudExpc3RlbmVyLmFwcGx5KHRoaXMsIFtuYXRpdmVFdmVudE5hbWUsXG4gICAgICB1bndyYXBwZWRDYl0pO1xuICB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgJ29uJyArIGV2ZW50TmFtZVRvV3JhcCwge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzWydfb24nICsgZXZlbnROYW1lVG9XcmFwXTtcbiAgICB9LFxuICAgIHNldChjYikge1xuICAgICAgaWYgKHRoaXNbJ19vbicgKyBldmVudE5hbWVUb1dyYXBdKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWVUb1dyYXAsXG4gICAgICAgICAgdGhpc1snX29uJyArIGV2ZW50TmFtZVRvV3JhcF0pO1xuICAgICAgICBkZWxldGUgdGhpc1snX29uJyArIGV2ZW50TmFtZVRvV3JhcF07XG4gICAgICB9XG4gICAgICBpZiAoY2IpIHtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZVRvV3JhcCxcbiAgICAgICAgICB0aGlzWydfb24nICsgZXZlbnROYW1lVG9XcmFwXSA9IGNiKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGlzYWJsZUxvZyhib29sKSB7XG4gIGlmICh0eXBlb2YgYm9vbCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcignQXJndW1lbnQgdHlwZTogJyArIHR5cGVvZiBib29sICtcbiAgICAgICAgJy4gUGxlYXNlIHVzZSBhIGJvb2xlYW4uJyk7XG4gIH1cbiAgbG9nRGlzYWJsZWRfID0gYm9vbDtcbiAgcmV0dXJuIChib29sKSA/ICdhZGFwdGVyLmpzIGxvZ2dpbmcgZGlzYWJsZWQnIDpcbiAgICAnYWRhcHRlci5qcyBsb2dnaW5nIGVuYWJsZWQnO1xufVxuXG4vKipcbiAqIERpc2FibGUgb3IgZW5hYmxlIGRlcHJlY2F0aW9uIHdhcm5pbmdzXG4gKiBAcGFyYW0geyFib29sZWFufSBib29sIHNldCB0byB0cnVlIHRvIGRpc2FibGUgd2FybmluZ3MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXNhYmxlV2FybmluZ3MoYm9vbCkge1xuICBpZiAodHlwZW9mIGJvb2wgIT09ICdib29sZWFuJykge1xuICAgIHJldHVybiBuZXcgRXJyb3IoJ0FyZ3VtZW50IHR5cGU6ICcgKyB0eXBlb2YgYm9vbCArXG4gICAgICAgICcuIFBsZWFzZSB1c2UgYSBib29sZWFuLicpO1xuICB9XG4gIGRlcHJlY2F0aW9uV2FybmluZ3NfID0gIWJvb2w7XG4gIHJldHVybiAnYWRhcHRlci5qcyBkZXByZWNhdGlvbiB3YXJuaW5ncyAnICsgKGJvb2wgPyAnZGlzYWJsZWQnIDogJ2VuYWJsZWQnKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvZygpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKGxvZ0Rpc2FibGVkXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25zb2xlLmxvZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBTaG93cyBhIGRlcHJlY2F0aW9uIHdhcm5pbmcgc3VnZ2VzdGluZyB0aGUgbW9kZXJuIGFuZCBzcGVjLWNvbXBhdGlibGUgQVBJLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVwcmVjYXRlZChvbGRNZXRob2QsIG5ld01ldGhvZCkge1xuICBpZiAoIWRlcHJlY2F0aW9uV2FybmluZ3NfKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnNvbGUud2FybihvbGRNZXRob2QgKyAnIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgJyArIG5ld01ldGhvZCArXG4gICAgICAnIGluc3RlYWQuJyk7XG59XG5cbi8qKlxuICogQnJvd3NlciBkZXRlY3Rvci5cbiAqXG4gKiBAcmV0dXJuIHtvYmplY3R9IHJlc3VsdCBjb250YWluaW5nIGJyb3dzZXIgYW5kIHZlcnNpb25cbiAqICAgICBwcm9wZXJ0aWVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGV0ZWN0QnJvd3Nlcih3aW5kb3cpIHtcbiAgLy8gUmV0dXJuZWQgcmVzdWx0IG9iamVjdC5cbiAgY29uc3QgcmVzdWx0ID0ge2Jyb3dzZXI6IG51bGwsIHZlcnNpb246IG51bGx9O1xuXG4gIC8vIEZhaWwgZWFybHkgaWYgaXQncyBub3QgYSBicm93c2VyXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhd2luZG93Lm5hdmlnYXRvciB8fFxuICAgICAgIXdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSB7XG4gICAgcmVzdWx0LmJyb3dzZXIgPSAnTm90IGEgYnJvd3Nlci4nO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBjb25zdCB7bmF2aWdhdG9yfSA9IHdpbmRvdztcblxuICBpZiAobmF2aWdhdG9yLm1vekdldFVzZXJNZWRpYSkgeyAvLyBGaXJlZm94LlxuICAgIHJlc3VsdC5icm93c2VyID0gJ2ZpcmVmb3gnO1xuICAgIHJlc3VsdC52ZXJzaW9uID0gZXh0cmFjdFZlcnNpb24obmF2aWdhdG9yLnVzZXJBZ2VudCxcbiAgICAgIC9GaXJlZm94XFwvKFxcZCspXFwuLywgMSk7XG4gIH0gZWxzZSBpZiAobmF2aWdhdG9yLndlYmtpdEdldFVzZXJNZWRpYSB8fFxuICAgICAgKHdpbmRvdy5pc1NlY3VyZUNvbnRleHQgPT09IGZhbHNlICYmIHdpbmRvdy53ZWJraXRSVENQZWVyQ29ubmVjdGlvbikpIHtcbiAgICAvLyBDaHJvbWUsIENocm9taXVtLCBXZWJ2aWV3LCBPcGVyYS5cbiAgICAvLyBWZXJzaW9uIG1hdGNoZXMgQ2hyb21lL1dlYlJUQyB2ZXJzaW9uLlxuICAgIC8vIENocm9tZSA3NCByZW1vdmVkIHdlYmtpdEdldFVzZXJNZWRpYSBvbiBodHRwIGFzIHdlbGwgc28gd2UgbmVlZCB0aGVcbiAgICAvLyBtb3JlIGNvbXBsaWNhdGVkIGZhbGxiYWNrIHRvIHdlYmtpdFJUQ1BlZXJDb25uZWN0aW9uLlxuICAgIHJlc3VsdC5icm93c2VyID0gJ2Nocm9tZSc7XG4gICAgcmVzdWx0LnZlcnNpb24gPSBleHRyYWN0VmVyc2lvbihuYXZpZ2F0b3IudXNlckFnZW50LFxuICAgICAgL0Nocm9tKGV8aXVtKVxcLyhcXGQrKVxcLi8sIDIpO1xuICB9IGVsc2UgaWYgKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJlxuICAgICAgbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvQXBwbGVXZWJLaXRcXC8oXFxkKylcXC4vKSkgeyAvLyBTYWZhcmkuXG4gICAgcmVzdWx0LmJyb3dzZXIgPSAnc2FmYXJpJztcbiAgICByZXN1bHQudmVyc2lvbiA9IGV4dHJhY3RWZXJzaW9uKG5hdmlnYXRvci51c2VyQWdlbnQsXG4gICAgICAvQXBwbGVXZWJLaXRcXC8oXFxkKylcXC4vLCAxKTtcbiAgICByZXN1bHQuc3VwcG9ydHNVbmlmaWVkUGxhbiA9IHdpbmRvdy5SVENSdHBUcmFuc2NlaXZlciAmJlxuICAgICAgICAnY3VycmVudERpcmVjdGlvbicgaW4gd2luZG93LlJUQ1J0cFRyYW5zY2VpdmVyLnByb3RvdHlwZTtcbiAgfSBlbHNlIHsgLy8gRGVmYXVsdCBmYWxsdGhyb3VnaDogbm90IHN1cHBvcnRlZC5cbiAgICByZXN1bHQuYnJvd3NlciA9ICdOb3QgYSBzdXBwb3J0ZWQgYnJvd3Nlci4nO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBzb21ldGhpbmcgaXMgYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSBzb21ldGhpbmcgeW91IHdhbnQgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHRydWUgaWYgdmFsIGlzIGFuIG9iamVjdCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBPYmplY3RdJztcbn1cblxuLyoqXG4gKiBSZW1vdmUgYWxsIGVtcHR5IG9iamVjdHMgYW5kIHVuZGVmaW5lZCB2YWx1ZXNcbiAqIGZyb20gYSBuZXN0ZWQgb2JqZWN0IC0tIGFuIGVuaGFuY2VkIGFuZCB2YW5pbGxhIHZlcnNpb25cbiAqIG9mIExvZGFzaCdzIGBjb21wYWN0YC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhY3RPYmplY3QoZGF0YSkge1xuICBpZiAoIWlzT2JqZWN0KGRhdGEpKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmtleXMoZGF0YSkucmVkdWNlKGZ1bmN0aW9uKGFjY3VtdWxhdG9yLCBrZXkpIHtcbiAgICBjb25zdCBpc09iaiA9IGlzT2JqZWN0KGRhdGFba2V5XSk7XG4gICAgY29uc3QgdmFsdWUgPSBpc09iaiA/IGNvbXBhY3RPYmplY3QoZGF0YVtrZXldKSA6IGRhdGFba2V5XTtcbiAgICBjb25zdCBpc0VtcHR5T2JqZWN0ID0gaXNPYmogJiYgIU9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGg7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgaXNFbXB0eU9iamVjdCkge1xuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihhY2N1bXVsYXRvciwge1trZXldOiB2YWx1ZX0pO1xuICB9LCB7fSk7XG59XG5cbi8qIGl0ZXJhdGVzIHRoZSBzdGF0cyBncmFwaCByZWN1cnNpdmVseS4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3YWxrU3RhdHMoc3RhdHMsIGJhc2UsIHJlc3VsdFNldCkge1xuICBpZiAoIWJhc2UgfHwgcmVzdWx0U2V0LmhhcyhiYXNlLmlkKSkge1xuICAgIHJldHVybjtcbiAgfVxuICByZXN1bHRTZXQuc2V0KGJhc2UuaWQsIGJhc2UpO1xuICBPYmplY3Qua2V5cyhiYXNlKS5mb3JFYWNoKG5hbWUgPT4ge1xuICAgIGlmIChuYW1lLmVuZHNXaXRoKCdJZCcpKSB7XG4gICAgICB3YWxrU3RhdHMoc3RhdHMsIHN0YXRzLmdldChiYXNlW25hbWVdKSwgcmVzdWx0U2V0KTtcbiAgICB9IGVsc2UgaWYgKG5hbWUuZW5kc1dpdGgoJ0lkcycpKSB7XG4gICAgICBiYXNlW25hbWVdLmZvckVhY2goaWQgPT4ge1xuICAgICAgICB3YWxrU3RhdHMoc3RhdHMsIHN0YXRzLmdldChpZCksIHJlc3VsdFNldCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKiBmaWx0ZXIgZ2V0U3RhdHMgZm9yIGEgc2VuZGVyL3JlY2VpdmVyIHRyYWNrLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlclN0YXRzKHJlc3VsdCwgdHJhY2ssIG91dGJvdW5kKSB7XG4gIGNvbnN0IHN0cmVhbVN0YXRzVHlwZSA9IG91dGJvdW5kID8gJ291dGJvdW5kLXJ0cCcgOiAnaW5ib3VuZC1ydHAnO1xuICBjb25zdCBmaWx0ZXJlZFJlc3VsdCA9IG5ldyBNYXAoKTtcbiAgaWYgKHRyYWNrID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZpbHRlcmVkUmVzdWx0O1xuICB9XG4gIGNvbnN0IHRyYWNrU3RhdHMgPSBbXTtcbiAgcmVzdWx0LmZvckVhY2godmFsdWUgPT4ge1xuICAgIGlmICh2YWx1ZS50eXBlID09PSAndHJhY2snICYmXG4gICAgICAgIHZhbHVlLnRyYWNrSWRlbnRpZmllciA9PT0gdHJhY2suaWQpIHtcbiAgICAgIHRyYWNrU3RhdHMucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9KTtcbiAgdHJhY2tTdGF0cy5mb3JFYWNoKHRyYWNrU3RhdCA9PiB7XG4gICAgcmVzdWx0LmZvckVhY2goc3RhdHMgPT4ge1xuICAgICAgaWYgKHN0YXRzLnR5cGUgPT09IHN0cmVhbVN0YXRzVHlwZSAmJiBzdGF0cy50cmFja0lkID09PSB0cmFja1N0YXQuaWQpIHtcbiAgICAgICAgd2Fsa1N0YXRzKHJlc3VsdCwgc3RhdHMsIGZpbHRlcmVkUmVzdWx0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBmaWx0ZXJlZFJlc3VsdDtcbn1cblxuIiwiLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4vKiBlc2xpbnQtZW52IG5vZGUgKi9cbid1c2Ugc3RyaWN0JztcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcbmNvbnN0IGxvZ2dpbmcgPSB1dGlscy5sb2c7XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGltR2V0VXNlck1lZGlhKHdpbmRvdywgYnJvd3NlckRldGFpbHMpIHtcbiAgY29uc3QgbmF2aWdhdG9yID0gd2luZG93ICYmIHdpbmRvdy5uYXZpZ2F0b3I7XG5cbiAgaWYgKCFuYXZpZ2F0b3IubWVkaWFEZXZpY2VzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgY29uc3RyYWludHNUb0Nocm9tZV8gPSBmdW5jdGlvbihjKSB7XG4gICAgaWYgKHR5cGVvZiBjICE9PSAnb2JqZWN0JyB8fCBjLm1hbmRhdG9yeSB8fCBjLm9wdGlvbmFsKSB7XG4gICAgICByZXR1cm4gYztcbiAgICB9XG4gICAgY29uc3QgY2MgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhjKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBpZiAoa2V5ID09PSAncmVxdWlyZScgfHwga2V5ID09PSAnYWR2YW5jZWQnIHx8IGtleSA9PT0gJ21lZGlhU291cmNlJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCByID0gKHR5cGVvZiBjW2tleV0gPT09ICdvYmplY3QnKSA/IGNba2V5XSA6IHtpZGVhbDogY1trZXldfTtcbiAgICAgIGlmIChyLmV4YWN0ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHIuZXhhY3QgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHIubWluID0gci5tYXggPSByLmV4YWN0O1xuICAgICAgfVxuICAgICAgY29uc3Qgb2xkbmFtZV8gPSBmdW5jdGlvbihwcmVmaXgsIG5hbWUpIHtcbiAgICAgICAgaWYgKHByZWZpeCkge1xuICAgICAgICAgIHJldHVybiBwcmVmaXggKyBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKG5hbWUgPT09ICdkZXZpY2VJZCcpID8gJ3NvdXJjZUlkJyA6IG5hbWU7XG4gICAgICB9O1xuICAgICAgaWYgKHIuaWRlYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjYy5vcHRpb25hbCA9IGNjLm9wdGlvbmFsIHx8IFtdO1xuICAgICAgICBsZXQgb2MgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiByLmlkZWFsID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIG9jW29sZG5hbWVfKCdtaW4nLCBrZXkpXSA9IHIuaWRlYWw7XG4gICAgICAgICAgY2Mub3B0aW9uYWwucHVzaChvYyk7XG4gICAgICAgICAgb2MgPSB7fTtcbiAgICAgICAgICBvY1tvbGRuYW1lXygnbWF4Jywga2V5KV0gPSByLmlkZWFsO1xuICAgICAgICAgIGNjLm9wdGlvbmFsLnB1c2gob2MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9jW29sZG5hbWVfKCcnLCBrZXkpXSA9IHIuaWRlYWw7XG4gICAgICAgICAgY2Mub3B0aW9uYWwucHVzaChvYyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyLmV4YWN0ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHIuZXhhY3QgIT09ICdudW1iZXInKSB7XG4gICAgICAgIGNjLm1hbmRhdG9yeSA9IGNjLm1hbmRhdG9yeSB8fCB7fTtcbiAgICAgICAgY2MubWFuZGF0b3J5W29sZG5hbWVfKCcnLCBrZXkpXSA9IHIuZXhhY3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBbJ21pbicsICdtYXgnXS5mb3JFYWNoKG1peCA9PiB7XG4gICAgICAgICAgaWYgKHJbbWl4XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjYy5tYW5kYXRvcnkgPSBjYy5tYW5kYXRvcnkgfHwge307XG4gICAgICAgICAgICBjYy5tYW5kYXRvcnlbb2xkbmFtZV8obWl4LCBrZXkpXSA9IHJbbWl4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChjLmFkdmFuY2VkKSB7XG4gICAgICBjYy5vcHRpb25hbCA9IChjYy5vcHRpb25hbCB8fCBbXSkuY29uY2F0KGMuYWR2YW5jZWQpO1xuICAgIH1cbiAgICByZXR1cm4gY2M7XG4gIH07XG5cbiAgY29uc3Qgc2hpbUNvbnN0cmFpbnRzXyA9IGZ1bmN0aW9uKGNvbnN0cmFpbnRzLCBmdW5jKSB7XG4gICAgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPj0gNjEpIHtcbiAgICAgIHJldHVybiBmdW5jKGNvbnN0cmFpbnRzKTtcbiAgICB9XG4gICAgY29uc3RyYWludHMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGNvbnN0cmFpbnRzKSk7XG4gICAgaWYgKGNvbnN0cmFpbnRzICYmIHR5cGVvZiBjb25zdHJhaW50cy5hdWRpbyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGNvbnN0IHJlbWFwID0gZnVuY3Rpb24ob2JqLCBhLCBiKSB7XG4gICAgICAgIGlmIChhIGluIG9iaiAmJiAhKGIgaW4gb2JqKSkge1xuICAgICAgICAgIG9ialtiXSA9IG9ialthXTtcbiAgICAgICAgICBkZWxldGUgb2JqW2FdO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3RyYWludHMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGNvbnN0cmFpbnRzKSk7XG4gICAgICByZW1hcChjb25zdHJhaW50cy5hdWRpbywgJ2F1dG9HYWluQ29udHJvbCcsICdnb29nQXV0b0dhaW5Db250cm9sJyk7XG4gICAgICByZW1hcChjb25zdHJhaW50cy5hdWRpbywgJ25vaXNlU3VwcHJlc3Npb24nLCAnZ29vZ05vaXNlU3VwcHJlc3Npb24nKTtcbiAgICAgIGNvbnN0cmFpbnRzLmF1ZGlvID0gY29uc3RyYWludHNUb0Nocm9tZV8oY29uc3RyYWludHMuYXVkaW8pO1xuICAgIH1cbiAgICBpZiAoY29uc3RyYWludHMgJiYgdHlwZW9mIGNvbnN0cmFpbnRzLnZpZGVvID09PSAnb2JqZWN0Jykge1xuICAgICAgLy8gU2hpbSBmYWNpbmdNb2RlIGZvciBtb2JpbGUgJiBzdXJmYWNlIHByby5cbiAgICAgIGxldCBmYWNlID0gY29uc3RyYWludHMudmlkZW8uZmFjaW5nTW9kZTtcbiAgICAgIGZhY2UgPSBmYWNlICYmICgodHlwZW9mIGZhY2UgPT09ICdvYmplY3QnKSA/IGZhY2UgOiB7aWRlYWw6IGZhY2V9KTtcbiAgICAgIGNvbnN0IGdldFN1cHBvcnRlZEZhY2luZ01vZGVMaWVzID0gYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDY2O1xuXG4gICAgICBpZiAoKGZhY2UgJiYgKGZhY2UuZXhhY3QgPT09ICd1c2VyJyB8fCBmYWNlLmV4YWN0ID09PSAnZW52aXJvbm1lbnQnIHx8XG4gICAgICAgICAgICAgICAgICAgIGZhY2UuaWRlYWwgPT09ICd1c2VyJyB8fCBmYWNlLmlkZWFsID09PSAnZW52aXJvbm1lbnQnKSkgJiZcbiAgICAgICAgICAhKG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0U3VwcG9ydGVkQ29uc3RyYWludHMgJiZcbiAgICAgICAgICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0U3VwcG9ydGVkQ29uc3RyYWludHMoKS5mYWNpbmdNb2RlICYmXG4gICAgICAgICAgICAhZ2V0U3VwcG9ydGVkRmFjaW5nTW9kZUxpZXMpKSB7XG4gICAgICAgIGRlbGV0ZSBjb25zdHJhaW50cy52aWRlby5mYWNpbmdNb2RlO1xuICAgICAgICBsZXQgbWF0Y2hlcztcbiAgICAgICAgaWYgKGZhY2UuZXhhY3QgPT09ICdlbnZpcm9ubWVudCcgfHwgZmFjZS5pZGVhbCA9PT0gJ2Vudmlyb25tZW50Jykge1xuICAgICAgICAgIG1hdGNoZXMgPSBbJ2JhY2snLCAncmVhciddO1xuICAgICAgICB9IGVsc2UgaWYgKGZhY2UuZXhhY3QgPT09ICd1c2VyJyB8fCBmYWNlLmlkZWFsID09PSAndXNlcicpIHtcbiAgICAgICAgICBtYXRjaGVzID0gWydmcm9udCddO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgLy8gTG9vayBmb3IgbWF0Y2hlcyBpbiBsYWJlbCwgb3IgdXNlIGxhc3QgY2FtIGZvciBiYWNrICh0eXBpY2FsKS5cbiAgICAgICAgICByZXR1cm4gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5lbnVtZXJhdGVEZXZpY2VzKClcbiAgICAgICAgICAgIC50aGVuKGRldmljZXMgPT4ge1xuICAgICAgICAgICAgICBkZXZpY2VzID0gZGV2aWNlcy5maWx0ZXIoZCA9PiBkLmtpbmQgPT09ICd2aWRlb2lucHV0Jyk7XG4gICAgICAgICAgICAgIGxldCBkZXYgPSBkZXZpY2VzLmZpbmQoZCA9PiBtYXRjaGVzLnNvbWUobWF0Y2ggPT5cbiAgICAgICAgICAgICAgICBkLmxhYmVsLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMobWF0Y2gpKSk7XG4gICAgICAgICAgICAgIGlmICghZGV2ICYmIGRldmljZXMubGVuZ3RoICYmIG1hdGNoZXMuaW5jbHVkZXMoJ2JhY2snKSkge1xuICAgICAgICAgICAgICAgIGRldiA9IGRldmljZXNbZGV2aWNlcy5sZW5ndGggLSAxXTsgLy8gbW9yZSBsaWtlbHkgdGhlIGJhY2sgY2FtXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGRldikge1xuICAgICAgICAgICAgICAgIGNvbnN0cmFpbnRzLnZpZGVvLmRldmljZUlkID0gZmFjZS5leGFjdFxuICAgICAgICAgICAgICAgICAgPyB7ZXhhY3Q6IGRldi5kZXZpY2VJZH1cbiAgICAgICAgICAgICAgICAgIDoge2lkZWFsOiBkZXYuZGV2aWNlSWR9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0cmFpbnRzLnZpZGVvID0gY29uc3RyYWludHNUb0Nocm9tZV8oY29uc3RyYWludHMudmlkZW8pO1xuICAgICAgICAgICAgICBsb2dnaW5nKCdjaHJvbWU6ICcgKyBKU09OLnN0cmluZ2lmeShjb25zdHJhaW50cykpO1xuICAgICAgICAgICAgICByZXR1cm4gZnVuYyhjb25zdHJhaW50cyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3RyYWludHMudmlkZW8gPSBjb25zdHJhaW50c1RvQ2hyb21lXyhjb25zdHJhaW50cy52aWRlbyk7XG4gICAgfVxuICAgIGxvZ2dpbmcoJ2Nocm9tZTogJyArIEpTT04uc3RyaW5naWZ5KGNvbnN0cmFpbnRzKSk7XG4gICAgcmV0dXJuIGZ1bmMoY29uc3RyYWludHMpO1xuICB9O1xuXG4gIGNvbnN0IHNoaW1FcnJvcl8gPSBmdW5jdGlvbihlKSB7XG4gICAgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPj0gNjQpIHtcbiAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbmFtZToge1xuICAgICAgICBQZXJtaXNzaW9uRGVuaWVkRXJyb3I6ICdOb3RBbGxvd2VkRXJyb3InLFxuICAgICAgICBQZXJtaXNzaW9uRGlzbWlzc2VkRXJyb3I6ICdOb3RBbGxvd2VkRXJyb3InLFxuICAgICAgICBJbnZhbGlkU3RhdGVFcnJvcjogJ05vdEFsbG93ZWRFcnJvcicsXG4gICAgICAgIERldmljZXNOb3RGb3VuZEVycm9yOiAnTm90Rm91bmRFcnJvcicsXG4gICAgICAgIENvbnN0cmFpbnROb3RTYXRpc2ZpZWRFcnJvcjogJ092ZXJjb25zdHJhaW5lZEVycm9yJyxcbiAgICAgICAgVHJhY2tTdGFydEVycm9yOiAnTm90UmVhZGFibGVFcnJvcicsXG4gICAgICAgIE1lZGlhRGV2aWNlRmFpbGVkRHVlVG9TaHV0ZG93bjogJ05vdEFsbG93ZWRFcnJvcicsXG4gICAgICAgIE1lZGlhRGV2aWNlS2lsbFN3aXRjaE9uOiAnTm90QWxsb3dlZEVycm9yJyxcbiAgICAgICAgVGFiQ2FwdHVyZUVycm9yOiAnQWJvcnRFcnJvcicsXG4gICAgICAgIFNjcmVlbkNhcHR1cmVFcnJvcjogJ0Fib3J0RXJyb3InLFxuICAgICAgICBEZXZpY2VDYXB0dXJlRXJyb3I6ICdBYm9ydEVycm9yJ1xuICAgICAgfVtlLm5hbWVdIHx8IGUubmFtZSxcbiAgICAgIG1lc3NhZ2U6IGUubWVzc2FnZSxcbiAgICAgIGNvbnN0cmFpbnQ6IGUuY29uc3RyYWludCB8fCBlLmNvbnN0cmFpbnROYW1lLFxuICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWUgKyAodGhpcy5tZXNzYWdlICYmICc6ICcpICsgdGhpcy5tZXNzYWdlO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgY29uc3QgZ2V0VXNlck1lZGlhXyA9IGZ1bmN0aW9uKGNvbnN0cmFpbnRzLCBvblN1Y2Nlc3MsIG9uRXJyb3IpIHtcbiAgICBzaGltQ29uc3RyYWludHNfKGNvbnN0cmFpbnRzLCBjID0+IHtcbiAgICAgIG5hdmlnYXRvci53ZWJraXRHZXRVc2VyTWVkaWEoYywgb25TdWNjZXNzLCBlID0+IHtcbiAgICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgICBvbkVycm9yKHNoaW1FcnJvcl8oZSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbiAgbmF2aWdhdG9yLmdldFVzZXJNZWRpYSA9IGdldFVzZXJNZWRpYV8uYmluZChuYXZpZ2F0b3IpO1xuXG4gIC8vIEV2ZW4gdGhvdWdoIENocm9tZSA0NSBoYXMgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcyBhbmQgYSBnZXRVc2VyTWVkaWFcbiAgLy8gZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhIFByb21pc2UsIGl0IGRvZXMgbm90IGFjY2VwdCBzcGVjLXN0eWxlXG4gIC8vIGNvbnN0cmFpbnRzLlxuICBpZiAobmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEpIHtcbiAgICBjb25zdCBvcmlnR2V0VXNlck1lZGlhID0gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEuXG4gICAgICBiaW5kKG5hdmlnYXRvci5tZWRpYURldmljZXMpO1xuICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhID0gZnVuY3Rpb24oY3MpIHtcbiAgICAgIHJldHVybiBzaGltQ29uc3RyYWludHNfKGNzLCBjID0+IG9yaWdHZXRVc2VyTWVkaWEoYykudGhlbihzdHJlYW0gPT4ge1xuICAgICAgICBpZiAoYy5hdWRpbyAmJiAhc3RyZWFtLmdldEF1ZGlvVHJhY2tzKCkubGVuZ3RoIHx8XG4gICAgICAgICAgICBjLnZpZGVvICYmICFzdHJlYW0uZ2V0VmlkZW9UcmFja3MoKS5sZW5ndGgpIHtcbiAgICAgICAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICAgICAgICB0cmFjay5zdG9wKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignJywgJ05vdEZvdW5kRXJyb3InKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgICAgfSwgZSA9PiBQcm9taXNlLnJlamVjdChzaGltRXJyb3JfKGUpKSkpO1xuICAgIH07XG4gIH1cbn1cbiIsIi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBhZGFwdGVyLmpzIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbi8qIGVzbGludC1lbnYgbm9kZSAqL1xuJ3VzZSBzdHJpY3QnO1xuZXhwb3J0IGZ1bmN0aW9uIHNoaW1HZXREaXNwbGF5TWVkaWEod2luZG93LCBnZXRTb3VyY2VJZCkge1xuICBpZiAod2luZG93Lm5hdmlnYXRvci5tZWRpYURldmljZXMgJiZcbiAgICAnZ2V0RGlzcGxheU1lZGlhJyBpbiB3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoISh3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gZ2V0U291cmNlSWQgaXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBwcm9taXNlIHJlc29sdmluZyB3aXRoXG4gIC8vIHRoZSBzb3VyY2VJZCBvZiB0aGUgc2NyZWVuL3dpbmRvdy90YWIgdG8gYmUgc2hhcmVkLlxuICBpZiAodHlwZW9mIGdldFNvdXJjZUlkICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc29sZS5lcnJvcignc2hpbUdldERpc3BsYXlNZWRpYTogZ2V0U291cmNlSWQgYXJndW1lbnQgaXMgbm90ICcgK1xuICAgICAgICAnYSBmdW5jdGlvbicpO1xuICAgIHJldHVybjtcbiAgfVxuICB3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXREaXNwbGF5TWVkaWEgPVxuICAgIGZ1bmN0aW9uIGdldERpc3BsYXlNZWRpYShjb25zdHJhaW50cykge1xuICAgICAgcmV0dXJuIGdldFNvdXJjZUlkKGNvbnN0cmFpbnRzKVxuICAgICAgICAudGhlbihzb3VyY2VJZCA9PiB7XG4gICAgICAgICAgY29uc3Qgd2lkdGhTcGVjaWZpZWQgPSBjb25zdHJhaW50cy52aWRlbyAmJiBjb25zdHJhaW50cy52aWRlby53aWR0aDtcbiAgICAgICAgICBjb25zdCBoZWlnaHRTcGVjaWZpZWQgPSBjb25zdHJhaW50cy52aWRlbyAmJlxuICAgICAgICAgICAgY29uc3RyYWludHMudmlkZW8uaGVpZ2h0O1xuICAgICAgICAgIGNvbnN0IGZyYW1lUmF0ZVNwZWNpZmllZCA9IGNvbnN0cmFpbnRzLnZpZGVvICYmXG4gICAgICAgICAgICBjb25zdHJhaW50cy52aWRlby5mcmFtZVJhdGU7XG4gICAgICAgICAgY29uc3RyYWludHMudmlkZW8gPSB7XG4gICAgICAgICAgICBtYW5kYXRvcnk6IHtcbiAgICAgICAgICAgICAgY2hyb21lTWVkaWFTb3VyY2U6ICdkZXNrdG9wJyxcbiAgICAgICAgICAgICAgY2hyb21lTWVkaWFTb3VyY2VJZDogc291cmNlSWQsXG4gICAgICAgICAgICAgIG1heEZyYW1lUmF0ZTogZnJhbWVSYXRlU3BlY2lmaWVkIHx8IDNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmICh3aWR0aFNwZWNpZmllZCkge1xuICAgICAgICAgICAgY29uc3RyYWludHMudmlkZW8ubWFuZGF0b3J5Lm1heFdpZHRoID0gd2lkdGhTcGVjaWZpZWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoZWlnaHRTcGVjaWZpZWQpIHtcbiAgICAgICAgICAgIGNvbnN0cmFpbnRzLnZpZGVvLm1hbmRhdG9yeS5tYXhIZWlnaHQgPSBoZWlnaHRTcGVjaWZpZWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuIiwiLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4vKiBlc2xpbnQtZW52IG5vZGUgKi9cbid1c2Ugc3RyaWN0JztcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcblxuZXhwb3J0IHtzaGltR2V0VXNlck1lZGlhfSBmcm9tICcuL2dldHVzZXJtZWRpYSc7XG5leHBvcnQge3NoaW1HZXREaXNwbGF5TWVkaWF9IGZyb20gJy4vZ2V0ZGlzcGxheW1lZGlhJztcblxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1NZWRpYVN0cmVhbSh3aW5kb3cpIHtcbiAgd2luZG93Lk1lZGlhU3RyZWFtID0gd2luZG93Lk1lZGlhU3RyZWFtIHx8IHdpbmRvdy53ZWJraXRNZWRpYVN0cmVhbTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1PblRyYWNrKHdpbmRvdykge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmICEoJ29udHJhY2snIGluXG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLCAnb250cmFjaycsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29udHJhY2s7XG4gICAgICB9LFxuICAgICAgc2V0KGYpIHtcbiAgICAgICAgaWYgKHRoaXMuX29udHJhY2spIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYWNrJywgdGhpcy5fb250cmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0cmFjaycsIHRoaXMuX29udHJhY2sgPSBmKTtcbiAgICAgIH0sXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgY29uc3Qgb3JpZ1NldFJlbW90ZURlc2NyaXB0aW9uID1cbiAgICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbjtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uID1cbiAgICAgIGZ1bmN0aW9uIHNldFJlbW90ZURlc2NyaXB0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuX29udHJhY2twb2x5KSB7XG4gICAgICAgICAgdGhpcy5fb250cmFja3BvbHkgPSAoZSkgPT4ge1xuICAgICAgICAgICAgLy8gb25hZGRzdHJlYW0gZG9lcyBub3QgZmlyZSB3aGVuIGEgdHJhY2sgaXMgYWRkZWQgdG8gYW4gZXhpc3RpbmdcbiAgICAgICAgICAgIC8vIHN0cmVhbS4gQnV0IHN0cmVhbS5vbmFkZHRyYWNrIGlzIGltcGxlbWVudGVkIHNvIHdlIHVzZSB0aGF0LlxuICAgICAgICAgICAgZS5zdHJlYW0uYWRkRXZlbnRMaXN0ZW5lcignYWRkdHJhY2snLCB0ZSA9PiB7XG4gICAgICAgICAgICAgIGxldCByZWNlaXZlcjtcbiAgICAgICAgICAgICAgaWYgKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0UmVjZWl2ZXJzKSB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZXIgPSB0aGlzLmdldFJlY2VpdmVycygpXG4gICAgICAgICAgICAgICAgICAuZmluZChyID0+IHIudHJhY2sgJiYgci50cmFjay5pZCA9PT0gdGUudHJhY2suaWQpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVyID0ge3RyYWNrOiB0ZS50cmFja307XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjb25zdCBldmVudCA9IG5ldyBFdmVudCgndHJhY2snKTtcbiAgICAgICAgICAgICAgZXZlbnQudHJhY2sgPSB0ZS50cmFjaztcbiAgICAgICAgICAgICAgZXZlbnQucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgICAgICAgZXZlbnQudHJhbnNjZWl2ZXIgPSB7cmVjZWl2ZXJ9O1xuICAgICAgICAgICAgICBldmVudC5zdHJlYW1zID0gW2Uuc3RyZWFtXTtcbiAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZS5zdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICAgICAgICAgIGxldCByZWNlaXZlcjtcbiAgICAgICAgICAgICAgaWYgKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0UmVjZWl2ZXJzKSB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZXIgPSB0aGlzLmdldFJlY2VpdmVycygpXG4gICAgICAgICAgICAgICAgICAuZmluZChyID0+IHIudHJhY2sgJiYgci50cmFjay5pZCA9PT0gdHJhY2suaWQpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVyID0ge3RyYWNrfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBldmVudCA9IG5ldyBFdmVudCgndHJhY2snKTtcbiAgICAgICAgICAgICAgZXZlbnQudHJhY2sgPSB0cmFjaztcbiAgICAgICAgICAgICAgZXZlbnQucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgICAgICAgZXZlbnQudHJhbnNjZWl2ZXIgPSB7cmVjZWl2ZXJ9O1xuICAgICAgICAgICAgICBldmVudC5zdHJlYW1zID0gW2Uuc3RyZWFtXTtcbiAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdhZGRzdHJlYW0nLCB0aGlzLl9vbnRyYWNrcG9seSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9yaWdTZXRSZW1vdGVEZXNjcmlwdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBldmVuIGlmIFJUQ1J0cFRyYW5zY2VpdmVyIGlzIGluIHdpbmRvdywgaXQgaXMgb25seSB1c2VkIGFuZFxuICAgIC8vIGVtaXR0ZWQgaW4gdW5pZmllZC1wbGFuLiBVbmZvcnR1bmF0ZWx5IHRoaXMgbWVhbnMgd2UgbmVlZFxuICAgIC8vIHRvIHVuY29uZGl0aW9uYWxseSB3cmFwIHRoZSBldmVudC5cbiAgICB1dGlscy53cmFwUGVlckNvbm5lY3Rpb25FdmVudCh3aW5kb3csICd0cmFjaycsIGUgPT4ge1xuICAgICAgaWYgKCFlLnRyYW5zY2VpdmVyKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCAndHJhbnNjZWl2ZXInLFxuICAgICAgICAgIHt2YWx1ZToge3JlY2VpdmVyOiBlLnJlY2VpdmVyfX0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGU7XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1HZXRTZW5kZXJzV2l0aER0bWYod2luZG93KSB7XG4gIC8vIE92ZXJyaWRlcyBhZGRUcmFjay9yZW1vdmVUcmFjaywgZGVwZW5kcyBvbiBzaGltQWRkVHJhY2tSZW1vdmVUcmFjay5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJlxuICAgICAgISgnZ2V0U2VuZGVycycgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkgJiZcbiAgICAgICdjcmVhdGVEVE1GU2VuZGVyJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSB7XG4gICAgY29uc3Qgc2hpbVNlbmRlcldpdGhEdG1mID0gZnVuY3Rpb24ocGMsIHRyYWNrKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0cmFjayxcbiAgICAgICAgZ2V0IGR0bWYoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2R0bWYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHRyYWNrLmtpbmQgPT09ICdhdWRpbycpIHtcbiAgICAgICAgICAgICAgdGhpcy5fZHRtZiA9IHBjLmNyZWF0ZURUTUZTZW5kZXIodHJhY2spO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5fZHRtZiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLl9kdG1mO1xuICAgICAgICB9LFxuICAgICAgICBfcGM6IHBjXG4gICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBhdWdtZW50IGFkZFRyYWNrIHdoZW4gZ2V0U2VuZGVycyBpcyBub3QgYXZhaWxhYmxlLlxuICAgIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTZW5kZXJzKSB7XG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFNlbmRlcnMgPSBmdW5jdGlvbiBnZXRTZW5kZXJzKCkge1xuICAgICAgICB0aGlzLl9zZW5kZXJzID0gdGhpcy5fc2VuZGVycyB8fCBbXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbmRlcnMuc2xpY2UoKTsgLy8gcmV0dXJuIGEgY29weSBvZiB0aGUgaW50ZXJuYWwgc3RhdGUuXG4gICAgICB9O1xuICAgICAgY29uc3Qgb3JpZ0FkZFRyYWNrID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjaztcbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2sgPVxuICAgICAgICBmdW5jdGlvbiBhZGRUcmFjayh0cmFjaywgc3RyZWFtKSB7XG4gICAgICAgICAgbGV0IHNlbmRlciA9IG9yaWdBZGRUcmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIGlmICghc2VuZGVyKSB7XG4gICAgICAgICAgICBzZW5kZXIgPSBzaGltU2VuZGVyV2l0aER0bWYodGhpcywgdHJhY2spO1xuICAgICAgICAgICAgdGhpcy5fc2VuZGVycy5wdXNoKHNlbmRlcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzZW5kZXI7XG4gICAgICAgIH07XG5cbiAgICAgIGNvbnN0IG9yaWdSZW1vdmVUcmFjayA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlVHJhY2s7XG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVRyYWNrID1cbiAgICAgICAgZnVuY3Rpb24gcmVtb3ZlVHJhY2soc2VuZGVyKSB7XG4gICAgICAgICAgb3JpZ1JlbW92ZVRyYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5fc2VuZGVycy5pbmRleE9mKHNlbmRlcik7XG4gICAgICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbmRlcnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBvcmlnQWRkU3RyZWFtID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRTdHJlYW07XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRTdHJlYW0gPSBmdW5jdGlvbiBhZGRTdHJlYW0oc3RyZWFtKSB7XG4gICAgICB0aGlzLl9zZW5kZXJzID0gdGhpcy5fc2VuZGVycyB8fCBbXTtcbiAgICAgIG9yaWdBZGRTdHJlYW0uYXBwbHkodGhpcywgW3N0cmVhbV0pO1xuICAgICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4ge1xuICAgICAgICB0aGlzLl9zZW5kZXJzLnB1c2goc2hpbVNlbmRlcldpdGhEdG1mKHRoaXMsIHRyYWNrKSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3Qgb3JpZ1JlbW92ZVN0cmVhbSA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlU3RyZWFtO1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlU3RyZWFtID1cbiAgICAgIGZ1bmN0aW9uIHJlbW92ZVN0cmVhbShzdHJlYW0pIHtcbiAgICAgICAgdGhpcy5fc2VuZGVycyA9IHRoaXMuX3NlbmRlcnMgfHwgW107XG4gICAgICAgIG9yaWdSZW1vdmVTdHJlYW0uYXBwbHkodGhpcywgW3N0cmVhbV0pO1xuXG4gICAgICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHtcbiAgICAgICAgICBjb25zdCBzZW5kZXIgPSB0aGlzLl9zZW5kZXJzLmZpbmQocyA9PiBzLnRyYWNrID09PSB0cmFjayk7XG4gICAgICAgICAgaWYgKHNlbmRlcikgeyAvLyByZW1vdmUgc2VuZGVyXG4gICAgICAgICAgICB0aGlzLl9zZW5kZXJzLnNwbGljZSh0aGlzLl9zZW5kZXJzLmluZGV4T2Yoc2VuZGVyKSwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmXG4gICAgICAgICAgICAgJ2dldFNlbmRlcnMnIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUgJiZcbiAgICAgICAgICAgICAnY3JlYXRlRFRNRlNlbmRlcicgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSAmJlxuICAgICAgICAgICAgIHdpbmRvdy5SVENSdHBTZW5kZXIgJiZcbiAgICAgICAgICAgICAhKCdkdG1mJyBpbiB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZSkpIHtcbiAgICBjb25zdCBvcmlnR2V0U2VuZGVycyA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U2VuZGVycztcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFNlbmRlcnMgPSBmdW5jdGlvbiBnZXRTZW5kZXJzKCkge1xuICAgICAgY29uc3Qgc2VuZGVycyA9IG9yaWdHZXRTZW5kZXJzLmFwcGx5KHRoaXMsIFtdKTtcbiAgICAgIHNlbmRlcnMuZm9yRWFjaChzZW5kZXIgPT4gc2VuZGVyLl9wYyA9IHRoaXMpO1xuICAgICAgcmV0dXJuIHNlbmRlcnM7XG4gICAgfTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZSwgJ2R0bWYnLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9kdG1mID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAodGhpcy50cmFjay5raW5kID09PSAnYXVkaW8nKSB7XG4gICAgICAgICAgICB0aGlzLl9kdG1mID0gdGhpcy5fcGMuY3JlYXRlRFRNRlNlbmRlcih0aGlzLnRyYWNrKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZHRtZiA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kdG1mO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGltR2V0U3RhdHMod2luZG93KSB7XG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgb3JpZ0dldFN0YXRzID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTdGF0cztcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uIGdldFN0YXRzKCkge1xuICAgIGNvbnN0IFtzZWxlY3Rvciwgb25TdWNjLCBvbkVycl0gPSBhcmd1bWVudHM7XG5cbiAgICAvLyBJZiBzZWxlY3RvciBpcyBhIGZ1bmN0aW9uIHRoZW4gd2UgYXJlIGluIHRoZSBvbGQgc3R5bGUgc3RhdHMgc28ganVzdFxuICAgIC8vIHBhc3MgYmFjayB0aGUgb3JpZ2luYWwgZ2V0U3RhdHMgZm9ybWF0IHRvIGF2b2lkIGJyZWFraW5nIG9sZCB1c2Vycy5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgdHlwZW9mIHNlbGVjdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gb3JpZ0dldFN0YXRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgLy8gV2hlbiBzcGVjLXN0eWxlIGdldFN0YXRzIGlzIHN1cHBvcnRlZCwgcmV0dXJuIHRob3NlIHdoZW4gY2FsbGVkIHdpdGhcbiAgICAvLyBlaXRoZXIgbm8gYXJndW1lbnRzIG9yIHRoZSBzZWxlY3RvciBhcmd1bWVudCBpcyBudWxsLlxuICAgIGlmIChvcmlnR2V0U3RhdHMubGVuZ3RoID09PSAwICYmIChhcmd1bWVudHMubGVuZ3RoID09PSAwIHx8XG4gICAgICAgIHR5cGVvZiBzZWxlY3RvciAhPT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgIHJldHVybiBvcmlnR2V0U3RhdHMuYXBwbHkodGhpcywgW10pO1xuICAgIH1cblxuICAgIGNvbnN0IGZpeENocm9tZVN0YXRzXyA9IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICBjb25zdCBzdGFuZGFyZFJlcG9ydCA9IHt9O1xuICAgICAgY29uc3QgcmVwb3J0cyA9IHJlc3BvbnNlLnJlc3VsdCgpO1xuICAgICAgcmVwb3J0cy5mb3JFYWNoKHJlcG9ydCA9PiB7XG4gICAgICAgIGNvbnN0IHN0YW5kYXJkU3RhdHMgPSB7XG4gICAgICAgICAgaWQ6IHJlcG9ydC5pZCxcbiAgICAgICAgICB0aW1lc3RhbXA6IHJlcG9ydC50aW1lc3RhbXAsXG4gICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgbG9jYWxjYW5kaWRhdGU6ICdsb2NhbC1jYW5kaWRhdGUnLFxuICAgICAgICAgICAgcmVtb3RlY2FuZGlkYXRlOiAncmVtb3RlLWNhbmRpZGF0ZSdcbiAgICAgICAgICB9W3JlcG9ydC50eXBlXSB8fCByZXBvcnQudHlwZVxuICAgICAgICB9O1xuICAgICAgICByZXBvcnQubmFtZXMoKS5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgICAgIHN0YW5kYXJkU3RhdHNbbmFtZV0gPSByZXBvcnQuc3RhdChuYW1lKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHN0YW5kYXJkUmVwb3J0W3N0YW5kYXJkU3RhdHMuaWRdID0gc3RhbmRhcmRTdGF0cztcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gc3RhbmRhcmRSZXBvcnQ7XG4gICAgfTtcblxuICAgIC8vIHNoaW0gZ2V0U3RhdHMgd2l0aCBtYXBsaWtlIHN1cHBvcnRcbiAgICBjb25zdCBtYWtlTWFwU3RhdHMgPSBmdW5jdGlvbihzdGF0cykge1xuICAgICAgcmV0dXJuIG5ldyBNYXAoT2JqZWN0LmtleXMoc3RhdHMpLm1hcChrZXkgPT4gW2tleSwgc3RhdHNba2V5XV0pKTtcbiAgICB9O1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMikge1xuICAgICAgY29uc3Qgc3VjY2Vzc0NhbGxiYWNrV3JhcHBlcl8gPSBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICBvblN1Y2MobWFrZU1hcFN0YXRzKGZpeENocm9tZVN0YXRzXyhyZXNwb25zZSkpKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBvcmlnR2V0U3RhdHMuYXBwbHkodGhpcywgW3N1Y2Nlc3NDYWxsYmFja1dyYXBwZXJfLFxuICAgICAgICBzZWxlY3Rvcl0pO1xuICAgIH1cblxuICAgIC8vIHByb21pc2Utc3VwcG9ydFxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBvcmlnR2V0U3RhdHMuYXBwbHkodGhpcywgW1xuICAgICAgICBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgIHJlc29sdmUobWFrZU1hcFN0YXRzKGZpeENocm9tZVN0YXRzXyhyZXNwb25zZSkpKTtcbiAgICAgICAgfSwgcmVqZWN0XSk7XG4gICAgfSkudGhlbihvblN1Y2MsIG9uRXJyKTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1TZW5kZXJSZWNlaXZlckdldFN0YXRzKHdpbmRvdykge1xuICBpZiAoISh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiZcbiAgICAgIHdpbmRvdy5SVENSdHBTZW5kZXIgJiYgd2luZG93LlJUQ1J0cFJlY2VpdmVyKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHNoaW0gc2VuZGVyIHN0YXRzLlxuICBpZiAoISgnZ2V0U3RhdHMnIGluIHdpbmRvdy5SVENSdHBTZW5kZXIucHJvdG90eXBlKSkge1xuICAgIGNvbnN0IG9yaWdHZXRTZW5kZXJzID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTZW5kZXJzO1xuICAgIGlmIChvcmlnR2V0U2VuZGVycykge1xuICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTZW5kZXJzID0gZnVuY3Rpb24gZ2V0U2VuZGVycygpIHtcbiAgICAgICAgY29uc3Qgc2VuZGVycyA9IG9yaWdHZXRTZW5kZXJzLmFwcGx5KHRoaXMsIFtdKTtcbiAgICAgICAgc2VuZGVycy5mb3JFYWNoKHNlbmRlciA9PiBzZW5kZXIuX3BjID0gdGhpcyk7XG4gICAgICAgIHJldHVybiBzZW5kZXJzO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCBvcmlnQWRkVHJhY2sgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrO1xuICAgIGlmIChvcmlnQWRkVHJhY2spIHtcbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2sgPSBmdW5jdGlvbiBhZGRUcmFjaygpIHtcbiAgICAgICAgY29uc3Qgc2VuZGVyID0gb3JpZ0FkZFRyYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHNlbmRlci5fcGMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gc2VuZGVyO1xuICAgICAgfTtcbiAgICB9XG4gICAgd2luZG93LlJUQ1J0cFNlbmRlci5wcm90b3R5cGUuZ2V0U3RhdHMgPSBmdW5jdGlvbiBnZXRTdGF0cygpIHtcbiAgICAgIGNvbnN0IHNlbmRlciA9IHRoaXM7XG4gICAgICByZXR1cm4gdGhpcy5fcGMuZ2V0U3RhdHMoKS50aGVuKHJlc3VsdCA9PlxuICAgICAgICAvKiBOb3RlOiB0aGlzIHdpbGwgaW5jbHVkZSBzdGF0cyBvZiBhbGwgc2VuZGVycyB0aGF0XG4gICAgICAgICAqICAgc2VuZCBhIHRyYWNrIHdpdGggdGhlIHNhbWUgaWQgYXMgc2VuZGVyLnRyYWNrIGFzXG4gICAgICAgICAqICAgaXQgaXMgbm90IHBvc3NpYmxlIHRvIGlkZW50aWZ5IHRoZSBSVENSdHBTZW5kZXIuXG4gICAgICAgICAqL1xuICAgICAgICB1dGlscy5maWx0ZXJTdGF0cyhyZXN1bHQsIHNlbmRlci50cmFjaywgdHJ1ZSkpO1xuICAgIH07XG4gIH1cblxuICAvLyBzaGltIHJlY2VpdmVyIHN0YXRzLlxuICBpZiAoISgnZ2V0U3RhdHMnIGluIHdpbmRvdy5SVENSdHBSZWNlaXZlci5wcm90b3R5cGUpKSB7XG4gICAgY29uc3Qgb3JpZ0dldFJlY2VpdmVycyA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0UmVjZWl2ZXJzO1xuICAgIGlmIChvcmlnR2V0UmVjZWl2ZXJzKSB7XG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFJlY2VpdmVycyA9XG4gICAgICAgIGZ1bmN0aW9uIGdldFJlY2VpdmVycygpIHtcbiAgICAgICAgICBjb25zdCByZWNlaXZlcnMgPSBvcmlnR2V0UmVjZWl2ZXJzLmFwcGx5KHRoaXMsIFtdKTtcbiAgICAgICAgICByZWNlaXZlcnMuZm9yRWFjaChyZWNlaXZlciA9PiByZWNlaXZlci5fcGMgPSB0aGlzKTtcbiAgICAgICAgICByZXR1cm4gcmVjZWl2ZXJzO1xuICAgICAgICB9O1xuICAgIH1cbiAgICB1dGlscy53cmFwUGVlckNvbm5lY3Rpb25FdmVudCh3aW5kb3csICd0cmFjaycsIGUgPT4ge1xuICAgICAgZS5yZWNlaXZlci5fcGMgPSBlLnNyY0VsZW1lbnQ7XG4gICAgICByZXR1cm4gZTtcbiAgICB9KTtcbiAgICB3aW5kb3cuUlRDUnRwUmVjZWl2ZXIucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24gZ2V0U3RhdHMoKSB7XG4gICAgICBjb25zdCByZWNlaXZlciA9IHRoaXM7XG4gICAgICByZXR1cm4gdGhpcy5fcGMuZ2V0U3RhdHMoKS50aGVuKHJlc3VsdCA9PlxuICAgICAgICB1dGlscy5maWx0ZXJTdGF0cyhyZXN1bHQsIHJlY2VpdmVyLnRyYWNrLCBmYWxzZSkpO1xuICAgIH07XG4gIH1cblxuICBpZiAoISgnZ2V0U3RhdHMnIGluIHdpbmRvdy5SVENSdHBTZW5kZXIucHJvdG90eXBlICYmXG4gICAgICAnZ2V0U3RhdHMnIGluIHdpbmRvdy5SVENSdHBSZWNlaXZlci5wcm90b3R5cGUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gc2hpbSBSVENQZWVyQ29ubmVjdGlvbi5nZXRTdGF0cyh0cmFjaykuXG4gIGNvbnN0IG9yaWdHZXRTdGF0cyA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U3RhdHM7XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U3RhdHMgPSBmdW5jdGlvbiBnZXRTdGF0cygpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgYXJndW1lbnRzWzBdIGluc3RhbmNlb2Ygd2luZG93Lk1lZGlhU3RyZWFtVHJhY2spIHtcbiAgICAgIGNvbnN0IHRyYWNrID0gYXJndW1lbnRzWzBdO1xuICAgICAgbGV0IHNlbmRlcjtcbiAgICAgIGxldCByZWNlaXZlcjtcbiAgICAgIGxldCBlcnI7XG4gICAgICB0aGlzLmdldFNlbmRlcnMoKS5mb3JFYWNoKHMgPT4ge1xuICAgICAgICBpZiAocy50cmFjayA9PT0gdHJhY2spIHtcbiAgICAgICAgICBpZiAoc2VuZGVyKSB7XG4gICAgICAgICAgICBlcnIgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZW5kZXIgPSBzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmdldFJlY2VpdmVycygpLmZvckVhY2gociA9PiB7XG4gICAgICAgIGlmIChyLnRyYWNrID09PSB0cmFjaykge1xuICAgICAgICAgIGlmIChyZWNlaXZlcikge1xuICAgICAgICAgICAgZXJyID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVjZWl2ZXIgPSByO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gci50cmFjayA9PT0gdHJhY2s7XG4gICAgICB9KTtcbiAgICAgIGlmIChlcnIgfHwgKHNlbmRlciAmJiByZWNlaXZlcikpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBET01FeGNlcHRpb24oXG4gICAgICAgICAgJ1RoZXJlIGFyZSBtb3JlIHRoYW4gb25lIHNlbmRlciBvciByZWNlaXZlciBmb3IgdGhlIHRyYWNrLicsXG4gICAgICAgICAgJ0ludmFsaWRBY2Nlc3NFcnJvcicpKTtcbiAgICAgIH0gZWxzZSBpZiAoc2VuZGVyKSB7XG4gICAgICAgIHJldHVybiBzZW5kZXIuZ2V0U3RhdHMoKTtcbiAgICAgIH0gZWxzZSBpZiAocmVjZWl2ZXIpIHtcbiAgICAgICAgcmV0dXJuIHJlY2VpdmVyLmdldFN0YXRzKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IERPTUV4Y2VwdGlvbihcbiAgICAgICAgJ1RoZXJlIGlzIG5vIHNlbmRlciBvciByZWNlaXZlciBmb3IgdGhlIHRyYWNrLicsXG4gICAgICAgICdJbnZhbGlkQWNjZXNzRXJyb3InKSk7XG4gICAgfVxuICAgIHJldHVybiBvcmlnR2V0U3RhdHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1BZGRUcmFja1JlbW92ZVRyYWNrV2l0aE5hdGl2ZSh3aW5kb3cpIHtcbiAgLy8gc2hpbSBhZGRUcmFjay9yZW1vdmVUcmFjayB3aXRoIG5hdGl2ZSB2YXJpYW50cyBpbiBvcmRlciB0byBtYWtlXG4gIC8vIHRoZSBpbnRlcmFjdGlvbnMgd2l0aCBsZWdhY3kgZ2V0TG9jYWxTdHJlYW1zIGJlaGF2ZSBhcyBpbiBvdGhlciBicm93c2Vycy5cbiAgLy8gS2VlcHMgYSBtYXBwaW5nIHN0cmVhbS5pZCA9PiBbc3RyZWFtLCBydHBzZW5kZXJzLi4uXVxuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldExvY2FsU3RyZWFtcyA9XG4gICAgZnVuY3Rpb24gZ2V0TG9jYWxTdHJlYW1zKCkge1xuICAgICAgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcyA9IHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMgfHwge307XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcylcbiAgICAgICAgLm1hcChzdHJlYW1JZCA9PiB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbUlkXVswXSk7XG4gICAgfTtcblxuICBjb25zdCBvcmlnQWRkVHJhY2sgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrID1cbiAgICBmdW5jdGlvbiBhZGRUcmFjayh0cmFjaywgc3RyZWFtKSB7XG4gICAgICBpZiAoIXN0cmVhbSkge1xuICAgICAgICByZXR1cm4gb3JpZ0FkZFRyYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zID0gdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcyB8fCB7fTtcblxuICAgICAgY29uc3Qgc2VuZGVyID0gb3JpZ0FkZFRyYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAoIXRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtLmlkXSkge1xuICAgICAgICB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbS5pZF0gPSBbc3RyZWFtLCBzZW5kZXJdO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbS5pZF0uaW5kZXhPZihzZW5kZXIpID09PSAtMSkge1xuICAgICAgICB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbS5pZF0ucHVzaChzZW5kZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbmRlcjtcbiAgICB9O1xuXG4gIGNvbnN0IG9yaWdBZGRTdHJlYW0gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFN0cmVhbTtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRTdHJlYW0gPSBmdW5jdGlvbiBhZGRTdHJlYW0oc3RyZWFtKSB7XG4gICAgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcyA9IHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMgfHwge307XG5cbiAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICBjb25zdCBhbHJlYWR5RXhpc3RzID0gdGhpcy5nZXRTZW5kZXJzKCkuZmluZChzID0+IHMudHJhY2sgPT09IHRyYWNrKTtcbiAgICAgIGlmIChhbHJlYWR5RXhpc3RzKSB7XG4gICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ1RyYWNrIGFscmVhZHkgZXhpc3RzLicsXG4gICAgICAgICAgJ0ludmFsaWRBY2Nlc3NFcnJvcicpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGV4aXN0aW5nU2VuZGVycyA9IHRoaXMuZ2V0U2VuZGVycygpO1xuICAgIG9yaWdBZGRTdHJlYW0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBjb25zdCBuZXdTZW5kZXJzID0gdGhpcy5nZXRTZW5kZXJzKClcbiAgICAgIC5maWx0ZXIobmV3U2VuZGVyID0+IGV4aXN0aW5nU2VuZGVycy5pbmRleE9mKG5ld1NlbmRlcikgPT09IC0xKTtcbiAgICB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbS5pZF0gPSBbc3RyZWFtXS5jb25jYXQobmV3U2VuZGVycyk7XG4gIH07XG5cbiAgY29uc3Qgb3JpZ1JlbW92ZVN0cmVhbSA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlU3RyZWFtO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVN0cmVhbSA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlU3RyZWFtKHN0cmVhbSkge1xuICAgICAgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcyA9IHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMgfHwge307XG4gICAgICBkZWxldGUgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW0uaWRdO1xuICAgICAgcmV0dXJuIG9yaWdSZW1vdmVTdHJlYW0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gIGNvbnN0IG9yaWdSZW1vdmVUcmFjayA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlVHJhY2s7XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlVHJhY2sgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZVRyYWNrKHNlbmRlcikge1xuICAgICAgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcyA9IHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMgfHwge307XG4gICAgICBpZiAoc2VuZGVyKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMpLmZvckVhY2goc3RyZWFtSWQgPT4ge1xuICAgICAgICAgIGNvbnN0IGlkeCA9IHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtSWRdLmluZGV4T2Yoc2VuZGVyKTtcbiAgICAgICAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW1JZF0uc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbUlkXS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbUlkXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9yaWdSZW1vdmVUcmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGltQWRkVHJhY2tSZW1vdmVUcmFjayh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKSB7XG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIHNoaW0gYWRkVHJhY2sgYW5kIHJlbW92ZVRyYWNrLlxuICBpZiAod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjayAmJlxuICAgICAgYnJvd3NlckRldGFpbHMudmVyc2lvbiA+PSA2NSkge1xuICAgIHJldHVybiBzaGltQWRkVHJhY2tSZW1vdmVUcmFja1dpdGhOYXRpdmUod2luZG93KTtcbiAgfVxuXG4gIC8vIGFsc28gc2hpbSBwYy5nZXRMb2NhbFN0cmVhbXMgd2hlbiBhZGRUcmFjayBpcyBzaGltbWVkXG4gIC8vIHRvIHJldHVybiB0aGUgb3JpZ2luYWwgc3RyZWFtcy5cbiAgY29uc3Qgb3JpZ0dldExvY2FsU3RyZWFtcyA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGVcbiAgICAuZ2V0TG9jYWxTdHJlYW1zO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldExvY2FsU3RyZWFtcyA9XG4gICAgZnVuY3Rpb24gZ2V0TG9jYWxTdHJlYW1zKCkge1xuICAgICAgY29uc3QgbmF0aXZlU3RyZWFtcyA9IG9yaWdHZXRMb2NhbFN0cmVhbXMuYXBwbHkodGhpcyk7XG4gICAgICB0aGlzLl9yZXZlcnNlU3RyZWFtcyA9IHRoaXMuX3JldmVyc2VTdHJlYW1zIHx8IHt9O1xuICAgICAgcmV0dXJuIG5hdGl2ZVN0cmVhbXMubWFwKHN0cmVhbSA9PiB0aGlzLl9yZXZlcnNlU3RyZWFtc1tzdHJlYW0uaWRdKTtcbiAgICB9O1xuXG4gIGNvbnN0IG9yaWdBZGRTdHJlYW0gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFN0cmVhbTtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRTdHJlYW0gPSBmdW5jdGlvbiBhZGRTdHJlYW0oc3RyZWFtKSB7XG4gICAgdGhpcy5fc3RyZWFtcyA9IHRoaXMuX3N0cmVhbXMgfHwge307XG4gICAgdGhpcy5fcmV2ZXJzZVN0cmVhbXMgPSB0aGlzLl9yZXZlcnNlU3RyZWFtcyB8fCB7fTtcblxuICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHtcbiAgICAgIGNvbnN0IGFscmVhZHlFeGlzdHMgPSB0aGlzLmdldFNlbmRlcnMoKS5maW5kKHMgPT4gcy50cmFjayA9PT0gdHJhY2spO1xuICAgICAgaWYgKGFscmVhZHlFeGlzdHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignVHJhY2sgYWxyZWFkeSBleGlzdHMuJyxcbiAgICAgICAgICAnSW52YWxpZEFjY2Vzc0Vycm9yJyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLy8gQWRkIGlkZW50aXR5IG1hcHBpbmcgZm9yIGNvbnNpc3RlbmN5IHdpdGggYWRkVHJhY2suXG4gICAgLy8gVW5sZXNzIHRoaXMgaXMgYmVpbmcgdXNlZCB3aXRoIGEgc3RyZWFtIGZyb20gYWRkVHJhY2suXG4gICAgaWYgKCF0aGlzLl9yZXZlcnNlU3RyZWFtc1tzdHJlYW0uaWRdKSB7XG4gICAgICBjb25zdCBuZXdTdHJlYW0gPSBuZXcgd2luZG93Lk1lZGlhU3RyZWFtKHN0cmVhbS5nZXRUcmFja3MoKSk7XG4gICAgICB0aGlzLl9zdHJlYW1zW3N0cmVhbS5pZF0gPSBuZXdTdHJlYW07XG4gICAgICB0aGlzLl9yZXZlcnNlU3RyZWFtc1tuZXdTdHJlYW0uaWRdID0gc3RyZWFtO1xuICAgICAgc3RyZWFtID0gbmV3U3RyZWFtO1xuICAgIH1cbiAgICBvcmlnQWRkU3RyZWFtLmFwcGx5KHRoaXMsIFtzdHJlYW1dKTtcbiAgfTtcblxuICBjb25zdCBvcmlnUmVtb3ZlU3RyZWFtID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVTdHJlYW07XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlU3RyZWFtID1cbiAgICBmdW5jdGlvbiByZW1vdmVTdHJlYW0oc3RyZWFtKSB7XG4gICAgICB0aGlzLl9zdHJlYW1zID0gdGhpcy5fc3RyZWFtcyB8fCB7fTtcbiAgICAgIHRoaXMuX3JldmVyc2VTdHJlYW1zID0gdGhpcy5fcmV2ZXJzZVN0cmVhbXMgfHwge307XG5cbiAgICAgIG9yaWdSZW1vdmVTdHJlYW0uYXBwbHkodGhpcywgWyh0aGlzLl9zdHJlYW1zW3N0cmVhbS5pZF0gfHwgc3RyZWFtKV0pO1xuICAgICAgZGVsZXRlIHRoaXMuX3JldmVyc2VTdHJlYW1zWyh0aGlzLl9zdHJlYW1zW3N0cmVhbS5pZF0gP1xuICAgICAgICB0aGlzLl9zdHJlYW1zW3N0cmVhbS5pZF0uaWQgOiBzdHJlYW0uaWQpXTtcbiAgICAgIGRlbGV0ZSB0aGlzLl9zdHJlYW1zW3N0cmVhbS5pZF07XG4gICAgfTtcblxuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrID1cbiAgICBmdW5jdGlvbiBhZGRUcmFjayh0cmFjaywgc3RyZWFtKSB7XG4gICAgICBpZiAodGhpcy5zaWduYWxpbmdTdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihcbiAgICAgICAgICAnVGhlIFJUQ1BlZXJDb25uZWN0aW9uXFwncyBzaWduYWxpbmdTdGF0ZSBpcyBcXCdjbG9zZWRcXCcuJyxcbiAgICAgICAgICAnSW52YWxpZFN0YXRlRXJyb3InKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0cmVhbXMgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICBpZiAoc3RyZWFtcy5sZW5ndGggIT09IDEgfHxcbiAgICAgICAgICAhc3RyZWFtc1swXS5nZXRUcmFja3MoKS5maW5kKHQgPT4gdCA9PT0gdHJhY2spKSB7XG4gICAgICAgIC8vIHRoaXMgaXMgbm90IGZ1bGx5IGNvcnJlY3QgYnV0IGFsbCB3ZSBjYW4gbWFuYWdlIHdpdGhvdXRcbiAgICAgICAgLy8gW1thc3NvY2lhdGVkIE1lZGlhU3RyZWFtc11dIGludGVybmFsIHNsb3QuXG4gICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oXG4gICAgICAgICAgJ1RoZSBhZGFwdGVyLmpzIGFkZFRyYWNrIHBvbHlmaWxsIG9ubHkgc3VwcG9ydHMgYSBzaW5nbGUgJyArXG4gICAgICAgICAgJyBzdHJlYW0gd2hpY2ggaXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBzcGVjaWZpZWQgdHJhY2suJyxcbiAgICAgICAgICAnTm90U3VwcG9ydGVkRXJyb3InKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYWxyZWFkeUV4aXN0cyA9IHRoaXMuZ2V0U2VuZGVycygpLmZpbmQocyA9PiBzLnRyYWNrID09PSB0cmFjayk7XG4gICAgICBpZiAoYWxyZWFkeUV4aXN0cykge1xuICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdUcmFjayBhbHJlYWR5IGV4aXN0cy4nLFxuICAgICAgICAgICdJbnZhbGlkQWNjZXNzRXJyb3InKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc3RyZWFtcyA9IHRoaXMuX3N0cmVhbXMgfHwge307XG4gICAgICB0aGlzLl9yZXZlcnNlU3RyZWFtcyA9IHRoaXMuX3JldmVyc2VTdHJlYW1zIHx8IHt9O1xuICAgICAgY29uc3Qgb2xkU3RyZWFtID0gdGhpcy5fc3RyZWFtc1tzdHJlYW0uaWRdO1xuICAgICAgaWYgKG9sZFN0cmVhbSkge1xuICAgICAgICAvLyB0aGlzIGlzIHVzaW5nIG9kZCBDaHJvbWUgYmVoYXZpb3VyLCB1c2Ugd2l0aCBjYXV0aW9uOlxuICAgICAgICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3Avd2VicnRjL2lzc3Vlcy9kZXRhaWw/aWQ9NzgxNVxuICAgICAgICAvLyBOb3RlOiB3ZSByZWx5IG9uIHRoZSBoaWdoLWxldmVsIGFkZFRyYWNrL2R0bWYgc2hpbSB0b1xuICAgICAgICAvLyBjcmVhdGUgdGhlIHNlbmRlciB3aXRoIGEgZHRtZiBzZW5kZXIuXG4gICAgICAgIG9sZFN0cmVhbS5hZGRUcmFjayh0cmFjayk7XG5cbiAgICAgICAgLy8gVHJpZ2dlciBPTk4gYXN5bmMuXG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ25lZ290aWF0aW9ubmVlZGVkJykpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG5ld1N0cmVhbSA9IG5ldyB3aW5kb3cuTWVkaWFTdHJlYW0oW3RyYWNrXSk7XG4gICAgICAgIHRoaXMuX3N0cmVhbXNbc3RyZWFtLmlkXSA9IG5ld1N0cmVhbTtcbiAgICAgICAgdGhpcy5fcmV2ZXJzZVN0cmVhbXNbbmV3U3RyZWFtLmlkXSA9IHN0cmVhbTtcbiAgICAgICAgdGhpcy5hZGRTdHJlYW0obmV3U3RyZWFtKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmdldFNlbmRlcnMoKS5maW5kKHMgPT4gcy50cmFjayA9PT0gdHJhY2spO1xuICAgIH07XG5cbiAgLy8gcmVwbGFjZSB0aGUgaW50ZXJuYWwgc3RyZWFtIGlkIHdpdGggdGhlIGV4dGVybmFsIG9uZSBhbmRcbiAgLy8gdmljZSB2ZXJzYS5cbiAgZnVuY3Rpb24gcmVwbGFjZUludGVybmFsU3RyZWFtSWQocGMsIGRlc2NyaXB0aW9uKSB7XG4gICAgbGV0IHNkcCA9IGRlc2NyaXB0aW9uLnNkcDtcbiAgICBPYmplY3Qua2V5cyhwYy5fcmV2ZXJzZVN0cmVhbXMgfHwgW10pLmZvckVhY2goaW50ZXJuYWxJZCA9PiB7XG4gICAgICBjb25zdCBleHRlcm5hbFN0cmVhbSA9IHBjLl9yZXZlcnNlU3RyZWFtc1tpbnRlcm5hbElkXTtcbiAgICAgIGNvbnN0IGludGVybmFsU3RyZWFtID0gcGMuX3N0cmVhbXNbZXh0ZXJuYWxTdHJlYW0uaWRdO1xuICAgICAgc2RwID0gc2RwLnJlcGxhY2UobmV3IFJlZ0V4cChpbnRlcm5hbFN0cmVhbS5pZCwgJ2cnKSxcbiAgICAgICAgZXh0ZXJuYWxTdHJlYW0uaWQpO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKHtcbiAgICAgIHR5cGU6IGRlc2NyaXB0aW9uLnR5cGUsXG4gICAgICBzZHBcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiByZXBsYWNlRXh0ZXJuYWxTdHJlYW1JZChwYywgZGVzY3JpcHRpb24pIHtcbiAgICBsZXQgc2RwID0gZGVzY3JpcHRpb24uc2RwO1xuICAgIE9iamVjdC5rZXlzKHBjLl9yZXZlcnNlU3RyZWFtcyB8fCBbXSkuZm9yRWFjaChpbnRlcm5hbElkID0+IHtcbiAgICAgIGNvbnN0IGV4dGVybmFsU3RyZWFtID0gcGMuX3JldmVyc2VTdHJlYW1zW2ludGVybmFsSWRdO1xuICAgICAgY29uc3QgaW50ZXJuYWxTdHJlYW0gPSBwYy5fc3RyZWFtc1tleHRlcm5hbFN0cmVhbS5pZF07XG4gICAgICBzZHAgPSBzZHAucmVwbGFjZShuZXcgUmVnRXhwKGV4dGVybmFsU3RyZWFtLmlkLCAnZycpLFxuICAgICAgICBpbnRlcm5hbFN0cmVhbS5pZCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBSVENTZXNzaW9uRGVzY3JpcHRpb24oe1xuICAgICAgdHlwZTogZGVzY3JpcHRpb24udHlwZSxcbiAgICAgIHNkcFxuICAgIH0pO1xuICB9XG4gIFsnY3JlYXRlT2ZmZXInLCAnY3JlYXRlQW5zd2VyJ10uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICBjb25zdCBuYXRpdmVNZXRob2QgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlW21ldGhvZF07XG4gICAgY29uc3QgbWV0aG9kT2JqID0ge1ttZXRob2RdKCkge1xuICAgICAgY29uc3QgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIGNvbnN0IGlzTGVnYWN5Q2FsbCA9IGFyZ3VtZW50cy5sZW5ndGggJiZcbiAgICAgICAgICB0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnZnVuY3Rpb24nO1xuICAgICAgaWYgKGlzTGVnYWN5Q2FsbCkge1xuICAgICAgICByZXR1cm4gbmF0aXZlTWV0aG9kLmFwcGx5KHRoaXMsIFtcbiAgICAgICAgICAoZGVzY3JpcHRpb24pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRlc2MgPSByZXBsYWNlSW50ZXJuYWxTdHJlYW1JZCh0aGlzLCBkZXNjcmlwdGlvbik7XG4gICAgICAgICAgICBhcmdzWzBdLmFwcGx5KG51bGwsIFtkZXNjXSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICAoZXJyKSA9PiB7XG4gICAgICAgICAgICBpZiAoYXJnc1sxXSkge1xuICAgICAgICAgICAgICBhcmdzWzFdLmFwcGx5KG51bGwsIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgYXJndW1lbnRzWzJdXG4gICAgICAgIF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5hdGl2ZU1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgIC50aGVuKGRlc2NyaXB0aW9uID0+IHJlcGxhY2VJbnRlcm5hbFN0cmVhbUlkKHRoaXMsIGRlc2NyaXB0aW9uKSk7XG4gICAgfX07XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZVttZXRob2RdID0gbWV0aG9kT2JqW21ldGhvZF07XG4gIH0pO1xuXG4gIGNvbnN0IG9yaWdTZXRMb2NhbERlc2NyaXB0aW9uID1cbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0TG9jYWxEZXNjcmlwdGlvbjtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRMb2NhbERlc2NyaXB0aW9uID1cbiAgICBmdW5jdGlvbiBzZXRMb2NhbERlc2NyaXB0aW9uKCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoIHx8ICFhcmd1bWVudHNbMF0udHlwZSkge1xuICAgICAgICByZXR1cm4gb3JpZ1NldExvY2FsRGVzY3JpcHRpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIGFyZ3VtZW50c1swXSA9IHJlcGxhY2VFeHRlcm5hbFN0cmVhbUlkKHRoaXMsIGFyZ3VtZW50c1swXSk7XG4gICAgICByZXR1cm4gb3JpZ1NldExvY2FsRGVzY3JpcHRpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gIC8vIFRPRE86IG1hbmdsZSBnZXRTdGF0czogaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYnJ0Yy1zdGF0cy8jZG9tLXJ0Y21lZGlhc3RyZWFtc3RhdHMtc3RyZWFtaWRlbnRpZmllclxuXG4gIGNvbnN0IG9yaWdMb2NhbERlc2NyaXB0aW9uID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLCAnbG9jYWxEZXNjcmlwdGlvbicpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSxcbiAgICAnbG9jYWxEZXNjcmlwdGlvbicsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSBvcmlnTG9jYWxEZXNjcmlwdGlvbi5nZXQuYXBwbHkodGhpcyk7XG4gICAgICAgIGlmIChkZXNjcmlwdGlvbi50eXBlID09PSAnJykge1xuICAgICAgICAgIHJldHVybiBkZXNjcmlwdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVwbGFjZUludGVybmFsU3RyZWFtSWQodGhpcywgZGVzY3JpcHRpb24pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlVHJhY2sgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZVRyYWNrKHNlbmRlcikge1xuICAgICAgaWYgKHRoaXMuc2lnbmFsaW5nU3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oXG4gICAgICAgICAgJ1RoZSBSVENQZWVyQ29ubmVjdGlvblxcJ3Mgc2lnbmFsaW5nU3RhdGUgaXMgXFwnY2xvc2VkXFwnLicsXG4gICAgICAgICAgJ0ludmFsaWRTdGF0ZUVycm9yJyk7XG4gICAgICB9XG4gICAgICAvLyBXZSBjYW4gbm90IHlldCBjaGVjayBmb3Igc2VuZGVyIGluc3RhbmNlb2YgUlRDUnRwU2VuZGVyXG4gICAgICAvLyBzaW5jZSB3ZSBzaGltIFJUUFNlbmRlci4gU28gd2UgY2hlY2sgaWYgc2VuZGVyLl9wYyBpcyBzZXQuXG4gICAgICBpZiAoIXNlbmRlci5fcGMpIHtcbiAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignQXJndW1lbnQgMSBvZiBSVENQZWVyQ29ubmVjdGlvbi5yZW1vdmVUcmFjayAnICtcbiAgICAgICAgICAgICdkb2VzIG5vdCBpbXBsZW1lbnQgaW50ZXJmYWNlIFJUQ1J0cFNlbmRlci4nLCAnVHlwZUVycm9yJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBpc0xvY2FsID0gc2VuZGVyLl9wYyA9PT0gdGhpcztcbiAgICAgIGlmICghaXNMb2NhbCkge1xuICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdTZW5kZXIgd2FzIG5vdCBjcmVhdGVkIGJ5IHRoaXMgY29ubmVjdGlvbi4nLFxuICAgICAgICAgICdJbnZhbGlkQWNjZXNzRXJyb3InKTtcbiAgICAgIH1cblxuICAgICAgLy8gU2VhcmNoIGZvciB0aGUgbmF0aXZlIHN0cmVhbSB0aGUgc2VuZGVycyB0cmFjayBiZWxvbmdzIHRvLlxuICAgICAgdGhpcy5fc3RyZWFtcyA9IHRoaXMuX3N0cmVhbXMgfHwge307XG4gICAgICBsZXQgc3RyZWFtO1xuICAgICAgT2JqZWN0LmtleXModGhpcy5fc3RyZWFtcykuZm9yRWFjaChzdHJlYW1pZCA9PiB7XG4gICAgICAgIGNvbnN0IGhhc1RyYWNrID0gdGhpcy5fc3RyZWFtc1tzdHJlYW1pZF0uZ2V0VHJhY2tzKClcbiAgICAgICAgICAuZmluZCh0cmFjayA9PiBzZW5kZXIudHJhY2sgPT09IHRyYWNrKTtcbiAgICAgICAgaWYgKGhhc1RyYWNrKSB7XG4gICAgICAgICAgc3RyZWFtID0gdGhpcy5fc3RyZWFtc1tzdHJlYW1pZF07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoc3RyZWFtKSB7XG4gICAgICAgIGlmIChzdHJlYW0uZ2V0VHJhY2tzKCkubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgLy8gaWYgdGhpcyBpcyB0aGUgbGFzdCB0cmFjayBvZiB0aGUgc3RyZWFtLCByZW1vdmUgdGhlIHN0cmVhbS4gVGhpc1xuICAgICAgICAgIC8vIHRha2VzIGNhcmUgb2YgYW55IHNoaW1tZWQgX3NlbmRlcnMuXG4gICAgICAgICAgdGhpcy5yZW1vdmVTdHJlYW0odGhpcy5fcmV2ZXJzZVN0cmVhbXNbc3RyZWFtLmlkXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gcmVseWluZyBvbiB0aGUgc2FtZSBvZGQgY2hyb21lIGJlaGF2aW91ciBhcyBhYm92ZS5cbiAgICAgICAgICBzdHJlYW0ucmVtb3ZlVHJhY2soc2VuZGVyLnRyYWNrKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCduZWdvdGlhdGlvbm5lZWRlZCcpKTtcbiAgICAgIH1cbiAgICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hpbVBlZXJDb25uZWN0aW9uKHdpbmRvdywgYnJvd3NlckRldGFpbHMpIHtcbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgd2luZG93LndlYmtpdFJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgLy8gdmVyeSBiYXNpYyBzdXBwb3J0IGZvciBvbGQgdmVyc2lvbnMuXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uID0gd2luZG93LndlYmtpdFJUQ1BlZXJDb25uZWN0aW9uO1xuICB9XG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gc2hpbSBpbXBsaWNpdCBjcmVhdGlvbiBvZiBSVENTZXNzaW9uRGVzY3JpcHRpb24vUlRDSWNlQ2FuZGlkYXRlXG4gIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uIDwgNTMpIHtcbiAgICBbJ3NldExvY2FsRGVzY3JpcHRpb24nLCAnc2V0UmVtb3RlRGVzY3JpcHRpb24nLCAnYWRkSWNlQ2FuZGlkYXRlJ11cbiAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgICBjb25zdCBuYXRpdmVNZXRob2QgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlW21ldGhvZF07XG4gICAgICAgIGNvbnN0IG1ldGhvZE9iaiA9IHtbbWV0aG9kXSgpIHtcbiAgICAgICAgICBhcmd1bWVudHNbMF0gPSBuZXcgKChtZXRob2QgPT09ICdhZGRJY2VDYW5kaWRhdGUnKSA/XG4gICAgICAgICAgICB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlIDpcbiAgICAgICAgICAgIHdpbmRvdy5SVENTZXNzaW9uRGVzY3JpcHRpb24pKGFyZ3VtZW50c1swXSk7XG4gICAgICAgICAgcmV0dXJuIG5hdGl2ZU1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9fTtcbiAgICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZVttZXRob2RdID0gbWV0aG9kT2JqW21ldGhvZF07XG4gICAgICB9KTtcbiAgfVxufVxuXG4vLyBBdHRlbXB0IHRvIGZpeCBPTk4gaW4gcGxhbi1iIG1vZGUuXG5leHBvcnQgZnVuY3Rpb24gZml4TmVnb3RpYXRpb25OZWVkZWQod2luZG93LCBicm93c2VyRGV0YWlscykge1xuICB1dGlscy53cmFwUGVlckNvbm5lY3Rpb25FdmVudCh3aW5kb3csICduZWdvdGlhdGlvbm5lZWRlZCcsIGUgPT4ge1xuICAgIGNvbnN0IHBjID0gZS50YXJnZXQ7XG4gICAgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA3MiB8fCAocGMuZ2V0Q29uZmlndXJhdGlvbiAmJlxuICAgICAgICBwYy5nZXRDb25maWd1cmF0aW9uKCkuc2RwU2VtYW50aWNzID09PSAncGxhbi1iJykpIHtcbiAgICAgIGlmIChwYy5zaWduYWxpbmdTdGF0ZSAhPT0gJ3N0YWJsZScpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZTtcbiAgfSk7XG59XG4iLCIvKlxuICogIENvcHlyaWdodCAoYykgMjAxNiBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbi8qIGVzbGludC1lbnYgbm9kZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGltR2V0VXNlck1lZGlhKHdpbmRvdywgYnJvd3NlckRldGFpbHMpIHtcbiAgY29uc3QgbmF2aWdhdG9yID0gd2luZG93ICYmIHdpbmRvdy5uYXZpZ2F0b3I7XG4gIGNvbnN0IE1lZGlhU3RyZWFtVHJhY2sgPSB3aW5kb3cgJiYgd2luZG93Lk1lZGlhU3RyZWFtVHJhY2s7XG5cbiAgbmF2aWdhdG9yLmdldFVzZXJNZWRpYSA9IGZ1bmN0aW9uKGNvbnN0cmFpbnRzLCBvblN1Y2Nlc3MsIG9uRXJyb3IpIHtcbiAgICAvLyBSZXBsYWNlIEZpcmVmb3ggNDQrJ3MgZGVwcmVjYXRpb24gd2FybmluZyB3aXRoIHVucHJlZml4ZWQgdmVyc2lvbi5cbiAgICB1dGlscy5kZXByZWNhdGVkKCduYXZpZ2F0b3IuZ2V0VXNlck1lZGlhJyxcbiAgICAgICduYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYScpO1xuICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKS50aGVuKG9uU3VjY2Vzcywgb25FcnJvcik7XG4gIH07XG5cbiAgaWYgKCEoYnJvd3NlckRldGFpbHMudmVyc2lvbiA+IDU1ICYmXG4gICAgICAnYXV0b0dhaW5Db250cm9sJyBpbiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFN1cHBvcnRlZENvbnN0cmFpbnRzKCkpKSB7XG4gICAgY29uc3QgcmVtYXAgPSBmdW5jdGlvbihvYmosIGEsIGIpIHtcbiAgICAgIGlmIChhIGluIG9iaiAmJiAhKGIgaW4gb2JqKSkge1xuICAgICAgICBvYmpbYl0gPSBvYmpbYV07XG4gICAgICAgIGRlbGV0ZSBvYmpbYV07XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IG5hdGl2ZUdldFVzZXJNZWRpYSA9IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhLlxuICAgICAgYmluZChuYXZpZ2F0b3IubWVkaWFEZXZpY2VzKTtcbiAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgIGlmICh0eXBlb2YgYyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGMuYXVkaW8gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGMpKTtcbiAgICAgICAgcmVtYXAoYy5hdWRpbywgJ2F1dG9HYWluQ29udHJvbCcsICdtb3pBdXRvR2FpbkNvbnRyb2wnKTtcbiAgICAgICAgcmVtYXAoYy5hdWRpbywgJ25vaXNlU3VwcHJlc3Npb24nLCAnbW96Tm9pc2VTdXBwcmVzc2lvbicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5hdGl2ZUdldFVzZXJNZWRpYShjKTtcbiAgICB9O1xuXG4gICAgaWYgKE1lZGlhU3RyZWFtVHJhY2sgJiYgTWVkaWFTdHJlYW1UcmFjay5wcm90b3R5cGUuZ2V0U2V0dGluZ3MpIHtcbiAgICAgIGNvbnN0IG5hdGl2ZUdldFNldHRpbmdzID0gTWVkaWFTdHJlYW1UcmFjay5wcm90b3R5cGUuZ2V0U2V0dGluZ3M7XG4gICAgICBNZWRpYVN0cmVhbVRyYWNrLnByb3RvdHlwZS5nZXRTZXR0aW5ncyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCBvYmogPSBuYXRpdmVHZXRTZXR0aW5ncy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICByZW1hcChvYmosICdtb3pBdXRvR2FpbkNvbnRyb2wnLCAnYXV0b0dhaW5Db250cm9sJyk7XG4gICAgICAgIHJlbWFwKG9iaiwgJ21vek5vaXNlU3VwcHJlc3Npb24nLCAnbm9pc2VTdXBwcmVzc2lvbicpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoTWVkaWFTdHJlYW1UcmFjayAmJiBNZWRpYVN0cmVhbVRyYWNrLnByb3RvdHlwZS5hcHBseUNvbnN0cmFpbnRzKSB7XG4gICAgICBjb25zdCBuYXRpdmVBcHBseUNvbnN0cmFpbnRzID1cbiAgICAgICAgTWVkaWFTdHJlYW1UcmFjay5wcm90b3R5cGUuYXBwbHlDb25zdHJhaW50cztcbiAgICAgIE1lZGlhU3RyZWFtVHJhY2sucHJvdG90eXBlLmFwcGx5Q29uc3RyYWludHMgPSBmdW5jdGlvbihjKSB7XG4gICAgICAgIGlmICh0aGlzLmtpbmQgPT09ICdhdWRpbycgJiYgdHlwZW9mIGMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgYyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoYykpO1xuICAgICAgICAgIHJlbWFwKGMsICdhdXRvR2FpbkNvbnRyb2wnLCAnbW96QXV0b0dhaW5Db250cm9sJyk7XG4gICAgICAgICAgcmVtYXAoYywgJ25vaXNlU3VwcHJlc3Npb24nLCAnbW96Tm9pc2VTdXBwcmVzc2lvbicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuYXRpdmVBcHBseUNvbnN0cmFpbnRzLmFwcGx5KHRoaXMsIFtjXSk7XG4gICAgICB9O1xuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIGFkYXB0ZXIuanMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuLyogZXNsaW50LWVudiBub2RlICovXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGltR2V0RGlzcGxheU1lZGlhKHdpbmRvdywgcHJlZmVycmVkTWVkaWFTb3VyY2UpIHtcbiAgaWYgKHdpbmRvdy5uYXZpZ2F0b3IubWVkaWFEZXZpY2VzICYmXG4gICAgJ2dldERpc3BsYXlNZWRpYScgaW4gd2luZG93Lm5hdmlnYXRvci5tZWRpYURldmljZXMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCEod2luZG93Lm5hdmlnYXRvci5tZWRpYURldmljZXMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdpbmRvdy5uYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldERpc3BsYXlNZWRpYSA9XG4gICAgZnVuY3Rpb24gZ2V0RGlzcGxheU1lZGlhKGNvbnN0cmFpbnRzKSB7XG4gICAgICBpZiAoIShjb25zdHJhaW50cyAmJiBjb25zdHJhaW50cy52aWRlbykpIHtcbiAgICAgICAgY29uc3QgZXJyID0gbmV3IERPTUV4Y2VwdGlvbignZ2V0RGlzcGxheU1lZGlhIHdpdGhvdXQgdmlkZW8gJyArXG4gICAgICAgICAgICAnY29uc3RyYWludHMgaXMgdW5kZWZpbmVkJyk7XG4gICAgICAgIGVyci5uYW1lID0gJ05vdEZvdW5kRXJyb3InO1xuICAgICAgICAvLyBmcm9tIGh0dHBzOi8vaGV5Y2FtLmdpdGh1Yi5pby93ZWJpZGwvI2lkbC1ET01FeGNlcHRpb24tZXJyb3ItbmFtZXNcbiAgICAgICAgZXJyLmNvZGUgPSA4O1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb25zdHJhaW50cy52aWRlbyA9PT0gdHJ1ZSkge1xuICAgICAgICBjb25zdHJhaW50cy52aWRlbyA9IHttZWRpYVNvdXJjZTogcHJlZmVycmVkTWVkaWFTb3VyY2V9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3RyYWludHMudmlkZW8ubWVkaWFTb3VyY2UgPSBwcmVmZXJyZWRNZWRpYVNvdXJjZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpO1xuICAgIH07XG59XG4iLCIvKlxuICogIENvcHlyaWdodCAoYykgMjAxNiBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbi8qIGVzbGludC1lbnYgbm9kZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuLi91dGlscyc7XG5leHBvcnQge3NoaW1HZXRVc2VyTWVkaWF9IGZyb20gJy4vZ2V0dXNlcm1lZGlhJztcbmV4cG9ydCB7c2hpbUdldERpc3BsYXlNZWRpYX0gZnJvbSAnLi9nZXRkaXNwbGF5bWVkaWEnO1xuXG5leHBvcnQgZnVuY3Rpb24gc2hpbU9uVHJhY2sod2luZG93KSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDVHJhY2tFdmVudCAmJlxuICAgICAgKCdyZWNlaXZlcicgaW4gd2luZG93LlJUQ1RyYWNrRXZlbnQucHJvdG90eXBlKSAmJlxuICAgICAgISgndHJhbnNjZWl2ZXInIGluIHdpbmRvdy5SVENUcmFja0V2ZW50LnByb3RvdHlwZSkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlJUQ1RyYWNrRXZlbnQucHJvdG90eXBlLCAndHJhbnNjZWl2ZXInLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiB7cmVjZWl2ZXI6IHRoaXMucmVjZWl2ZXJ9O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGltUGVlckNvbm5lY3Rpb24od2luZG93LCBicm93c2VyRGV0YWlscykge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ29iamVjdCcgfHxcbiAgICAgICEod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uIHx8IHdpbmRvdy5tb3pSVENQZWVyQ29ubmVjdGlvbikpIHtcbiAgICByZXR1cm47IC8vIHByb2JhYmx5IG1lZGlhLnBlZXJjb25uZWN0aW9uLmVuYWJsZWQ9ZmFsc2UgaW4gYWJvdXQ6Y29uZmlnXG4gIH1cbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgd2luZG93Lm1velJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgLy8gdmVyeSBiYXNpYyBzdXBwb3J0IGZvciBvbGQgdmVyc2lvbnMuXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uID0gd2luZG93Lm1velJUQ1BlZXJDb25uZWN0aW9uO1xuICB9XG5cbiAgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA1Mykge1xuICAgIC8vIHNoaW0gYXdheSBuZWVkIGZvciBvYnNvbGV0ZSBSVENJY2VDYW5kaWRhdGUvUlRDU2Vzc2lvbkRlc2NyaXB0aW9uLlxuICAgIFsnc2V0TG9jYWxEZXNjcmlwdGlvbicsICdzZXRSZW1vdGVEZXNjcmlwdGlvbicsICdhZGRJY2VDYW5kaWRhdGUnXVxuICAgICAgLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICAgIGNvbnN0IG5hdGl2ZU1ldGhvZCA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXTtcbiAgICAgICAgY29uc3QgbWV0aG9kT2JqID0ge1ttZXRob2RdKCkge1xuICAgICAgICAgIGFyZ3VtZW50c1swXSA9IG5ldyAoKG1ldGhvZCA9PT0gJ2FkZEljZUNhbmRpZGF0ZScpID9cbiAgICAgICAgICAgIHdpbmRvdy5SVENJY2VDYW5kaWRhdGUgOlxuICAgICAgICAgICAgd2luZG93LlJUQ1Nlc3Npb25EZXNjcmlwdGlvbikoYXJndW1lbnRzWzBdKTtcbiAgICAgICAgICByZXR1cm4gbmF0aXZlTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH19O1xuICAgICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlW21ldGhvZF0gPSBtZXRob2RPYmpbbWV0aG9kXTtcbiAgICAgIH0pO1xuICB9XG5cbiAgY29uc3QgbW9kZXJuU3RhdHNUeXBlcyA9IHtcbiAgICBpbmJvdW5kcnRwOiAnaW5ib3VuZC1ydHAnLFxuICAgIG91dGJvdW5kcnRwOiAnb3V0Ym91bmQtcnRwJyxcbiAgICBjYW5kaWRhdGVwYWlyOiAnY2FuZGlkYXRlLXBhaXInLFxuICAgIGxvY2FsY2FuZGlkYXRlOiAnbG9jYWwtY2FuZGlkYXRlJyxcbiAgICByZW1vdGVjYW5kaWRhdGU6ICdyZW1vdGUtY2FuZGlkYXRlJ1xuICB9O1xuXG4gIGNvbnN0IG5hdGl2ZUdldFN0YXRzID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTdGF0cztcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uIGdldFN0YXRzKCkge1xuICAgIGNvbnN0IFtzZWxlY3Rvciwgb25TdWNjLCBvbkVycl0gPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIG5hdGl2ZUdldFN0YXRzLmFwcGx5KHRoaXMsIFtzZWxlY3RvciB8fCBudWxsXSlcbiAgICAgIC50aGVuKHN0YXRzID0+IHtcbiAgICAgICAgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA1MyAmJiAhb25TdWNjKSB7XG4gICAgICAgICAgLy8gU2hpbSBvbmx5IHByb21pc2UgZ2V0U3RhdHMgd2l0aCBzcGVjLWh5cGhlbnMgaW4gdHlwZSBuYW1lc1xuICAgICAgICAgIC8vIExlYXZlIGNhbGxiYWNrIHZlcnNpb24gYWxvbmU7IG1pc2Mgb2xkIHVzZXMgb2YgZm9yRWFjaCBiZWZvcmUgTWFwXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHN0YXRzLmZvckVhY2goc3RhdCA9PiB7XG4gICAgICAgICAgICAgIHN0YXQudHlwZSA9IG1vZGVyblN0YXRzVHlwZXNbc3RhdC50eXBlXSB8fCBzdGF0LnR5cGU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZS5uYW1lICE9PSAnVHlwZUVycm9yJykge1xuICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQXZvaWQgVHlwZUVycm9yOiBcInR5cGVcIiBpcyByZWFkLW9ubHksIGluIG9sZCB2ZXJzaW9ucy4gMzQtNDNpc2hcbiAgICAgICAgICAgIHN0YXRzLmZvckVhY2goKHN0YXQsIGkpID0+IHtcbiAgICAgICAgICAgICAgc3RhdHMuc2V0KGksIE9iamVjdC5hc3NpZ24oe30sIHN0YXQsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBtb2Rlcm5TdGF0c1R5cGVzW3N0YXQudHlwZV0gfHwgc3RhdC50eXBlXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdHM7XG4gICAgICB9KVxuICAgICAgLnRoZW4ob25TdWNjLCBvbkVycik7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGltU2VuZGVyR2V0U3RhdHMod2luZG93KSB7XG4gIGlmICghKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJlxuICAgICAgd2luZG93LlJUQ1J0cFNlbmRlcikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHdpbmRvdy5SVENSdHBTZW5kZXIgJiYgJ2dldFN0YXRzJyBpbiB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBvcmlnR2V0U2VuZGVycyA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U2VuZGVycztcbiAgaWYgKG9yaWdHZXRTZW5kZXJzKSB7XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTZW5kZXJzID0gZnVuY3Rpb24gZ2V0U2VuZGVycygpIHtcbiAgICAgIGNvbnN0IHNlbmRlcnMgPSBvcmlnR2V0U2VuZGVycy5hcHBseSh0aGlzLCBbXSk7XG4gICAgICBzZW5kZXJzLmZvckVhY2goc2VuZGVyID0+IHNlbmRlci5fcGMgPSB0aGlzKTtcbiAgICAgIHJldHVybiBzZW5kZXJzO1xuICAgIH07XG4gIH1cblxuICBjb25zdCBvcmlnQWRkVHJhY2sgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrO1xuICBpZiAob3JpZ0FkZFRyYWNrKSB7XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjayA9IGZ1bmN0aW9uIGFkZFRyYWNrKCkge1xuICAgICAgY29uc3Qgc2VuZGVyID0gb3JpZ0FkZFRyYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBzZW5kZXIuX3BjID0gdGhpcztcbiAgICAgIHJldHVybiBzZW5kZXI7XG4gICAgfTtcbiAgfVxuICB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uIGdldFN0YXRzKCkge1xuICAgIHJldHVybiB0aGlzLnRyYWNrID8gdGhpcy5fcGMuZ2V0U3RhdHModGhpcy50cmFjaykgOlxuICAgICAgUHJvbWlzZS5yZXNvbHZlKG5ldyBNYXAoKSk7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGltUmVjZWl2ZXJHZXRTdGF0cyh3aW5kb3cpIHtcbiAgaWYgKCEodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmXG4gICAgICB3aW5kb3cuUlRDUnRwU2VuZGVyKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAod2luZG93LlJUQ1J0cFNlbmRlciAmJiAnZ2V0U3RhdHMnIGluIHdpbmRvdy5SVENSdHBSZWNlaXZlci5wcm90b3R5cGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgb3JpZ0dldFJlY2VpdmVycyA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0UmVjZWl2ZXJzO1xuICBpZiAob3JpZ0dldFJlY2VpdmVycykge1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0UmVjZWl2ZXJzID0gZnVuY3Rpb24gZ2V0UmVjZWl2ZXJzKCkge1xuICAgICAgY29uc3QgcmVjZWl2ZXJzID0gb3JpZ0dldFJlY2VpdmVycy5hcHBseSh0aGlzLCBbXSk7XG4gICAgICByZWNlaXZlcnMuZm9yRWFjaChyZWNlaXZlciA9PiByZWNlaXZlci5fcGMgPSB0aGlzKTtcbiAgICAgIHJldHVybiByZWNlaXZlcnM7XG4gICAgfTtcbiAgfVxuICB1dGlscy53cmFwUGVlckNvbm5lY3Rpb25FdmVudCh3aW5kb3csICd0cmFjaycsIGUgPT4ge1xuICAgIGUucmVjZWl2ZXIuX3BjID0gZS5zcmNFbGVtZW50O1xuICAgIHJldHVybiBlO1xuICB9KTtcbiAgd2luZG93LlJUQ1J0cFJlY2VpdmVyLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uIGdldFN0YXRzKCkge1xuICAgIHJldHVybiB0aGlzLl9wYy5nZXRTdGF0cyh0aGlzLnRyYWNrKTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1SZW1vdmVTdHJlYW0od2luZG93KSB7XG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uIHx8XG4gICAgICAncmVtb3ZlU3RyZWFtJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlU3RyZWFtID1cbiAgICBmdW5jdGlvbiByZW1vdmVTdHJlYW0oc3RyZWFtKSB7XG4gICAgICB1dGlscy5kZXByZWNhdGVkKCdyZW1vdmVTdHJlYW0nLCAncmVtb3ZlVHJhY2snKTtcbiAgICAgIHRoaXMuZ2V0U2VuZGVycygpLmZvckVhY2goc2VuZGVyID0+IHtcbiAgICAgICAgaWYgKHNlbmRlci50cmFjayAmJiBzdHJlYW0uZ2V0VHJhY2tzKCkuaW5jbHVkZXMoc2VuZGVyLnRyYWNrKSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlVHJhY2soc2VuZGVyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1SVENEYXRhQ2hhbm5lbCh3aW5kb3cpIHtcbiAgLy8gcmVuYW1lIERhdGFDaGFubmVsIHRvIFJUQ0RhdGFDaGFubmVsIChuYXRpdmUgZml4IGluIEZGNjApOlxuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMTczODUxXG4gIGlmICh3aW5kb3cuRGF0YUNoYW5uZWwgJiYgIXdpbmRvdy5SVENEYXRhQ2hhbm5lbCkge1xuICAgIHdpbmRvdy5SVENEYXRhQ2hhbm5lbCA9IHdpbmRvdy5EYXRhQ2hhbm5lbDtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hpbUFkZFRyYW5zY2VpdmVyKHdpbmRvdykge1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2VicnRjSGFja3MvYWRhcHRlci9pc3N1ZXMvOTk4I2lzc3VlY29tbWVudC01MTY5MjE2NDdcbiAgLy8gRmlyZWZveCBpZ25vcmVzIHRoZSBpbml0IHNlbmRFbmNvZGluZ3Mgb3B0aW9ucyBwYXNzZWQgdG8gYWRkVHJhbnNjZWl2ZXJcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM5NjkxOFxuICBpZiAoISh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG9yaWdBZGRUcmFuc2NlaXZlciA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhbnNjZWl2ZXI7XG4gIGlmIChvcmlnQWRkVHJhbnNjZWl2ZXIpIHtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYW5zY2VpdmVyID1cbiAgICAgIGZ1bmN0aW9uIGFkZFRyYW5zY2VpdmVyKCkge1xuICAgICAgICB0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcyA9IFtdO1xuICAgICAgICAvLyBXZWJJREwgaW5wdXQgY29lcmNpb24gYW5kIHZhbGlkYXRpb25cbiAgICAgICAgbGV0IHNlbmRFbmNvZGluZ3MgPSBhcmd1bWVudHNbMV0gJiYgYXJndW1lbnRzWzFdLnNlbmRFbmNvZGluZ3M7XG4gICAgICAgIGlmIChzZW5kRW5jb2RpbmdzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzZW5kRW5jb2RpbmdzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgc2VuZEVuY29kaW5ncyA9IFsuLi5zZW5kRW5jb2RpbmdzXTtcbiAgICAgICAgY29uc3Qgc2hvdWxkUGVyZm9ybUNoZWNrID0gc2VuZEVuY29kaW5ncy5sZW5ndGggPiAwO1xuICAgICAgICBpZiAoc2hvdWxkUGVyZm9ybUNoZWNrKSB7XG4gICAgICAgICAgLy8gSWYgc2VuZEVuY29kaW5ncyBwYXJhbXMgYXJlIHByb3ZpZGVkLCB2YWxpZGF0ZSBncmFtbWFyXG4gICAgICAgICAgc2VuZEVuY29kaW5ncy5mb3JFYWNoKChlbmNvZGluZ1BhcmFtKSA9PiB7XG4gICAgICAgICAgICBpZiAoJ3JpZCcgaW4gZW5jb2RpbmdQYXJhbSkge1xuICAgICAgICAgICAgICBjb25zdCByaWRSZWdleCA9IC9eW2EtejAtOV17MCwxNn0kL2k7XG4gICAgICAgICAgICAgIGlmICghcmlkUmVnZXgudGVzdChlbmNvZGluZ1BhcmFtLnJpZCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIFJJRCB2YWx1ZSBwcm92aWRlZC4nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCdzY2FsZVJlc29sdXRpb25Eb3duQnknIGluIGVuY29kaW5nUGFyYW0pIHtcbiAgICAgICAgICAgICAgaWYgKCEocGFyc2VGbG9hdChlbmNvZGluZ1BhcmFtLnNjYWxlUmVzb2x1dGlvbkRvd25CeSkgPj0gMS4wKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzY2FsZV9yZXNvbHV0aW9uX2Rvd25fYnkgbXVzdCBiZSA+PSAxLjAnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCdtYXhGcmFtZXJhdGUnIGluIGVuY29kaW5nUGFyYW0pIHtcbiAgICAgICAgICAgICAgaWYgKCEocGFyc2VGbG9hdChlbmNvZGluZ1BhcmFtLm1heEZyYW1lcmF0ZSkgPj0gMCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignbWF4X2ZyYW1lcmF0ZSBtdXN0IGJlID49IDAuMCcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSBvcmlnQWRkVHJhbnNjZWl2ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKHNob3VsZFBlcmZvcm1DaGVjaykge1xuICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBpbml0IG9wdGlvbnMgd2VyZSBhcHBsaWVkLiBJZiBub3Qgd2UgZG8gdGhpcyBpbiBhblxuICAgICAgICAgIC8vIGFzeW5jaHJvbm91cyB3YXkgYW5kIHNhdmUgdGhlIHByb21pc2UgcmVmZXJlbmNlIGluIGEgZ2xvYmFsIG9iamVjdC5cbiAgICAgICAgICAvLyBUaGlzIGlzIGFuIHVnbHkgaGFjaywgYnV0IGF0IHRoZSBzYW1lIHRpbWUgaXMgd2F5IG1vcmUgcm9idXN0IHRoYW5cbiAgICAgICAgICAvLyBjaGVja2luZyB0aGUgc2VuZGVyIHBhcmFtZXRlcnMgYmVmb3JlIGFuZCBhZnRlciB0aGUgY3JlYXRlT2ZmZXJcbiAgICAgICAgICAvLyBBbHNvIG5vdGUgdGhhdCBhZnRlciB0aGUgY3JlYXRlb2ZmZXIgd2UgYXJlIG5vdCAxMDAlIHN1cmUgdGhhdFxuICAgICAgICAgIC8vIHRoZSBwYXJhbXMgd2VyZSBhc3luY2hyb25vdXNseSBhcHBsaWVkIHNvIHdlIG1pZ2h0IG1pc3MgdGhlXG4gICAgICAgICAgLy8gb3Bwb3J0dW5pdHkgdG8gcmVjcmVhdGUgb2ZmZXIuXG4gICAgICAgICAgY29uc3Qge3NlbmRlcn0gPSB0cmFuc2NlaXZlcjtcbiAgICAgICAgICBjb25zdCBwYXJhbXMgPSBzZW5kZXIuZ2V0UGFyYW1ldGVycygpO1xuICAgICAgICAgIGlmICghKCdlbmNvZGluZ3MnIGluIHBhcmFtcykgfHxcbiAgICAgICAgICAgICAgLy8gQXZvaWQgYmVpbmcgZm9vbGVkIGJ5IHBhdGNoZWQgZ2V0UGFyYW1ldGVycygpIGJlbG93LlxuICAgICAgICAgICAgICAocGFyYW1zLmVuY29kaW5ncy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHBhcmFtcy5lbmNvZGluZ3NbMF0pLmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgICAgIHBhcmFtcy5lbmNvZGluZ3MgPSBzZW5kRW5jb2RpbmdzO1xuICAgICAgICAgICAgc2VuZGVyLnNlbmRFbmNvZGluZ3MgPSBzZW5kRW5jb2RpbmdzO1xuICAgICAgICAgICAgdGhpcy5zZXRQYXJhbWV0ZXJzUHJvbWlzZXMucHVzaChzZW5kZXIuc2V0UGFyYW1ldGVycyhwYXJhbXMpXG4gICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBkZWxldGUgc2VuZGVyLnNlbmRFbmNvZGluZ3M7XG4gICAgICAgICAgICAgIH0pLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICBkZWxldGUgc2VuZGVyLnNlbmRFbmNvZGluZ3M7XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJhbnNjZWl2ZXI7XG4gICAgICB9O1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGltR2V0UGFyYW1ldGVycyh3aW5kb3cpIHtcbiAgaWYgKCEodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1J0cFNlbmRlcikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgb3JpZ0dldFBhcmFtZXRlcnMgPSB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZS5nZXRQYXJhbWV0ZXJzO1xuICBpZiAob3JpZ0dldFBhcmFtZXRlcnMpIHtcbiAgICB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZS5nZXRQYXJhbWV0ZXJzID1cbiAgICAgIGZ1bmN0aW9uIGdldFBhcmFtZXRlcnMoKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IG9yaWdHZXRQYXJhbWV0ZXJzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmICghKCdlbmNvZGluZ3MnIGluIHBhcmFtcykpIHtcbiAgICAgICAgICBwYXJhbXMuZW5jb2RpbmdzID0gW10uY29uY2F0KHRoaXMuc2VuZEVuY29kaW5ncyB8fCBbe31dKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgICAgfTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hpbUNyZWF0ZU9mZmVyKHdpbmRvdykge1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2VicnRjSGFja3MvYWRhcHRlci9pc3N1ZXMvOTk4I2lzc3VlY29tbWVudC01MTY5MjE2NDdcbiAgLy8gRmlyZWZveCBpZ25vcmVzIHRoZSBpbml0IHNlbmRFbmNvZGluZ3Mgb3B0aW9ucyBwYXNzZWQgdG8gYWRkVHJhbnNjZWl2ZXJcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM5NjkxOFxuICBpZiAoISh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG9yaWdDcmVhdGVPZmZlciA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlT2ZmZXI7XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlT2ZmZXIgPSBmdW5jdGlvbiBjcmVhdGVPZmZlcigpIHtcbiAgICBpZiAodGhpcy5zZXRQYXJhbWV0ZXJzUHJvbWlzZXMgJiYgdGhpcy5zZXRQYXJhbWV0ZXJzUHJvbWlzZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwodGhpcy5zZXRQYXJhbWV0ZXJzUHJvbWlzZXMpXG4gICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICByZXR1cm4gb3JpZ0NyZWF0ZU9mZmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0pXG4gICAgICAgIC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICB0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcyA9IFtdO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG9yaWdDcmVhdGVPZmZlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hpbUNyZWF0ZUFuc3dlcih3aW5kb3cpIHtcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnJ0Y0hhY2tzL2FkYXB0ZXIvaXNzdWVzLzk5OCNpc3N1ZWNvbW1lbnQtNTE2OTIxNjQ3XG4gIC8vIEZpcmVmb3ggaWdub3JlcyB0aGUgaW5pdCBzZW5kRW5jb2RpbmdzIG9wdGlvbnMgcGFzc2VkIHRvIGFkZFRyYW5zY2VpdmVyXG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEzOTY5MThcbiAgaWYgKCEodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBvcmlnQ3JlYXRlQW5zd2VyID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVBbnN3ZXI7XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlQW5zd2VyID0gZnVuY3Rpb24gY3JlYXRlQW5zd2VyKCkge1xuICAgIGlmICh0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcyAmJiB0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbCh0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcylcbiAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIHJldHVybiBvcmlnQ3JlYXRlQW5zd2VyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0pXG4gICAgICAgIC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICB0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcyA9IFtdO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG9yaWdDcmVhdGVBbnN3ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cbiIsIi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi4vdXRpbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gc2hpbUxvY2FsU3RyZWFtc0FQSSh3aW5kb3cpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICdvYmplY3QnIHx8ICF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCEoJ2dldExvY2FsU3RyZWFtcycgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldExvY2FsU3RyZWFtcyA9XG4gICAgICBmdW5jdGlvbiBnZXRMb2NhbFN0cmVhbXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5fbG9jYWxTdHJlYW1zKSB7XG4gICAgICAgICAgdGhpcy5fbG9jYWxTdHJlYW1zID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsU3RyZWFtcztcbiAgICAgIH07XG4gIH1cbiAgaWYgKCEoJ2FkZFN0cmVhbScgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgICBjb25zdCBfYWRkVHJhY2sgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrO1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkU3RyZWFtID0gZnVuY3Rpb24gYWRkU3RyZWFtKHN0cmVhbSkge1xuICAgICAgaWYgKCF0aGlzLl9sb2NhbFN0cmVhbXMpIHtcbiAgICAgICAgdGhpcy5fbG9jYWxTdHJlYW1zID0gW107XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuX2xvY2FsU3RyZWFtcy5pbmNsdWRlcyhzdHJlYW0pKSB7XG4gICAgICAgIHRoaXMuX2xvY2FsU3RyZWFtcy5wdXNoKHN0cmVhbSk7XG4gICAgICB9XG4gICAgICAvLyBUcnkgdG8gZW11bGF0ZSBDaHJvbWUncyBiZWhhdmlvdXIgb2YgYWRkaW5nIGluIGF1ZGlvLXZpZGVvIG9yZGVyLlxuICAgICAgLy8gU2FmYXJpIG9yZGVycyBieSB0cmFjayBpZC5cbiAgICAgIHN0cmVhbS5nZXRBdWRpb1RyYWNrcygpLmZvckVhY2godHJhY2sgPT4gX2FkZFRyYWNrLmNhbGwodGhpcywgdHJhY2ssXG4gICAgICAgIHN0cmVhbSkpO1xuICAgICAgc3RyZWFtLmdldFZpZGVvVHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiBfYWRkVHJhY2suY2FsbCh0aGlzLCB0cmFjayxcbiAgICAgICAgc3RyZWFtKSk7XG4gICAgfTtcblxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2sgPVxuICAgICAgZnVuY3Rpb24gYWRkVHJhY2sodHJhY2ssIC4uLnN0cmVhbXMpIHtcbiAgICAgICAgaWYgKHN0cmVhbXMpIHtcbiAgICAgICAgICBzdHJlYW1zLmZvckVhY2goKHN0cmVhbSkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9sb2NhbFN0cmVhbXMpIHtcbiAgICAgICAgICAgICAgdGhpcy5fbG9jYWxTdHJlYW1zID0gW3N0cmVhbV07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9sb2NhbFN0cmVhbXMuaW5jbHVkZXMoc3RyZWFtKSkge1xuICAgICAgICAgICAgICB0aGlzLl9sb2NhbFN0cmVhbXMucHVzaChzdHJlYW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfYWRkVHJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gIH1cbiAgaWYgKCEoJ3JlbW92ZVN0cmVhbScgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVN0cmVhbSA9XG4gICAgICBmdW5jdGlvbiByZW1vdmVTdHJlYW0oc3RyZWFtKSB7XG4gICAgICAgIGlmICghdGhpcy5fbG9jYWxTdHJlYW1zKSB7XG4gICAgICAgICAgdGhpcy5fbG9jYWxTdHJlYW1zID0gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9sb2NhbFN0cmVhbXMuaW5kZXhPZihzdHJlYW0pO1xuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xvY2FsU3RyZWFtcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBjb25zdCB0cmFja3MgPSBzdHJlYW0uZ2V0VHJhY2tzKCk7XG4gICAgICAgIHRoaXMuZ2V0U2VuZGVycygpLmZvckVhY2goc2VuZGVyID0+IHtcbiAgICAgICAgICBpZiAodHJhY2tzLmluY2x1ZGVzKHNlbmRlci50cmFjaykpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlVHJhY2soc2VuZGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hpbVJlbW90ZVN0cmVhbXNBUEkod2luZG93KSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAnb2JqZWN0JyB8fCAhd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghKCdnZXRSZW1vdGVTdHJlYW1zJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0UmVtb3RlU3RyZWFtcyA9XG4gICAgICBmdW5jdGlvbiBnZXRSZW1vdGVTdHJlYW1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVtb3RlU3RyZWFtcyA/IHRoaXMuX3JlbW90ZVN0cmVhbXMgOiBbXTtcbiAgICAgIH07XG4gIH1cbiAgaWYgKCEoJ29uYWRkc3RyZWFtJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLCAnb25hZGRzdHJlYW0nLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vbmFkZHN0cmVhbTtcbiAgICAgIH0sXG4gICAgICBzZXQoZikge1xuICAgICAgICBpZiAodGhpcy5fb25hZGRzdHJlYW0pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2FkZHN0cmVhbScsIHRoaXMuX29uYWRkc3RyZWFtKTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYWNrJywgdGhpcy5fb25hZGRzdHJlYW1wb2x5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2FkZHN0cmVhbScsIHRoaXMuX29uYWRkc3RyZWFtID0gZik7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndHJhY2snLCB0aGlzLl9vbmFkZHN0cmVhbXBvbHkgPSAoZSkgPT4ge1xuICAgICAgICAgIGUuc3RyZWFtcy5mb3JFYWNoKHN0cmVhbSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3JlbW90ZVN0cmVhbXMpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcmVtb3RlU3RyZWFtcyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3JlbW90ZVN0cmVhbXMuaW5jbHVkZXMoc3RyZWFtKSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9yZW1vdGVTdHJlYW1zLnB1c2goc3RyZWFtKTtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEV2ZW50KCdhZGRzdHJlYW0nKTtcbiAgICAgICAgICAgIGV2ZW50LnN0cmVhbSA9IHN0cmVhbTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IG9yaWdTZXRSZW1vdGVEZXNjcmlwdGlvbiA9XG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uO1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0UmVtb3RlRGVzY3JpcHRpb24gPVxuICAgICAgZnVuY3Rpb24gc2V0UmVtb3RlRGVzY3JpcHRpb24oKSB7XG4gICAgICAgIGNvbnN0IHBjID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLl9vbmFkZHN0cmVhbXBvbHkpIHtcbiAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYWNrJywgdGhpcy5fb25hZGRzdHJlYW1wb2x5ID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgZS5zdHJlYW1zLmZvckVhY2goc3RyZWFtID0+IHtcbiAgICAgICAgICAgICAgaWYgKCFwYy5fcmVtb3RlU3RyZWFtcykge1xuICAgICAgICAgICAgICAgIHBjLl9yZW1vdGVTdHJlYW1zID0gW107XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHBjLl9yZW1vdGVTdHJlYW1zLmluZGV4T2Yoc3RyZWFtKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHBjLl9yZW1vdGVTdHJlYW1zLnB1c2goc3RyZWFtKTtcbiAgICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgRXZlbnQoJ2FkZHN0cmVhbScpO1xuICAgICAgICAgICAgICBldmVudC5zdHJlYW0gPSBzdHJlYW07XG4gICAgICAgICAgICAgIHBjLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9yaWdTZXRSZW1vdGVEZXNjcmlwdGlvbi5hcHBseShwYywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1DYWxsYmFja3NBUEkod2luZG93KSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAnb2JqZWN0JyB8fCAhd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHByb3RvdHlwZSA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGU7XG4gIGNvbnN0IG9yaWdDcmVhdGVPZmZlciA9IHByb3RvdHlwZS5jcmVhdGVPZmZlcjtcbiAgY29uc3Qgb3JpZ0NyZWF0ZUFuc3dlciA9IHByb3RvdHlwZS5jcmVhdGVBbnN3ZXI7XG4gIGNvbnN0IHNldExvY2FsRGVzY3JpcHRpb24gPSBwcm90b3R5cGUuc2V0TG9jYWxEZXNjcmlwdGlvbjtcbiAgY29uc3Qgc2V0UmVtb3RlRGVzY3JpcHRpb24gPSBwcm90b3R5cGUuc2V0UmVtb3RlRGVzY3JpcHRpb247XG4gIGNvbnN0IGFkZEljZUNhbmRpZGF0ZSA9IHByb3RvdHlwZS5hZGRJY2VDYW5kaWRhdGU7XG5cbiAgcHJvdG90eXBlLmNyZWF0ZU9mZmVyID1cbiAgICBmdW5jdGlvbiBjcmVhdGVPZmZlcihzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjaykge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IChhcmd1bWVudHMubGVuZ3RoID49IDIpID8gYXJndW1lbnRzWzJdIDogYXJndW1lbnRzWzBdO1xuICAgICAgY29uc3QgcHJvbWlzZSA9IG9yaWdDcmVhdGVPZmZlci5hcHBseSh0aGlzLCBbb3B0aW9uc10pO1xuICAgICAgaWYgKCFmYWlsdXJlQ2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICB9XG4gICAgICBwcm9taXNlLnRoZW4oc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH07XG5cbiAgcHJvdG90eXBlLmNyZWF0ZUFuc3dlciA9XG4gICAgZnVuY3Rpb24gY3JlYXRlQW5zd2VyKHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgICBjb25zdCBvcHRpb25zID0gKGFyZ3VtZW50cy5sZW5ndGggPj0gMikgPyBhcmd1bWVudHNbMl0gOiBhcmd1bWVudHNbMF07XG4gICAgICBjb25zdCBwcm9taXNlID0gb3JpZ0NyZWF0ZUFuc3dlci5hcHBseSh0aGlzLCBbb3B0aW9uc10pO1xuICAgICAgaWYgKCFmYWlsdXJlQ2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICB9XG4gICAgICBwcm9taXNlLnRoZW4oc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH07XG5cbiAgbGV0IHdpdGhDYWxsYmFjayA9IGZ1bmN0aW9uKGRlc2NyaXB0aW9uLCBzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjaykge1xuICAgIGNvbnN0IHByb21pc2UgPSBzZXRMb2NhbERlc2NyaXB0aW9uLmFwcGx5KHRoaXMsIFtkZXNjcmlwdGlvbl0pO1xuICAgIGlmICghZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgcHJvbWlzZS50aGVuKHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH07XG4gIHByb3RvdHlwZS5zZXRMb2NhbERlc2NyaXB0aW9uID0gd2l0aENhbGxiYWNrO1xuXG4gIHdpdGhDYWxsYmFjayA9IGZ1bmN0aW9uKGRlc2NyaXB0aW9uLCBzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjaykge1xuICAgIGNvbnN0IHByb21pc2UgPSBzZXRSZW1vdGVEZXNjcmlwdGlvbi5hcHBseSh0aGlzLCBbZGVzY3JpcHRpb25dKTtcbiAgICBpZiAoIWZhaWx1cmVDYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIHByb21pc2UudGhlbihzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjayk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9O1xuICBwcm90b3R5cGUuc2V0UmVtb3RlRGVzY3JpcHRpb24gPSB3aXRoQ2FsbGJhY2s7XG5cbiAgd2l0aENhbGxiYWNrID0gZnVuY3Rpb24oY2FuZGlkYXRlLCBzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjaykge1xuICAgIGNvbnN0IHByb21pc2UgPSBhZGRJY2VDYW5kaWRhdGUuYXBwbHkodGhpcywgW2NhbmRpZGF0ZV0pO1xuICAgIGlmICghZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgcHJvbWlzZS50aGVuKHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH07XG4gIHByb3RvdHlwZS5hZGRJY2VDYW5kaWRhdGUgPSB3aXRoQ2FsbGJhY2s7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGltR2V0VXNlck1lZGlhKHdpbmRvdykge1xuICBjb25zdCBuYXZpZ2F0b3IgPSB3aW5kb3cgJiYgd2luZG93Lm5hdmlnYXRvcjtcblxuICBpZiAobmF2aWdhdG9yLm1lZGlhRGV2aWNlcyAmJiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSkge1xuICAgIC8vIHNoaW0gbm90IG5lZWRlZCBpbiBTYWZhcmkgMTIuMVxuICAgIGNvbnN0IG1lZGlhRGV2aWNlcyA9IG5hdmlnYXRvci5tZWRpYURldmljZXM7XG4gICAgY29uc3QgX2dldFVzZXJNZWRpYSA9IG1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEuYmluZChtZWRpYURldmljZXMpO1xuICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhID0gKGNvbnN0cmFpbnRzKSA9PiB7XG4gICAgICByZXR1cm4gX2dldFVzZXJNZWRpYShzaGltQ29uc3RyYWludHMoY29uc3RyYWludHMpKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKCFuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhICYmIG5hdmlnYXRvci5tZWRpYURldmljZXMgJiZcbiAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSkge1xuICAgIG5hdmlnYXRvci5nZXRVc2VyTWVkaWEgPSBmdW5jdGlvbiBnZXRVc2VyTWVkaWEoY29uc3RyYWludHMsIGNiLCBlcnJjYikge1xuICAgICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpXG4gICAgICAgIC50aGVuKGNiLCBlcnJjYik7XG4gICAgfS5iaW5kKG5hdmlnYXRvcik7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1Db25zdHJhaW50cyhjb25zdHJhaW50cykge1xuICBpZiAoY29uc3RyYWludHMgJiYgY29uc3RyYWludHMudmlkZW8gIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LFxuICAgICAgY29uc3RyYWludHMsXG4gICAgICB7dmlkZW86IHV0aWxzLmNvbXBhY3RPYmplY3QoY29uc3RyYWludHMudmlkZW8pfVxuICAgICk7XG4gIH1cblxuICByZXR1cm4gY29uc3RyYWludHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGltUlRDSWNlU2VydmVyVXJscyh3aW5kb3cpIHtcbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gbWlncmF0ZSBmcm9tIG5vbi1zcGVjIFJUQ0ljZVNlcnZlci51cmwgdG8gUlRDSWNlU2VydmVyLnVybHNcbiAgY29uc3QgT3JpZ1BlZXJDb25uZWN0aW9uID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gPVxuICAgIGZ1bmN0aW9uIFJUQ1BlZXJDb25uZWN0aW9uKHBjQ29uZmlnLCBwY0NvbnN0cmFpbnRzKSB7XG4gICAgICBpZiAocGNDb25maWcgJiYgcGNDb25maWcuaWNlU2VydmVycykge1xuICAgICAgICBjb25zdCBuZXdJY2VTZXJ2ZXJzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGNDb25maWcuaWNlU2VydmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGxldCBzZXJ2ZXIgPSBwY0NvbmZpZy5pY2VTZXJ2ZXJzW2ldO1xuICAgICAgICAgIGlmIChzZXJ2ZXIudXJscyA9PT0gdW5kZWZpbmVkICYmIHNlcnZlci51cmwpIHtcbiAgICAgICAgICAgIHV0aWxzLmRlcHJlY2F0ZWQoJ1JUQ0ljZVNlcnZlci51cmwnLCAnUlRDSWNlU2VydmVyLnVybHMnKTtcbiAgICAgICAgICAgIHNlcnZlciA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoc2VydmVyKSk7XG4gICAgICAgICAgICBzZXJ2ZXIudXJscyA9IHNlcnZlci51cmw7XG4gICAgICAgICAgICBkZWxldGUgc2VydmVyLnVybDtcbiAgICAgICAgICAgIG5ld0ljZVNlcnZlcnMucHVzaChzZXJ2ZXIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdJY2VTZXJ2ZXJzLnB1c2gocGNDb25maWcuaWNlU2VydmVyc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBjQ29uZmlnLmljZVNlcnZlcnMgPSBuZXdJY2VTZXJ2ZXJzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBPcmlnUGVlckNvbm5lY3Rpb24ocGNDb25maWcsIHBjQ29uc3RyYWludHMpO1xuICAgIH07XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUgPSBPcmlnUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlO1xuICAvLyB3cmFwIHN0YXRpYyBtZXRob2RzLiBDdXJyZW50bHkganVzdCBnZW5lcmF0ZUNlcnRpZmljYXRlLlxuICBpZiAoJ2dlbmVyYXRlQ2VydGlmaWNhdGUnIGluIE9yaWdQZWVyQ29ubmVjdGlvbikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24sICdnZW5lcmF0ZUNlcnRpZmljYXRlJywge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gT3JpZ1BlZXJDb25uZWN0aW9uLmdlbmVyYXRlQ2VydGlmaWNhdGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1UcmFja0V2ZW50VHJhbnNjZWl2ZXIod2luZG93KSB7XG4gIC8vIEFkZCBldmVudC50cmFuc2NlaXZlciBtZW1iZXIgb3ZlciBkZXByZWNhdGVkIGV2ZW50LnJlY2VpdmVyXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDVHJhY2tFdmVudCAmJlxuICAgICAgJ3JlY2VpdmVyJyBpbiB3aW5kb3cuUlRDVHJhY2tFdmVudC5wcm90b3R5cGUgJiZcbiAgICAgICEoJ3RyYW5zY2VpdmVyJyBpbiB3aW5kb3cuUlRDVHJhY2tFdmVudC5wcm90b3R5cGUpKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5SVENUcmFja0V2ZW50LnByb3RvdHlwZSwgJ3RyYW5zY2VpdmVyJywge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4ge3JlY2VpdmVyOiB0aGlzLnJlY2VpdmVyfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hpbUNyZWF0ZU9mZmVyTGVnYWN5KHdpbmRvdykge1xuICBjb25zdCBvcmlnQ3JlYXRlT2ZmZXIgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZU9mZmVyO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZU9mZmVyID1cbiAgICBmdW5jdGlvbiBjcmVhdGVPZmZlcihvZmZlck9wdGlvbnMpIHtcbiAgICAgIGlmIChvZmZlck9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVBdWRpbyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBzdXBwb3J0IGJpdCB2YWx1ZXNcbiAgICAgICAgICBvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVBdWRpbyA9XG4gICAgICAgICAgICAhIW9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZUF1ZGlvO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGF1ZGlvVHJhbnNjZWl2ZXIgPSB0aGlzLmdldFRyYW5zY2VpdmVycygpLmZpbmQodHJhbnNjZWl2ZXIgPT5cbiAgICAgICAgICB0cmFuc2NlaXZlci5yZWNlaXZlci50cmFjay5raW5kID09PSAnYXVkaW8nKTtcbiAgICAgICAgaWYgKG9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZUF1ZGlvID09PSBmYWxzZSAmJiBhdWRpb1RyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgaWYgKGF1ZGlvVHJhbnNjZWl2ZXIuZGlyZWN0aW9uID09PSAnc2VuZHJlY3YnKSB7XG4gICAgICAgICAgICBpZiAoYXVkaW9UcmFuc2NlaXZlci5zZXREaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgYXVkaW9UcmFuc2NlaXZlci5zZXREaXJlY3Rpb24oJ3NlbmRvbmx5Jyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhdWRpb1RyYW5zY2VpdmVyLmRpcmVjdGlvbiA9ICdzZW5kb25seSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChhdWRpb1RyYW5zY2VpdmVyLmRpcmVjdGlvbiA9PT0gJ3JlY3Zvbmx5Jykge1xuICAgICAgICAgICAgaWYgKGF1ZGlvVHJhbnNjZWl2ZXIuc2V0RGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgIGF1ZGlvVHJhbnNjZWl2ZXIuc2V0RGlyZWN0aW9uKCdpbmFjdGl2ZScpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYXVkaW9UcmFuc2NlaXZlci5kaXJlY3Rpb24gPSAnaW5hY3RpdmUnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVBdWRpbyA9PT0gdHJ1ZSAmJlxuICAgICAgICAgICAgIWF1ZGlvVHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICB0aGlzLmFkZFRyYW5zY2VpdmVyKCdhdWRpbycsIHtkaXJlY3Rpb246ICdyZWN2b25seSd9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygb2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlVmlkZW8gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgLy8gc3VwcG9ydCBiaXQgdmFsdWVzXG4gICAgICAgICAgb2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlVmlkZW8gPVxuICAgICAgICAgICAgISFvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVWaWRlbztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2aWRlb1RyYW5zY2VpdmVyID0gdGhpcy5nZXRUcmFuc2NlaXZlcnMoKS5maW5kKHRyYW5zY2VpdmVyID0+XG4gICAgICAgICAgdHJhbnNjZWl2ZXIucmVjZWl2ZXIudHJhY2sua2luZCA9PT0gJ3ZpZGVvJyk7XG4gICAgICAgIGlmIChvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVWaWRlbyA9PT0gZmFsc2UgJiYgdmlkZW9UcmFuc2NlaXZlcikge1xuICAgICAgICAgIGlmICh2aWRlb1RyYW5zY2VpdmVyLmRpcmVjdGlvbiA9PT0gJ3NlbmRyZWN2Jykge1xuICAgICAgICAgICAgaWYgKHZpZGVvVHJhbnNjZWl2ZXIuc2V0RGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgIHZpZGVvVHJhbnNjZWl2ZXIuc2V0RGlyZWN0aW9uKCdzZW5kb25seScpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmlkZW9UcmFuc2NlaXZlci5kaXJlY3Rpb24gPSAnc2VuZG9ubHknO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAodmlkZW9UcmFuc2NlaXZlci5kaXJlY3Rpb24gPT09ICdyZWN2b25seScpIHtcbiAgICAgICAgICAgIGlmICh2aWRlb1RyYW5zY2VpdmVyLnNldERpcmVjdGlvbikge1xuICAgICAgICAgICAgICB2aWRlb1RyYW5zY2VpdmVyLnNldERpcmVjdGlvbignaW5hY3RpdmUnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZpZGVvVHJhbnNjZWl2ZXIuZGlyZWN0aW9uID0gJ2luYWN0aXZlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAob2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlVmlkZW8gPT09IHRydWUgJiZcbiAgICAgICAgICAgICF2aWRlb1RyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgdGhpcy5hZGRUcmFuc2NlaXZlcigndmlkZW8nLCB7ZGlyZWN0aW9uOiAncmVjdm9ubHknfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvcmlnQ3JlYXRlT2ZmZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hpbUF1ZGlvQ29udGV4dCh3aW5kb3cpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICdvYmplY3QnIHx8IHdpbmRvdy5BdWRpb0NvbnRleHQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd2luZG93LkF1ZGlvQ29udGV4dCA9IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQ7XG59XG5cbiIsIi8qIGVzbGludC1lbnYgbm9kZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBTRFAgaGVscGVycy5cbmNvbnN0IFNEUFV0aWxzID0ge307XG5cbi8vIEdlbmVyYXRlIGFuIGFscGhhbnVtZXJpYyBpZGVudGlmaWVyIGZvciBjbmFtZSBvciBtaWRzLlxuLy8gVE9ETzogdXNlIFVVSURzIGluc3RlYWQ/IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2plZC85ODI4ODNcblNEUFV0aWxzLmdlbmVyYXRlSWRlbnRpZmllciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDEyKTtcbn07XG5cbi8vIFRoZSBSVENQIENOQU1FIHVzZWQgYnkgYWxsIHBlZXJjb25uZWN0aW9ucyBmcm9tIHRoZSBzYW1lIEpTLlxuU0RQVXRpbHMubG9jYWxDTmFtZSA9IFNEUFV0aWxzLmdlbmVyYXRlSWRlbnRpZmllcigpO1xuXG4vLyBTcGxpdHMgU0RQIGludG8gbGluZXMsIGRlYWxpbmcgd2l0aCBib3RoIENSTEYgYW5kIExGLlxuU0RQVXRpbHMuc3BsaXRMaW5lcyA9IGZ1bmN0aW9uKGJsb2IpIHtcbiAgcmV0dXJuIGJsb2IudHJpbSgpLnNwbGl0KCdcXG4nKS5tYXAobGluZSA9PiBsaW5lLnRyaW0oKSk7XG59O1xuLy8gU3BsaXRzIFNEUCBpbnRvIHNlc3Npb25wYXJ0IGFuZCBtZWRpYXNlY3Rpb25zLiBFbnN1cmVzIENSTEYuXG5TRFBVdGlscy5zcGxpdFNlY3Rpb25zID0gZnVuY3Rpb24oYmxvYikge1xuICBjb25zdCBwYXJ0cyA9IGJsb2Iuc3BsaXQoJ1xcbm09Jyk7XG4gIHJldHVybiBwYXJ0cy5tYXAoKHBhcnQsIGluZGV4KSA9PiAoaW5kZXggPiAwID9cbiAgICAnbT0nICsgcGFydCA6IHBhcnQpLnRyaW0oKSArICdcXHJcXG4nKTtcbn07XG5cbi8vIFJldHVybnMgdGhlIHNlc3Npb24gZGVzY3JpcHRpb24uXG5TRFBVdGlscy5nZXREZXNjcmlwdGlvbiA9IGZ1bmN0aW9uKGJsb2IpIHtcbiAgY29uc3Qgc2VjdGlvbnMgPSBTRFBVdGlscy5zcGxpdFNlY3Rpb25zKGJsb2IpO1xuICByZXR1cm4gc2VjdGlvbnMgJiYgc2VjdGlvbnNbMF07XG59O1xuXG4vLyBSZXR1cm5zIHRoZSBpbmRpdmlkdWFsIG1lZGlhIHNlY3Rpb25zLlxuU0RQVXRpbHMuZ2V0TWVkaWFTZWN0aW9ucyA9IGZ1bmN0aW9uKGJsb2IpIHtcbiAgY29uc3Qgc2VjdGlvbnMgPSBTRFBVdGlscy5zcGxpdFNlY3Rpb25zKGJsb2IpO1xuICBzZWN0aW9ucy5zaGlmdCgpO1xuICByZXR1cm4gc2VjdGlvbnM7XG59O1xuXG4vLyBSZXR1cm5zIGxpbmVzIHRoYXQgc3RhcnQgd2l0aCBhIGNlcnRhaW4gcHJlZml4LlxuU0RQVXRpbHMubWF0Y2hQcmVmaXggPSBmdW5jdGlvbihibG9iLCBwcmVmaXgpIHtcbiAgcmV0dXJuIFNEUFV0aWxzLnNwbGl0TGluZXMoYmxvYikuZmlsdGVyKGxpbmUgPT4gbGluZS5pbmRleE9mKHByZWZpeCkgPT09IDApO1xufTtcblxuLy8gUGFyc2VzIGFuIElDRSBjYW5kaWRhdGUgbGluZS4gU2FtcGxlIGlucHV0OlxuLy8gY2FuZGlkYXRlOjcwMjc4NjM1MCAyIHVkcCA0MTgxOTkwMiA4LjguOC44IDYwNzY5IHR5cCByZWxheSByYWRkciA4LjguOC44XG4vLyBycG9ydCA1NTk5NlwiXG4vLyBJbnB1dCBjYW4gYmUgcHJlZml4ZWQgd2l0aCBhPS5cblNEUFV0aWxzLnBhcnNlQ2FuZGlkYXRlID0gZnVuY3Rpb24obGluZSkge1xuICBsZXQgcGFydHM7XG4gIC8vIFBhcnNlIGJvdGggdmFyaWFudHMuXG4gIGlmIChsaW5lLmluZGV4T2YoJ2E9Y2FuZGlkYXRlOicpID09PSAwKSB7XG4gICAgcGFydHMgPSBsaW5lLnN1YnN0cmluZygxMikuc3BsaXQoJyAnKTtcbiAgfSBlbHNlIHtcbiAgICBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKDEwKS5zcGxpdCgnICcpO1xuICB9XG5cbiAgY29uc3QgY2FuZGlkYXRlID0ge1xuICAgIGZvdW5kYXRpb246IHBhcnRzWzBdLFxuICAgIGNvbXBvbmVudDogezE6ICdydHAnLCAyOiAncnRjcCd9W3BhcnRzWzFdXSB8fCBwYXJ0c1sxXSxcbiAgICBwcm90b2NvbDogcGFydHNbMl0udG9Mb3dlckNhc2UoKSxcbiAgICBwcmlvcml0eTogcGFyc2VJbnQocGFydHNbM10sIDEwKSxcbiAgICBpcDogcGFydHNbNF0sXG4gICAgYWRkcmVzczogcGFydHNbNF0sIC8vIGFkZHJlc3MgaXMgYW4gYWxpYXMgZm9yIGlwLlxuICAgIHBvcnQ6IHBhcnNlSW50KHBhcnRzWzVdLCAxMCksXG4gICAgLy8gc2tpcCBwYXJ0c1s2XSA9PSAndHlwJ1xuICAgIHR5cGU6IHBhcnRzWzddLFxuICB9O1xuXG4gIGZvciAobGV0IGkgPSA4OyBpIDwgcGFydHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICBzd2l0Y2ggKHBhcnRzW2ldKSB7XG4gICAgICBjYXNlICdyYWRkcic6XG4gICAgICAgIGNhbmRpZGF0ZS5yZWxhdGVkQWRkcmVzcyA9IHBhcnRzW2kgKyAxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdycG9ydCc6XG4gICAgICAgIGNhbmRpZGF0ZS5yZWxhdGVkUG9ydCA9IHBhcnNlSW50KHBhcnRzW2kgKyAxXSwgMTApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RjcHR5cGUnOlxuICAgICAgICBjYW5kaWRhdGUudGNwVHlwZSA9IHBhcnRzW2kgKyAxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd1ZnJhZyc6XG4gICAgICAgIGNhbmRpZGF0ZS51ZnJhZyA9IHBhcnRzW2kgKyAxXTsgLy8gZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXG4gICAgICAgIGNhbmRpZGF0ZS51c2VybmFtZUZyYWdtZW50ID0gcGFydHNbaSArIDFdO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6IC8vIGV4dGVuc2lvbiBoYW5kbGluZywgaW4gcGFydGljdWxhciB1ZnJhZy4gRG9uJ3Qgb3ZlcndyaXRlLlxuICAgICAgICBpZiAoY2FuZGlkYXRlW3BhcnRzW2ldXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY2FuZGlkYXRlW3BhcnRzW2ldXSA9IHBhcnRzW2kgKyAxXTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNhbmRpZGF0ZTtcbn07XG5cbi8vIFRyYW5zbGF0ZXMgYSBjYW5kaWRhdGUgb2JqZWN0IGludG8gU0RQIGNhbmRpZGF0ZSBhdHRyaWJ1dGUuXG4vLyBUaGlzIGRvZXMgbm90IGluY2x1ZGUgdGhlIGE9IHByZWZpeCFcblNEUFV0aWxzLndyaXRlQ2FuZGlkYXRlID0gZnVuY3Rpb24oY2FuZGlkYXRlKSB7XG4gIGNvbnN0IHNkcCA9IFtdO1xuICBzZHAucHVzaChjYW5kaWRhdGUuZm91bmRhdGlvbik7XG5cbiAgY29uc3QgY29tcG9uZW50ID0gY2FuZGlkYXRlLmNvbXBvbmVudDtcbiAgaWYgKGNvbXBvbmVudCA9PT0gJ3J0cCcpIHtcbiAgICBzZHAucHVzaCgxKTtcbiAgfSBlbHNlIGlmIChjb21wb25lbnQgPT09ICdydGNwJykge1xuICAgIHNkcC5wdXNoKDIpO1xuICB9IGVsc2Uge1xuICAgIHNkcC5wdXNoKGNvbXBvbmVudCk7XG4gIH1cbiAgc2RwLnB1c2goY2FuZGlkYXRlLnByb3RvY29sLnRvVXBwZXJDYXNlKCkpO1xuICBzZHAucHVzaChjYW5kaWRhdGUucHJpb3JpdHkpO1xuICBzZHAucHVzaChjYW5kaWRhdGUuYWRkcmVzcyB8fCBjYW5kaWRhdGUuaXApO1xuICBzZHAucHVzaChjYW5kaWRhdGUucG9ydCk7XG5cbiAgY29uc3QgdHlwZSA9IGNhbmRpZGF0ZS50eXBlO1xuICBzZHAucHVzaCgndHlwJyk7XG4gIHNkcC5wdXNoKHR5cGUpO1xuICBpZiAodHlwZSAhPT0gJ2hvc3QnICYmIGNhbmRpZGF0ZS5yZWxhdGVkQWRkcmVzcyAmJlxuICAgICAgY2FuZGlkYXRlLnJlbGF0ZWRQb3J0KSB7XG4gICAgc2RwLnB1c2goJ3JhZGRyJyk7XG4gICAgc2RwLnB1c2goY2FuZGlkYXRlLnJlbGF0ZWRBZGRyZXNzKTtcbiAgICBzZHAucHVzaCgncnBvcnQnKTtcbiAgICBzZHAucHVzaChjYW5kaWRhdGUucmVsYXRlZFBvcnQpO1xuICB9XG4gIGlmIChjYW5kaWRhdGUudGNwVHlwZSAmJiBjYW5kaWRhdGUucHJvdG9jb2wudG9Mb3dlckNhc2UoKSA9PT0gJ3RjcCcpIHtcbiAgICBzZHAucHVzaCgndGNwdHlwZScpO1xuICAgIHNkcC5wdXNoKGNhbmRpZGF0ZS50Y3BUeXBlKTtcbiAgfVxuICBpZiAoY2FuZGlkYXRlLnVzZXJuYW1lRnJhZ21lbnQgfHwgY2FuZGlkYXRlLnVmcmFnKSB7XG4gICAgc2RwLnB1c2goJ3VmcmFnJyk7XG4gICAgc2RwLnB1c2goY2FuZGlkYXRlLnVzZXJuYW1lRnJhZ21lbnQgfHwgY2FuZGlkYXRlLnVmcmFnKTtcbiAgfVxuICByZXR1cm4gJ2NhbmRpZGF0ZTonICsgc2RwLmpvaW4oJyAnKTtcbn07XG5cbi8vIFBhcnNlcyBhbiBpY2Utb3B0aW9ucyBsaW5lLCByZXR1cm5zIGFuIGFycmF5IG9mIG9wdGlvbiB0YWdzLlxuLy8gU2FtcGxlIGlucHV0OlxuLy8gYT1pY2Utb3B0aW9uczpmb28gYmFyXG5TRFBVdGlscy5wYXJzZUljZU9wdGlvbnMgPSBmdW5jdGlvbihsaW5lKSB7XG4gIHJldHVybiBsaW5lLnN1YnN0cmluZygxNCkuc3BsaXQoJyAnKTtcbn07XG5cbi8vIFBhcnNlcyBhIHJ0cG1hcCBsaW5lLCByZXR1cm5zIFJUQ1J0cENvZGRlY1BhcmFtZXRlcnMuIFNhbXBsZSBpbnB1dDpcbi8vIGE9cnRwbWFwOjExMSBvcHVzLzQ4MDAwLzJcblNEUFV0aWxzLnBhcnNlUnRwTWFwID0gZnVuY3Rpb24obGluZSkge1xuICBsZXQgcGFydHMgPSBsaW5lLnN1YnN0cmluZyg5KS5zcGxpdCgnICcpO1xuICBjb25zdCBwYXJzZWQgPSB7XG4gICAgcGF5bG9hZFR5cGU6IHBhcnNlSW50KHBhcnRzLnNoaWZ0KCksIDEwKSwgLy8gd2FzOiBpZFxuICB9O1xuXG4gIHBhcnRzID0gcGFydHNbMF0uc3BsaXQoJy8nKTtcblxuICBwYXJzZWQubmFtZSA9IHBhcnRzWzBdO1xuICBwYXJzZWQuY2xvY2tSYXRlID0gcGFyc2VJbnQocGFydHNbMV0sIDEwKTsgLy8gd2FzOiBjbG9ja3JhdGVcbiAgcGFyc2VkLmNoYW5uZWxzID0gcGFydHMubGVuZ3RoID09PSAzID8gcGFyc2VJbnQocGFydHNbMl0sIDEwKSA6IDE7XG4gIC8vIGxlZ2FjeSBhbGlhcywgZ290IHJlbmFtZWQgYmFjayB0byBjaGFubmVscyBpbiBPUlRDLlxuICBwYXJzZWQubnVtQ2hhbm5lbHMgPSBwYXJzZWQuY2hhbm5lbHM7XG4gIHJldHVybiBwYXJzZWQ7XG59O1xuXG4vLyBHZW5lcmF0ZXMgYSBydHBtYXAgbGluZSBmcm9tIFJUQ1J0cENvZGVjQ2FwYWJpbGl0eSBvclxuLy8gUlRDUnRwQ29kZWNQYXJhbWV0ZXJzLlxuU0RQVXRpbHMud3JpdGVSdHBNYXAgPSBmdW5jdGlvbihjb2RlYykge1xuICBsZXQgcHQgPSBjb2RlYy5wYXlsb2FkVHlwZTtcbiAgaWYgKGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICBwdCA9IGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlO1xuICB9XG4gIGNvbnN0IGNoYW5uZWxzID0gY29kZWMuY2hhbm5lbHMgfHwgY29kZWMubnVtQ2hhbm5lbHMgfHwgMTtcbiAgcmV0dXJuICdhPXJ0cG1hcDonICsgcHQgKyAnICcgKyBjb2RlYy5uYW1lICsgJy8nICsgY29kZWMuY2xvY2tSYXRlICtcbiAgICAgIChjaGFubmVscyAhPT0gMSA/ICcvJyArIGNoYW5uZWxzIDogJycpICsgJ1xcclxcbic7XG59O1xuXG4vLyBQYXJzZXMgYSBleHRtYXAgbGluZSAoaGVhZGVyZXh0ZW5zaW9uIGZyb20gUkZDIDUyODUpLiBTYW1wbGUgaW5wdXQ6XG4vLyBhPWV4dG1hcDoyIHVybjppZXRmOnBhcmFtczpydHAtaGRyZXh0OnRvZmZzZXRcbi8vIGE9ZXh0bWFwOjIvc2VuZG9ubHkgdXJuOmlldGY6cGFyYW1zOnJ0cC1oZHJleHQ6dG9mZnNldFxuU0RQVXRpbHMucGFyc2VFeHRtYXAgPSBmdW5jdGlvbihsaW5lKSB7XG4gIGNvbnN0IHBhcnRzID0gbGluZS5zdWJzdHJpbmcoOSkuc3BsaXQoJyAnKTtcbiAgcmV0dXJuIHtcbiAgICBpZDogcGFyc2VJbnQocGFydHNbMF0sIDEwKSxcbiAgICBkaXJlY3Rpb246IHBhcnRzWzBdLmluZGV4T2YoJy8nKSA+IDAgPyBwYXJ0c1swXS5zcGxpdCgnLycpWzFdIDogJ3NlbmRyZWN2JyxcbiAgICB1cmk6IHBhcnRzWzFdLFxuICAgIGF0dHJpYnV0ZXM6IHBhcnRzLnNsaWNlKDIpLmpvaW4oJyAnKSxcbiAgfTtcbn07XG5cbi8vIEdlbmVyYXRlcyBhbiBleHRtYXAgbGluZSBmcm9tIFJUQ1J0cEhlYWRlckV4dGVuc2lvblBhcmFtZXRlcnMgb3Jcbi8vIFJUQ1J0cEhlYWRlckV4dGVuc2lvbi5cblNEUFV0aWxzLndyaXRlRXh0bWFwID0gZnVuY3Rpb24oaGVhZGVyRXh0ZW5zaW9uKSB7XG4gIHJldHVybiAnYT1leHRtYXA6JyArIChoZWFkZXJFeHRlbnNpb24uaWQgfHwgaGVhZGVyRXh0ZW5zaW9uLnByZWZlcnJlZElkKSArXG4gICAgICAoaGVhZGVyRXh0ZW5zaW9uLmRpcmVjdGlvbiAmJiBoZWFkZXJFeHRlbnNpb24uZGlyZWN0aW9uICE9PSAnc2VuZHJlY3YnXG4gICAgICAgID8gJy8nICsgaGVhZGVyRXh0ZW5zaW9uLmRpcmVjdGlvblxuICAgICAgICA6ICcnKSArXG4gICAgICAnICcgKyBoZWFkZXJFeHRlbnNpb24udXJpICtcbiAgICAgIChoZWFkZXJFeHRlbnNpb24uYXR0cmlidXRlcyA/ICcgJyArIGhlYWRlckV4dGVuc2lvbi5hdHRyaWJ1dGVzIDogJycpICtcbiAgICAgICdcXHJcXG4nO1xufTtcblxuLy8gUGFyc2VzIGEgZm10cCBsaW5lLCByZXR1cm5zIGRpY3Rpb25hcnkuIFNhbXBsZSBpbnB1dDpcbi8vIGE9Zm10cDo5NiB2YnI9b247Y25nPW9uXG4vLyBBbHNvIGRlYWxzIHdpdGggdmJyPW9uOyBjbmc9b25cblNEUFV0aWxzLnBhcnNlRm10cCA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgY29uc3QgcGFyc2VkID0ge307XG4gIGxldCBrdjtcbiAgY29uc3QgcGFydHMgPSBsaW5lLnN1YnN0cmluZyhsaW5lLmluZGV4T2YoJyAnKSArIDEpLnNwbGl0KCc7Jyk7XG4gIGZvciAobGV0IGogPSAwOyBqIDwgcGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICBrdiA9IHBhcnRzW2pdLnRyaW0oKS5zcGxpdCgnPScpO1xuICAgIHBhcnNlZFtrdlswXS50cmltKCldID0ga3ZbMV07XG4gIH1cbiAgcmV0dXJuIHBhcnNlZDtcbn07XG5cbi8vIEdlbmVyYXRlcyBhIGZtdHAgbGluZSBmcm9tIFJUQ1J0cENvZGVjQ2FwYWJpbGl0eSBvciBSVENSdHBDb2RlY1BhcmFtZXRlcnMuXG5TRFBVdGlscy53cml0ZUZtdHAgPSBmdW5jdGlvbihjb2RlYykge1xuICBsZXQgbGluZSA9ICcnO1xuICBsZXQgcHQgPSBjb2RlYy5wYXlsb2FkVHlwZTtcbiAgaWYgKGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICBwdCA9IGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlO1xuICB9XG4gIGlmIChjb2RlYy5wYXJhbWV0ZXJzICYmIE9iamVjdC5rZXlzKGNvZGVjLnBhcmFtZXRlcnMpLmxlbmd0aCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IFtdO1xuICAgIE9iamVjdC5rZXlzKGNvZGVjLnBhcmFtZXRlcnMpLmZvckVhY2gocGFyYW0gPT4ge1xuICAgICAgaWYgKGNvZGVjLnBhcmFtZXRlcnNbcGFyYW1dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcGFyYW1zLnB1c2gocGFyYW0gKyAnPScgKyBjb2RlYy5wYXJhbWV0ZXJzW3BhcmFtXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJhbXMucHVzaChwYXJhbSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgbGluZSArPSAnYT1mbXRwOicgKyBwdCArICcgJyArIHBhcmFtcy5qb2luKCc7JykgKyAnXFxyXFxuJztcbiAgfVxuICByZXR1cm4gbGluZTtcbn07XG5cbi8vIFBhcnNlcyBhIHJ0Y3AtZmIgbGluZSwgcmV0dXJucyBSVENQUnRjcEZlZWRiYWNrIG9iamVjdC4gU2FtcGxlIGlucHV0OlxuLy8gYT1ydGNwLWZiOjk4IG5hY2sgcnBzaVxuU0RQVXRpbHMucGFyc2VSdGNwRmIgPSBmdW5jdGlvbihsaW5lKSB7XG4gIGNvbnN0IHBhcnRzID0gbGluZS5zdWJzdHJpbmcobGluZS5pbmRleE9mKCcgJykgKyAxKS5zcGxpdCgnICcpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IHBhcnRzLnNoaWZ0KCksXG4gICAgcGFyYW1ldGVyOiBwYXJ0cy5qb2luKCcgJyksXG4gIH07XG59O1xuXG4vLyBHZW5lcmF0ZSBhPXJ0Y3AtZmIgbGluZXMgZnJvbSBSVENSdHBDb2RlY0NhcGFiaWxpdHkgb3IgUlRDUnRwQ29kZWNQYXJhbWV0ZXJzLlxuU0RQVXRpbHMud3JpdGVSdGNwRmIgPSBmdW5jdGlvbihjb2RlYykge1xuICBsZXQgbGluZXMgPSAnJztcbiAgbGV0IHB0ID0gY29kZWMucGF5bG9hZFR5cGU7XG4gIGlmIChjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcHQgPSBjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZTtcbiAgfVxuICBpZiAoY29kZWMucnRjcEZlZWRiYWNrICYmIGNvZGVjLnJ0Y3BGZWVkYmFjay5sZW5ndGgpIHtcbiAgICAvLyBGSVhNRTogc3BlY2lhbCBoYW5kbGluZyBmb3IgdHJyLWludD9cbiAgICBjb2RlYy5ydGNwRmVlZGJhY2suZm9yRWFjaChmYiA9PiB7XG4gICAgICBsaW5lcyArPSAnYT1ydGNwLWZiOicgKyBwdCArICcgJyArIGZiLnR5cGUgK1xuICAgICAgKGZiLnBhcmFtZXRlciAmJiBmYi5wYXJhbWV0ZXIubGVuZ3RoID8gJyAnICsgZmIucGFyYW1ldGVyIDogJycpICtcbiAgICAgICAgICAnXFxyXFxuJztcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbGluZXM7XG59O1xuXG4vLyBQYXJzZXMgYSBSRkMgNTU3NiBzc3JjIG1lZGlhIGF0dHJpYnV0ZS4gU2FtcGxlIGlucHV0OlxuLy8gYT1zc3JjOjM3MzU5Mjg1NTkgY25hbWU6c29tZXRoaW5nXG5TRFBVdGlscy5wYXJzZVNzcmNNZWRpYSA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgY29uc3Qgc3AgPSBsaW5lLmluZGV4T2YoJyAnKTtcbiAgY29uc3QgcGFydHMgPSB7XG4gICAgc3NyYzogcGFyc2VJbnQobGluZS5zdWJzdHJpbmcoNywgc3ApLCAxMCksXG4gIH07XG4gIGNvbnN0IGNvbG9uID0gbGluZS5pbmRleE9mKCc6Jywgc3ApO1xuICBpZiAoY29sb24gPiAtMSkge1xuICAgIHBhcnRzLmF0dHJpYnV0ZSA9IGxpbmUuc3Vic3RyaW5nKHNwICsgMSwgY29sb24pO1xuICAgIHBhcnRzLnZhbHVlID0gbGluZS5zdWJzdHJpbmcoY29sb24gKyAxKTtcbiAgfSBlbHNlIHtcbiAgICBwYXJ0cy5hdHRyaWJ1dGUgPSBsaW5lLnN1YnN0cmluZyhzcCArIDEpO1xuICB9XG4gIHJldHVybiBwYXJ0cztcbn07XG5cbi8vIFBhcnNlIGEgc3NyYy1ncm91cCBsaW5lIChzZWUgUkZDIDU1NzYpLiBTYW1wbGUgaW5wdXQ6XG4vLyBhPXNzcmMtZ3JvdXA6c2VtYW50aWNzIDEyIDM0XG5TRFBVdGlscy5wYXJzZVNzcmNHcm91cCA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgY29uc3QgcGFydHMgPSBsaW5lLnN1YnN0cmluZygxMykuc3BsaXQoJyAnKTtcbiAgcmV0dXJuIHtcbiAgICBzZW1hbnRpY3M6IHBhcnRzLnNoaWZ0KCksXG4gICAgc3NyY3M6IHBhcnRzLm1hcChzc3JjID0+IHBhcnNlSW50KHNzcmMsIDEwKSksXG4gIH07XG59O1xuXG4vLyBFeHRyYWN0cyB0aGUgTUlEIChSRkMgNTg4OCkgZnJvbSBhIG1lZGlhIHNlY3Rpb24uXG4vLyBSZXR1cm5zIHRoZSBNSUQgb3IgdW5kZWZpbmVkIGlmIG5vIG1pZCBsaW5lIHdhcyBmb3VuZC5cblNEUFV0aWxzLmdldE1pZCA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICBjb25zdCBtaWQgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPW1pZDonKVswXTtcbiAgaWYgKG1pZCkge1xuICAgIHJldHVybiBtaWQuc3Vic3RyaW5nKDYpO1xuICB9XG59O1xuXG4vLyBQYXJzZXMgYSBmaW5nZXJwcmludCBsaW5lIGZvciBEVExTLVNSVFAuXG5TRFBVdGlscy5wYXJzZUZpbmdlcnByaW50ID0gZnVuY3Rpb24obGluZSkge1xuICBjb25zdCBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKDE0KS5zcGxpdCgnICcpO1xuICByZXR1cm4ge1xuICAgIGFsZ29yaXRobTogcGFydHNbMF0udG9Mb3dlckNhc2UoKSwgLy8gYWxnb3JpdGhtIGlzIGNhc2Utc2Vuc2l0aXZlIGluIEVkZ2UuXG4gICAgdmFsdWU6IHBhcnRzWzFdLnRvVXBwZXJDYXNlKCksIC8vIHRoZSBkZWZpbml0aW9uIGlzIHVwcGVyLWNhc2UgaW4gUkZDIDQ1NzIuXG4gIH07XG59O1xuXG4vLyBFeHRyYWN0cyBEVExTIHBhcmFtZXRlcnMgZnJvbSBTRFAgbWVkaWEgc2VjdGlvbiBvciBzZXNzaW9ucGFydC5cbi8vIEZJWE1FOiBmb3IgY29uc2lzdGVuY3kgd2l0aCBvdGhlciBmdW5jdGlvbnMgdGhpcyBzaG91bGQgb25seVxuLy8gICBnZXQgdGhlIGZpbmdlcnByaW50IGxpbmUgYXMgaW5wdXQuIFNlZSBhbHNvIGdldEljZVBhcmFtZXRlcnMuXG5TRFBVdGlscy5nZXREdGxzUGFyYW1ldGVycyA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbiwgc2Vzc2lvbnBhcnQpIHtcbiAgY29uc3QgbGluZXMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24gKyBzZXNzaW9ucGFydCxcbiAgICAnYT1maW5nZXJwcmludDonKTtcbiAgLy8gTm90ZTogYT1zZXR1cCBsaW5lIGlzIGlnbm9yZWQgc2luY2Ugd2UgdXNlIHRoZSAnYXV0bycgcm9sZSBpbiBFZGdlLlxuICByZXR1cm4ge1xuICAgIHJvbGU6ICdhdXRvJyxcbiAgICBmaW5nZXJwcmludHM6IGxpbmVzLm1hcChTRFBVdGlscy5wYXJzZUZpbmdlcnByaW50KSxcbiAgfTtcbn07XG5cbi8vIFNlcmlhbGl6ZXMgRFRMUyBwYXJhbWV0ZXJzIHRvIFNEUC5cblNEUFV0aWxzLndyaXRlRHRsc1BhcmFtZXRlcnMgPSBmdW5jdGlvbihwYXJhbXMsIHNldHVwVHlwZSkge1xuICBsZXQgc2RwID0gJ2E9c2V0dXA6JyArIHNldHVwVHlwZSArICdcXHJcXG4nO1xuICBwYXJhbXMuZmluZ2VycHJpbnRzLmZvckVhY2goZnAgPT4ge1xuICAgIHNkcCArPSAnYT1maW5nZXJwcmludDonICsgZnAuYWxnb3JpdGhtICsgJyAnICsgZnAudmFsdWUgKyAnXFxyXFxuJztcbiAgfSk7XG4gIHJldHVybiBzZHA7XG59O1xuXG4vLyBQYXJzZXMgYT1jcnlwdG8gbGluZXMgaW50b1xuLy8gICBodHRwczovL3Jhd2dpdC5jb20vYWJvYmEvZWRnZXJ0Yy9tYXN0ZXIvbXNvcnRjLXJzNC5odG1sI2RpY3Rpb25hcnktcnRjc3J0cHNkZXNwYXJhbWV0ZXJzLW1lbWJlcnNcblNEUFV0aWxzLnBhcnNlQ3J5cHRvTGluZSA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgY29uc3QgcGFydHMgPSBsaW5lLnN1YnN0cmluZyg5KS5zcGxpdCgnICcpO1xuICByZXR1cm4ge1xuICAgIHRhZzogcGFyc2VJbnQocGFydHNbMF0sIDEwKSxcbiAgICBjcnlwdG9TdWl0ZTogcGFydHNbMV0sXG4gICAga2V5UGFyYW1zOiBwYXJ0c1syXSxcbiAgICBzZXNzaW9uUGFyYW1zOiBwYXJ0cy5zbGljZSgzKSxcbiAgfTtcbn07XG5cblNEUFV0aWxzLndyaXRlQ3J5cHRvTGluZSA9IGZ1bmN0aW9uKHBhcmFtZXRlcnMpIHtcbiAgcmV0dXJuICdhPWNyeXB0bzonICsgcGFyYW1ldGVycy50YWcgKyAnICcgK1xuICAgIHBhcmFtZXRlcnMuY3J5cHRvU3VpdGUgKyAnICcgK1xuICAgICh0eXBlb2YgcGFyYW1ldGVycy5rZXlQYXJhbXMgPT09ICdvYmplY3QnXG4gICAgICA/IFNEUFV0aWxzLndyaXRlQ3J5cHRvS2V5UGFyYW1zKHBhcmFtZXRlcnMua2V5UGFyYW1zKVxuICAgICAgOiBwYXJhbWV0ZXJzLmtleVBhcmFtcykgK1xuICAgIChwYXJhbWV0ZXJzLnNlc3Npb25QYXJhbXMgPyAnICcgKyBwYXJhbWV0ZXJzLnNlc3Npb25QYXJhbXMuam9pbignICcpIDogJycpICtcbiAgICAnXFxyXFxuJztcbn07XG5cbi8vIFBhcnNlcyB0aGUgY3J5cHRvIGtleSBwYXJhbWV0ZXJzIGludG9cbi8vICAgaHR0cHM6Ly9yYXdnaXQuY29tL2Fib2JhL2VkZ2VydGMvbWFzdGVyL21zb3J0Yy1yczQuaHRtbCNydGNzcnRwa2V5cGFyYW0qXG5TRFBVdGlscy5wYXJzZUNyeXB0b0tleVBhcmFtcyA9IGZ1bmN0aW9uKGtleVBhcmFtcykge1xuICBpZiAoa2V5UGFyYW1zLmluZGV4T2YoJ2lubGluZTonKSAhPT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHBhcnRzID0ga2V5UGFyYW1zLnN1YnN0cmluZyg3KS5zcGxpdCgnfCcpO1xuICByZXR1cm4ge1xuICAgIGtleU1ldGhvZDogJ2lubGluZScsXG4gICAga2V5U2FsdDogcGFydHNbMF0sXG4gICAgbGlmZVRpbWU6IHBhcnRzWzFdLFxuICAgIG1raVZhbHVlOiBwYXJ0c1syXSA/IHBhcnRzWzJdLnNwbGl0KCc6JylbMF0gOiB1bmRlZmluZWQsXG4gICAgbWtpTGVuZ3RoOiBwYXJ0c1syXSA/IHBhcnRzWzJdLnNwbGl0KCc6JylbMV0gOiB1bmRlZmluZWQsXG4gIH07XG59O1xuXG5TRFBVdGlscy53cml0ZUNyeXB0b0tleVBhcmFtcyA9IGZ1bmN0aW9uKGtleVBhcmFtcykge1xuICByZXR1cm4ga2V5UGFyYW1zLmtleU1ldGhvZCArICc6J1xuICAgICsga2V5UGFyYW1zLmtleVNhbHQgK1xuICAgIChrZXlQYXJhbXMubGlmZVRpbWUgPyAnfCcgKyBrZXlQYXJhbXMubGlmZVRpbWUgOiAnJykgK1xuICAgIChrZXlQYXJhbXMubWtpVmFsdWUgJiYga2V5UGFyYW1zLm1raUxlbmd0aFxuICAgICAgPyAnfCcgKyBrZXlQYXJhbXMubWtpVmFsdWUgKyAnOicgKyBrZXlQYXJhbXMubWtpTGVuZ3RoXG4gICAgICA6ICcnKTtcbn07XG5cbi8vIEV4dHJhY3RzIGFsbCBTREVTIHBhcmFtZXRlcnMuXG5TRFBVdGlscy5nZXRDcnlwdG9QYXJhbWV0ZXJzID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uLCBzZXNzaW9ucGFydCkge1xuICBjb25zdCBsaW5lcyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiArIHNlc3Npb25wYXJ0LFxuICAgICdhPWNyeXB0bzonKTtcbiAgcmV0dXJuIGxpbmVzLm1hcChTRFBVdGlscy5wYXJzZUNyeXB0b0xpbmUpO1xufTtcblxuLy8gUGFyc2VzIElDRSBpbmZvcm1hdGlvbiBmcm9tIFNEUCBtZWRpYSBzZWN0aW9uIG9yIHNlc3Npb25wYXJ0LlxuLy8gRklYTUU6IGZvciBjb25zaXN0ZW5jeSB3aXRoIG90aGVyIGZ1bmN0aW9ucyB0aGlzIHNob3VsZCBvbmx5XG4vLyAgIGdldCB0aGUgaWNlLXVmcmFnIGFuZCBpY2UtcHdkIGxpbmVzIGFzIGlucHV0LlxuU0RQVXRpbHMuZ2V0SWNlUGFyYW1ldGVycyA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbiwgc2Vzc2lvbnBhcnQpIHtcbiAgY29uc3QgdWZyYWcgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24gKyBzZXNzaW9ucGFydCxcbiAgICAnYT1pY2UtdWZyYWc6JylbMF07XG4gIGNvbnN0IHB3ZCA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiArIHNlc3Npb25wYXJ0LFxuICAgICdhPWljZS1wd2Q6JylbMF07XG4gIGlmICghKHVmcmFnICYmIHB3ZCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHVzZXJuYW1lRnJhZ21lbnQ6IHVmcmFnLnN1YnN0cmluZygxMiksXG4gICAgcGFzc3dvcmQ6IHB3ZC5zdWJzdHJpbmcoMTApLFxuICB9O1xufTtcblxuLy8gU2VyaWFsaXplcyBJQ0UgcGFyYW1ldGVycyB0byBTRFAuXG5TRFBVdGlscy53cml0ZUljZVBhcmFtZXRlcnMgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgbGV0IHNkcCA9ICdhPWljZS11ZnJhZzonICsgcGFyYW1zLnVzZXJuYW1lRnJhZ21lbnQgKyAnXFxyXFxuJyArXG4gICAgICAnYT1pY2UtcHdkOicgKyBwYXJhbXMucGFzc3dvcmQgKyAnXFxyXFxuJztcbiAgaWYgKHBhcmFtcy5pY2VMaXRlKSB7XG4gICAgc2RwICs9ICdhPWljZS1saXRlXFxyXFxuJztcbiAgfVxuICByZXR1cm4gc2RwO1xufTtcblxuLy8gUGFyc2VzIHRoZSBTRFAgbWVkaWEgc2VjdGlvbiBhbmQgcmV0dXJucyBSVENSdHBQYXJhbWV0ZXJzLlxuU0RQVXRpbHMucGFyc2VSdHBQYXJhbWV0ZXJzID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uKSB7XG4gIGNvbnN0IGRlc2NyaXB0aW9uID0ge1xuICAgIGNvZGVjczogW10sXG4gICAgaGVhZGVyRXh0ZW5zaW9uczogW10sXG4gICAgZmVjTWVjaGFuaXNtczogW10sXG4gICAgcnRjcDogW10sXG4gIH07XG4gIGNvbnN0IGxpbmVzID0gU0RQVXRpbHMuc3BsaXRMaW5lcyhtZWRpYVNlY3Rpb24pO1xuICBjb25zdCBtbGluZSA9IGxpbmVzWzBdLnNwbGl0KCcgJyk7XG4gIGRlc2NyaXB0aW9uLnByb2ZpbGUgPSBtbGluZVsyXTtcbiAgZm9yIChsZXQgaSA9IDM7IGkgPCBtbGluZS5sZW5ndGg7IGkrKykgeyAvLyBmaW5kIGFsbCBjb2RlY3MgZnJvbSBtbGluZVszLi5dXG4gICAgY29uc3QgcHQgPSBtbGluZVtpXTtcbiAgICBjb25zdCBydHBtYXBsaW5lID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgoXG4gICAgICBtZWRpYVNlY3Rpb24sICdhPXJ0cG1hcDonICsgcHQgKyAnICcpWzBdO1xuICAgIGlmIChydHBtYXBsaW5lKSB7XG4gICAgICBjb25zdCBjb2RlYyA9IFNEUFV0aWxzLnBhcnNlUnRwTWFwKHJ0cG1hcGxpbmUpO1xuICAgICAgY29uc3QgZm10cHMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChcbiAgICAgICAgbWVkaWFTZWN0aW9uLCAnYT1mbXRwOicgKyBwdCArICcgJyk7XG4gICAgICAvLyBPbmx5IHRoZSBmaXJzdCBhPWZtdHA6PHB0PiBpcyBjb25zaWRlcmVkLlxuICAgICAgY29kZWMucGFyYW1ldGVycyA9IGZtdHBzLmxlbmd0aCA/IFNEUFV0aWxzLnBhcnNlRm10cChmbXRwc1swXSkgOiB7fTtcbiAgICAgIGNvZGVjLnJ0Y3BGZWVkYmFjayA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KFxuICAgICAgICBtZWRpYVNlY3Rpb24sICdhPXJ0Y3AtZmI6JyArIHB0ICsgJyAnKVxuICAgICAgICAubWFwKFNEUFV0aWxzLnBhcnNlUnRjcEZiKTtcbiAgICAgIGRlc2NyaXB0aW9uLmNvZGVjcy5wdXNoKGNvZGVjKTtcbiAgICAgIC8vIHBhcnNlIEZFQyBtZWNoYW5pc21zIGZyb20gcnRwbWFwIGxpbmVzLlxuICAgICAgc3dpdGNoIChjb2RlYy5uYW1lLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgY2FzZSAnUkVEJzpcbiAgICAgICAgY2FzZSAnVUxQRkVDJzpcbiAgICAgICAgICBkZXNjcmlwdGlvbi5mZWNNZWNoYW5pc21zLnB1c2goY29kZWMubmFtZS50b1VwcGVyQ2FzZSgpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDogLy8gb25seSBSRUQgYW5kIFVMUEZFQyBhcmUgcmVjb2duaXplZCBhcyBGRUMgbWVjaGFuaXNtcy5cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1leHRtYXA6JykuZm9yRWFjaChsaW5lID0+IHtcbiAgICBkZXNjcmlwdGlvbi5oZWFkZXJFeHRlbnNpb25zLnB1c2goU0RQVXRpbHMucGFyc2VFeHRtYXAobGluZSkpO1xuICB9KTtcbiAgY29uc3Qgd2lsZGNhcmRSdGNwRmIgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXJ0Y3AtZmI6KiAnKVxuICAgIC5tYXAoU0RQVXRpbHMucGFyc2VSdGNwRmIpO1xuICBkZXNjcmlwdGlvbi5jb2RlY3MuZm9yRWFjaChjb2RlYyA9PiB7XG4gICAgd2lsZGNhcmRSdGNwRmIuZm9yRWFjaChmYj0+IHtcbiAgICAgIGNvbnN0IGR1cGxpY2F0ZSA9IGNvZGVjLnJ0Y3BGZWVkYmFjay5maW5kKGV4aXN0aW5nRmVlZGJhY2sgPT4ge1xuICAgICAgICByZXR1cm4gZXhpc3RpbmdGZWVkYmFjay50eXBlID09PSBmYi50eXBlICYmXG4gICAgICAgICAgZXhpc3RpbmdGZWVkYmFjay5wYXJhbWV0ZXIgPT09IGZiLnBhcmFtZXRlcjtcbiAgICAgIH0pO1xuICAgICAgaWYgKCFkdXBsaWNhdGUpIHtcbiAgICAgICAgY29kZWMucnRjcEZlZWRiYWNrLnB1c2goZmIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgLy8gRklYTUU6IHBhcnNlIHJ0Y3AuXG4gIHJldHVybiBkZXNjcmlwdGlvbjtcbn07XG5cbi8vIEdlbmVyYXRlcyBwYXJ0cyBvZiB0aGUgU0RQIG1lZGlhIHNlY3Rpb24gZGVzY3JpYmluZyB0aGUgY2FwYWJpbGl0aWVzIC9cbi8vIHBhcmFtZXRlcnMuXG5TRFBVdGlscy53cml0ZVJ0cERlc2NyaXB0aW9uID0gZnVuY3Rpb24oa2luZCwgY2Fwcykge1xuICBsZXQgc2RwID0gJyc7XG5cbiAgLy8gQnVpbGQgdGhlIG1saW5lLlxuICBzZHAgKz0gJ209JyArIGtpbmQgKyAnICc7XG4gIHNkcCArPSBjYXBzLmNvZGVjcy5sZW5ndGggPiAwID8gJzknIDogJzAnOyAvLyByZWplY3QgaWYgbm8gY29kZWNzLlxuICBzZHAgKz0gJyAnICsgKGNhcHMucHJvZmlsZSB8fCAnVURQL1RMUy9SVFAvU0FWUEYnKSArICcgJztcbiAgc2RwICs9IGNhcHMuY29kZWNzLm1hcChjb2RlYyA9PiB7XG4gICAgaWYgKGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIGNvZGVjLnBheWxvYWRUeXBlO1xuICB9KS5qb2luKCcgJykgKyAnXFxyXFxuJztcblxuICBzZHAgKz0gJ2M9SU4gSVA0IDAuMC4wLjBcXHJcXG4nO1xuICBzZHAgKz0gJ2E9cnRjcDo5IElOIElQNCAwLjAuMC4wXFxyXFxuJztcblxuICAvLyBBZGQgYT1ydHBtYXAgbGluZXMgZm9yIGVhY2ggY29kZWMuIEFsc28gZm10cCBhbmQgcnRjcC1mYi5cbiAgY2Fwcy5jb2RlY3MuZm9yRWFjaChjb2RlYyA9PiB7XG4gICAgc2RwICs9IFNEUFV0aWxzLndyaXRlUnRwTWFwKGNvZGVjKTtcbiAgICBzZHAgKz0gU0RQVXRpbHMud3JpdGVGbXRwKGNvZGVjKTtcbiAgICBzZHAgKz0gU0RQVXRpbHMud3JpdGVSdGNwRmIoY29kZWMpO1xuICB9KTtcbiAgbGV0IG1heHB0aW1lID0gMDtcbiAgY2Fwcy5jb2RlY3MuZm9yRWFjaChjb2RlYyA9PiB7XG4gICAgaWYgKGNvZGVjLm1heHB0aW1lID4gbWF4cHRpbWUpIHtcbiAgICAgIG1heHB0aW1lID0gY29kZWMubWF4cHRpbWU7XG4gICAgfVxuICB9KTtcbiAgaWYgKG1heHB0aW1lID4gMCkge1xuICAgIHNkcCArPSAnYT1tYXhwdGltZTonICsgbWF4cHRpbWUgKyAnXFxyXFxuJztcbiAgfVxuXG4gIGlmIChjYXBzLmhlYWRlckV4dGVuc2lvbnMpIHtcbiAgICBjYXBzLmhlYWRlckV4dGVuc2lvbnMuZm9yRWFjaChleHRlbnNpb24gPT4ge1xuICAgICAgc2RwICs9IFNEUFV0aWxzLndyaXRlRXh0bWFwKGV4dGVuc2lvbik7XG4gICAgfSk7XG4gIH1cbiAgLy8gRklYTUU6IHdyaXRlIGZlY01lY2hhbmlzbXMuXG4gIHJldHVybiBzZHA7XG59O1xuXG4vLyBQYXJzZXMgdGhlIFNEUCBtZWRpYSBzZWN0aW9uIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mXG4vLyBSVENSdHBFbmNvZGluZ1BhcmFtZXRlcnMuXG5TRFBVdGlscy5wYXJzZVJ0cEVuY29kaW5nUGFyYW1ldGVycyA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICBjb25zdCBlbmNvZGluZ1BhcmFtZXRlcnMgPSBbXTtcbiAgY29uc3QgZGVzY3JpcHRpb24gPSBTRFBVdGlscy5wYXJzZVJ0cFBhcmFtZXRlcnMobWVkaWFTZWN0aW9uKTtcbiAgY29uc3QgaGFzUmVkID0gZGVzY3JpcHRpb24uZmVjTWVjaGFuaXNtcy5pbmRleE9mKCdSRUQnKSAhPT0gLTE7XG4gIGNvbnN0IGhhc1VscGZlYyA9IGRlc2NyaXB0aW9uLmZlY01lY2hhbmlzbXMuaW5kZXhPZignVUxQRkVDJykgIT09IC0xO1xuXG4gIC8vIGZpbHRlciBhPXNzcmM6Li4uIGNuYW1lOiwgaWdub3JlIFBsYW5CLW1zaWRcbiAgY29uc3Qgc3NyY3MgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNzcmM6JylcbiAgICAubWFwKGxpbmUgPT4gU0RQVXRpbHMucGFyc2VTc3JjTWVkaWEobGluZSkpXG4gICAgLmZpbHRlcihwYXJ0cyA9PiBwYXJ0cy5hdHRyaWJ1dGUgPT09ICdjbmFtZScpO1xuICBjb25zdCBwcmltYXJ5U3NyYyA9IHNzcmNzLmxlbmd0aCA+IDAgJiYgc3NyY3NbMF0uc3NyYztcbiAgbGV0IHNlY29uZGFyeVNzcmM7XG5cbiAgY29uc3QgZmxvd3MgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNzcmMtZ3JvdXA6RklEJylcbiAgICAubWFwKGxpbmUgPT4ge1xuICAgICAgY29uc3QgcGFydHMgPSBsaW5lLnN1YnN0cmluZygxNykuc3BsaXQoJyAnKTtcbiAgICAgIHJldHVybiBwYXJ0cy5tYXAocGFydCA9PiBwYXJzZUludChwYXJ0LCAxMCkpO1xuICAgIH0pO1xuICBpZiAoZmxvd3MubGVuZ3RoID4gMCAmJiBmbG93c1swXS5sZW5ndGggPiAxICYmIGZsb3dzWzBdWzBdID09PSBwcmltYXJ5U3NyYykge1xuICAgIHNlY29uZGFyeVNzcmMgPSBmbG93c1swXVsxXTtcbiAgfVxuXG4gIGRlc2NyaXB0aW9uLmNvZGVjcy5mb3JFYWNoKGNvZGVjID0+IHtcbiAgICBpZiAoY29kZWMubmFtZS50b1VwcGVyQ2FzZSgpID09PSAnUlRYJyAmJiBjb2RlYy5wYXJhbWV0ZXJzLmFwdCkge1xuICAgICAgbGV0IGVuY1BhcmFtID0ge1xuICAgICAgICBzc3JjOiBwcmltYXJ5U3NyYyxcbiAgICAgICAgY29kZWNQYXlsb2FkVHlwZTogcGFyc2VJbnQoY29kZWMucGFyYW1ldGVycy5hcHQsIDEwKSxcbiAgICAgIH07XG4gICAgICBpZiAocHJpbWFyeVNzcmMgJiYgc2Vjb25kYXJ5U3NyYykge1xuICAgICAgICBlbmNQYXJhbS5ydHggPSB7c3NyYzogc2Vjb25kYXJ5U3NyY307XG4gICAgICB9XG4gICAgICBlbmNvZGluZ1BhcmFtZXRlcnMucHVzaChlbmNQYXJhbSk7XG4gICAgICBpZiAoaGFzUmVkKSB7XG4gICAgICAgIGVuY1BhcmFtID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShlbmNQYXJhbSkpO1xuICAgICAgICBlbmNQYXJhbS5mZWMgPSB7XG4gICAgICAgICAgc3NyYzogcHJpbWFyeVNzcmMsXG4gICAgICAgICAgbWVjaGFuaXNtOiBoYXNVbHBmZWMgPyAncmVkK3VscGZlYycgOiAncmVkJyxcbiAgICAgICAgfTtcbiAgICAgICAgZW5jb2RpbmdQYXJhbWV0ZXJzLnB1c2goZW5jUGFyYW0pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGlmIChlbmNvZGluZ1BhcmFtZXRlcnMubGVuZ3RoID09PSAwICYmIHByaW1hcnlTc3JjKSB7XG4gICAgZW5jb2RpbmdQYXJhbWV0ZXJzLnB1c2goe1xuICAgICAgc3NyYzogcHJpbWFyeVNzcmMsXG4gICAgfSk7XG4gIH1cblxuICAvLyB3ZSBzdXBwb3J0IGJvdGggYj1BUyBhbmQgYj1USUFTIGJ1dCBpbnRlcnByZXQgQVMgYXMgVElBUy5cbiAgbGV0IGJhbmR3aWR0aCA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2I9Jyk7XG4gIGlmIChiYW5kd2lkdGgubGVuZ3RoKSB7XG4gICAgaWYgKGJhbmR3aWR0aFswXS5pbmRleE9mKCdiPVRJQVM6JykgPT09IDApIHtcbiAgICAgIGJhbmR3aWR0aCA9IHBhcnNlSW50KGJhbmR3aWR0aFswXS5zdWJzdHJpbmcoNyksIDEwKTtcbiAgICB9IGVsc2UgaWYgKGJhbmR3aWR0aFswXS5pbmRleE9mKCdiPUFTOicpID09PSAwKSB7XG4gICAgICAvLyB1c2UgZm9ybXVsYSBmcm9tIEpTRVAgdG8gY29udmVydCBiPUFTIHRvIFRJQVMgdmFsdWUuXG4gICAgICBiYW5kd2lkdGggPSBwYXJzZUludChiYW5kd2lkdGhbMF0uc3Vic3RyaW5nKDUpLCAxMCkgKiAxMDAwICogMC45NVxuICAgICAgICAgIC0gKDUwICogNDAgKiA4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmFuZHdpZHRoID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBlbmNvZGluZ1BhcmFtZXRlcnMuZm9yRWFjaChwYXJhbXMgPT4ge1xuICAgICAgcGFyYW1zLm1heEJpdHJhdGUgPSBiYW5kd2lkdGg7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGVuY29kaW5nUGFyYW1ldGVycztcbn07XG5cbi8vIHBhcnNlcyBodHRwOi8vZHJhZnQub3J0Yy5vcmcvI3J0Y3J0Y3BwYXJhbWV0ZXJzKlxuU0RQVXRpbHMucGFyc2VSdGNwUGFyYW1ldGVycyA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICBjb25zdCBydGNwUGFyYW1ldGVycyA9IHt9O1xuXG4gIC8vIEdldHMgdGhlIGZpcnN0IFNTUkMuIE5vdGUgdGhhdCB3aXRoIFJUWCB0aGVyZSBtaWdodCBiZSBtdWx0aXBsZVxuICAvLyBTU1JDcy5cbiAgY29uc3QgcmVtb3RlU3NyYyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9c3NyYzonKVxuICAgIC5tYXAobGluZSA9PiBTRFBVdGlscy5wYXJzZVNzcmNNZWRpYShsaW5lKSlcbiAgICAuZmlsdGVyKG9iaiA9PiBvYmouYXR0cmlidXRlID09PSAnY25hbWUnKVswXTtcbiAgaWYgKHJlbW90ZVNzcmMpIHtcbiAgICBydGNwUGFyYW1ldGVycy5jbmFtZSA9IHJlbW90ZVNzcmMudmFsdWU7XG4gICAgcnRjcFBhcmFtZXRlcnMuc3NyYyA9IHJlbW90ZVNzcmMuc3NyYztcbiAgfVxuXG4gIC8vIEVkZ2UgdXNlcyB0aGUgY29tcG91bmQgYXR0cmlidXRlIGluc3RlYWQgb2YgcmVkdWNlZFNpemVcbiAgLy8gY29tcG91bmQgaXMgIXJlZHVjZWRTaXplXG4gIGNvbnN0IHJzaXplID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1ydGNwLXJzaXplJyk7XG4gIHJ0Y3BQYXJhbWV0ZXJzLnJlZHVjZWRTaXplID0gcnNpemUubGVuZ3RoID4gMDtcbiAgcnRjcFBhcmFtZXRlcnMuY29tcG91bmQgPSByc2l6ZS5sZW5ndGggPT09IDA7XG5cbiAgLy8gcGFyc2VzIHRoZSBydGNwLW11eCBhdHRy0ZZidXRlLlxuICAvLyBOb3RlIHRoYXQgRWRnZSBkb2VzIG5vdCBzdXBwb3J0IHVubXV4ZWQgUlRDUC5cbiAgY29uc3QgbXV4ID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1ydGNwLW11eCcpO1xuICBydGNwUGFyYW1ldGVycy5tdXggPSBtdXgubGVuZ3RoID4gMDtcblxuICByZXR1cm4gcnRjcFBhcmFtZXRlcnM7XG59O1xuXG5TRFBVdGlscy53cml0ZVJ0Y3BQYXJhbWV0ZXJzID0gZnVuY3Rpb24ocnRjcFBhcmFtZXRlcnMpIHtcbiAgbGV0IHNkcCA9ICcnO1xuICBpZiAocnRjcFBhcmFtZXRlcnMucmVkdWNlZFNpemUpIHtcbiAgICBzZHAgKz0gJ2E9cnRjcC1yc2l6ZVxcclxcbic7XG4gIH1cbiAgaWYgKHJ0Y3BQYXJhbWV0ZXJzLm11eCkge1xuICAgIHNkcCArPSAnYT1ydGNwLW11eFxcclxcbic7XG4gIH1cbiAgaWYgKHJ0Y3BQYXJhbWV0ZXJzLnNzcmMgIT09IHVuZGVmaW5lZCAmJiBydGNwUGFyYW1ldGVycy5jbmFtZSkge1xuICAgIHNkcCArPSAnYT1zc3JjOicgKyBydGNwUGFyYW1ldGVycy5zc3JjICtcbiAgICAgICcgY25hbWU6JyArIHJ0Y3BQYXJhbWV0ZXJzLmNuYW1lICsgJ1xcclxcbic7XG4gIH1cbiAgcmV0dXJuIHNkcDtcbn07XG5cblxuLy8gcGFyc2VzIGVpdGhlciBhPW1zaWQ6IG9yIGE9c3NyYzouLi4gbXNpZCBsaW5lcyBhbmQgcmV0dXJuc1xuLy8gdGhlIGlkIG9mIHRoZSBNZWRpYVN0cmVhbSBhbmQgTWVkaWFTdHJlYW1UcmFjay5cblNEUFV0aWxzLnBhcnNlTXNpZCA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICBsZXQgcGFydHM7XG4gIGNvbnN0IHNwZWMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPW1zaWQ6Jyk7XG4gIGlmIChzcGVjLmxlbmd0aCA9PT0gMSkge1xuICAgIHBhcnRzID0gc3BlY1swXS5zdWJzdHJpbmcoNykuc3BsaXQoJyAnKTtcbiAgICByZXR1cm4ge3N0cmVhbTogcGFydHNbMF0sIHRyYWNrOiBwYXJ0c1sxXX07XG4gIH1cbiAgY29uc3QgcGxhbkIgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNzcmM6JylcbiAgICAubWFwKGxpbmUgPT4gU0RQVXRpbHMucGFyc2VTc3JjTWVkaWEobGluZSkpXG4gICAgLmZpbHRlcihtc2lkUGFydHMgPT4gbXNpZFBhcnRzLmF0dHJpYnV0ZSA9PT0gJ21zaWQnKTtcbiAgaWYgKHBsYW5CLmxlbmd0aCA+IDApIHtcbiAgICBwYXJ0cyA9IHBsYW5CWzBdLnZhbHVlLnNwbGl0KCcgJyk7XG4gICAgcmV0dXJuIHtzdHJlYW06IHBhcnRzWzBdLCB0cmFjazogcGFydHNbMV19O1xuICB9XG59O1xuXG4vLyBTQ1RQXG4vLyBwYXJzZXMgZHJhZnQtaWV0Zi1tbXVzaWMtc2N0cC1zZHAtMjYgZmlyc3QgYW5kIGZhbGxzIGJhY2tcbi8vIHRvIGRyYWZ0LWlldGYtbW11c2ljLXNjdHAtc2RwLTA1XG5TRFBVdGlscy5wYXJzZVNjdHBEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICBjb25zdCBtbGluZSA9IFNEUFV0aWxzLnBhcnNlTUxpbmUobWVkaWFTZWN0aW9uKTtcbiAgY29uc3QgbWF4U2l6ZUxpbmUgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPW1heC1tZXNzYWdlLXNpemU6Jyk7XG4gIGxldCBtYXhNZXNzYWdlU2l6ZTtcbiAgaWYgKG1heFNpemVMaW5lLmxlbmd0aCA+IDApIHtcbiAgICBtYXhNZXNzYWdlU2l6ZSA9IHBhcnNlSW50KG1heFNpemVMaW5lWzBdLnN1YnN0cmluZygxOSksIDEwKTtcbiAgfVxuICBpZiAoaXNOYU4obWF4TWVzc2FnZVNpemUpKSB7XG4gICAgbWF4TWVzc2FnZVNpemUgPSA2NTUzNjtcbiAgfVxuICBjb25zdCBzY3RwUG9ydCA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9c2N0cC1wb3J0OicpO1xuICBpZiAoc2N0cFBvcnQubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiB7XG4gICAgICBwb3J0OiBwYXJzZUludChzY3RwUG9ydFswXS5zdWJzdHJpbmcoMTIpLCAxMCksXG4gICAgICBwcm90b2NvbDogbWxpbmUuZm10LFxuICAgICAgbWF4TWVzc2FnZVNpemUsXG4gICAgfTtcbiAgfVxuICBjb25zdCBzY3RwTWFwTGluZXMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNjdHBtYXA6Jyk7XG4gIGlmIChzY3RwTWFwTGluZXMubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IHBhcnRzID0gc2N0cE1hcExpbmVzWzBdXG4gICAgICAuc3Vic3RyaW5nKDEwKVxuICAgICAgLnNwbGl0KCcgJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvcnQ6IHBhcnNlSW50KHBhcnRzWzBdLCAxMCksXG4gICAgICBwcm90b2NvbDogcGFydHNbMV0sXG4gICAgICBtYXhNZXNzYWdlU2l6ZSxcbiAgICB9O1xuICB9XG59O1xuXG4vLyBTQ1RQXG4vLyBvdXRwdXRzIHRoZSBkcmFmdC1pZXRmLW1tdXNpYy1zY3RwLXNkcC0yNiB2ZXJzaW9uIHRoYXQgYWxsIGJyb3dzZXJzXG4vLyBzdXBwb3J0IGJ5IG5vdyByZWNlaXZpbmcgaW4gdGhpcyBmb3JtYXQsIHVubGVzcyB3ZSBvcmlnaW5hbGx5IHBhcnNlZFxuLy8gYXMgdGhlIGRyYWZ0LWlldGYtbW11c2ljLXNjdHAtc2RwLTA1IGZvcm1hdCAoaW5kaWNhdGVkIGJ5IHRoZSBtLWxpbmVcbi8vIHByb3RvY29sIG9mIERUTFMvU0NUUCAtLSB3aXRob3V0IFVEUC8gb3IgVENQLylcblNEUFV0aWxzLndyaXRlU2N0cERlc2NyaXB0aW9uID0gZnVuY3Rpb24obWVkaWEsIHNjdHApIHtcbiAgbGV0IG91dHB1dCA9IFtdO1xuICBpZiAobWVkaWEucHJvdG9jb2wgIT09ICdEVExTL1NDVFAnKSB7XG4gICAgb3V0cHV0ID0gW1xuICAgICAgJ209JyArIG1lZGlhLmtpbmQgKyAnIDkgJyArIG1lZGlhLnByb3RvY29sICsgJyAnICsgc2N0cC5wcm90b2NvbCArICdcXHJcXG4nLFxuICAgICAgJ2M9SU4gSVA0IDAuMC4wLjBcXHJcXG4nLFxuICAgICAgJ2E9c2N0cC1wb3J0OicgKyBzY3RwLnBvcnQgKyAnXFxyXFxuJyxcbiAgICBdO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IFtcbiAgICAgICdtPScgKyBtZWRpYS5raW5kICsgJyA5ICcgKyBtZWRpYS5wcm90b2NvbCArICcgJyArIHNjdHAucG9ydCArICdcXHJcXG4nLFxuICAgICAgJ2M9SU4gSVA0IDAuMC4wLjBcXHJcXG4nLFxuICAgICAgJ2E9c2N0cG1hcDonICsgc2N0cC5wb3J0ICsgJyAnICsgc2N0cC5wcm90b2NvbCArICcgNjU1MzVcXHJcXG4nLFxuICAgIF07XG4gIH1cbiAgaWYgKHNjdHAubWF4TWVzc2FnZVNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgIG91dHB1dC5wdXNoKCdhPW1heC1tZXNzYWdlLXNpemU6JyArIHNjdHAubWF4TWVzc2FnZVNpemUgKyAnXFxyXFxuJyk7XG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKTtcbn07XG5cbi8vIEdlbmVyYXRlIGEgc2Vzc2lvbiBJRCBmb3IgU0RQLlxuLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LWlldGYtcnRjd2ViLWpzZXAtMjAjc2VjdGlvbi01LjIuMVxuLy8gcmVjb21tZW5kcyB1c2luZyBhIGNyeXB0b2dyYXBoaWNhbGx5IHJhbmRvbSArdmUgNjQtYml0IHZhbHVlXG4vLyBidXQgcmlnaHQgbm93IHRoaXMgc2hvdWxkIGJlIGFjY2VwdGFibGUgYW5kIHdpdGhpbiB0aGUgcmlnaHQgcmFuZ2VcblNEUFV0aWxzLmdlbmVyYXRlU2Vzc2lvbklkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKCkuc3Vic3RyKDIsIDIyKTtcbn07XG5cbi8vIFdyaXRlIGJvaWxlciBwbGF0ZSBmb3Igc3RhcnQgb2YgU0RQXG4vLyBzZXNzSWQgYXJndW1lbnQgaXMgb3B0aW9uYWwgLSBpZiBub3Qgc3VwcGxpZWQgaXQgd2lsbFxuLy8gYmUgZ2VuZXJhdGVkIHJhbmRvbWx5XG4vLyBzZXNzVmVyc2lvbiBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gMlxuLy8gc2Vzc1VzZXIgaXMgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvICd0aGlzaXNhZGFwdGVyb3J0YydcblNEUFV0aWxzLndyaXRlU2Vzc2lvbkJvaWxlcnBsYXRlID0gZnVuY3Rpb24oc2Vzc0lkLCBzZXNzVmVyLCBzZXNzVXNlcikge1xuICBsZXQgc2Vzc2lvbklkO1xuICBjb25zdCB2ZXJzaW9uID0gc2Vzc1ZlciAhPT0gdW5kZWZpbmVkID8gc2Vzc1ZlciA6IDI7XG4gIGlmIChzZXNzSWQpIHtcbiAgICBzZXNzaW9uSWQgPSBzZXNzSWQ7XG4gIH0gZWxzZSB7XG4gICAgc2Vzc2lvbklkID0gU0RQVXRpbHMuZ2VuZXJhdGVTZXNzaW9uSWQoKTtcbiAgfVxuICBjb25zdCB1c2VyID0gc2Vzc1VzZXIgfHwgJ3RoaXNpc2FkYXB0ZXJvcnRjJztcbiAgLy8gRklYTUU6IHNlc3MtaWQgc2hvdWxkIGJlIGFuIE5UUCB0aW1lc3RhbXAuXG4gIHJldHVybiAndj0wXFxyXFxuJyArXG4gICAgICAnbz0nICsgdXNlciArICcgJyArIHNlc3Npb25JZCArICcgJyArIHZlcnNpb24gK1xuICAgICAgICAnIElOIElQNCAxMjcuMC4wLjFcXHJcXG4nICtcbiAgICAgICdzPS1cXHJcXG4nICtcbiAgICAgICd0PTAgMFxcclxcbic7XG59O1xuXG4vLyBHZXRzIHRoZSBkaXJlY3Rpb24gZnJvbSB0aGUgbWVkaWFTZWN0aW9uIG9yIHRoZSBzZXNzaW9ucGFydC5cblNEUFV0aWxzLmdldERpcmVjdGlvbiA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbiwgc2Vzc2lvbnBhcnQpIHtcbiAgLy8gTG9vayBmb3Igc2VuZHJlY3YsIHNlbmRvbmx5LCByZWN2b25seSwgaW5hY3RpdmUsIGRlZmF1bHQgdG8gc2VuZHJlY3YuXG4gIGNvbnN0IGxpbmVzID0gU0RQVXRpbHMuc3BsaXRMaW5lcyhtZWRpYVNlY3Rpb24pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgc3dpdGNoIChsaW5lc1tpXSkge1xuICAgICAgY2FzZSAnYT1zZW5kcmVjdic6XG4gICAgICBjYXNlICdhPXNlbmRvbmx5JzpcbiAgICAgIGNhc2UgJ2E9cmVjdm9ubHknOlxuICAgICAgY2FzZSAnYT1pbmFjdGl2ZSc6XG4gICAgICAgIHJldHVybiBsaW5lc1tpXS5zdWJzdHJpbmcoMik7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBGSVhNRTogV2hhdCBzaG91bGQgaGFwcGVuIGhlcmU/XG4gICAgfVxuICB9XG4gIGlmIChzZXNzaW9ucGFydCkge1xuICAgIHJldHVybiBTRFBVdGlscy5nZXREaXJlY3Rpb24oc2Vzc2lvbnBhcnQpO1xuICB9XG4gIHJldHVybiAnc2VuZHJlY3YnO1xufTtcblxuU0RQVXRpbHMuZ2V0S2luZCA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICBjb25zdCBsaW5lcyA9IFNEUFV0aWxzLnNwbGl0TGluZXMobWVkaWFTZWN0aW9uKTtcbiAgY29uc3QgbWxpbmUgPSBsaW5lc1swXS5zcGxpdCgnICcpO1xuICByZXR1cm4gbWxpbmVbMF0uc3Vic3RyaW5nKDIpO1xufTtcblxuU0RQVXRpbHMuaXNSZWplY3RlZCA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICByZXR1cm4gbWVkaWFTZWN0aW9uLnNwbGl0KCcgJywgMilbMV0gPT09ICcwJztcbn07XG5cblNEUFV0aWxzLnBhcnNlTUxpbmUgPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24pIHtcbiAgY29uc3QgbGluZXMgPSBTRFBVdGlscy5zcGxpdExpbmVzKG1lZGlhU2VjdGlvbik7XG4gIGNvbnN0IHBhcnRzID0gbGluZXNbMF0uc3Vic3RyaW5nKDIpLnNwbGl0KCcgJyk7XG4gIHJldHVybiB7XG4gICAga2luZDogcGFydHNbMF0sXG4gICAgcG9ydDogcGFyc2VJbnQocGFydHNbMV0sIDEwKSxcbiAgICBwcm90b2NvbDogcGFydHNbMl0sXG4gICAgZm10OiBwYXJ0cy5zbGljZSgzKS5qb2luKCcgJyksXG4gIH07XG59O1xuXG5TRFBVdGlscy5wYXJzZU9MaW5lID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uKSB7XG4gIGNvbnN0IGxpbmUgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdvPScpWzBdO1xuICBjb25zdCBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKDIpLnNwbGl0KCcgJyk7XG4gIHJldHVybiB7XG4gICAgdXNlcm5hbWU6IHBhcnRzWzBdLFxuICAgIHNlc3Npb25JZDogcGFydHNbMV0sXG4gICAgc2Vzc2lvblZlcnNpb246IHBhcnNlSW50KHBhcnRzWzJdLCAxMCksXG4gICAgbmV0VHlwZTogcGFydHNbM10sXG4gICAgYWRkcmVzc1R5cGU6IHBhcnRzWzRdLFxuICAgIGFkZHJlc3M6IHBhcnRzWzVdLFxuICB9O1xufTtcblxuLy8gYSB2ZXJ5IG5haXZlIGludGVycHJldGF0aW9uIG9mIGEgdmFsaWQgU0RQLlxuU0RQVXRpbHMuaXNWYWxpZFNEUCA9IGZ1bmN0aW9uKGJsb2IpIHtcbiAgaWYgKHR5cGVvZiBibG9iICE9PSAnc3RyaW5nJyB8fCBibG9iLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBsaW5lcyA9IFNEUFV0aWxzLnNwbGl0TGluZXMoYmxvYik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobGluZXNbaV0ubGVuZ3RoIDwgMiB8fCBsaW5lc1tpXS5jaGFyQXQoMSkgIT09ICc9Jykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBUT0RPOiBjaGVjayB0aGUgbW9kaWZpZXIgYSBiaXQgbW9yZS5cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIEV4cG9zZSBwdWJsaWMgbWV0aG9kcy5cbmlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jykge1xuICBtb2R1bGUuZXhwb3J0cyA9IFNEUFV0aWxzO1xufVxuIiwiLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTcgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4vKiBlc2xpbnQtZW52IG5vZGUgKi9cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IFNEUFV0aWxzIGZyb20gJ3NkcCc7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuL3V0aWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1SVENJY2VDYW5kaWRhdGUod2luZG93KSB7XG4gIC8vIGZvdW5kYXRpb24gaXMgYXJiaXRyYXJpbHkgY2hvc2VuIGFzIGFuIGluZGljYXRvciBmb3IgZnVsbCBzdXBwb3J0IGZvclxuICAvLyBodHRwczovL3czYy5naXRodWIuaW8vd2VicnRjLXBjLyNydGNpY2VjYW5kaWRhdGUtaW50ZXJmYWNlXG4gIGlmICghd2luZG93LlJUQ0ljZUNhbmRpZGF0ZSB8fCAod2luZG93LlJUQ0ljZUNhbmRpZGF0ZSAmJiAnZm91bmRhdGlvbicgaW5cbiAgICAgIHdpbmRvdy5SVENJY2VDYW5kaWRhdGUucHJvdG90eXBlKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IE5hdGl2ZVJUQ0ljZUNhbmRpZGF0ZSA9IHdpbmRvdy5SVENJY2VDYW5kaWRhdGU7XG4gIHdpbmRvdy5SVENJY2VDYW5kaWRhdGUgPSBmdW5jdGlvbiBSVENJY2VDYW5kaWRhdGUoYXJncykge1xuICAgIC8vIFJlbW92ZSB0aGUgYT0gd2hpY2ggc2hvdWxkbid0IGJlIHBhcnQgb2YgdGhlIGNhbmRpZGF0ZSBzdHJpbmcuXG4gICAgaWYgKHR5cGVvZiBhcmdzID09PSAnb2JqZWN0JyAmJiBhcmdzLmNhbmRpZGF0ZSAmJlxuICAgICAgICBhcmdzLmNhbmRpZGF0ZS5pbmRleE9mKCdhPScpID09PSAwKSB7XG4gICAgICBhcmdzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShhcmdzKSk7XG4gICAgICBhcmdzLmNhbmRpZGF0ZSA9IGFyZ3MuY2FuZGlkYXRlLnN1YnN0cmluZygyKTtcbiAgICB9XG5cbiAgICBpZiAoYXJncy5jYW5kaWRhdGUgJiYgYXJncy5jYW5kaWRhdGUubGVuZ3RoKSB7XG4gICAgICAvLyBBdWdtZW50IHRoZSBuYXRpdmUgY2FuZGlkYXRlIHdpdGggdGhlIHBhcnNlZCBmaWVsZHMuXG4gICAgICBjb25zdCBuYXRpdmVDYW5kaWRhdGUgPSBuZXcgTmF0aXZlUlRDSWNlQ2FuZGlkYXRlKGFyZ3MpO1xuICAgICAgY29uc3QgcGFyc2VkQ2FuZGlkYXRlID0gU0RQVXRpbHMucGFyc2VDYW5kaWRhdGUoYXJncy5jYW5kaWRhdGUpO1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyc2VkQ2FuZGlkYXRlKSB7XG4gICAgICAgIGlmICghKGtleSBpbiBuYXRpdmVDYW5kaWRhdGUpKSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5hdGl2ZUNhbmRpZGF0ZSwga2V5LFxuICAgICAgICAgICAge3ZhbHVlOiBwYXJzZWRDYW5kaWRhdGVba2V5XX0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE92ZXJyaWRlIHNlcmlhbGl6ZXIgdG8gbm90IHNlcmlhbGl6ZSB0aGUgZXh0cmEgYXR0cmlidXRlcy5cbiAgICAgIG5hdGl2ZUNhbmRpZGF0ZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2FuZGlkYXRlOiBuYXRpdmVDYW5kaWRhdGUuY2FuZGlkYXRlLFxuICAgICAgICAgIHNkcE1pZDogbmF0aXZlQ2FuZGlkYXRlLnNkcE1pZCxcbiAgICAgICAgICBzZHBNTGluZUluZGV4OiBuYXRpdmVDYW5kaWRhdGUuc2RwTUxpbmVJbmRleCxcbiAgICAgICAgICB1c2VybmFtZUZyYWdtZW50OiBuYXRpdmVDYW5kaWRhdGUudXNlcm5hbWVGcmFnbWVudCxcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gbmF0aXZlQ2FuZGlkYXRlO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE5hdGl2ZVJUQ0ljZUNhbmRpZGF0ZShhcmdzKTtcbiAgfTtcbiAgd2luZG93LlJUQ0ljZUNhbmRpZGF0ZS5wcm90b3R5cGUgPSBOYXRpdmVSVENJY2VDYW5kaWRhdGUucHJvdG90eXBlO1xuXG4gIC8vIEhvb2sgdXAgdGhlIGF1Z21lbnRlZCBjYW5kaWRhdGUgaW4gb25pY2VjYW5kaWRhdGUgYW5kXG4gIC8vIGFkZEV2ZW50TGlzdGVuZXIoJ2ljZWNhbmRpZGF0ZScsIC4uLilcbiAgdXRpbHMud3JhcFBlZXJDb25uZWN0aW9uRXZlbnQod2luZG93LCAnaWNlY2FuZGlkYXRlJywgZSA9PiB7XG4gICAgaWYgKGUuY2FuZGlkYXRlKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgJ2NhbmRpZGF0ZScsIHtcbiAgICAgICAgdmFsdWU6IG5ldyB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlKGUuY2FuZGlkYXRlKSxcbiAgICAgICAgd3JpdGFibGU6ICdmYWxzZSdcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGltUlRDSWNlQ2FuZGlkYXRlUmVsYXlQcm90b2NvbCh3aW5kb3cpIHtcbiAgaWYgKCF3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlIHx8ICh3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlICYmICdyZWxheVByb3RvY29sJyBpblxuICAgICAgd2luZG93LlJUQ0ljZUNhbmRpZGF0ZS5wcm90b3R5cGUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSG9vayB1cCB0aGUgYXVnbWVudGVkIGNhbmRpZGF0ZSBpbiBvbmljZWNhbmRpZGF0ZSBhbmRcbiAgLy8gYWRkRXZlbnRMaXN0ZW5lcignaWNlY2FuZGlkYXRlJywgLi4uKVxuICB1dGlscy53cmFwUGVlckNvbm5lY3Rpb25FdmVudCh3aW5kb3csICdpY2VjYW5kaWRhdGUnLCBlID0+IHtcbiAgICBpZiAoZS5jYW5kaWRhdGUpIHtcbiAgICAgIGNvbnN0IHBhcnNlZENhbmRpZGF0ZSA9IFNEUFV0aWxzLnBhcnNlQ2FuZGlkYXRlKGUuY2FuZGlkYXRlLmNhbmRpZGF0ZSk7XG4gICAgICBpZiAocGFyc2VkQ2FuZGlkYXRlLnR5cGUgPT09ICdyZWxheScpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIGxpYndlYnJ0Yy1zcGVjaWZpYyBtYXBwaW5nIG9mIGxvY2FsIHR5cGUgcHJlZmVyZW5jZVxuICAgICAgICAvLyB0byByZWxheVByb3RvY29sLlxuICAgICAgICBlLmNhbmRpZGF0ZS5yZWxheVByb3RvY29sID0ge1xuICAgICAgICAgIDA6ICd0bHMnLFxuICAgICAgICAgIDE6ICd0Y3AnLFxuICAgICAgICAgIDI6ICd1ZHAnLFxuICAgICAgICB9W3BhcnNlZENhbmRpZGF0ZS5wcmlvcml0eSA+PiAyNF07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1NYXhNZXNzYWdlU2l6ZSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKSB7XG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCEoJ3NjdHAnIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUsICdzY3RwJywge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMuX3NjdHAgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHRoaXMuX3NjdHA7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBjb25zdCBzY3RwSW5EZXNjcmlwdGlvbiA9IGZ1bmN0aW9uKGRlc2NyaXB0aW9uKSB7XG4gICAgaWYgKCFkZXNjcmlwdGlvbiB8fCAhZGVzY3JpcHRpb24uc2RwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHNlY3Rpb25zID0gU0RQVXRpbHMuc3BsaXRTZWN0aW9ucyhkZXNjcmlwdGlvbi5zZHApO1xuICAgIHNlY3Rpb25zLnNoaWZ0KCk7XG4gICAgcmV0dXJuIHNlY3Rpb25zLnNvbWUobWVkaWFTZWN0aW9uID0+IHtcbiAgICAgIGNvbnN0IG1MaW5lID0gU0RQVXRpbHMucGFyc2VNTGluZShtZWRpYVNlY3Rpb24pO1xuICAgICAgcmV0dXJuIG1MaW5lICYmIG1MaW5lLmtpbmQgPT09ICdhcHBsaWNhdGlvbidcbiAgICAgICAgICAmJiBtTGluZS5wcm90b2NvbC5pbmRleE9mKCdTQ1RQJykgIT09IC0xO1xuICAgIH0pO1xuICB9O1xuXG4gIGNvbnN0IGdldFJlbW90ZUZpcmVmb3hWZXJzaW9uID0gZnVuY3Rpb24oZGVzY3JpcHRpb24pIHtcbiAgICAvLyBUT0RPOiBJcyB0aGVyZSBhIGJldHRlciBzb2x1dGlvbiBmb3IgZGV0ZWN0aW5nIEZpcmVmb3g/XG4gICAgY29uc3QgbWF0Y2ggPSBkZXNjcmlwdGlvbi5zZHAubWF0Y2goL21vemlsbGEuLi5USElTX0lTX1NEUEFSVEEtKFxcZCspLyk7XG4gICAgaWYgKG1hdGNoID09PSBudWxsIHx8IG1hdGNoLmxlbmd0aCA8IDIpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgY29uc3QgdmVyc2lvbiA9IHBhcnNlSW50KG1hdGNoWzFdLCAxMCk7XG4gICAgLy8gVGVzdCBmb3IgTmFOICh5ZXMsIHRoaXMgaXMgdWdseSlcbiAgICByZXR1cm4gdmVyc2lvbiAhPT0gdmVyc2lvbiA/IC0xIDogdmVyc2lvbjtcbiAgfTtcblxuICBjb25zdCBnZXRDYW5TZW5kTWF4TWVzc2FnZVNpemUgPSBmdW5jdGlvbihyZW1vdGVJc0ZpcmVmb3gpIHtcbiAgICAvLyBFdmVyeSBpbXBsZW1lbnRhdGlvbiB3ZSBrbm93IGNhbiBzZW5kIGF0IGxlYXN0IDY0IEtpQi5cbiAgICAvLyBOb3RlOiBBbHRob3VnaCBDaHJvbWUgaXMgdGVjaG5pY2FsbHkgYWJsZSB0byBzZW5kIHVwIHRvIDI1NiBLaUIsIHRoZVxuICAgIC8vICAgICAgIGRhdGEgZG9lcyBub3QgcmVhY2ggdGhlIG90aGVyIHBlZXIgcmVsaWFibHkuXG4gICAgLy8gICAgICAgU2VlOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3Avd2VicnRjL2lzc3Vlcy9kZXRhaWw/aWQ9ODQxOVxuICAgIGxldCBjYW5TZW5kTWF4TWVzc2FnZVNpemUgPSA2NTUzNjtcbiAgICBpZiAoYnJvd3NlckRldGFpbHMuYnJvd3NlciA9PT0gJ2ZpcmVmb3gnKSB7XG4gICAgICBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDU3KSB7XG4gICAgICAgIGlmIChyZW1vdGVJc0ZpcmVmb3ggPT09IC0xKSB7XG4gICAgICAgICAgLy8gRkYgPCA1NyB3aWxsIHNlbmQgaW4gMTYgS2lCIGNodW5rcyB1c2luZyB0aGUgZGVwcmVjYXRlZCBQUElEXG4gICAgICAgICAgLy8gZnJhZ21lbnRhdGlvbi5cbiAgICAgICAgICBjYW5TZW5kTWF4TWVzc2FnZVNpemUgPSAxNjM4NDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBIb3dldmVyLCBvdGhlciBGRiAoYW5kIFJBV1JUQykgY2FuIHJlYXNzZW1ibGUgUFBJRC1mcmFnbWVudGVkXG4gICAgICAgICAgLy8gbWVzc2FnZXMuIFRodXMsIHN1cHBvcnRpbmcgfjIgR2lCIHdoZW4gc2VuZGluZy5cbiAgICAgICAgICBjYW5TZW5kTWF4TWVzc2FnZVNpemUgPSAyMTQ3NDgzNjM3O1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA2MCkge1xuICAgICAgICAvLyBDdXJyZW50bHksIGFsbCBGRiA+PSA1NyB3aWxsIHJlc2V0IHRoZSByZW1vdGUgbWF4aW11bSBtZXNzYWdlIHNpemVcbiAgICAgICAgLy8gdG8gdGhlIGRlZmF1bHQgdmFsdWUgd2hlbiBhIGRhdGEgY2hhbm5lbCBpcyBjcmVhdGVkIGF0IGEgbGF0ZXJcbiAgICAgICAgLy8gc3RhZ2UuIDooXG4gICAgICAgIC8vIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTQyNjgzMVxuICAgICAgICBjYW5TZW5kTWF4TWVzc2FnZVNpemUgPVxuICAgICAgICAgIGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPT09IDU3ID8gNjU1MzUgOiA2NTUzNjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZGID49IDYwIHN1cHBvcnRzIHNlbmRpbmcgfjIgR2lCXG4gICAgICAgIGNhblNlbmRNYXhNZXNzYWdlU2l6ZSA9IDIxNDc0ODM2Mzc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjYW5TZW5kTWF4TWVzc2FnZVNpemU7XG4gIH07XG5cbiAgY29uc3QgZ2V0TWF4TWVzc2FnZVNpemUgPSBmdW5jdGlvbihkZXNjcmlwdGlvbiwgcmVtb3RlSXNGaXJlZm94KSB7XG4gICAgLy8gTm90ZTogNjU1MzYgYnl0ZXMgaXMgdGhlIGRlZmF1bHQgdmFsdWUgZnJvbSB0aGUgU0RQIHNwZWMuIEFsc28sXG4gICAgLy8gICAgICAgZXZlcnkgaW1wbGVtZW50YXRpb24gd2Uga25vdyBzdXBwb3J0cyByZWNlaXZpbmcgNjU1MzYgYnl0ZXMuXG4gICAgbGV0IG1heE1lc3NhZ2VTaXplID0gNjU1MzY7XG5cbiAgICAvLyBGRiA1NyBoYXMgYSBzbGlnaHRseSBpbmNvcnJlY3QgZGVmYXVsdCByZW1vdGUgbWF4IG1lc3NhZ2Ugc2l6ZSwgc29cbiAgICAvLyB3ZSBuZWVkIHRvIGFkanVzdCBpdCBoZXJlIHRvIGF2b2lkIGEgZmFpbHVyZSB3aGVuIHNlbmRpbmcuXG4gICAgLy8gU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xNDI1Njk3XG4gICAgaWYgKGJyb3dzZXJEZXRhaWxzLmJyb3dzZXIgPT09ICdmaXJlZm94J1xuICAgICAgICAgJiYgYnJvd3NlckRldGFpbHMudmVyc2lvbiA9PT0gNTcpIHtcbiAgICAgIG1heE1lc3NhZ2VTaXplID0gNjU1MzU7XG4gICAgfVxuXG4gICAgY29uc3QgbWF0Y2ggPSBTRFBVdGlscy5tYXRjaFByZWZpeChkZXNjcmlwdGlvbi5zZHAsXG4gICAgICAnYT1tYXgtbWVzc2FnZS1zaXplOicpO1xuICAgIGlmIChtYXRjaC5sZW5ndGggPiAwKSB7XG4gICAgICBtYXhNZXNzYWdlU2l6ZSA9IHBhcnNlSW50KG1hdGNoWzBdLnN1YnN0cmluZygxOSksIDEwKTtcbiAgICB9IGVsc2UgaWYgKGJyb3dzZXJEZXRhaWxzLmJyb3dzZXIgPT09ICdmaXJlZm94JyAmJlxuICAgICAgICAgICAgICAgIHJlbW90ZUlzRmlyZWZveCAhPT0gLTEpIHtcbiAgICAgIC8vIElmIHRoZSBtYXhpbXVtIG1lc3NhZ2Ugc2l6ZSBpcyBub3QgcHJlc2VudCBpbiB0aGUgcmVtb3RlIFNEUCBhbmRcbiAgICAgIC8vIGJvdGggbG9jYWwgYW5kIHJlbW90ZSBhcmUgRmlyZWZveCwgdGhlIHJlbW90ZSBwZWVyIGNhbiByZWNlaXZlXG4gICAgICAvLyB+MiBHaUIuXG4gICAgICBtYXhNZXNzYWdlU2l6ZSA9IDIxNDc0ODM2Mzc7XG4gICAgfVxuICAgIHJldHVybiBtYXhNZXNzYWdlU2l6ZTtcbiAgfTtcblxuICBjb25zdCBvcmlnU2V0UmVtb3RlRGVzY3JpcHRpb24gPVxuICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbjtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbiA9XG4gICAgZnVuY3Rpb24gc2V0UmVtb3RlRGVzY3JpcHRpb24oKSB7XG4gICAgICB0aGlzLl9zY3RwID0gbnVsbDtcbiAgICAgIC8vIENocm9tZSBkZWNpZGVkIHRvIG5vdCBleHBvc2UgLnNjdHAgaW4gcGxhbi1iIG1vZGUuXG4gICAgICAvLyBBcyB1c3VhbCwgYWRhcHRlci5qcyBoYXMgdG8gZG8gYW4gJ3VnbHkgd29yYWthcm91bmQnXG4gICAgICAvLyB0byBjb3ZlciB1cCB0aGUgbWVzcy5cbiAgICAgIGlmIChicm93c2VyRGV0YWlscy5icm93c2VyID09PSAnY2hyb21lJyAmJiBicm93c2VyRGV0YWlscy52ZXJzaW9uID49IDc2KSB7XG4gICAgICAgIGNvbnN0IHtzZHBTZW1hbnRpY3N9ID0gdGhpcy5nZXRDb25maWd1cmF0aW9uKCk7XG4gICAgICAgIGlmIChzZHBTZW1hbnRpY3MgPT09ICdwbGFuLWInKSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzY3RwJywge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMuX3NjdHAgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHRoaXMuX3NjdHA7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2N0cEluRGVzY3JpcHRpb24oYXJndW1lbnRzWzBdKSkge1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgcmVtb3RlIGlzIEZGLlxuICAgICAgICBjb25zdCBpc0ZpcmVmb3ggPSBnZXRSZW1vdGVGaXJlZm94VmVyc2lvbihhcmd1bWVudHNbMF0pO1xuXG4gICAgICAgIC8vIEdldCB0aGUgbWF4aW11bSBtZXNzYWdlIHNpemUgdGhlIGxvY2FsIHBlZXIgaXMgY2FwYWJsZSBvZiBzZW5kaW5nXG4gICAgICAgIGNvbnN0IGNhblNlbmRNTVMgPSBnZXRDYW5TZW5kTWF4TWVzc2FnZVNpemUoaXNGaXJlZm94KTtcblxuICAgICAgICAvLyBHZXQgdGhlIG1heGltdW0gbWVzc2FnZSBzaXplIG9mIHRoZSByZW1vdGUgcGVlci5cbiAgICAgICAgY29uc3QgcmVtb3RlTU1TID0gZ2V0TWF4TWVzc2FnZVNpemUoYXJndW1lbnRzWzBdLCBpc0ZpcmVmb3gpO1xuXG4gICAgICAgIC8vIERldGVybWluZSBmaW5hbCBtYXhpbXVtIG1lc3NhZ2Ugc2l6ZVxuICAgICAgICBsZXQgbWF4TWVzc2FnZVNpemU7XG4gICAgICAgIGlmIChjYW5TZW5kTU1TID09PSAwICYmIHJlbW90ZU1NUyA9PT0gMCkge1xuICAgICAgICAgIG1heE1lc3NhZ2VTaXplID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgICB9IGVsc2UgaWYgKGNhblNlbmRNTVMgPT09IDAgfHwgcmVtb3RlTU1TID09PSAwKSB7XG4gICAgICAgICAgbWF4TWVzc2FnZVNpemUgPSBNYXRoLm1heChjYW5TZW5kTU1TLCByZW1vdGVNTVMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1heE1lc3NhZ2VTaXplID0gTWF0aC5taW4oY2FuU2VuZE1NUywgcmVtb3RlTU1TKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWF0ZSBhIGR1bW15IFJUQ1NjdHBUcmFuc3BvcnQgb2JqZWN0IGFuZCB0aGUgJ21heE1lc3NhZ2VTaXplJ1xuICAgICAgICAvLyBhdHRyaWJ1dGUuXG4gICAgICAgIGNvbnN0IHNjdHAgPSB7fTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNjdHAsICdtYXhNZXNzYWdlU2l6ZScsIHtcbiAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF4TWVzc2FnZVNpemU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fc2N0cCA9IHNjdHA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvcmlnU2V0UmVtb3RlRGVzY3JpcHRpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hpbVNlbmRUaHJvd1R5cGVFcnJvcih3aW5kb3cpIHtcbiAgaWYgKCEod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmXG4gICAgICAnY3JlYXRlRGF0YUNoYW5uZWwnIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gTm90ZTogQWx0aG91Z2ggRmlyZWZveCA+PSA1NyBoYXMgYSBuYXRpdmUgaW1wbGVtZW50YXRpb24sIHRoZSBtYXhpbXVtXG4gIC8vICAgICAgIG1lc3NhZ2Ugc2l6ZSBjYW4gYmUgcmVzZXQgZm9yIGFsbCBkYXRhIGNoYW5uZWxzIGF0IGEgbGF0ZXIgc3RhZ2UuXG4gIC8vICAgICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTQyNjgzMVxuXG4gIGZ1bmN0aW9uIHdyYXBEY1NlbmQoZGMsIHBjKSB7XG4gICAgY29uc3Qgb3JpZ0RhdGFDaGFubmVsU2VuZCA9IGRjLnNlbmQ7XG4gICAgZGMuc2VuZCA9IGZ1bmN0aW9uIHNlbmQoKSB7XG4gICAgICBjb25zdCBkYXRhID0gYXJndW1lbnRzWzBdO1xuICAgICAgY29uc3QgbGVuZ3RoID0gZGF0YS5sZW5ndGggfHwgZGF0YS5zaXplIHx8IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgIGlmIChkYy5yZWFkeVN0YXRlID09PSAnb3BlbicgJiZcbiAgICAgICAgICBwYy5zY3RwICYmIGxlbmd0aCA+IHBjLnNjdHAubWF4TWVzc2FnZVNpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTWVzc2FnZSB0b28gbGFyZ2UgKGNhbiBzZW5kIGEgbWF4aW11bSBvZiAnICtcbiAgICAgICAgICBwYy5zY3RwLm1heE1lc3NhZ2VTaXplICsgJyBieXRlcyknKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcmlnRGF0YUNoYW5uZWxTZW5kLmFwcGx5KGRjLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cbiAgY29uc3Qgb3JpZ0NyZWF0ZURhdGFDaGFubmVsID1cbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZURhdGFDaGFubmVsO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZURhdGFDaGFubmVsID1cbiAgICBmdW5jdGlvbiBjcmVhdGVEYXRhQ2hhbm5lbCgpIHtcbiAgICAgIGNvbnN0IGRhdGFDaGFubmVsID0gb3JpZ0NyZWF0ZURhdGFDaGFubmVsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB3cmFwRGNTZW5kKGRhdGFDaGFubmVsLCB0aGlzKTtcbiAgICAgIHJldHVybiBkYXRhQ2hhbm5lbDtcbiAgICB9O1xuICB1dGlscy53cmFwUGVlckNvbm5lY3Rpb25FdmVudCh3aW5kb3csICdkYXRhY2hhbm5lbCcsIGUgPT4ge1xuICAgIHdyYXBEY1NlbmQoZS5jaGFubmVsLCBlLnRhcmdldCk7XG4gICAgcmV0dXJuIGU7XG4gIH0pO1xufVxuXG5cbi8qIHNoaW1zIFJUQ0Nvbm5lY3Rpb25TdGF0ZSBieSBwcmV0ZW5kaW5nIGl0IGlzIHRoZSBzYW1lIGFzIGljZUNvbm5lY3Rpb25TdGF0ZS5cbiAqIFNlZSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3Avd2VicnRjL2lzc3Vlcy9kZXRhaWw/aWQ9NjE0NSNjMTJcbiAqIGZvciB3aHkgdGhpcyBpcyBhIHZhbGlkIGhhY2sgaW4gQ2hyb21lLiBJbiBGaXJlZm94IGl0IGlzIHNsaWdodGx5IGluY29ycmVjdFxuICogc2luY2UgRFRMUyBmYWlsdXJlcyB3b3VsZCBiZSBoaWRkZW4uIFNlZVxuICogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTI2NTgyN1xuICogZm9yIHRoZSBGaXJlZm94IHRyYWNraW5nIGJ1Zy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNoaW1Db25uZWN0aW9uU3RhdGUod2luZG93KSB7XG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uIHx8XG4gICAgICAnY29ubmVjdGlvblN0YXRlJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHByb3RvID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCAnY29ubmVjdGlvblN0YXRlJywge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbXBsZXRlZDogJ2Nvbm5lY3RlZCcsXG4gICAgICAgIGNoZWNraW5nOiAnY29ubmVjdGluZydcbiAgICAgIH1bdGhpcy5pY2VDb25uZWN0aW9uU3RhdGVdIHx8IHRoaXMuaWNlQ29ubmVjdGlvblN0YXRlO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgJ29uY29ubmVjdGlvbnN0YXRlY2hhbmdlJywge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSB8fCBudWxsO1xuICAgIH0sXG4gICAgc2V0KGNiKSB7XG4gICAgICBpZiAodGhpcy5fb25jb25uZWN0aW9uc3RhdGVjaGFuZ2UpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLFxuICAgICAgICAgIHRoaXMuX29uY29ubmVjdGlvbnN0YXRlY2hhbmdlKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX29uY29ubmVjdGlvbnN0YXRlY2hhbmdlO1xuICAgICAgfVxuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignY29ubmVjdGlvbnN0YXRlY2hhbmdlJyxcbiAgICAgICAgICB0aGlzLl9vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IGNiKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuXG4gIFsnc2V0TG9jYWxEZXNjcmlwdGlvbicsICdzZXRSZW1vdGVEZXNjcmlwdGlvbiddLmZvckVhY2goKG1ldGhvZCkgPT4ge1xuICAgIGNvbnN0IG9yaWdNZXRob2QgPSBwcm90b1ttZXRob2RdO1xuICAgIHByb3RvW21ldGhvZF0gPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5fY29ubmVjdGlvbnN0YXRlY2hhbmdlcG9seSkge1xuICAgICAgICB0aGlzLl9jb25uZWN0aW9uc3RhdGVjaGFuZ2Vwb2x5ID0gZSA9PiB7XG4gICAgICAgICAgY29uc3QgcGMgPSBlLnRhcmdldDtcbiAgICAgICAgICBpZiAocGMuX2xhc3RDb25uZWN0aW9uU3RhdGUgIT09IHBjLmNvbm5lY3Rpb25TdGF0ZSkge1xuICAgICAgICAgICAgcGMuX2xhc3RDb25uZWN0aW9uU3RhdGUgPSBwYy5jb25uZWN0aW9uU3RhdGU7XG4gICAgICAgICAgICBjb25zdCBuZXdFdmVudCA9IG5ldyBFdmVudCgnY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgZSk7XG4gICAgICAgICAgICBwYy5kaXNwYXRjaEV2ZW50KG5ld0V2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlJyxcbiAgICAgICAgICB0aGlzLl9jb25uZWN0aW9uc3RhdGVjaGFuZ2Vwb2x5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcmlnTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVFeHRtYXBBbGxvd01peGVkKHdpbmRvdywgYnJvd3NlckRldGFpbHMpIHtcbiAgLyogcmVtb3ZlIGE9ZXh0bWFwLWFsbG93LW1peGVkIGZvciB3ZWJydGMub3JnIDwgTTcxICovXG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChicm93c2VyRGV0YWlscy5icm93c2VyID09PSAnY2hyb21lJyAmJiBicm93c2VyRGV0YWlscy52ZXJzaW9uID49IDcxKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChicm93c2VyRGV0YWlscy5icm93c2VyID09PSAnc2FmYXJpJyAmJiBicm93c2VyRGV0YWlscy52ZXJzaW9uID49IDYwNSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBuYXRpdmVTUkQgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uID1cbiAgZnVuY3Rpb24gc2V0UmVtb3RlRGVzY3JpcHRpb24oZGVzYykge1xuICAgIGlmIChkZXNjICYmIGRlc2Muc2RwICYmIGRlc2Muc2RwLmluZGV4T2YoJ1xcbmE9ZXh0bWFwLWFsbG93LW1peGVkJykgIT09IC0xKSB7XG4gICAgICBjb25zdCBzZHAgPSBkZXNjLnNkcC5zcGxpdCgnXFxuJykuZmlsdGVyKChsaW5lKSA9PiB7XG4gICAgICAgIHJldHVybiBsaW5lLnRyaW0oKSAhPT0gJ2E9ZXh0bWFwLWFsbG93LW1peGVkJztcbiAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgLy8gU2FmYXJpIGVuZm9yY2VzIHJlYWQtb25seS1uZXNzIG9mIFJUQ1Nlc3Npb25EZXNjcmlwdGlvbiBmaWVsZHMuXG4gICAgICBpZiAod2luZG93LlJUQ1Nlc3Npb25EZXNjcmlwdGlvbiAmJlxuICAgICAgICAgIGRlc2MgaW5zdGFuY2VvZiB3aW5kb3cuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKSB7XG4gICAgICAgIGFyZ3VtZW50c1swXSA9IG5ldyB3aW5kb3cuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKHtcbiAgICAgICAgICB0eXBlOiBkZXNjLnR5cGUsXG4gICAgICAgICAgc2RwLFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlc2Muc2RwID0gc2RwO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmF0aXZlU1JELmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGltQWRkSWNlQ2FuZGlkYXRlTnVsbE9yRW1wdHkod2luZG93LCBicm93c2VyRGV0YWlscykge1xuICAvLyBTdXBwb3J0IGZvciBhZGRJY2VDYW5kaWRhdGUobnVsbCBvciB1bmRlZmluZWQpXG4gIC8vIGFzIHdlbGwgYXMgYWRkSWNlQ2FuZGlkYXRlKHtjYW5kaWRhdGU6IFwiXCIsIC4uLn0pXG4gIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTk3ODU4MlxuICAvLyBOb3RlOiBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgb3RoZXIgcG9seWZpbGxzIHdoaWNoIGNoYW5nZSB0aGUgc2lnbmF0dXJlLlxuICBpZiAoISh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgbmF0aXZlQWRkSWNlQ2FuZGlkYXRlID1cbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkSWNlQ2FuZGlkYXRlO1xuICBpZiAoIW5hdGl2ZUFkZEljZUNhbmRpZGF0ZSB8fCBuYXRpdmVBZGRJY2VDYW5kaWRhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkSWNlQ2FuZGlkYXRlID1cbiAgICBmdW5jdGlvbiBhZGRJY2VDYW5kaWRhdGUoKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50c1swXSkge1xuICAgICAgICBpZiAoYXJndW1lbnRzWzFdKSB7XG4gICAgICAgICAgYXJndW1lbnRzWzFdLmFwcGx5KG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIH1cbiAgICAgIC8vIEZpcmVmb3ggNjgrIGVtaXRzIGFuZCBwcm9jZXNzZXMge2NhbmRpZGF0ZTogXCJcIiwgLi4ufSwgaWdub3JlXG4gICAgICAvLyBpbiBvbGRlciB2ZXJzaW9ucy5cbiAgICAgIC8vIE5hdGl2ZSBzdXBwb3J0IGZvciBpZ25vcmluZyBleGlzdHMgZm9yIENocm9tZSBNNzcrLlxuICAgICAgLy8gU2FmYXJpIGlnbm9yZXMgYXMgd2VsbCwgZXhhY3QgdmVyc2lvbiB1bmtub3duIGJ1dCB3b3JrcyBpbiB0aGUgc2FtZVxuICAgICAgLy8gdmVyc2lvbiB0aGF0IGFsc28gaWdub3JlcyBhZGRJY2VDYW5kaWRhdGUobnVsbCkuXG4gICAgICBpZiAoKChicm93c2VyRGV0YWlscy5icm93c2VyID09PSAnY2hyb21lJyAmJiBicm93c2VyRGV0YWlscy52ZXJzaW9uIDwgNzgpXG4gICAgICAgICAgIHx8IChicm93c2VyRGV0YWlscy5icm93c2VyID09PSAnZmlyZWZveCdcbiAgICAgICAgICAgICAgICYmIGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA2OClcbiAgICAgICAgICAgfHwgKGJyb3dzZXJEZXRhaWxzLmJyb3dzZXIgPT09ICdzYWZhcmknKSlcbiAgICAgICAgICAmJiBhcmd1bWVudHNbMF0gJiYgYXJndW1lbnRzWzBdLmNhbmRpZGF0ZSA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5hdGl2ZUFkZEljZUNhbmRpZGF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG59XG5cbi8vIE5vdGU6IE1ha2Ugc3VyZSB0byBjYWxsIHRoaXMgYWhlYWQgb2YgQVBJcyB0aGF0IG1vZGlmeVxuLy8gc2V0TG9jYWxEZXNjcmlwdGlvbi5sZW5ndGhcbmV4cG9ydCBmdW5jdGlvbiBzaGltUGFyYW1ldGVybGVzc1NldExvY2FsRGVzY3JpcHRpb24od2luZG93LCBicm93c2VyRGV0YWlscykge1xuICBpZiAoISh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgbmF0aXZlU2V0TG9jYWxEZXNjcmlwdGlvbiA9XG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldExvY2FsRGVzY3JpcHRpb247XG4gIGlmICghbmF0aXZlU2V0TG9jYWxEZXNjcmlwdGlvbiB8fCBuYXRpdmVTZXRMb2NhbERlc2NyaXB0aW9uLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldExvY2FsRGVzY3JpcHRpb24gPVxuICAgIGZ1bmN0aW9uIHNldExvY2FsRGVzY3JpcHRpb24oKSB7XG4gICAgICBsZXQgZGVzYyA9IGFyZ3VtZW50c1swXSB8fCB7fTtcbiAgICAgIGlmICh0eXBlb2YgZGVzYyAhPT0gJ29iamVjdCcgfHwgKGRlc2MudHlwZSAmJiBkZXNjLnNkcCkpIHtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZVNldExvY2FsRGVzY3JpcHRpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIC8vIFRoZSByZW1haW5pbmcgc3RlcHMgc2hvdWxkIHRlY2huaWNhbGx5IGhhcHBlbiB3aGVuIFNMRCBjb21lcyBvZmYgdGhlXG4gICAgICAvLyBSVENQZWVyQ29ubmVjdGlvbidzIG9wZXJhdGlvbnMgY2hhaW4gKG5vdCBhaGVhZCBvZiBnb2luZyBvbiBpdCksIGJ1dFxuICAgICAgLy8gdGhpcyBpcyB0b28gZGlmZmljdWx0IHRvIHNoaW0uIEluc3RlYWQsIHRoaXMgc2hpbSBvbmx5IGNvdmVycyB0aGVcbiAgICAgIC8vIGNvbW1vbiBjYXNlIHdoZXJlIHRoZSBvcGVyYXRpb25zIGNoYWluIGlzIGVtcHR5LiBUaGlzIGlzIGltcGVyZmVjdCwgYnV0XG4gICAgICAvLyBzaG91bGQgY292ZXIgbWFueSBjYXNlcy4gUmF0aW9uYWxlOiBFdmVuIGlmIHdlIGNhbid0IHJlZHVjZSB0aGUgZ2xhcmVcbiAgICAgIC8vIHdpbmRvdyB0byB6ZXJvIG9uIGltcGVyZmVjdCBpbXBsZW1lbnRhdGlvbnMsIHRoZXJlJ3MgdmFsdWUgaW4gdGFwcGluZ1xuICAgICAgLy8gaW50byB0aGUgcGVyZmVjdCBuZWdvdGlhdGlvbiBwYXR0ZXJuIHRoYXQgc2V2ZXJhbCBicm93c2VycyBzdXBwb3J0LlxuICAgICAgZGVzYyA9IHt0eXBlOiBkZXNjLnR5cGUsIHNkcDogZGVzYy5zZHB9O1xuICAgICAgaWYgKCFkZXNjLnR5cGUpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnNpZ25hbGluZ1N0YXRlKSB7XG4gICAgICAgICAgY2FzZSAnc3RhYmxlJzpcbiAgICAgICAgICBjYXNlICdoYXZlLWxvY2FsLW9mZmVyJzpcbiAgICAgICAgICBjYXNlICdoYXZlLXJlbW90ZS1wcmFuc3dlcic6XG4gICAgICAgICAgICBkZXNjLnR5cGUgPSAnb2ZmZXInO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGRlc2MudHlwZSA9ICdhbnN3ZXInO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChkZXNjLnNkcCB8fCAoZGVzYy50eXBlICE9PSAnb2ZmZXInICYmIGRlc2MudHlwZSAhPT0gJ2Fuc3dlcicpKSB7XG4gICAgICAgIHJldHVybiBuYXRpdmVTZXRMb2NhbERlc2NyaXB0aW9uLmFwcGx5KHRoaXMsIFtkZXNjXSk7XG4gICAgICB9XG4gICAgICBjb25zdCBmdW5jID0gZGVzYy50eXBlID09PSAnb2ZmZXInID8gdGhpcy5jcmVhdGVPZmZlciA6IHRoaXMuY3JlYXRlQW5zd2VyO1xuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcylcbiAgICAgICAgLnRoZW4oZCA9PiBuYXRpdmVTZXRMb2NhbERlc2NyaXB0aW9uLmFwcGx5KHRoaXMsIFtkXSkpO1xuICAgIH07XG59XG4iLCIvKlxuICogIENvcHlyaWdodCAoYykgMjAxNiBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4vdXRpbHMnO1xuXG4vLyBCcm93c2VyIHNoaW1zLlxuaW1wb3J0ICogYXMgY2hyb21lU2hpbSBmcm9tICcuL2Nocm9tZS9jaHJvbWVfc2hpbSc7XG5pbXBvcnQgKiBhcyBmaXJlZm94U2hpbSBmcm9tICcuL2ZpcmVmb3gvZmlyZWZveF9zaGltJztcbmltcG9ydCAqIGFzIHNhZmFyaVNoaW0gZnJvbSAnLi9zYWZhcmkvc2FmYXJpX3NoaW0nO1xuaW1wb3J0ICogYXMgY29tbW9uU2hpbSBmcm9tICcuL2NvbW1vbl9zaGltJztcbmltcG9ydCAqIGFzIHNkcCBmcm9tICdzZHAnO1xuXG4vLyBTaGltbWluZyBzdGFydHMgaGVyZS5cbmV4cG9ydCBmdW5jdGlvbiBhZGFwdGVyRmFjdG9yeSh7d2luZG93fSA9IHt9LCBvcHRpb25zID0ge1xuICBzaGltQ2hyb21lOiB0cnVlLFxuICBzaGltRmlyZWZveDogdHJ1ZSxcbiAgc2hpbVNhZmFyaTogdHJ1ZSxcbn0pIHtcbiAgLy8gVXRpbHMuXG4gIGNvbnN0IGxvZ2dpbmcgPSB1dGlscy5sb2c7XG4gIGNvbnN0IGJyb3dzZXJEZXRhaWxzID0gdXRpbHMuZGV0ZWN0QnJvd3Nlcih3aW5kb3cpO1xuXG4gIGNvbnN0IGFkYXB0ZXIgPSB7XG4gICAgYnJvd3NlckRldGFpbHMsXG4gICAgY29tbW9uU2hpbSxcbiAgICBleHRyYWN0VmVyc2lvbjogdXRpbHMuZXh0cmFjdFZlcnNpb24sXG4gICAgZGlzYWJsZUxvZzogdXRpbHMuZGlzYWJsZUxvZyxcbiAgICBkaXNhYmxlV2FybmluZ3M6IHV0aWxzLmRpc2FibGVXYXJuaW5ncyxcbiAgICAvLyBFeHBvc2Ugc2RwIGFzIGEgY29udmVuaWVuY2UuIEZvciBwcm9kdWN0aW9uIGFwcHMgaW5jbHVkZSBkaXJlY3RseS5cbiAgICBzZHAsXG4gIH07XG5cbiAgLy8gU2hpbSBicm93c2VyIGlmIGZvdW5kLlxuICBzd2l0Y2ggKGJyb3dzZXJEZXRhaWxzLmJyb3dzZXIpIHtcbiAgICBjYXNlICdjaHJvbWUnOlxuICAgICAgaWYgKCFjaHJvbWVTaGltIHx8ICFjaHJvbWVTaGltLnNoaW1QZWVyQ29ubmVjdGlvbiB8fFxuICAgICAgICAgICFvcHRpb25zLnNoaW1DaHJvbWUpIHtcbiAgICAgICAgbG9nZ2luZygnQ2hyb21lIHNoaW0gaXMgbm90IGluY2x1ZGVkIGluIHRoaXMgYWRhcHRlciByZWxlYXNlLicpO1xuICAgICAgICByZXR1cm4gYWRhcHRlcjtcbiAgICAgIH1cbiAgICAgIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uID09PSBudWxsKSB7XG4gICAgICAgIGxvZ2dpbmcoJ0Nocm9tZSBzaGltIGNhbiBub3QgZGV0ZXJtaW5lIHZlcnNpb24sIG5vdCBzaGltbWluZy4nKTtcbiAgICAgICAgcmV0dXJuIGFkYXB0ZXI7XG4gICAgICB9XG4gICAgICBsb2dnaW5nKCdhZGFwdGVyLmpzIHNoaW1taW5nIGNocm9tZS4nKTtcbiAgICAgIC8vIEV4cG9ydCB0byB0aGUgYWRhcHRlciBnbG9iYWwgb2JqZWN0IHZpc2libGUgaW4gdGhlIGJyb3dzZXIuXG4gICAgICBhZGFwdGVyLmJyb3dzZXJTaGltID0gY2hyb21lU2hpbTtcblxuICAgICAgLy8gTXVzdCBiZSBjYWxsZWQgYmVmb3JlIHNoaW1QZWVyQ29ubmVjdGlvbi5cbiAgICAgIGNvbW1vblNoaW0uc2hpbUFkZEljZUNhbmRpZGF0ZU51bGxPckVtcHR5KHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgY29tbW9uU2hpbS5zaGltUGFyYW1ldGVybGVzc1NldExvY2FsRGVzY3JpcHRpb24od2luZG93LCBicm93c2VyRGV0YWlscyk7XG5cbiAgICAgIGNocm9tZVNoaW0uc2hpbUdldFVzZXJNZWRpYSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGNocm9tZVNoaW0uc2hpbU1lZGlhU3RyZWFtKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgY2hyb21lU2hpbS5zaGltUGVlckNvbm5lY3Rpb24od2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBjaHJvbWVTaGltLnNoaW1PblRyYWNrKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgY2hyb21lU2hpbS5zaGltQWRkVHJhY2tSZW1vdmVUcmFjayh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGNocm9tZVNoaW0uc2hpbUdldFNlbmRlcnNXaXRoRHRtZih3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGNocm9tZVNoaW0uc2hpbUdldFN0YXRzKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgY2hyb21lU2hpbS5zaGltU2VuZGVyUmVjZWl2ZXJHZXRTdGF0cyh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGNocm9tZVNoaW0uZml4TmVnb3RpYXRpb25OZWVkZWQod2luZG93LCBicm93c2VyRGV0YWlscyk7XG5cbiAgICAgIGNvbW1vblNoaW0uc2hpbVJUQ0ljZUNhbmRpZGF0ZSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGNvbW1vblNoaW0uc2hpbVJUQ0ljZUNhbmRpZGF0ZVJlbGF5UHJvdG9jb2wod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBjb21tb25TaGltLnNoaW1Db25uZWN0aW9uU3RhdGUod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBjb21tb25TaGltLnNoaW1NYXhNZXNzYWdlU2l6ZSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGNvbW1vblNoaW0uc2hpbVNlbmRUaHJvd1R5cGVFcnJvcih3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGNvbW1vblNoaW0ucmVtb3ZlRXh0bWFwQWxsb3dNaXhlZCh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2ZpcmVmb3gnOlxuICAgICAgaWYgKCFmaXJlZm94U2hpbSB8fCAhZmlyZWZveFNoaW0uc2hpbVBlZXJDb25uZWN0aW9uIHx8XG4gICAgICAgICAgIW9wdGlvbnMuc2hpbUZpcmVmb3gpIHtcbiAgICAgICAgbG9nZ2luZygnRmlyZWZveCBzaGltIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGlzIGFkYXB0ZXIgcmVsZWFzZS4nKTtcbiAgICAgICAgcmV0dXJuIGFkYXB0ZXI7XG4gICAgICB9XG4gICAgICBsb2dnaW5nKCdhZGFwdGVyLmpzIHNoaW1taW5nIGZpcmVmb3guJyk7XG4gICAgICAvLyBFeHBvcnQgdG8gdGhlIGFkYXB0ZXIgZ2xvYmFsIG9iamVjdCB2aXNpYmxlIGluIHRoZSBicm93c2VyLlxuICAgICAgYWRhcHRlci5icm93c2VyU2hpbSA9IGZpcmVmb3hTaGltO1xuXG4gICAgICAvLyBNdXN0IGJlIGNhbGxlZCBiZWZvcmUgc2hpbVBlZXJDb25uZWN0aW9uLlxuICAgICAgY29tbW9uU2hpbS5zaGltQWRkSWNlQ2FuZGlkYXRlTnVsbE9yRW1wdHkod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBjb21tb25TaGltLnNoaW1QYXJhbWV0ZXJsZXNzU2V0TG9jYWxEZXNjcmlwdGlvbih3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcblxuICAgICAgZmlyZWZveFNoaW0uc2hpbUdldFVzZXJNZWRpYSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGZpcmVmb3hTaGltLnNoaW1QZWVyQ29ubmVjdGlvbih3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGZpcmVmb3hTaGltLnNoaW1PblRyYWNrKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgZmlyZWZveFNoaW0uc2hpbVJlbW92ZVN0cmVhbSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGZpcmVmb3hTaGltLnNoaW1TZW5kZXJHZXRTdGF0cyh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGZpcmVmb3hTaGltLnNoaW1SZWNlaXZlckdldFN0YXRzKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgZmlyZWZveFNoaW0uc2hpbVJUQ0RhdGFDaGFubmVsKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgZmlyZWZveFNoaW0uc2hpbUFkZFRyYW5zY2VpdmVyKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgZmlyZWZveFNoaW0uc2hpbUdldFBhcmFtZXRlcnMod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBmaXJlZm94U2hpbS5zaGltQ3JlYXRlT2ZmZXIod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBmaXJlZm94U2hpbS5zaGltQ3JlYXRlQW5zd2VyKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuXG4gICAgICBjb21tb25TaGltLnNoaW1SVENJY2VDYW5kaWRhdGUod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBjb21tb25TaGltLnNoaW1Db25uZWN0aW9uU3RhdGUod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBjb21tb25TaGltLnNoaW1NYXhNZXNzYWdlU2l6ZSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGNvbW1vblNoaW0uc2hpbVNlbmRUaHJvd1R5cGVFcnJvcih3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NhZmFyaSc6XG4gICAgICBpZiAoIXNhZmFyaVNoaW0gfHwgIW9wdGlvbnMuc2hpbVNhZmFyaSkge1xuICAgICAgICBsb2dnaW5nKCdTYWZhcmkgc2hpbSBpcyBub3QgaW5jbHVkZWQgaW4gdGhpcyBhZGFwdGVyIHJlbGVhc2UuJyk7XG4gICAgICAgIHJldHVybiBhZGFwdGVyO1xuICAgICAgfVxuICAgICAgbG9nZ2luZygnYWRhcHRlci5qcyBzaGltbWluZyBzYWZhcmkuJyk7XG4gICAgICAvLyBFeHBvcnQgdG8gdGhlIGFkYXB0ZXIgZ2xvYmFsIG9iamVjdCB2aXNpYmxlIGluIHRoZSBicm93c2VyLlxuICAgICAgYWRhcHRlci5icm93c2VyU2hpbSA9IHNhZmFyaVNoaW07XG5cbiAgICAgIC8vIE11c3QgYmUgY2FsbGVkIGJlZm9yZSBzaGltQ2FsbGJhY2tBUEkuXG4gICAgICBjb21tb25TaGltLnNoaW1BZGRJY2VDYW5kaWRhdGVOdWxsT3JFbXB0eSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGNvbW1vblNoaW0uc2hpbVBhcmFtZXRlcmxlc3NTZXRMb2NhbERlc2NyaXB0aW9uKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuXG4gICAgICBzYWZhcmlTaGltLnNoaW1SVENJY2VTZXJ2ZXJVcmxzKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgc2FmYXJpU2hpbS5zaGltQ3JlYXRlT2ZmZXJMZWdhY3kod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBzYWZhcmlTaGltLnNoaW1DYWxsYmFja3NBUEkod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBzYWZhcmlTaGltLnNoaW1Mb2NhbFN0cmVhbXNBUEkod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBzYWZhcmlTaGltLnNoaW1SZW1vdGVTdHJlYW1zQVBJKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgc2FmYXJpU2hpbS5zaGltVHJhY2tFdmVudFRyYW5zY2VpdmVyKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgc2FmYXJpU2hpbS5zaGltR2V0VXNlck1lZGlhKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgc2FmYXJpU2hpbS5zaGltQXVkaW9Db250ZXh0KHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuXG4gICAgICBjb21tb25TaGltLnNoaW1SVENJY2VDYW5kaWRhdGUod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBjb21tb25TaGltLnNoaW1SVENJY2VDYW5kaWRhdGVSZWxheVByb3RvY29sKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgY29tbW9uU2hpbS5zaGltTWF4TWVzc2FnZVNpemUod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBjb21tb25TaGltLnNoaW1TZW5kVGhyb3dUeXBlRXJyb3Iod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBjb21tb25TaGltLnJlbW92ZUV4dG1hcEFsbG93TWl4ZWQod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgbG9nZ2luZygnVW5zdXBwb3J0ZWQgYnJvd3NlciEnKTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIGFkYXB0ZXI7XG59XG4iLCIvKlxuICogIENvcHlyaWdodCAoYykgMjAxNiBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbi8qIGVzbGludC1lbnYgbm9kZSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7YWRhcHRlckZhY3Rvcnl9IGZyb20gJy4vYWRhcHRlcl9mYWN0b3J5LmpzJztcblxuY29uc3QgYWRhcHRlciA9XG4gIGFkYXB0ZXJGYWN0b3J5KHt3aW5kb3c6IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogd2luZG93fSk7XG5leHBvcnQgZGVmYXVsdCBhZGFwdGVyO1xuIiwiaW1wb3J0IHR5cGUgeyBLZXlQcm92aWRlck9wdGlvbnMgfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGNvbnN0IEVOQ1JZUFRJT05fQUxHT1JJVEhNID0gJ0FFUy1HQ00nO1xuXG4vLyBXZSB1c2UgYSByaW5nYnVmZmVyIG9mIGtleXMgc28gd2UgY2FuIGNoYW5nZSB0aGVtIGFuZCBzdGlsbCBkZWNvZGUgcGFja2V0cyB0aGF0IHdlcmVcbi8vIGVuY3J5cHRlZCB3aXRoIGFuIG9sZCBrZXkuIFdlIHVzZSBhIHNpemUgb2YgMTYgd2hpY2ggY29ycmVzcG9uZHMgdG8gdGhlIGZvdXIgYml0c1xuLy8gaW4gdGhlIGZyYW1lIHRyYWlsZXIuXG5leHBvcnQgY29uc3QgS0VZUklOR19TSVpFID0gMTY7XG5cbi8vIEhvdyBtYW55IGNvbnNlY3V0aXZlIGZyYW1lcyBjYW4gZmFpbCBkZWNyeXB0aW5nIGJlZm9yZSBhIHBhcnRpY3VsYXIga2V5IGdldHMgbWFya2VkIGFzIGludmFsaWRcbmV4cG9ydCBjb25zdCBERUNSWVBUSU9OX0ZBSUxVUkVfVE9MRVJBTkNFID0gMTA7XG5cbi8vIFdlIGNvcHkgdGhlIGZpcnN0IGJ5dGVzIG9mIHRoZSBWUDggcGF5bG9hZCB1bmVuY3J5cHRlZC5cbi8vIEZvciBrZXlmcmFtZXMgdGhpcyBpcyAxMCBieXRlcywgZm9yIG5vbi1rZXlmcmFtZXMgKGRlbHRhKSAzLiBTZWVcbi8vICAgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzYzODYjc2VjdGlvbi05LjFcbi8vIFRoaXMgYWxsb3dzIHRoZSBicmlkZ2UgdG8gY29udGludWUgZGV0ZWN0aW5nIGtleWZyYW1lcyAob25seSBvbmUgYnl0ZSBuZWVkZWQgaW4gdGhlIEpWQilcbi8vIGFuZCBpcyBhbHNvIGEgYml0IGVhc2llciBmb3IgdGhlIFZQOCBkZWNvZGVyIChpLmUuIGl0IGdlbmVyYXRlcyBmdW5ueSBnYXJiYWdlIHBpY3R1cmVzXG4vLyBpbnN0ZWFkIG9mIGJlaW5nIHVuYWJsZSB0byBkZWNvZGUpLlxuLy8gVGhpcyBpcyBhIGJpdCBmb3Igc2hvdyBhbmQgd2UgbWlnaHQgd2FudCB0byByZWR1Y2UgdG8gMSB1bmNvbmRpdGlvbmFsbHkgaW4gdGhlIGZpbmFsIHZlcnNpb24uXG4vL1xuLy8gRm9yIGF1ZGlvICh3aGVyZSBmcmFtZS50eXBlIGlzIG5vdCBzZXQpIHdlIGRvIG5vdCBlbmNyeXB0IHRoZSBvcHVzIFRPQyBieXRlOlxuLy8gICBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjcxNiNzZWN0aW9uLTMuMVxuZXhwb3J0IGNvbnN0IFVORU5DUllQVEVEX0JZVEVTID0ge1xuICBrZXk6IDEwLFxuICBkZWx0YTogMyxcbiAgYXVkaW86IDEsIC8vIGZyYW1lLnR5cGUgaXMgbm90IHNldCBvbiBhdWRpbywgc28gdGhpcyBpcyBzZXQgbWFudWFsbHlcbiAgZW1wdHk6IDAsXG59IGFzIGNvbnN0O1xuXG4vKiBXZSB1c2UgYSAxMiBieXRlIGJpdCBJVi4gVGhpcyBpcyBzaWduYWxsZWQgaW4gcGxhaW4gdG9nZXRoZXIgd2l0aCB0aGVcbiBwYWNrZXQuIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU3VidGxlQ3J5cHRvL2VuY3J5cHQjcGFyYW1ldGVycyAqL1xuZXhwb3J0IGNvbnN0IElWX0xFTkdUSCA9IDEyO1xuXG4vLyBmbGFnIHNldCB0byBpbmRpY2F0ZSB0aGF0IGUyZWUgaGFzIGJlZW4gc2V0dXAgZm9yIHNlbmRlci9yZWNlaXZlcjtcbmV4cG9ydCBjb25zdCBFMkVFX0ZMQUcgPSAnbGtfZTJlZSc7XG5cbmV4cG9ydCBjb25zdCBTQUxUID0gJ0xLRnJhbWVFbmNyeXB0aW9uS2V5JztcblxuZXhwb3J0IGNvbnN0IEtFWV9QUk9WSURFUl9ERUZBVUxUUzogS2V5UHJvdmlkZXJPcHRpb25zID0ge1xuICBzaGFyZWRLZXk6IGZhbHNlLFxuICByYXRjaGV0U2FsdDogU0FMVCxcbiAgcmF0Y2hldFdpbmRvd1NpemU6IDgsXG4gIGZhaWx1cmVUb2xlcmFuY2U6IERFQ1JZUFRJT05fRkFJTFVSRV9UT0xFUkFOQ0UsXG59IGFzIGNvbnN0O1xuXG5leHBvcnQgY29uc3QgTUFYX1NJRl9DT1VOVCA9IDEwMDtcbmV4cG9ydCBjb25zdCBNQVhfU0lGX0RVUkFUSU9OID0gMjAwMDtcbiIsImltcG9ydCB0eXBlIFBhcnRpY2lwYW50IGZyb20gJy4uL3Jvb20vcGFydGljaXBhbnQvUGFydGljaXBhbnQnO1xuaW1wb3J0IHR5cGUgeyBDcnlwdG9yRXJyb3IgfSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQgdHlwZSB7IEtleUluZm8gfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGVudW0gS2V5UHJvdmlkZXJFdmVudCB7XG4gIFNldEtleSA9ICdzZXRLZXknLFxuICBSYXRjaGV0UmVxdWVzdCA9ICdyYXRjaGV0UmVxdWVzdCcsXG4gIEtleVJhdGNoZXRlZCA9ICdrZXlSYXRjaGV0ZWQnLFxufVxuXG5leHBvcnQgdHlwZSBLZXlQcm92aWRlckNhbGxiYWNrcyA9IHtcbiAgW0tleVByb3ZpZGVyRXZlbnQuU2V0S2V5XTogKGtleUluZm86IEtleUluZm8pID0+IHZvaWQ7XG4gIFtLZXlQcm92aWRlckV2ZW50LlJhdGNoZXRSZXF1ZXN0XTogKHBhcnRpY2lwYW50SWRlbnRpdHk/OiBzdHJpbmcsIGtleUluZGV4PzogbnVtYmVyKSA9PiB2b2lkO1xuICBbS2V5UHJvdmlkZXJFdmVudC5LZXlSYXRjaGV0ZWRdOiAobWF0ZXJpYWw6IENyeXB0b0tleSwga2V5SW5kZXg/OiBudW1iZXIpID0+IHZvaWQ7XG59O1xuXG5leHBvcnQgZW51bSBLZXlIYW5kbGVyRXZlbnQge1xuICBLZXlSYXRjaGV0ZWQgPSAna2V5UmF0Y2hldGVkJyxcbn1cblxuZXhwb3J0IHR5cGUgUGFydGljaXBhbnRLZXlIYW5kbGVyQ2FsbGJhY2tzID0ge1xuICBbS2V5SGFuZGxlckV2ZW50LktleVJhdGNoZXRlZF06IChcbiAgICBtYXRlcmlhbDogQ3J5cHRvS2V5LFxuICAgIHBhcnRpY2lwYW50SWRlbnRpdHk6IHN0cmluZyxcbiAgICBrZXlJbmRleD86IG51bWJlcixcbiAgKSA9PiB2b2lkO1xufTtcblxuZXhwb3J0IGVudW0gRW5jcnlwdGlvbkV2ZW50IHtcbiAgUGFydGljaXBhbnRFbmNyeXB0aW9uU3RhdHVzQ2hhbmdlZCA9ICdwYXJ0aWNpcGFudEVuY3J5cHRpb25TdGF0dXNDaGFuZ2VkJyxcbiAgRW5jcnlwdGlvbkVycm9yID0gJ2VuY3J5cHRpb25FcnJvcicsXG59XG5cbmV4cG9ydCB0eXBlIEUyRUVNYW5hZ2VyQ2FsbGJhY2tzID0ge1xuICBbRW5jcnlwdGlvbkV2ZW50LlBhcnRpY2lwYW50RW5jcnlwdGlvblN0YXR1c0NoYW5nZWRdOiAoXG4gICAgZW5hYmxlZDogYm9vbGVhbixcbiAgICBwYXJ0aWNpcGFudDogUGFydGljaXBhbnQsXG4gICkgPT4gdm9pZDtcbiAgW0VuY3J5cHRpb25FdmVudC5FbmNyeXB0aW9uRXJyb3JdOiAoZXJyb3I6IEVycm9yKSA9PiB2b2lkO1xufTtcblxuZXhwb3J0IHR5cGUgQ3J5cHRvckNhbGxiYWNrcyA9IHtcbiAgW0NyeXB0b3JFdmVudC5FcnJvcl06IChlcnJvcjogQ3J5cHRvckVycm9yKSA9PiB2b2lkO1xufTtcblxuZXhwb3J0IGVudW0gQ3J5cHRvckV2ZW50IHtcbiAgRXJyb3IgPSAnY3J5cHRvckVycm9yJyxcbn1cbiIsImltcG9ydCB7IEVOQ1JZUFRJT05fQUxHT1JJVEhNIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNFMkVFU3VwcG9ydGVkKCkge1xuICByZXR1cm4gaXNJbnNlcnRhYmxlU3RyZWFtU3VwcG9ydGVkKCkgfHwgaXNTY3JpcHRUcmFuc2Zvcm1TdXBwb3J0ZWQoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU2NyaXB0VHJhbnNmb3JtU3VwcG9ydGVkKCkge1xuICAvLyBAdHMtaWdub3JlXG4gIHJldHVybiB0eXBlb2Ygd2luZG93LlJUQ1J0cFNjcmlwdFRyYW5zZm9ybSAhPT0gJ3VuZGVmaW5lZCc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0luc2VydGFibGVTdHJlYW1TdXBwb3J0ZWQoKSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHdpbmRvdy5SVENSdHBTZW5kZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHR5cGVvZiB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZS5jcmVhdGVFbmNvZGVkU3RyZWFtcyAhPT0gJ3VuZGVmaW5lZCdcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzVmlkZW9GcmFtZShcbiAgZnJhbWU6IFJUQ0VuY29kZWRBdWRpb0ZyYW1lIHwgUlRDRW5jb2RlZFZpZGVvRnJhbWUsXG4pOiBmcmFtZSBpcyBSVENFbmNvZGVkVmlkZW9GcmFtZSB7XG4gIHJldHVybiAndHlwZScgaW4gZnJhbWU7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbXBvcnRLZXkoXG4gIGtleUJ5dGVzOiBVaW50OEFycmF5IHwgQXJyYXlCdWZmZXIsXG4gIGFsZ29yaXRobTogc3RyaW5nIHwgeyBuYW1lOiBzdHJpbmcgfSA9IHsgbmFtZTogRU5DUllQVElPTl9BTEdPUklUSE0gfSxcbiAgdXNhZ2U6ICdkZXJpdmUnIHwgJ2VuY3J5cHQnID0gJ2VuY3J5cHQnLFxuKSB7XG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TdWJ0bGVDcnlwdG8vaW1wb3J0S2V5XG4gIHJldHVybiBjcnlwdG8uc3VidGxlLmltcG9ydEtleShcbiAgICAncmF3JyxcbiAgICBrZXlCeXRlcyxcbiAgICBhbGdvcml0aG0sXG4gICAgZmFsc2UsXG4gICAgdXNhZ2UgPT09ICdkZXJpdmUnID8gWydkZXJpdmVCaXRzJywgJ2Rlcml2ZUtleSddIDogWydlbmNyeXB0JywgJ2RlY3J5cHQnXSxcbiAgKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUtleU1hdGVyaWFsRnJvbVN0cmluZyhwYXNzd29yZDogc3RyaW5nKSB7XG4gIGxldCBlbmMgPSBuZXcgVGV4dEVuY29kZXIoKTtcblxuICBjb25zdCBrZXlNYXRlcmlhbCA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KFxuICAgICdyYXcnLFxuICAgIGVuYy5lbmNvZGUocGFzc3dvcmQpLFxuICAgIHtcbiAgICAgIG5hbWU6ICdQQktERjInLFxuICAgIH0sXG4gICAgZmFsc2UsXG4gICAgWydkZXJpdmVCaXRzJywgJ2Rlcml2ZUtleSddLFxuICApO1xuXG4gIHJldHVybiBrZXlNYXRlcmlhbDtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUtleU1hdGVyaWFsRnJvbUJ1ZmZlcihjcnlwdG9CdWZmZXI6IEFycmF5QnVmZmVyKSB7XG4gIGNvbnN0IGtleU1hdGVyaWFsID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoJ3JhdycsIGNyeXB0b0J1ZmZlciwgJ0hLREYnLCBmYWxzZSwgW1xuICAgICdkZXJpdmVCaXRzJyxcbiAgICAnZGVyaXZlS2V5JyxcbiAgXSk7XG5cbiAgcmV0dXJuIGtleU1hdGVyaWFsO1xufVxuXG5mdW5jdGlvbiBnZXRBbGdvT3B0aW9ucyhhbGdvcml0aG1OYW1lOiBzdHJpbmcsIHNhbHQ6IHN0cmluZykge1xuICBjb25zdCB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICBjb25zdCBlbmNvZGVkU2FsdCA9IHRleHRFbmNvZGVyLmVuY29kZShzYWx0KTtcbiAgc3dpdGNoIChhbGdvcml0aG1OYW1lKSB7XG4gICAgY2FzZSAnSEtERic6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiAnSEtERicsXG4gICAgICAgIHNhbHQ6IGVuY29kZWRTYWx0LFxuICAgICAgICBoYXNoOiAnU0hBLTI1NicsXG4gICAgICAgIGluZm86IG5ldyBBcnJheUJ1ZmZlcigxMjgpLFxuICAgICAgfTtcbiAgICBjYXNlICdQQktERjInOiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiAnUEJLREYyJyxcbiAgICAgICAgc2FsdDogZW5jb2RlZFNhbHQsXG4gICAgICAgIGhhc2g6ICdTSEEtMjU2JyxcbiAgICAgICAgaXRlcmF0aW9uczogMTAwMDAwLFxuICAgICAgfTtcbiAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgYWxnb3JpdGhtICR7YWxnb3JpdGhtTmFtZX0gaXMgY3VycmVudGx5IHVuc3VwcG9ydGVkYCk7XG4gIH1cbn1cblxuLyoqXG4gKiBEZXJpdmVzIGEgc2V0IG9mIGtleXMgZnJvbSB0aGUgbWFzdGVyIGtleS5cbiAqIFNlZSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtb21hcmEtc2ZyYW1lLTAwI3NlY3Rpb24tNC4zLjFcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlcml2ZUtleXMobWF0ZXJpYWw6IENyeXB0b0tleSwgc2FsdDogc3RyaW5nKSB7XG4gIGNvbnN0IGFsZ29yaXRobU9wdGlvbnMgPSBnZXRBbGdvT3B0aW9ucyhtYXRlcmlhbC5hbGdvcml0aG0ubmFtZSwgc2FsdCk7XG5cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1N1YnRsZUNyeXB0by9kZXJpdmVLZXkjSEtERlxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSGtkZlBhcmFtc1xuICBjb25zdCBlbmNyeXB0aW9uS2V5ID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5kZXJpdmVLZXkoXG4gICAgYWxnb3JpdGhtT3B0aW9ucyxcbiAgICBtYXRlcmlhbCxcbiAgICB7XG4gICAgICBuYW1lOiBFTkNSWVBUSU9OX0FMR09SSVRITSxcbiAgICAgIGxlbmd0aDogMTI4LFxuICAgIH0sXG4gICAgZmFsc2UsXG4gICAgWydlbmNyeXB0JywgJ2RlY3J5cHQnXSxcbiAgKTtcblxuICByZXR1cm4geyBtYXRlcmlhbCwgZW5jcnlwdGlvbktleSB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRTJFRUtleSgpOiBVaW50OEFycmF5IHtcbiAgcmV0dXJuIHdpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KDMyKSk7XG59XG5cbi8qKlxuICogUmF0Y2hldHMgYSBrZXkuIFNlZVxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LW9tYXJhLXNmcmFtZS0wMCNzZWN0aW9uLTQuMy41LjFcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJhdGNoZXQobWF0ZXJpYWw6IENyeXB0b0tleSwgc2FsdDogc3RyaW5nKTogUHJvbWlzZTxBcnJheUJ1ZmZlcj4ge1xuICBjb25zdCBhbGdvcml0aG1PcHRpb25zID0gZ2V0QWxnb09wdGlvbnMobWF0ZXJpYWwuYWxnb3JpdGhtLm5hbWUsIHNhbHQpO1xuXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TdWJ0bGVDcnlwdG8vZGVyaXZlQml0c1xuICByZXR1cm4gY3J5cHRvLnN1YnRsZS5kZXJpdmVCaXRzKGFsZ29yaXRobU9wdGlvbnMsIG1hdGVyaWFsLCAyNTYpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbmVlZHNSYnNwVW5lc2NhcGluZyhmcmFtZURhdGE6IFVpbnQ4QXJyYXkpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmcmFtZURhdGEubGVuZ3RoIC0gMzsgaSsrKSB7XG4gICAgaWYgKGZyYW1lRGF0YVtpXSA9PSAwICYmIGZyYW1lRGF0YVtpICsgMV0gPT0gMCAmJiBmcmFtZURhdGFbaSArIDJdID09IDMpIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUmJzcChzdHJlYW06IFVpbnQ4QXJyYXkpOiBVaW50OEFycmF5IHtcbiAgY29uc3QgZGF0YU91dDogbnVtYmVyW10gPSBbXTtcbiAgdmFyIGxlbmd0aCA9IHN0cmVhbS5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyZWFtLmxlbmd0aDsgKSB7XG4gICAgLy8gQmUgY2FyZWZ1bCBhYm91dCBvdmVyL3VuZGVyZmxvdyBoZXJlLiBieXRlX2xlbmd0aF8gLSAzIGNhbiB1bmRlcmZsb3csIGFuZFxuICAgIC8vIGkgKyAzIGNhbiBvdmVyZmxvdywgYnV0IGJ5dGVfbGVuZ3RoXyAtIGkgY2FuJ3QsIGJlY2F1c2UgaSA8IGJ5dGVfbGVuZ3RoX1xuICAgIC8vIGFib3ZlLCBhbmQgdGhhdCBleHByZXNzaW9uIHdpbGwgcHJvZHVjZSB0aGUgbnVtYmVyIG9mIGJ5dGVzIGxlZnQgaW5cbiAgICAvLyB0aGUgc3RyZWFtIGluY2x1ZGluZyB0aGUgYnl0ZSBhdCBpLlxuICAgIGlmIChsZW5ndGggLSBpID49IDMgJiYgIXN0cmVhbVtpXSAmJiAhc3RyZWFtW2kgKyAxXSAmJiBzdHJlYW1baSArIDJdID09IDMpIHtcbiAgICAgIC8vIFR3byByYnNwIGJ5dGVzLlxuICAgICAgZGF0YU91dC5wdXNoKHN0cmVhbVtpKytdKTtcbiAgICAgIGRhdGFPdXQucHVzaChzdHJlYW1baSsrXSk7XG4gICAgICAvLyBTa2lwIHRoZSBlbXVsYXRpb24gYnl0ZS5cbiAgICAgIGkrKztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2luZ2xlIHJic3AgYnl0ZS5cbiAgICAgIGRhdGFPdXQucHVzaChzdHJlYW1baSsrXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgVWludDhBcnJheShkYXRhT3V0KTtcbn1cblxuY29uc3Qga1plcm9zSW5TdGFydFNlcXVlbmNlID0gMjtcbmNvbnN0IGtFbXVsYXRpb25CeXRlID0gMztcblxuZXhwb3J0IGZ1bmN0aW9uIHdyaXRlUmJzcChkYXRhX2luOiBVaW50OEFycmF5KTogVWludDhBcnJheSB7XG4gIGNvbnN0IGRhdGFPdXQ6IG51bWJlcltdID0gW107XG4gIHZhciBudW1Db25zZWN1dGl2ZVplcm9zID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhX2luLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ5dGUgPSBkYXRhX2luW2ldO1xuICAgIGlmIChieXRlIDw9IGtFbXVsYXRpb25CeXRlICYmIG51bUNvbnNlY3V0aXZlWmVyb3MgPj0ga1plcm9zSW5TdGFydFNlcXVlbmNlKSB7XG4gICAgICAvLyBOZWVkIHRvIGVzY2FwZS5cbiAgICAgIGRhdGFPdXQucHVzaChrRW11bGF0aW9uQnl0ZSk7XG4gICAgICBudW1Db25zZWN1dGl2ZVplcm9zID0gMDtcbiAgICB9XG4gICAgZGF0YU91dC5wdXNoKGJ5dGUpO1xuICAgIGlmIChieXRlID09IDApIHtcbiAgICAgICsrbnVtQ29uc2VjdXRpdmVaZXJvcztcbiAgICB9IGVsc2Uge1xuICAgICAgbnVtQ29uc2VjdXRpdmVaZXJvcyA9IDA7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgVWludDhBcnJheShkYXRhT3V0KTtcbn1cbiIsImltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgdHlwZSBUeXBlZEV2ZW50RW1pdHRlciBmcm9tICd0eXBlZC1lbWl0dGVyJztcbmltcG9ydCBsb2cgZnJvbSAnLi4vbG9nZ2VyJztcbmltcG9ydCB7IEtFWV9QUk9WSURFUl9ERUZBVUxUUyB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7IHR5cGUgS2V5UHJvdmlkZXJDYWxsYmFja3MsIEtleVByb3ZpZGVyRXZlbnQgfSBmcm9tICcuL2V2ZW50cyc7XG5pbXBvcnQgdHlwZSB7IEtleUluZm8sIEtleVByb3ZpZGVyT3B0aW9ucyB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgY3JlYXRlS2V5TWF0ZXJpYWxGcm9tQnVmZmVyLCBjcmVhdGVLZXlNYXRlcmlhbEZyb21TdHJpbmcgfSBmcm9tICcuL3V0aWxzJztcblxuLyoqXG4gKiBAZXhwZXJpbWVudGFsXG4gKi9cbmV4cG9ydCBjbGFzcyBCYXNlS2V5UHJvdmlkZXIgZXh0ZW5kcyAoRXZlbnRFbWl0dGVyIGFzIG5ldyAoKSA9PiBUeXBlZEV2ZW50RW1pdHRlcjxLZXlQcm92aWRlckNhbGxiYWNrcz4pIHtcbiAgcHJpdmF0ZSBrZXlJbmZvTWFwOiBNYXA8c3RyaW5nLCBLZXlJbmZvPjtcblxuICBwcml2YXRlIG9wdGlvbnM6IEtleVByb3ZpZGVyT3B0aW9ucztcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBQYXJ0aWFsPEtleVByb3ZpZGVyT3B0aW9ucz4gPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5rZXlJbmZvTWFwID0gbmV3IE1hcCgpO1xuICAgIHRoaXMub3B0aW9ucyA9IHsgLi4uS0VZX1BST1ZJREVSX0RFRkFVTFRTLCAuLi5vcHRpb25zIH07XG4gICAgdGhpcy5vbihLZXlQcm92aWRlckV2ZW50LktleVJhdGNoZXRlZCwgdGhpcy5vbktleVJhdGNoZXRlZCk7XG4gIH1cblxuICAvKipcbiAgICogY2FsbGJhY2sgdG8gaW52b2tlIG9uY2UgYSBrZXkgaGFzIGJlZW4gc2V0IGZvciBhIHBhcnRpY2lwYW50XG4gICAqIEBwYXJhbSBrZXlcbiAgICogQHBhcmFtIHBhcnRpY2lwYW50SWRlbnRpdHlcbiAgICogQHBhcmFtIGtleUluZGV4XG4gICAqL1xuICBwcm90ZWN0ZWQgb25TZXRFbmNyeXB0aW9uS2V5KGtleTogQ3J5cHRvS2V5LCBwYXJ0aWNpcGFudElkZW50aXR5Pzogc3RyaW5nLCBrZXlJbmRleD86IG51bWJlcikge1xuICAgIGNvbnN0IGtleUluZm86IEtleUluZm8gPSB7IGtleSwgcGFydGljaXBhbnRJZGVudGl0eSwga2V5SW5kZXggfTtcbiAgICB0aGlzLmtleUluZm9NYXAuc2V0KGAke3BhcnRpY2lwYW50SWRlbnRpdHkgPz8gJ3NoYXJlZCd9LSR7a2V5SW5kZXggPz8gMH1gLCBrZXlJbmZvKTtcbiAgICB0aGlzLmVtaXQoS2V5UHJvdmlkZXJFdmVudC5TZXRLZXksIGtleUluZm8pO1xuICB9XG5cbiAgLyoqXG4gICAqIGNhbGxiYWNrIGJlaW5nIGludm9rZWQgYWZ0ZXIgYSByYXRjaGV0IHJlcXVlc3QgaGFzIGJlZW4gcGVyZm9ybWVkIG9uIGEgcGFydGljaXBhbnRcbiAgICogdGhhdCBzdXJmYWNlcyB0aGUgbmV3IGtleSBtYXRlcmlhbC5cbiAgICogQHBhcmFtIG1hdGVyaWFsXG4gICAqIEBwYXJhbSBrZXlJbmRleFxuICAgKi9cbiAgcHJvdGVjdGVkIG9uS2V5UmF0Y2hldGVkID0gKG1hdGVyaWFsOiBDcnlwdG9LZXksIGtleUluZGV4PzogbnVtYmVyKSA9PiB7XG4gICAgbG9nLmRlYnVnKCdrZXkgcmF0Y2hldGVkIGV2ZW50IHJlY2VpdmVkJywgeyBtYXRlcmlhbCwga2V5SW5kZXggfSk7XG4gIH07XG5cbiAgZ2V0S2V5cygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmtleUluZm9NYXAudmFsdWVzKCkpO1xuICB9XG5cbiAgZ2V0T3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zO1xuICB9XG5cbiAgcmF0Y2hldEtleShwYXJ0aWNpcGFudElkZW50aXR5Pzogc3RyaW5nLCBrZXlJbmRleD86IG51bWJlcikge1xuICAgIHRoaXMuZW1pdChLZXlQcm92aWRlckV2ZW50LlJhdGNoZXRSZXF1ZXN0LCBwYXJ0aWNpcGFudElkZW50aXR5LCBrZXlJbmRleCk7XG4gIH1cbn1cblxuLyoqXG4gKiBBIGJhc2ljIEtleVByb3ZpZGVyIGltcGxlbWVudGF0aW9uIGludGVuZGVkIGZvciBhIHNpbmdsZSBzaGFyZWRcbiAqIHBhc3NwaHJhc2UgYmV0d2VlbiBhbGwgcGFydGljaXBhbnRzXG4gKiBAZXhwZXJpbWVudGFsXG4gKi9cbmV4cG9ydCBjbGFzcyBFeHRlcm5hbEUyRUVLZXlQcm92aWRlciBleHRlbmRzIEJhc2VLZXlQcm92aWRlciB7XG4gIHJhdGNoZXRJbnRlcnZhbDogbnVtYmVyIHwgdW5kZWZpbmVkO1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM6IFBhcnRpYWw8T21pdDxLZXlQcm92aWRlck9wdGlvbnMsICdzaGFyZWRLZXknPj4gPSB7fSkge1xuICAgIGNvbnN0IG9wdHM6IFBhcnRpYWw8S2V5UHJvdmlkZXJPcHRpb25zPiA9IHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBzaGFyZWRLZXk6IHRydWUsXG4gICAgICAvLyBmb3IgYSBzaGFyZWQga2V5IHByb3ZpZGVyIGZhaWxpbmcgdG8gZGVjcnlwdCBmb3IgYSBzcGVjaWZpYyBwYXJ0aWNpcGFudFxuICAgICAgLy8gc2hvdWxkIG5vdCBtYXJrIHRoZSBrZXkgYXMgaW52YWxpZCwgc28gd2UgYWNjZXB0IHdyb25nIGtleXMgZm9yZXZlclxuICAgICAgLy8gYW5kIHdvbid0IHRyeSB0byBhdXRvLXJhdGNoZXRcbiAgICAgIHJhdGNoZXRXaW5kb3dTaXplOiAwLFxuICAgICAgZmFpbHVyZVRvbGVyYW5jZTogLTEsXG4gICAgfTtcbiAgICBzdXBlcihvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY2NlcHRzIGEgcGFzc3BocmFzZSB0aGF0J3MgdXNlZCB0byBjcmVhdGUgdGhlIGNyeXB0byBrZXlzLlxuICAgKiBXaGVuIHBhc3NpbmcgaW4gYSBzdHJpbmcsIFBCS0RGMiBpcyB1c2VkLlxuICAgKiBXaGVuIHBhc3NpbmcgaW4gYW4gQXJyYXkgYnVmZmVyIG9mIGNyeXB0b2dyYXBoaWNhbGx5IHJhbmRvbSBudW1iZXJzLCBIS0RGIGlzIGJlaW5nIHVzZWQuIChyZWNvbW1lbmRlZClcbiAgICogQHBhcmFtIGtleVxuICAgKi9cbiAgYXN5bmMgc2V0S2V5KGtleTogc3RyaW5nIHwgQXJyYXlCdWZmZXIpIHtcbiAgICBjb25zdCBkZXJpdmVkS2V5ID1cbiAgICAgIHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnXG4gICAgICAgID8gYXdhaXQgY3JlYXRlS2V5TWF0ZXJpYWxGcm9tU3RyaW5nKGtleSlcbiAgICAgICAgOiBhd2FpdCBjcmVhdGVLZXlNYXRlcmlhbEZyb21CdWZmZXIoa2V5KTtcbiAgICB0aGlzLm9uU2V0RW5jcnlwdGlvbktleShkZXJpdmVkS2V5KTtcbiAgfVxufVxuIiwiZXhwb3J0IGNsYXNzIExpdmVraXRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29kZTogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKGNvZGU6IG51bWJlciwgbWVzc2FnZT86IHN0cmluZykge1xuICAgIHN1cGVyKG1lc3NhZ2UgfHwgJ2FuIGVycm9yIGhhcyBvY2N1cmVkJyk7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZW51bSBDb25uZWN0aW9uRXJyb3JSZWFzb24ge1xuICBOb3RBbGxvd2VkLFxuICBTZXJ2ZXJVbnJlYWNoYWJsZSxcbiAgSW50ZXJuYWxFcnJvcixcbiAgQ2FuY2VsbGVkLFxuICBMZWF2ZVJlcXVlc3QsXG59XG5cbmV4cG9ydCBjbGFzcyBDb25uZWN0aW9uRXJyb3IgZXh0ZW5kcyBMaXZla2l0RXJyb3Ige1xuICBzdGF0dXM/OiBudW1iZXI7XG5cbiAgcmVhc29uPzogQ29ubmVjdGlvbkVycm9yUmVhc29uO1xuXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U/OiBzdHJpbmcsIHJlYXNvbj86IENvbm5lY3Rpb25FcnJvclJlYXNvbiwgc3RhdHVzPzogbnVtYmVyKSB7XG4gICAgc3VwZXIoMSwgbWVzc2FnZSk7XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgdGhpcy5yZWFzb24gPSByZWFzb247XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIERldmljZVVuc3VwcG9ydGVkRXJyb3IgZXh0ZW5kcyBMaXZla2l0RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlPzogc3RyaW5nKSB7XG4gICAgc3VwZXIoMjEsIG1lc3NhZ2UgPz8gJ2RldmljZSBpcyB1bnN1cHBvcnRlZCcpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBUcmFja0ludmFsaWRFcnJvciBleHRlbmRzIExpdmVraXRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U/OiBzdHJpbmcpIHtcbiAgICBzdXBlcigyMCwgbWVzc2FnZSA/PyAndHJhY2sgaXMgaW52YWxpZCcpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBVbnN1cHBvcnRlZFNlcnZlciBleHRlbmRzIExpdmVraXRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U/OiBzdHJpbmcpIHtcbiAgICBzdXBlcigxMCwgbWVzc2FnZSA/PyAndW5zdXBwb3J0ZWQgc2VydmVyJyk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUgZXh0ZW5kcyBMaXZla2l0RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlPzogc3RyaW5nKSB7XG4gICAgc3VwZXIoMTIsIG1lc3NhZ2UgPz8gJ3VuZXhwZWN0ZWQgY29ubmVjdGlvbiBzdGF0ZScpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBOZWdvdGlhdGlvbkVycm9yIGV4dGVuZHMgTGl2ZWtpdEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZT86IHN0cmluZykge1xuICAgIHN1cGVyKDEzLCBtZXNzYWdlID8/ICd1bmFibGUgdG8gbmVnb3RpYXRlJyk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFB1Ymxpc2hEYXRhRXJyb3IgZXh0ZW5kcyBMaXZla2l0RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlPzogc3RyaW5nKSB7XG4gICAgc3VwZXIoMTMsIG1lc3NhZ2UgPz8gJ3VuYWJsZSB0byBwdWJsaXNoIGRhdGEnKTtcbiAgfVxufVxuXG5leHBvcnQgZW51bSBNZWRpYURldmljZUZhaWx1cmUge1xuICAvLyB1c2VyIHJlamVjdGVkIHBlcm1pc3Npb25zXG4gIFBlcm1pc3Npb25EZW5pZWQgPSAnUGVybWlzc2lvbkRlbmllZCcsXG4gIC8vIGRldmljZSBpcyBub3QgYXZhaWxhYmxlXG4gIE5vdEZvdW5kID0gJ05vdEZvdW5kJyxcbiAgLy8gZGV2aWNlIGlzIGluIHVzZS4gT24gV2luZG93cywgb25seSBhIHNpbmdsZSB0YWIgbWF5IGdldCBhY2Nlc3MgdG8gYSBkZXZpY2UgYXQgYSB0aW1lLlxuICBEZXZpY2VJblVzZSA9ICdEZXZpY2VJblVzZScsXG4gIE90aGVyID0gJ090aGVyJyxcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBNZWRpYURldmljZUZhaWx1cmUge1xuICBleHBvcnQgZnVuY3Rpb24gZ2V0RmFpbHVyZShlcnJvcjogYW55KTogTWVkaWFEZXZpY2VGYWlsdXJlIHwgdW5kZWZpbmVkIHtcbiAgICBpZiAoZXJyb3IgJiYgJ25hbWUnIGluIGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ05vdEZvdW5kRXJyb3InIHx8IGVycm9yLm5hbWUgPT09ICdEZXZpY2VzTm90Rm91bmRFcnJvcicpIHtcbiAgICAgICAgcmV0dXJuIE1lZGlhRGV2aWNlRmFpbHVyZS5Ob3RGb3VuZDtcbiAgICAgIH1cbiAgICAgIGlmIChlcnJvci5uYW1lID09PSAnTm90QWxsb3dlZEVycm9yJyB8fCBlcnJvci5uYW1lID09PSAnUGVybWlzc2lvbkRlbmllZEVycm9yJykge1xuICAgICAgICByZXR1cm4gTWVkaWFEZXZpY2VGYWlsdXJlLlBlcm1pc3Npb25EZW5pZWQ7XG4gICAgICB9XG4gICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ05vdFJlYWRhYmxlRXJyb3InIHx8IGVycm9yLm5hbWUgPT09ICdUcmFja1N0YXJ0RXJyb3InKSB7XG4gICAgICAgIHJldHVybiBNZWRpYURldmljZUZhaWx1cmUuRGV2aWNlSW5Vc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gTWVkaWFEZXZpY2VGYWlsdXJlLk90aGVyO1xuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBFdmVudHMgYXJlIHRoZSBwcmltYXJ5IHdheSBMaXZlS2l0IG5vdGlmaWVzIHlvdXIgYXBwbGljYXRpb24gb2YgY2hhbmdlcy5cbiAqXG4gKiBUaGUgZm9sbG93aW5nIGFyZSBldmVudHMgZW1pdHRlZCBieSBbW1Jvb21dXSwgbGlzdGVuIHRvIHJvb20gZXZlbnRzIGxpa2VcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiByb29tLm9uKFJvb21FdmVudC5UcmFja1B1Ymxpc2hlZCwgKHRyYWNrLCBwdWJsaWNhdGlvbiwgcGFydGljaXBhbnQpID0+IHt9KVxuICogYGBgXG4gKi9cblxuZXhwb3J0IGVudW0gUm9vbUV2ZW50IHtcbiAgLyoqXG4gICAqIFdoZW4gdGhlIGNvbm5lY3Rpb24gdG8gdGhlIHNlcnZlciBoYXMgYmVlbiBlc3RhYmxpc2hlZFxuICAgKi9cbiAgQ29ubmVjdGVkID0gJ2Nvbm5lY3RlZCcsXG5cbiAgLyoqXG4gICAqIFdoZW4gdGhlIGNvbm5lY3Rpb24gdG8gdGhlIHNlcnZlciBoYXMgYmVlbiBpbnRlcnJ1cHRlZCBhbmQgaXQncyBhdHRlbXB0aW5nXG4gICAqIHRvIHJlY29ubmVjdC5cbiAgICovXG4gIFJlY29ubmVjdGluZyA9ICdyZWNvbm5lY3RpbmcnLFxuXG4gIC8qKlxuICAgKiBGaXJlcyB3aGVuIGEgcmVjb25uZWN0aW9uIGhhcyBiZWVuIHN1Y2Nlc3NmdWwuXG4gICAqL1xuICBSZWNvbm5lY3RlZCA9ICdyZWNvbm5lY3RlZCcsXG5cbiAgLyoqXG4gICAqIFdoZW4gZGlzY29ubmVjdGVkIGZyb20gcm9vbS4gVGhpcyBmaXJlcyB3aGVuIHJvb20uZGlzY29ubmVjdCgpIGlzIGNhbGxlZCBvclxuICAgKiB3aGVuIGFuIHVucmVjb3ZlcmFibGUgY29ubmVjdGlvbiBpc3N1ZSBoYWQgb2NjdXJlZFxuICAgKi9cbiAgRGlzY29ubmVjdGVkID0gJ2Rpc2Nvbm5lY3RlZCcsXG5cbiAgLyoqXG4gICAqIFdoZW5ldmVyIHRoZSBjb25uZWN0aW9uIHN0YXRlIG9mIHRoZSByb29tIGNoYW5nZXNcbiAgICpcbiAgICogYXJnczogKFtbQ29ubmVjdGlvblN0YXRlXV0pXG4gICAqL1xuICBDb25uZWN0aW9uU3RhdGVDaGFuZ2VkID0gJ2Nvbm5lY3Rpb25TdGF0ZUNoYW5nZWQnLFxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBTdGF0ZUNoYW5nZWQgaGFzIGJlZW4gcmVuYW1lZCB0byBDb25uZWN0aW9uU3RhdGVDaGFuZ2VkXG4gICAqL1xuICBTdGF0ZUNoYW5nZWQgPSAnY29ubmVjdGlvblN0YXRlQ2hhbmdlZCcsXG5cbiAgLyoqXG4gICAqIFdoZW4gaW5wdXQgb3Igb3V0cHV0IGRldmljZXMgb24gdGhlIG1hY2hpbmUgaGF2ZSBjaGFuZ2VkLlxuICAgKi9cbiAgTWVkaWFEZXZpY2VzQ2hhbmdlZCA9ICdtZWRpYURldmljZXNDaGFuZ2VkJyxcblxuICAvKipcbiAgICogV2hlbiBhIFtbUmVtb3RlUGFydGljaXBhbnRdXSBqb2lucyAqYWZ0ZXIqIHRoZSBsb2NhbFxuICAgKiBwYXJ0aWNpcGFudC4gSXQgd2lsbCBub3QgZW1pdCBldmVudHMgZm9yIHBhcnRpY2lwYW50cyB0aGF0IGFyZSBhbHJlYWR5XG4gICAqIGluIHRoZSByb29tXG4gICAqXG4gICAqIGFyZ3M6IChbW1JlbW90ZVBhcnRpY2lwYW50XV0pXG4gICAqL1xuICBQYXJ0aWNpcGFudENvbm5lY3RlZCA9ICdwYXJ0aWNpcGFudENvbm5lY3RlZCcsXG5cbiAgLyoqXG4gICAqIFdoZW4gYSBbW1JlbW90ZVBhcnRpY2lwYW50XV0gbGVhdmVzICphZnRlciogdGhlIGxvY2FsXG4gICAqIHBhcnRpY2lwYW50IGhhcyBqb2luZWQuXG4gICAqXG4gICAqIGFyZ3M6IChbW1JlbW90ZVBhcnRpY2lwYW50XV0pXG4gICAqL1xuICBQYXJ0aWNpcGFudERpc2Nvbm5lY3RlZCA9ICdwYXJ0aWNpcGFudERpc2Nvbm5lY3RlZCcsXG5cbiAgLyoqXG4gICAqIFdoZW4gYSBuZXcgdHJhY2sgaXMgcHVibGlzaGVkIHRvIHJvb20gKmFmdGVyKiB0aGUgbG9jYWxcbiAgICogcGFydGljaXBhbnQgaGFzIGpvaW5lZC4gSXQgd2lsbCBub3QgZmlyZSBmb3IgdHJhY2tzIHRoYXQgYXJlIGFscmVhZHkgcHVibGlzaGVkLlxuICAgKlxuICAgKiBBIHRyYWNrIHB1Ymxpc2hlZCBkb2Vzbid0IG1lYW4gdGhlIHBhcnRpY2lwYW50IGhhcyBzdWJzY3JpYmVkIHRvIGl0LiBJdCdzXG4gICAqIHNpbXBseSByZWZsZWN0aW5nIHRoZSBzdGF0ZSBvZiB0aGUgcm9vbS5cbiAgICpcbiAgICogYXJnczogKFtbUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl1dLCBbW1JlbW90ZVBhcnRpY2lwYW50XV0pXG4gICAqL1xuICBUcmFja1B1Ymxpc2hlZCA9ICd0cmFja1B1Ymxpc2hlZCcsXG5cbiAgLyoqXG4gICAqIFRoZSBbW0xvY2FsUGFydGljaXBhbnRdXSBoYXMgc3Vic2NyaWJlZCB0byBhIG5ldyB0cmFjay4gVGhpcyBldmVudCB3aWxsICoqYWx3YXlzKipcbiAgICogZmlyZSBhcyBsb25nIGFzIG5ldyB0cmFja3MgYXJlIHJlYWR5IGZvciB1c2UuXG4gICAqXG4gICAqIGFyZ3M6IChbW1JlbW90ZVRyYWNrXV0sIFtbUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl1dLCBbW1JlbW90ZVBhcnRpY2lwYW50XV0pXG4gICAqL1xuICBUcmFja1N1YnNjcmliZWQgPSAndHJhY2tTdWJzY3JpYmVkJyxcblxuICAvKipcbiAgICogQ291bGQgbm90IHN1YnNjcmliZSB0byBhIHRyYWNrXG4gICAqXG4gICAqIGFyZ3M6ICh0cmFjayBzaWQsIFtbUmVtb3RlUGFydGljaXBhbnRdXSlcbiAgICovXG4gIFRyYWNrU3Vic2NyaXB0aW9uRmFpbGVkID0gJ3RyYWNrU3Vic2NyaXB0aW9uRmFpbGVkJyxcblxuICAvKipcbiAgICogQSBbW1JlbW90ZVBhcnRpY2lwYW50XV0gaGFzIHVucHVibGlzaGVkIGEgdHJhY2tcbiAgICpcbiAgICogYXJnczogKFtbUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl1dLCBbW1JlbW90ZVBhcnRpY2lwYW50XV0pXG4gICAqL1xuICBUcmFja1VucHVibGlzaGVkID0gJ3RyYWNrVW5wdWJsaXNoZWQnLFxuXG4gIC8qKlxuICAgKiBBIHN1YnNjcmliZWQgdHJhY2sgaXMgbm8gbG9uZ2VyIGF2YWlsYWJsZS4gQ2xpZW50cyBzaG91bGQgbGlzdGVuIHRvIHRoaXNcbiAgICogZXZlbnQgYW5kIGVuc3VyZSB0aGV5IGRldGFjaCB0cmFja3MuXG4gICAqXG4gICAqIGFyZ3M6IChbW1RyYWNrXV0sIFtbUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl1dLCBbW1JlbW90ZVBhcnRpY2lwYW50XV0pXG4gICAqL1xuICBUcmFja1Vuc3Vic2NyaWJlZCA9ICd0cmFja1Vuc3Vic2NyaWJlZCcsXG5cbiAgLyoqXG4gICAqIEEgdHJhY2sgdGhhdCB3YXMgbXV0ZWQsIGZpcmVzIG9uIGJvdGggW1tSZW1vdGVQYXJ0aWNpcGFudF1dcyBhbmQgW1tMb2NhbFBhcnRpY2lwYW50XV1cbiAgICpcbiAgICogYXJnczogKFtbVHJhY2tQdWJsaWNhdGlvbl1dLCBbW1BhcnRpY2lwYW50XV0pXG4gICAqL1xuICBUcmFja011dGVkID0gJ3RyYWNrTXV0ZWQnLFxuXG4gIC8qKlxuICAgKiBBIHRyYWNrIHRoYXQgd2FzIHVubXV0ZWQsIGZpcmVzIG9uIGJvdGggW1tSZW1vdGVQYXJ0aWNpcGFudF1dcyBhbmQgW1tMb2NhbFBhcnRpY2lwYW50XV1cbiAgICpcbiAgICogYXJnczogKFtbVHJhY2tQdWJsaWNhdGlvbl1dLCBbW1BhcnRpY2lwYW50XV0pXG4gICAqL1xuICBUcmFja1VubXV0ZWQgPSAndHJhY2tVbm11dGVkJyxcblxuICAvKipcbiAgICogQSBsb2NhbCB0cmFjayB3YXMgcHVibGlzaGVkIHN1Y2Nlc3NmdWxseS4gVGhpcyBldmVudCBpcyBoZWxwZnVsIHRvIGtub3dcbiAgICogd2hlbiB0byB1cGRhdGUgeW91ciBsb2NhbCBVSSB3aXRoIHRoZSBuZXdseSBwdWJsaXNoZWQgdHJhY2suXG4gICAqXG4gICAqIGFyZ3M6IChbW0xvY2FsVHJhY2tQdWJsaWNhdGlvbl1dLCBbW0xvY2FsUGFydGljaXBhbnRdXSlcbiAgICovXG4gIExvY2FsVHJhY2tQdWJsaXNoZWQgPSAnbG9jYWxUcmFja1B1Ymxpc2hlZCcsXG5cbiAgLyoqXG4gICAqIEEgbG9jYWwgdHJhY2sgd2FzIHVucHVibGlzaGVkLiBUaGlzIGV2ZW50IGlzIGhlbHBmdWwgdG8ga25vdyB3aGVuIHRvIHJlbW92ZVxuICAgKiB0aGUgbG9jYWwgdHJhY2sgZnJvbSB5b3VyIFVJLlxuICAgKlxuICAgKiBXaGVuIGEgdXNlciBzdG9wcyBzaGFyaW5nIHRoZWlyIHNjcmVlbiBieSBwcmVzc2luZyBcIkVuZFwiIG9uIHRoZSBicm93c2VyIFVJLFxuICAgKiB0aGlzIGV2ZW50IHdpbGwgYWxzbyBmaXJlLlxuICAgKlxuICAgKiBhcmdzOiAoW1tMb2NhbFRyYWNrUHVibGljYXRpb25dXSwgW1tMb2NhbFBhcnRpY2lwYW50XV0pXG4gICAqL1xuICBMb2NhbFRyYWNrVW5wdWJsaXNoZWQgPSAnbG9jYWxUcmFja1VucHVibGlzaGVkJyxcblxuICAvKipcbiAgICogV2hlbiBhIGxvY2FsIGF1ZGlvIHRyYWNrIGlzIHB1Ymxpc2hlZCB0aGUgU0RLIGNoZWNrcyB3aGV0aGVyIHRoZXJlIGlzIGNvbXBsZXRlIHNpbGVuY2VcbiAgICogb24gdGhhdCB0cmFjayBhbmQgZW1pdHMgdGhlIExvY2FsQXVkaW9TaWxlbmNlRGV0ZWN0ZWQgZXZlbnQgaW4gdGhhdCBjYXNlLlxuICAgKiBUaGlzIGFsbG93cyBmb3IgYXBwbGljYXRpb25zIHRvIHNob3cgVUkgaW5mb3JtaW5nIHVzZXJzIHRoYXQgdGhleSBtaWdodCBoYXZlIHRvXG4gICAqIHJlc2V0IHRoZWlyIGF1ZGlvIGhhcmR3YXJlIG9yIGNoZWNrIGZvciBwcm9wZXIgZGV2aWNlIGNvbm5lY3Rpdml0eS5cbiAgICovXG4gIExvY2FsQXVkaW9TaWxlbmNlRGV0ZWN0ZWQgPSAnbG9jYWxBdWRpb1NpbGVuY2VEZXRlY3RlZCcsXG5cbiAgLyoqXG4gICAqIEFjdGl2ZSBzcGVha2VycyBjaGFuZ2VkLiBMaXN0IG9mIHNwZWFrZXJzIGFyZSBvcmRlcmVkIGJ5IHRoZWlyIGF1ZGlvIGxldmVsLlxuICAgKiBsb3VkZXN0IHNwZWFrZXJzIGZpcnN0LiBUaGlzIHdpbGwgaW5jbHVkZSB0aGUgTG9jYWxQYXJ0aWNpcGFudCB0b28uXG4gICAqXG4gICAqIFNwZWFrZXIgdXBkYXRlcyBhcmUgc2VudCBvbmx5IHRvIHRoZSBwdWJsaXNoaW5nIHBhcnRpY2lwYW50IGFuZCB0aGVpciBzdWJzY3JpYmVycy5cbiAgICpcbiAgICogYXJnczogKEFycmF5PFtbUGFydGljaXBhbnRdXT4pXG4gICAqL1xuICBBY3RpdmVTcGVha2Vyc0NoYW5nZWQgPSAnYWN0aXZlU3BlYWtlcnNDaGFuZ2VkJyxcblxuICAvKipcbiAgICogUGFydGljaXBhbnQgbWV0YWRhdGEgaXMgYSBzaW1wbGUgd2F5IGZvciBhcHAtc3BlY2lmaWMgc3RhdGUgdG8gYmUgcHVzaGVkIHRvXG4gICAqIGFsbCB1c2Vycy5cbiAgICogV2hlbiBSb29tU2VydmljZS5VcGRhdGVQYXJ0aWNpcGFudE1ldGFkYXRhIGlzIGNhbGxlZCB0byBjaGFuZ2UgYSBwYXJ0aWNpcGFudCdzXG4gICAqIHN0YXRlLCAqYWxsKiAgcGFydGljaXBhbnRzIGluIHRoZSByb29tIHdpbGwgZmlyZSB0aGlzIGV2ZW50LlxuICAgKlxuICAgKiBhcmdzOiAocHJldk1ldGFkYXRhOiBzdHJpbmcsIFtbUGFydGljaXBhbnRdXSlcbiAgICpcbiAgICovXG4gIFBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkID0gJ3BhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkJyxcblxuICAvKipcbiAgICogUGFydGljaXBhbnQncyBkaXNwbGF5IG5hbWUgY2hhbmdlZFxuICAgKlxuICAgKiBhcmdzOiAobmFtZTogc3RyaW5nLCBbW1BhcnRpY2lwYW50XV0pXG4gICAqXG4gICAqL1xuICBQYXJ0aWNpcGFudE5hbWVDaGFuZ2VkID0gJ3BhcnRpY2lwYW50TmFtZUNoYW5nZWQnLFxuXG4gIC8qKlxuICAgKiBSb29tIG1ldGFkYXRhIGlzIGEgc2ltcGxlIHdheSBmb3IgYXBwLXNwZWNpZmljIHN0YXRlIHRvIGJlIHB1c2hlZCB0b1xuICAgKiBhbGwgdXNlcnMuXG4gICAqIFdoZW4gUm9vbVNlcnZpY2UuVXBkYXRlUm9vbU1ldGFkYXRhIGlzIGNhbGxlZCB0byBjaGFuZ2UgYSByb29tJ3Mgc3RhdGUsXG4gICAqICphbGwqICBwYXJ0aWNpcGFudHMgaW4gdGhlIHJvb20gd2lsbCBmaXJlIHRoaXMgZXZlbnQuXG4gICAqXG4gICAqIGFyZ3M6IChzdHJpbmcpXG4gICAqL1xuICBSb29tTWV0YWRhdGFDaGFuZ2VkID0gJ3Jvb21NZXRhZGF0YUNoYW5nZWQnLFxuXG4gIC8qKlxuICAgKiBEYXRhIHJlY2VpdmVkIGZyb20gYW5vdGhlciBwYXJ0aWNpcGFudC5cbiAgICogRGF0YSBwYWNrZXRzIHByb3ZpZGVzIHRoZSBhYmlsaXR5IHRvIHVzZSBMaXZlS2l0IHRvIHNlbmQvcmVjZWl2ZSBhcmJpdHJhcnkgcGF5bG9hZHMuXG4gICAqIEFsbCBwYXJ0aWNpcGFudHMgaW4gdGhlIHJvb20gd2lsbCByZWNlaXZlIHRoZSBtZXNzYWdlcyBzZW50IHRvIHRoZSByb29tLlxuICAgKlxuICAgKiBhcmdzOiAocGF5bG9hZDogVWludDhBcnJheSwgcGFydGljaXBhbnQ6IFtbUGFydGljaXBhbnRdXSwga2luZDogW1tEYXRhUGFja2V0X0tpbmRdXSwgdG9waWM/OiBzdHJpbmcpXG4gICAqL1xuICBEYXRhUmVjZWl2ZWQgPSAnZGF0YVJlY2VpdmVkJyxcblxuICAvKipcbiAgICogQ29ubmVjdGlvbiBxdWFsaXR5IHdhcyBjaGFuZ2VkIGZvciBhIFBhcnRpY2lwYW50LiBJdCdsbCByZWNlaXZlIHVwZGF0ZXNcbiAgICogZnJvbSB0aGUgbG9jYWwgcGFydGljaXBhbnQsIGFzIHdlbGwgYXMgYW55IFtbUmVtb3RlUGFydGljaXBhbnRdXXMgdGhhdCB3ZSBhcmVcbiAgICogc3Vic2NyaWJlZCB0by5cbiAgICpcbiAgICogYXJnczogKGNvbm5lY3Rpb25RdWFsaXR5OiBbW0Nvbm5lY3Rpb25RdWFsaXR5XV0sIHBhcnRpY2lwYW50OiBbW1BhcnRpY2lwYW50XV0pXG4gICAqL1xuICBDb25uZWN0aW9uUXVhbGl0eUNoYW5nZWQgPSAnY29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkJyxcblxuICAvKipcbiAgICogU3RyZWFtU3RhdGUgaW5kaWNhdGVzIGlmIGEgc3Vic2NyaWJlZCAocmVtb3RlKSB0cmFjayBoYXMgYmVlbiBwYXVzZWQgYnkgdGhlIFNGVVxuICAgKiAodHlwaWNhbGx5IHRoaXMgaGFwcGVucyBiZWNhdXNlIG9mIHN1YnNjcmliZXIncyBiYW5kd2lkdGggY29uc3RyYWludHMpXG4gICAqXG4gICAqIFdoZW4gYmFuZHdpZHRoIGNvbmRpdGlvbnMgYWxsb3csIHRoZSB0cmFjayB3aWxsIGJlIHJlc3VtZWQgYXV0b21hdGljYWxseS5cbiAgICogVHJhY2tTdHJlYW1TdGF0ZUNoYW5nZWQgd2lsbCBhbHNvIGJlIGVtaXR0ZWQgd2hlbiB0aGF0IGhhcHBlbnMuXG4gICAqXG4gICAqIGFyZ3M6IChwdWI6IFtbUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl1dLCBzdHJlYW1TdGF0ZTogW1tUcmFjay5TdHJlYW1TdGF0ZV1dLFxuICAgKiAgICAgICAgcGFydGljaXBhbnQ6IFtbUmVtb3RlUGFydGljaXBhbnRdXSlcbiAgICovXG4gIFRyYWNrU3RyZWFtU3RhdGVDaGFuZ2VkID0gJ3RyYWNrU3RyZWFtU3RhdGVDaGFuZ2VkJyxcblxuICAvKipcbiAgICogT25lIG9mIHN1YnNjcmliZWQgdHJhY2tzIGhhdmUgY2hhbmdlZCBpdHMgcGVybWlzc2lvbnMgZm9yIHRoZSBjdXJyZW50XG4gICAqIHBhcnRpY2lwYW50LiBJZiBwZXJtaXNzaW9uIHdhcyByZXZva2VkLCB0aGVuIHRoZSB0cmFjayB3aWxsIG5vIGxvbmdlclxuICAgKiBiZSBzdWJzY3JpYmVkLiBJZiBwZXJtaXNzaW9uIHdhcyBncmFudGVkLCBhIFRyYWNrU3Vic2NyaWJlZCBldmVudCB3aWxsXG4gICAqIGJlIGVtaXR0ZWQuXG4gICAqXG4gICAqIGFyZ3M6IChwdWI6IFtbUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl1dLFxuICAgKiAgICAgICAgc3RhdHVzOiBbW1RyYWNrUHVibGljYXRpb24uUGVybWlzc2lvblN0YXR1c11dLFxuICAgKiAgICAgICAgcGFydGljaXBhbnQ6IFtbUmVtb3RlUGFydGljaXBhbnRdXSlcbiAgICovXG4gIFRyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWQgPSAndHJhY2tTdWJzY3JpcHRpb25QZXJtaXNzaW9uQ2hhbmdlZCcsXG5cbiAgLyoqXG4gICAqIE9uZSBvZiBzdWJzY3JpYmVkIHRyYWNrcyBoYXZlIGNoYW5nZWQgaXRzIHN0YXR1cyBmb3IgdGhlIGN1cnJlbnRcbiAgICogcGFydGljaXBhbnQuXG4gICAqXG4gICAqIGFyZ3M6IChwdWI6IFtbUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl1dLFxuICAgKiAgICAgICAgc3RhdHVzOiBbW1RyYWNrUHVibGljYXRpb24uU3Vic2NyaXB0aW9uU3RhdHVzXV0sXG4gICAqICAgICAgICBwYXJ0aWNpcGFudDogW1tSZW1vdGVQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgVHJhY2tTdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkID0gJ3RyYWNrU3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZCcsXG5cbiAgLyoqXG4gICAqIExpdmVLaXQgd2lsbCBhdHRlbXB0IHRvIGF1dG9wbGF5IGFsbCBhdWRpbyB0cmFja3Mgd2hlbiB5b3UgYXR0YWNoIHRoZW0gdG9cbiAgICogYXVkaW8gZWxlbWVudHMuIEhvd2V2ZXIsIGlmIHRoYXQgZmFpbHMsIHdlJ2xsIG5vdGlmeSB5b3UgdmlhIEF1ZGlvUGxheWJhY2tTdGF0dXNDaGFuZ2VkLlxuICAgKiBgUm9vbS5jYW5QbGF5YmFja0F1ZGlvYCB3aWxsIGluZGljYXRlIGlmIGF1ZGlvIHBsYXliYWNrIGlzIHBlcm1pdHRlZC5cbiAgICovXG4gIEF1ZGlvUGxheWJhY2tTdGF0dXNDaGFuZ2VkID0gJ2F1ZGlvUGxheWJhY2tDaGFuZ2VkJyxcblxuICAvKipcbiAgICogTGl2ZUtpdCB3aWxsIGF0dGVtcHQgdG8gYXV0b3BsYXkgYWxsIHZpZGVvIHRyYWNrcyB3aGVuIHlvdSBhdHRhY2ggdGhlbSB0b1xuICAgKiBhIHZpZGVvIGVsZW1lbnQuIEhvd2V2ZXIsIGlmIHRoYXQgZmFpbHMsIHdlJ2xsIG5vdGlmeSB5b3UgdmlhIFZpZGVvUGxheWJhY2tTdGF0dXNDaGFuZ2VkLlxuICAgKiBDYWxsaW5nIGByb29tLnN0YXJ0VmlkZW8oKWAgaW4gYSB1c2VyIGdlc3R1cmUgZXZlbnQgaGFuZGxlciB3aWxsIHJlc3VtZSB0aGUgdmlkZW8gcGxheWJhY2suXG4gICAqL1xuICBWaWRlb1BsYXliYWNrU3RhdHVzQ2hhbmdlZCA9ICd2aWRlb1BsYXliYWNrQ2hhbmdlZCcsXG5cbiAgLyoqXG4gICAqIFdoZW4gd2UgaGF2ZSBlbmNvdW50ZXJlZCBhbiBlcnJvciB3aGlsZSBhdHRlbXB0aW5nIHRvIGNyZWF0ZSBhIHRyYWNrLlxuICAgKiBUaGUgZXJyb3JzIHRha2UgcGxhY2UgaW4gZ2V0VXNlck1lZGlhKCkuXG4gICAqIFVzZSBNZWRpYURldmljZUZhaWx1cmUuZ2V0RmFpbHVyZShlcnJvcikgdG8gZ2V0IHRoZSByZWFzb24gb2YgZmFpbHVyZS5cbiAgICogW1tMb2NhbFBhcnRpY2lwYW50Lmxhc3RDYW1lcmFFcnJvcl1dIGFuZCBbW0xvY2FsUGFydGljaXBhbnQubGFzdE1pY3JvcGhvbmVFcnJvcl1dXG4gICAqIHdpbGwgaW5kaWNhdGUgaWYgaXQgaGFkIGFuIGVycm9yIHdoaWxlIGNyZWF0aW5nIHRoZSBhdWRpbyBvciB2aWRlbyB0cmFjayByZXNwZWN0aXZlbHkuXG4gICAqXG4gICAqIGFyZ3M6IChlcnJvcjogRXJyb3IpXG4gICAqL1xuICBNZWRpYURldmljZXNFcnJvciA9ICdtZWRpYURldmljZXNFcnJvcicsXG5cbiAgLyoqXG4gICAqIEEgcGFydGljaXBhbnQncyBwZXJtaXNzaW9uIGhhcyBjaGFuZ2VkLiBDdXJyZW50bHkgb25seSBmaXJlZCBvbiBMb2NhbFBhcnRpY2lwYW50LlxuICAgKiBhcmdzOiAocHJldlBlcm1pc3Npb25zOiBbW1BhcnRpY2lwYW50UGVybWlzc2lvbl1dLCBwYXJ0aWNpcGFudDogW1tQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWQgPSAncGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWQnLFxuXG4gIC8qKlxuICAgKiBTaWduYWwgY29ubmVjdGVkLCBjYW4gcHVibGlzaCB0cmFja3MuXG4gICAqL1xuICBTaWduYWxDb25uZWN0ZWQgPSAnc2lnbmFsQ29ubmVjdGVkJyxcblxuICAvKipcbiAgICogUmVjb3JkaW5nIG9mIGEgcm9vbSBoYXMgc3RhcnRlZC9zdG9wcGVkLiBSb29tLmlzUmVjb3JkaW5nIHdpbGwgYmUgdXBkYXRlZCB0b28uXG4gICAqIGFyZ3M6IChpc1JlY29yZGluZzogYm9vbGVhbilcbiAgICovXG4gIFJlY29yZGluZ1N0YXR1c0NoYW5nZWQgPSAncmVjb3JkaW5nU3RhdHVzQ2hhbmdlZCcsXG5cbiAgUGFydGljaXBhbnRFbmNyeXB0aW9uU3RhdHVzQ2hhbmdlZCA9ICdwYXJ0aWNpcGFudEVuY3J5cHRpb25TdGF0dXNDaGFuZ2VkJyxcblxuICBFbmNyeXB0aW9uRXJyb3IgPSAnZW5jcnlwdGlvbkVycm9yJyxcbiAgLyoqXG4gICAqIEVtaXRzIHdoZW5ldmVyIHRoZSBjdXJyZW50IGJ1ZmZlciBzdGF0dXMgb2YgYSBkYXRhIGNoYW5uZWwgY2hhbmdlc1xuICAgKiBhcmdzOiAoaXNMb3c6IGJvb2xlYW4sIGtpbmQ6IFtbRGF0YVBhY2tldF9LaW5kXV0pXG4gICAqL1xuICBEQ0J1ZmZlclN0YXR1c0NoYW5nZWQgPSAnZGNCdWZmZXJTdGF0dXNDaGFuZ2VkJyxcblxuICAvKipcbiAgICogVHJpZ2dlcmVkIGJ5IGEgY2FsbCB0byByb29tLnN3aXRjaEFjdGl2ZURldmljZVxuICAgKiBhcmdzOiAoa2luZDogTWVkaWFEZXZpY2VLaW5kLCBkZXZpY2VJZDogc3RyaW5nKVxuICAgKi9cbiAgQWN0aXZlRGV2aWNlQ2hhbmdlZCA9ICdhY3RpdmVEZXZpY2VDaGFuZ2VkJyxcbn1cblxuZXhwb3J0IGVudW0gUGFydGljaXBhbnRFdmVudCB7XG4gIC8qKlxuICAgKiBXaGVuIGEgbmV3IHRyYWNrIGlzIHB1Ymxpc2hlZCB0byByb29tICphZnRlciogdGhlIGxvY2FsXG4gICAqIHBhcnRpY2lwYW50IGhhcyBqb2luZWQuIEl0IHdpbGwgbm90IGZpcmUgZm9yIHRyYWNrcyB0aGF0IGFyZSBhbHJlYWR5IHB1Ymxpc2hlZC5cbiAgICpcbiAgICogQSB0cmFjayBwdWJsaXNoZWQgZG9lc24ndCBtZWFuIHRoZSBwYXJ0aWNpcGFudCBoYXMgc3Vic2NyaWJlZCB0byBpdC4gSXQnc1xuICAgKiBzaW1wbHkgcmVmbGVjdGluZyB0aGUgc3RhdGUgb2YgdGhlIHJvb20uXG4gICAqXG4gICAqIGFyZ3M6IChbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSlcbiAgICovXG4gIFRyYWNrUHVibGlzaGVkID0gJ3RyYWNrUHVibGlzaGVkJyxcblxuICAvKipcbiAgICogU3VjY2Vzc2Z1bGx5IHN1YnNjcmliZWQgdG8gdGhlIFtbUmVtb3RlUGFydGljaXBhbnRdXSdzIHRyYWNrLlxuICAgKiBUaGlzIGV2ZW50IHdpbGwgKiphbHdheXMqKiBmaXJlIGFzIGxvbmcgYXMgbmV3IHRyYWNrcyBhcmUgcmVhZHkgZm9yIHVzZS5cbiAgICpcbiAgICogYXJnczogKFtbUmVtb3RlVHJhY2tdXSwgW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0pXG4gICAqL1xuICBUcmFja1N1YnNjcmliZWQgPSAndHJhY2tTdWJzY3JpYmVkJyxcblxuICAvKipcbiAgICogQ291bGQgbm90IHN1YnNjcmliZSB0byBhIHRyYWNrXG4gICAqXG4gICAqIGFyZ3M6ICh0cmFjayBzaWQpXG4gICAqL1xuICBUcmFja1N1YnNjcmlwdGlvbkZhaWxlZCA9ICd0cmFja1N1YnNjcmlwdGlvbkZhaWxlZCcsXG5cbiAgLyoqXG4gICAqIEEgW1tSZW1vdGVQYXJ0aWNpcGFudF1dIGhhcyB1bnB1Ymxpc2hlZCBhIHRyYWNrXG4gICAqXG4gICAqIGFyZ3M6IChbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSlcbiAgICovXG4gIFRyYWNrVW5wdWJsaXNoZWQgPSAndHJhY2tVbnB1Ymxpc2hlZCcsXG5cbiAgLyoqXG4gICAqIEEgc3Vic2NyaWJlZCB0cmFjayBpcyBubyBsb25nZXIgYXZhaWxhYmxlLiBDbGllbnRzIHNob3VsZCBsaXN0ZW4gdG8gdGhpc1xuICAgKiBldmVudCBhbmQgZW5zdXJlIHRoZXkgZGV0YWNoIHRyYWNrcy5cbiAgICpcbiAgICogYXJnczogKFtbUmVtb3RlVHJhY2tdXSwgW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0pXG4gICAqL1xuICBUcmFja1Vuc3Vic2NyaWJlZCA9ICd0cmFja1Vuc3Vic2NyaWJlZCcsXG5cbiAgLyoqXG4gICAqIEEgdHJhY2sgdGhhdCB3YXMgbXV0ZWQsIGZpcmVzIG9uIGJvdGggW1tSZW1vdGVQYXJ0aWNpcGFudF1dcyBhbmQgW1tMb2NhbFBhcnRpY2lwYW50XV1cbiAgICpcbiAgICogYXJnczogKFtbVHJhY2tQdWJsaWNhdGlvbl1dKVxuICAgKi9cbiAgVHJhY2tNdXRlZCA9ICd0cmFja011dGVkJyxcblxuICAvKipcbiAgICogQSB0cmFjayB0aGF0IHdhcyB1bm11dGVkLCBmaXJlcyBvbiBib3RoIFtbUmVtb3RlUGFydGljaXBhbnRdXXMgYW5kIFtbTG9jYWxQYXJ0aWNpcGFudF1dXG4gICAqXG4gICAqIGFyZ3M6IChbW1RyYWNrUHVibGljYXRpb25dXSlcbiAgICovXG4gIFRyYWNrVW5tdXRlZCA9ICd0cmFja1VubXV0ZWQnLFxuXG4gIC8qKlxuICAgKiBBIGxvY2FsIHRyYWNrIHdhcyBwdWJsaXNoZWQgc3VjY2Vzc2Z1bGx5LiBUaGlzIGV2ZW50IGlzIGhlbHBmdWwgdG8ga25vd1xuICAgKiB3aGVuIHRvIHVwZGF0ZSB5b3VyIGxvY2FsIFVJIHdpdGggdGhlIG5ld2x5IHB1Ymxpc2hlZCB0cmFjay5cbiAgICpcbiAgICogYXJnczogKFtbTG9jYWxUcmFja1B1YmxpY2F0aW9uXV0pXG4gICAqL1xuICBMb2NhbFRyYWNrUHVibGlzaGVkID0gJ2xvY2FsVHJhY2tQdWJsaXNoZWQnLFxuXG4gIC8qKlxuICAgKiBBIGxvY2FsIHRyYWNrIHdhcyB1bnB1Ymxpc2hlZC4gVGhpcyBldmVudCBpcyBoZWxwZnVsIHRvIGtub3cgd2hlbiB0byByZW1vdmVcbiAgICogdGhlIGxvY2FsIHRyYWNrIGZyb20geW91ciBVSS5cbiAgICpcbiAgICogV2hlbiBhIHVzZXIgc3RvcHMgc2hhcmluZyB0aGVpciBzY3JlZW4gYnkgcHJlc3NpbmcgXCJFbmRcIiBvbiB0aGUgYnJvd3NlciBVSSxcbiAgICogdGhpcyBldmVudCB3aWxsIGFsc28gZmlyZS5cbiAgICpcbiAgICogYXJnczogKFtbTG9jYWxUcmFja1B1YmxpY2F0aW9uXV0pXG4gICAqL1xuICBMb2NhbFRyYWNrVW5wdWJsaXNoZWQgPSAnbG9jYWxUcmFja1VucHVibGlzaGVkJyxcblxuICAvKipcbiAgICogUGFydGljaXBhbnQgbWV0YWRhdGEgaXMgYSBzaW1wbGUgd2F5IGZvciBhcHAtc3BlY2lmaWMgc3RhdGUgdG8gYmUgcHVzaGVkIHRvXG4gICAqIGFsbCB1c2Vycy5cbiAgICogV2hlbiBSb29tU2VydmljZS5VcGRhdGVQYXJ0aWNpcGFudE1ldGFkYXRhIGlzIGNhbGxlZCB0byBjaGFuZ2UgYSBwYXJ0aWNpcGFudCdzXG4gICAqIHN0YXRlLCAqYWxsKiAgcGFydGljaXBhbnRzIGluIHRoZSByb29tIHdpbGwgZmlyZSB0aGlzIGV2ZW50LlxuICAgKiBUbyBhY2Nlc3MgdGhlIGN1cnJlbnQgbWV0YWRhdGEsIHNlZSBbW1BhcnRpY2lwYW50Lm1ldGFkYXRhXV0uXG4gICAqXG4gICAqIGFyZ3M6IChwcmV2TWV0YWRhdGE6IHN0cmluZylcbiAgICpcbiAgICovXG4gIFBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkID0gJ3BhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkJyxcblxuICAvKipcbiAgICogUGFydGljaXBhbnQncyBkaXNwbGF5IG5hbWUgY2hhbmdlZFxuICAgKlxuICAgKiBhcmdzOiAobmFtZTogc3RyaW5nLCBbW1BhcnRpY2lwYW50XV0pXG4gICAqXG4gICAqL1xuICBQYXJ0aWNpcGFudE5hbWVDaGFuZ2VkID0gJ3BhcnRpY2lwYW50TmFtZUNoYW5nZWQnLFxuXG4gIC8qKlxuICAgKiBEYXRhIHJlY2VpdmVkIGZyb20gdGhpcyBwYXJ0aWNpcGFudCBhcyBzZW5kZXIuXG4gICAqIERhdGEgcGFja2V0cyBwcm92aWRlcyB0aGUgYWJpbGl0eSB0byB1c2UgTGl2ZUtpdCB0byBzZW5kL3JlY2VpdmUgYXJiaXRyYXJ5IHBheWxvYWRzLlxuICAgKiBBbGwgcGFydGljaXBhbnRzIGluIHRoZSByb29tIHdpbGwgcmVjZWl2ZSB0aGUgbWVzc2FnZXMgc2VudCB0byB0aGUgcm9vbS5cbiAgICpcbiAgICogYXJnczogKHBheWxvYWQ6IFVpbnQ4QXJyYXksIGtpbmQ6IFtbRGF0YVBhY2tldF9LaW5kXV0pXG4gICAqL1xuICBEYXRhUmVjZWl2ZWQgPSAnZGF0YVJlY2VpdmVkJyxcblxuICAvKipcbiAgICogSGFzIHNwZWFraW5nIHN0YXR1cyBjaGFuZ2VkIGZvciB0aGUgY3VycmVudCBwYXJ0aWNpcGFudFxuICAgKlxuICAgKiBhcmdzOiAoc3BlYWtpbmc6IGJvb2xlYW4pXG4gICAqL1xuICBJc1NwZWFraW5nQ2hhbmdlZCA9ICdpc1NwZWFraW5nQ2hhbmdlZCcsXG5cbiAgLyoqXG4gICAqIENvbm5lY3Rpb24gcXVhbGl0eSB3YXMgY2hhbmdlZCBmb3IgYSBQYXJ0aWNpcGFudC4gSXQnbGwgcmVjZWl2ZSB1cGRhdGVzXG4gICAqIGZyb20gdGhlIGxvY2FsIHBhcnRpY2lwYW50LCBhcyB3ZWxsIGFzIGFueSBbW1JlbW90ZVBhcnRpY2lwYW50XV1zIHRoYXQgd2UgYXJlXG4gICAqIHN1YnNjcmliZWQgdG8uXG4gICAqXG4gICAqIGFyZ3M6IChjb25uZWN0aW9uUXVhbGl0eTogW1tDb25uZWN0aW9uUXVhbGl0eV1dKVxuICAgKi9cbiAgQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkID0gJ2Nvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCcsXG5cbiAgLyoqXG4gICAqIFN0cmVhbVN0YXRlIGluZGljYXRlcyBpZiBhIHN1YnNjcmliZWQgdHJhY2sgaGFzIGJlZW4gcGF1c2VkIGJ5IHRoZSBTRlVcbiAgICogKHR5cGljYWxseSB0aGlzIGhhcHBlbnMgYmVjYXVzZSBvZiBzdWJzY3JpYmVyJ3MgYmFuZHdpZHRoIGNvbnN0cmFpbnRzKVxuICAgKlxuICAgKiBXaGVuIGJhbmR3aWR0aCBjb25kaXRpb25zIGFsbG93LCB0aGUgdHJhY2sgd2lsbCBiZSByZXN1bWVkIGF1dG9tYXRpY2FsbHkuXG4gICAqIFRyYWNrU3RyZWFtU3RhdGVDaGFuZ2VkIHdpbGwgYWxzbyBiZSBlbWl0dGVkIHdoZW4gdGhhdCBoYXBwZW5zLlxuICAgKlxuICAgKiBhcmdzOiAocHViOiBbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSwgc3RyZWFtU3RhdGU6IFtbVHJhY2suU3RyZWFtU3RhdGVdXSlcbiAgICovXG4gIFRyYWNrU3RyZWFtU3RhdGVDaGFuZ2VkID0gJ3RyYWNrU3RyZWFtU3RhdGVDaGFuZ2VkJyxcblxuICAvKipcbiAgICogT25lIG9mIHN1YnNjcmliZWQgdHJhY2tzIGhhdmUgY2hhbmdlZCBpdHMgcGVybWlzc2lvbnMgZm9yIHRoZSBjdXJyZW50XG4gICAqIHBhcnRpY2lwYW50LiBJZiBwZXJtaXNzaW9uIHdhcyByZXZva2VkLCB0aGVuIHRoZSB0cmFjayB3aWxsIG5vIGxvbmdlclxuICAgKiBiZSBzdWJzY3JpYmVkLiBJZiBwZXJtaXNzaW9uIHdhcyBncmFudGVkLCBhIFRyYWNrU3Vic2NyaWJlZCBldmVudCB3aWxsXG4gICAqIGJlIGVtaXR0ZWQuXG4gICAqXG4gICAqIGFyZ3M6IChwdWI6IFtbUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl1dLFxuICAgKiAgICAgICAgc3RhdHVzOiBbW1RyYWNrUHVibGljYXRpb24uU3Vic2NyaXB0aW9uU3RhdHVzXV0pXG4gICAqL1xuICBUcmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkID0gJ3RyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWQnLFxuXG4gIC8qKlxuICAgKiBPbmUgb2YgdGhlIHJlbW90ZSBwYXJ0aWNpcGFudHMgcHVibGljYXRpb25zIGhhcyBjaGFuZ2VkIGl0cyBzdWJzY3JpcHRpb24gc3RhdHVzLlxuICAgKlxuICAgKi9cbiAgVHJhY2tTdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkID0gJ3RyYWNrU3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZCcsXG5cbiAgLy8gZmlyZWQgb25seSBvbiBMb2NhbFBhcnRpY2lwYW50XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgTWVkaWFEZXZpY2VzRXJyb3IgPSAnbWVkaWFEZXZpY2VzRXJyb3InLFxuXG4gIC8vIGZpcmVkIG9ubHkgb24gTG9jYWxQYXJ0aWNpcGFudFxuICAvKiogQGludGVybmFsICovXG4gIEF1ZGlvU3RyZWFtQWNxdWlyZWQgPSAnYXVkaW9TdHJlYW1BY3F1aXJlZCcsXG5cbiAgLyoqXG4gICAqIEEgcGFydGljaXBhbnQncyBwZXJtaXNzaW9uIGhhcyBjaGFuZ2VkLiBDdXJyZW50bHkgb25seSBmaXJlZCBvbiBMb2NhbFBhcnRpY2lwYW50LlxuICAgKiBhcmdzOiAocHJldlBlcm1pc3Npb25zOiBbW1BhcnRpY2lwYW50UGVybWlzc2lvbl1dKVxuICAgKi9cbiAgUGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWQgPSAncGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWQnLFxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgUENUcmFja0FkZGVkID0gJ3BjVHJhY2tBZGRlZCcsXG59XG5cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBlbnVtIEVuZ2luZUV2ZW50IHtcbiAgVHJhbnNwb3J0c0NyZWF0ZWQgPSAndHJhbnNwb3J0c0NyZWF0ZWQnLFxuICBDb25uZWN0ZWQgPSAnY29ubmVjdGVkJyxcbiAgRGlzY29ubmVjdGVkID0gJ2Rpc2Nvbm5lY3RlZCcsXG4gIFJlc3VtaW5nID0gJ3Jlc3VtaW5nJyxcbiAgUmVzdW1lZCA9ICdyZXN1bWVkJyxcbiAgUmVzdGFydGluZyA9ICdyZXN0YXJ0aW5nJyxcbiAgUmVzdGFydGVkID0gJ3Jlc3RhcnRlZCcsXG4gIFNpZ25hbFJlc3VtZWQgPSAnc2lnbmFsUmVzdW1lZCcsXG4gIFNpZ25hbFJlc3RhcnRlZCA9ICdzaWduYWxSZXN0YXJ0ZWQnLFxuICBDbG9zaW5nID0gJ2Nsb3NpbmcnLFxuICBNZWRpYVRyYWNrQWRkZWQgPSAnbWVkaWFUcmFja0FkZGVkJyxcbiAgQWN0aXZlU3BlYWtlcnNVcGRhdGUgPSAnYWN0aXZlU3BlYWtlcnNVcGRhdGUnLFxuICBEYXRhUGFja2V0UmVjZWl2ZWQgPSAnZGF0YVBhY2tldFJlY2VpdmVkJyxcbiAgUlRQVmlkZW9NYXBVcGRhdGUgPSAncnRwVmlkZW9NYXBVcGRhdGUnLFxuICBEQ0J1ZmZlclN0YXR1c0NoYW5nZWQgPSAnZGNCdWZmZXJTdGF0dXNDaGFuZ2VkJyxcbiAgUGFydGljaXBhbnRVcGRhdGUgPSAncGFydGljaXBhbnRVcGRhdGUnLFxuICBSb29tVXBkYXRlID0gJ3Jvb21VcGRhdGUnLFxuICBTcGVha2Vyc0NoYW5nZWQgPSAnc3BlYWtlcnNDaGFuZ2VkJyxcbiAgU3RyZWFtU3RhdGVDaGFuZ2VkID0gJ3N0cmVhbVN0YXRlQ2hhbmdlZCcsXG4gIENvbm5lY3Rpb25RdWFsaXR5VXBkYXRlID0gJ2Nvbm5lY3Rpb25RdWFsaXR5VXBkYXRlJyxcbiAgU3Vic2NyaXB0aW9uRXJyb3IgPSAnc3Vic2NyaXB0aW9uRXJyb3InLFxuICBTdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlID0gJ3N1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUnLFxuICBSZW1vdGVNdXRlID0gJ3JlbW90ZU11dGUnLFxuICBTdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSA9ICdzdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZScsXG4gIExvY2FsVHJhY2tVbnB1Ymxpc2hlZCA9ICdsb2NhbFRyYWNrVW5wdWJsaXNoZWQnLFxufVxuXG5leHBvcnQgZW51bSBUcmFja0V2ZW50IHtcbiAgTWVzc2FnZSA9ICdtZXNzYWdlJyxcbiAgTXV0ZWQgPSAnbXV0ZWQnLFxuICBVbm11dGVkID0gJ3VubXV0ZWQnLFxuICAvKipcbiAgICogT25seSBmaXJlcyBvbiBMb2NhbFRyYWNrc1xuICAgKi9cbiAgUmVzdGFydGVkID0gJ3Jlc3RhcnRlZCcsXG4gIEVuZGVkID0gJ2VuZGVkJyxcbiAgU3Vic2NyaWJlZCA9ICdzdWJzY3JpYmVkJyxcbiAgVW5zdWJzY3JpYmVkID0gJ3Vuc3Vic2NyaWJlZCcsXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgVXBkYXRlU2V0dGluZ3MgPSAndXBkYXRlU2V0dGluZ3MnLFxuICAvKiogQGludGVybmFsICovXG4gIFVwZGF0ZVN1YnNjcmlwdGlvbiA9ICd1cGRhdGVTdWJzY3JpcHRpb24nLFxuICAvKiogQGludGVybmFsICovXG4gIEF1ZGlvUGxheWJhY2tTdGFydGVkID0gJ2F1ZGlvUGxheWJhY2tTdGFydGVkJyxcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBBdWRpb1BsYXliYWNrRmFpbGVkID0gJ2F1ZGlvUGxheWJhY2tGYWlsZWQnLFxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIE9ubHkgZmlyZXMgb24gTG9jYWxBdWRpb1RyYWNrIGluc3RhbmNlc1xuICAgKi9cbiAgQXVkaW9TaWxlbmNlRGV0ZWN0ZWQgPSAnYXVkaW9TaWxlbmNlRGV0ZWN0ZWQnLFxuICAvKiogQGludGVybmFsICovXG4gIFZpc2liaWxpdHlDaGFuZ2VkID0gJ3Zpc2liaWxpdHlDaGFuZ2VkJyxcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBWaWRlb0RpbWVuc2lvbnNDaGFuZ2VkID0gJ3ZpZGVvRGltZW5zaW9uc0NoYW5nZWQnLFxuICAvKiogQGludGVybmFsICovXG4gIFZpZGVvUGxheWJhY2tTdGFydGVkID0gJ3ZpZGVvUGxheWJhY2tTdGFydGVkJyxcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBWaWRlb1BsYXliYWNrRmFpbGVkID0gJ3ZpZGVvUGxheWJhY2tGYWlsZWQnLFxuICAvKiogQGludGVybmFsICovXG4gIEVsZW1lbnRBdHRhY2hlZCA9ICdlbGVtZW50QXR0YWNoZWQnLFxuICAvKiogQGludGVybmFsICovXG4gIEVsZW1lbnREZXRhY2hlZCA9ICdlbGVtZW50RGV0YWNoZWQnLFxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIE9ubHkgZmlyZXMgb24gTG9jYWxUcmFja3NcbiAgICovXG4gIFVwc3RyZWFtUGF1c2VkID0gJ3Vwc3RyZWFtUGF1c2VkJyxcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBPbmx5IGZpcmVzIG9uIExvY2FsVHJhY2tzXG4gICAqL1xuICBVcHN0cmVhbVJlc3VtZWQgPSAndXBzdHJlYW1SZXN1bWVkJyxcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBGaXJlcyBvbiBSZW1vdGVUcmFja1B1YmxpY2F0aW9uXG4gICAqL1xuICBTdWJzY3JpcHRpb25QZXJtaXNzaW9uQ2hhbmdlZCA9ICdzdWJzY3JpcHRpb25QZXJtaXNzaW9uQ2hhbmdlZCcsXG4gIC8qKlxuICAgKiBGaXJlcyBvbiBSZW1vdGVUcmFja1B1YmxpY2F0aW9uXG4gICAqL1xuICBTdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkID0gJ3N1YnNjcmlwdGlvblN0YXR1c0NoYW5nZWQnLFxuICAvKipcbiAgICogRmlyZXMgb24gUmVtb3RlVHJhY2tQdWJsaWNhdGlvblxuICAgKi9cbiAgU3Vic2NyaXB0aW9uRmFpbGVkID0gJ3N1YnNjcmlwdGlvbkZhaWxlZCcsXG59XG4iLCJmdW5jdGlvbiByKHIsZSxuKXt2YXIgaSx0LG87dm9pZCAwPT09ZSYmKGU9NTApLHZvaWQgMD09PW4mJihuPXt9KTt2YXIgYT1udWxsIT0oaT1uLmlzSW1tZWRpYXRlKSYmaSx1PW51bGwhPSh0PW4uY2FsbGJhY2spJiZ0LGM9bi5tYXhXYWl0LHY9RGF0ZS5ub3coKSxsPVtdO2Z1bmN0aW9uIGYoKXtpZih2b2lkIDAhPT1jKXt2YXIgcj1EYXRlLm5vdygpLXY7aWYocitlPj1jKXJldHVybiBjLXJ9cmV0dXJuIGV9dmFyIGQ9ZnVuY3Rpb24oKXt2YXIgZT1bXS5zbGljZS5jYWxsKGFyZ3VtZW50cyksbj10aGlzO3JldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihpLHQpe3ZhciBjPWEmJnZvaWQgMD09PW87aWYodm9pZCAwIT09byYmY2xlYXJUaW1lb3V0KG8pLG89c2V0VGltZW91dChmdW5jdGlvbigpe2lmKG89dm9pZCAwLHY9RGF0ZS5ub3coKSwhYSl7dmFyIGk9ci5hcHBseShuLGUpO3UmJnUoaSksbC5mb3JFYWNoKGZ1bmN0aW9uKHIpe3JldHVybigwLHIucmVzb2x2ZSkoaSl9KSxsPVtdfX0sZigpKSxjKXt2YXIgZD1yLmFwcGx5KG4sZSk7cmV0dXJuIHUmJnUoZCksaShkKX1sLnB1c2goe3Jlc29sdmU6aSxyZWplY3Q6dH0pfSl9O3JldHVybiBkLmNhbmNlbD1mdW5jdGlvbihyKXt2b2lkIDAhPT1vJiZjbGVhclRpbWVvdXQobyksbC5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybigwLGUucmVqZWN0KShyKX0pLGw9W119LGR9ZXhwb3J0e3IgYXMgZGVib3VuY2V9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtLmpzLm1hcFxuIiwiLy8gdGlueSwgc2ltcGxpZmllZCB2ZXJzaW9uIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9sYW5jZWRpa3Nvbi9ib3dzZXIvYmxvYi9tYXN0ZXIvc3JjL3BhcnNlci1icm93c2Vycy5qc1xuLy8gcmVkdWNlZCB0byBvbmx5IGRpZmZlcmVudGlhdGUgQ2hyb21lKGl1bSkgYmFzZWQgYnJvd3NlcnMgLyBGaXJlZm94IC8gU2FmYXJpXG5cbmNvbnN0IGNvbW1vblZlcnNpb25JZGVudGlmaWVyID0gL3ZlcnNpb25cXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2k7XG5cbmV4cG9ydCB0eXBlIERldGVjdGFibGVCcm93c2VyID0gJ0Nocm9tZScgfCAnRmlyZWZveCcgfCAnU2FmYXJpJztcbmV4cG9ydCB0eXBlIERldGVjdGFibGVPUyA9ICdpT1MnIHwgJ21hY09TJztcblxuZXhwb3J0IHR5cGUgQnJvd3NlckRldGFpbHMgPSB7XG4gIG5hbWU6IERldGVjdGFibGVCcm93c2VyO1xuICB2ZXJzaW9uOiBzdHJpbmc7XG4gIG9zPzogRGV0ZWN0YWJsZU9TO1xufTtcblxubGV0IGJyb3dzZXJEZXRhaWxzOiBCcm93c2VyRGV0YWlscyB8IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEJyb3dzZXIodXNlckFnZW50Pzogc3RyaW5nLCBmb3JjZSA9IHRydWUpIHtcbiAgaWYgKHR5cGVvZiB1c2VyQWdlbnQgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHVhID0gKHVzZXJBZ2VudCA/PyBuYXZpZ2F0b3IudXNlckFnZW50KS50b0xvd2VyQ2FzZSgpO1xuICBpZiAoYnJvd3NlckRldGFpbHMgPT09IHVuZGVmaW5lZCB8fCBmb3JjZSkge1xuICAgIGNvbnN0IGJyb3dzZXIgPSBicm93c2Vyc0xpc3QuZmluZCgoeyB0ZXN0IH0pID0+IHRlc3QudGVzdCh1YSkpO1xuICAgIGJyb3dzZXJEZXRhaWxzID0gYnJvd3Nlcj8uZGVzY3JpYmUodWEpO1xuICB9XG4gIHJldHVybiBicm93c2VyRGV0YWlscztcbn1cblxuY29uc3QgYnJvd3NlcnNMaXN0ID0gW1xuICB7XG4gICAgdGVzdDogL2ZpcmVmb3h8aWNld2Vhc2VsfGZ4aW9zL2ksXG4gICAgZGVzY3JpYmUodWE6IHN0cmluZykge1xuICAgICAgY29uc3QgYnJvd3NlcjogQnJvd3NlckRldGFpbHMgPSB7XG4gICAgICAgIG5hbWU6ICdGaXJlZm94JyxcbiAgICAgICAgdmVyc2lvbjogZ2V0TWF0Y2goLyg/OmZpcmVmb3h8aWNld2Vhc2VsfGZ4aW9zKVtcXHMvXShcXGQrKFxcLj9fP1xcZCspKykvaSwgdWEpLFxuICAgICAgICBvczogdWEudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnZnhpb3MnKSA/ICdpT1MnIDogdW5kZWZpbmVkLFxuICAgICAgfTtcbiAgICAgIHJldHVybiBicm93c2VyO1xuICAgIH0sXG4gIH0sXG4gIHtcbiAgICB0ZXN0OiAvY2hyb218Y3Jpb3N8Y3Jtby9pLFxuICAgIGRlc2NyaWJlKHVhOiBzdHJpbmcpIHtcbiAgICAgIGNvbnN0IGJyb3dzZXI6IEJyb3dzZXJEZXRhaWxzID0ge1xuICAgICAgICBuYW1lOiAnQ2hyb21lJyxcbiAgICAgICAgdmVyc2lvbjogZ2V0TWF0Y2goLyg/OmNocm9tZXxjaHJvbWl1bXxjcmlvc3xjcm1vKVxcLyhcXGQrKFxcLj9fP1xcZCspKykvaSwgdWEpLFxuICAgICAgICBvczogdWEudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnY3Jpb3MnKSA/ICdpT1MnIDogdW5kZWZpbmVkLFxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGJyb3dzZXI7XG4gICAgfSxcbiAgfSxcbiAgLyogU2FmYXJpICovXG4gIHtcbiAgICB0ZXN0OiAvc2FmYXJpfGFwcGxld2Via2l0L2ksXG4gICAgZGVzY3JpYmUodWE6IHN0cmluZykge1xuICAgICAgY29uc3QgYnJvd3NlcjogQnJvd3NlckRldGFpbHMgPSB7XG4gICAgICAgIG5hbWU6ICdTYWZhcmknLFxuICAgICAgICB2ZXJzaW9uOiBnZXRNYXRjaChjb21tb25WZXJzaW9uSWRlbnRpZmllciwgdWEpLFxuICAgICAgICBvczogdWEuaW5jbHVkZXMoJ21vYmlsZS8nKSA/ICdpT1MnIDogJ21hY09TJyxcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBicm93c2VyO1xuICAgIH0sXG4gIH0sXG5dO1xuXG5mdW5jdGlvbiBnZXRNYXRjaChleHA6IFJlZ0V4cCwgdWE6IHN0cmluZywgaWQgPSAxKSB7XG4gIGNvbnN0IG1hdGNoID0gdWEubWF0Y2goZXhwKTtcbiAgcmV0dXJuIChtYXRjaCAmJiBtYXRjaC5sZW5ndGggPj0gaWQgJiYgbWF0Y2hbaWRdKSB8fCAnJztcbn1cbiIsImltcG9ydCB7IHZlcnNpb24gYXMgdiB9IGZyb20gJy4uL3BhY2thZ2UuanNvbic7XG5cbmV4cG9ydCBjb25zdCB2ZXJzaW9uID0gdjtcbmV4cG9ydCBjb25zdCBwcm90b2NvbFZlcnNpb24gPSAxMTtcbiIsIi8qKlxuICogVGltZXJzIHRoYXQgY2FuIGJlIG92ZXJyaWRkZW4gd2l0aCBwbGF0Zm9ybSBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbnNcbiAqIHRoYXQgZW5zdXJlIHRoYXQgdGhleSBhcmUgZmlyZWQuIFRoZXNlIHNob3VsZCBiZSB1c2VkIHdoZW4gaXQgaXMgY3JpdGljYWxcbiAqIHRoYXQgdGhlIHRpbWVyIGZpcmVzIG9uIHRpbWUuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENyaXRpY2FsVGltZXJzIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1pbXBsaWVkLWV2YWxcbiAgc3RhdGljIHNldFRpbWVvdXQgPSAoLi4uYXJnczogUGFyYW1ldGVyczx0eXBlb2Ygc2V0VGltZW91dD4pID0+IHNldFRpbWVvdXQoLi4uYXJncyk7XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1pbXBsaWVkLWV2YWxcbiAgc3RhdGljIHNldEludGVydmFsID0gKC4uLmFyZ3M6IFBhcmFtZXRlcnM8dHlwZW9mIHNldEludGVydmFsPikgPT4gc2V0SW50ZXJ2YWwoLi4uYXJncyk7XG5cbiAgc3RhdGljIGNsZWFyVGltZW91dCA9ICguLi5hcmdzOiBQYXJhbWV0ZXJzPHR5cGVvZiBjbGVhclRpbWVvdXQ+KSA9PiBjbGVhclRpbWVvdXQoLi4uYXJncyk7XG5cbiAgc3RhdGljIGNsZWFySW50ZXJ2YWwgPSAoLi4uYXJnczogUGFyYW1ldGVyczx0eXBlb2YgY2xlYXJJbnRlcnZhbD4pID0+IGNsZWFySW50ZXJ2YWwoLi4uYXJncyk7XG59XG4iLCJpbXBvcnQgdHlwZSB7IFRyYWNrIH0gZnJvbSAnLi9UcmFjayc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhY2tQdWJsaXNoRGVmYXVsdHMge1xuICAvKipcbiAgICogZW5jb2RpbmcgcGFyYW1ldGVycyBmb3IgY2FtZXJhIHRyYWNrXG4gICAqL1xuICB2aWRlb0VuY29kaW5nPzogVmlkZW9FbmNvZGluZztcblxuICAvKipcbiAgICogTXVsdGktY29kZWMgU2ltdWxjYXN0XG4gICAqIFZQOSBhbmQgQVYxIGFyZSBub3Qgc3VwcG9ydGVkIGJ5IGFsbCBicm93c2VyIGNsaWVudHMuIFdoZW4gYmFja3VwQ29kZWMgaXNcbiAgICogc2V0LCB3aGVuIGFuIGluY29tcGF0aWJsZSBjbGllbnQgYXR0ZW1wdHMgdG8gc3Vic2NyaWJlIHRvIHRoZSB0cmFjaywgTGl2ZUtpdFxuICAgKiB3aWxsIGF1dG9tYXRpY2FsbHkgcHVibGlzaCBhIHNlY29uZGFyeSB0cmFjayBlbmNvZGVkIHdpdGggdGhlIGJhY2t1cCBjb2RlYy5cbiAgICpcbiAgICogWW91IGNvdWxkIGN1c3RvbWl6ZSBzcGVjaWZpYyBlbmNvZGluZyBwYXJhbWV0ZXJzIG9mIHRoZSBiYWNrdXAgdHJhY2sgYnlcbiAgICogZXhwbGljaXRseSBzZXR0aW5nIGNvZGVjIGFuZCBlbmNvZGluZyBmaWVsZHMuXG4gICAqXG4gICAqIERlZmF1bHRzIHRvIGB0cnVlYFxuICAgKi9cbiAgYmFja3VwQ29kZWM/OiB0cnVlIHwgZmFsc2UgfCB7IGNvZGVjOiBCYWNrdXBWaWRlb0NvZGVjOyBlbmNvZGluZz86IFZpZGVvRW5jb2RpbmcgfTtcblxuICAvKipcbiAgICogZW5jb2RpbmcgcGFyYW1ldGVycyBmb3Igc2NyZWVuIHNoYXJlIHRyYWNrXG4gICAqL1xuICBzY3JlZW5TaGFyZUVuY29kaW5nPzogVmlkZW9FbmNvZGluZztcblxuICAvKipcbiAgICogY29kZWMsIGRlZmF1bHRzIHRvIHZwODsgZm9yIHN2YyBjb2RlY3MsIGF1dG8gZW5hYmxlIHZwOFxuICAgKiBhcyBiYWNrdXAuIChUQkQpXG4gICAqL1xuICB2aWRlb0NvZGVjPzogVmlkZW9Db2RlYztcblxuICAvKipcbiAgICogbWF4IGF1ZGlvIGJpdHJhdGUsIGRlZmF1bHRzIHRvIFtbQXVkaW9QcmVzZXRzLm11c2ljXV1cbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBhdWRpb1ByZXNldGAgaW5zdGVhZFxuICAgKi9cbiAgYXVkaW9CaXRyYXRlPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiB3aGljaCBhdWRpbyBwcmVzZXQgc2hvdWxkIGJlIHVzZWQgZm9yIHB1Ymxpc2hpbmcgKGF1ZGlvKSB0cmFja3NcbiAgICogZGVmYXVsdHMgdG8gW1tBdWRpb1ByZXNldHMubXVzaWNdXVxuICAgKi9cbiAgYXVkaW9QcmVzZXQ/OiBBdWRpb1ByZXNldDtcblxuICAvKipcbiAgICogZHR4IChEaXNjb250aW51b3VzIFRyYW5zbWlzc2lvbiBvZiBhdWRpbyksIGVuYWJsZWQgYnkgZGVmYXVsdCBmb3IgbW9ubyB0cmFja3MuXG4gICAqL1xuICBkdHg/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiByZWQgKFJlZHVuZGFudCBBdWRpbyBEYXRhKSwgZW5hYmxlZCBieSBkZWZhdWx0IGZvciBtb25vIHRyYWNrcy5cbiAgICovXG4gIHJlZD86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIHB1Ymxpc2ggdHJhY2sgaW4gc3RlcmVvIG1vZGUgKG9yIHNldCB0byBmYWxzZSB0byBkaXNhYmxlKS4gZGVmYXVsdHMgZGV0ZXJtaW5lZCBieSBjYXB0dXJlIGNoYW5uZWwgY291bnQuXG4gICAqL1xuICBmb3JjZVN0ZXJlbz86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIHVzZSBzaW11bGNhc3QsIGRlZmF1bHRzIHRvIHRydWUuXG4gICAqIFdoZW4gdXNpbmcgc2ltdWxjYXN0LCBMaXZlS2l0IHdpbGwgcHVibGlzaCB1cCB0byB0aHJlZSB2ZXJzaW9ucyBvZiB0aGUgc3RyZWFtXG4gICAqIGF0IHZhcmlvdXMgcmVzb2x1dGlvbnMuXG4gICAqL1xuICBzaW11bGNhc3Q/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBzY2FsYWJpbGl0eSBtb2RlIGZvciBzdmMgY29kZWNzLCBkZWZhdWx0cyB0byAnTDNUMycuXG4gICAqIGZvciBzdmMgY29kZWNzLCBzaW11bGNhc3QgaXMgZGlzYWJsZWQuXG4gICAqL1xuICBzY2FsYWJpbGl0eU1vZGU/OiBTY2FsYWJpbGl0eU1vZGU7XG5cbiAgLyoqXG4gICAqIFVwIHRvIHR3byBhZGRpdGlvbmFsIHNpbXVsY2FzdCBsYXllcnMgdG8gcHVibGlzaCBpbiBhZGRpdGlvbiB0byB0aGUgb3JpZ2luYWxcbiAgICogVHJhY2suXG4gICAqIFdoZW4gbGVmdCBibGFuaywgaXQgZGVmYXVsdHMgdG8gaDE4MCwgaDM2MC5cbiAgICogSWYgYSBTVkMgY29kZWMgaXMgdXNlZCAoVlA5IG9yIEFWMSksIHRoaXMgZmllbGQgaGFzIG5vIGVmZmVjdC5cbiAgICpcbiAgICogVG8gcHVibGlzaCB0aHJlZSB0b3RhbCBsYXllcnMsIHlvdSB3b3VsZCBzcGVjaWZ5OlxuICAgKiB7XG4gICAqICAgdmlkZW9FbmNvZGluZzogey4uLn0sIC8vIGVuY29kaW5nIG9mIHRoZSBwcmltYXJ5IGxheWVyXG4gICAqICAgdmlkZW9TaW11bGNhc3RMYXllcnM6IFtcbiAgICogICAgIFZpZGVvUHJlc2V0cy5oNTQwLFxuICAgKiAgICAgVmlkZW9QcmVzZXRzLmgyMTYsXG4gICAqICAgXSxcbiAgICogfVxuICAgKi9cbiAgdmlkZW9TaW11bGNhc3RMYXllcnM/OiBBcnJheTxWaWRlb1ByZXNldD47XG5cbiAgLyoqXG4gICAqIGN1c3RvbSB2aWRlbyBzaW11bGNhc3QgbGF5ZXJzIGZvciBzY3JlZW4gdHJhY2tzXG4gICAqIE5vdGU6IHRoZSBsYXllcnMgbmVlZCB0byBiZSBvcmRlcmVkIGZyb20gbG93ZXN0IHRvIGhpZ2hlc3QgcXVhbGl0eVxuICAgKi9cbiAgc2NyZWVuU2hhcmVTaW11bGNhc3RMYXllcnM/OiBBcnJheTxWaWRlb1ByZXNldD47XG5cbiAgLyoqXG4gICAqIEZvciBsb2NhbCB0cmFja3MsIHN0b3AgdGhlIHVuZGVybHlpbmcgTWVkaWFTdHJlYW1UcmFjayB3aGVuIHRoZSB0cmFjayBpcyBtdXRlZCAob3IgcGF1c2VkKVxuICAgKiBvbiBzb21lIHBsYXRmb3JtcywgdGhpcyBvcHRpb24gaXMgbmVjZXNzYXJ5IHRvIGRpc2FibGUgdGhlIG1pY3JvcGhvbmUgcmVjb3JkaW5nIGluZGljYXRvci5cbiAgICogTm90ZTogd2hlbiB0aGlzIGlzIGVuYWJsZWQsIGFuZCBCVCBkZXZpY2VzIGFyZSBjb25uZWN0ZWQsIHRoZXkgd2lsbCB0cmFuc2l0aW9uIGJldHdlZW5cbiAgICogcHJvZmlsZXMgKGUuZy4gSEZQIHRvIEEyRFApIGFuZCB0aGVyZSB3aWxsIGJlIGFuIGF1ZGlibGUgZGlmZmVyZW5jZSBpbiBwbGF5YmFjay5cbiAgICpcbiAgICogZGVmYXVsdHMgdG8gZmFsc2VcbiAgICovXG4gIHN0b3BNaWNUcmFja09uTXV0ZT86IGJvb2xlYW47XG59XG5cbi8qKlxuICogT3B0aW9ucyB3aGVuIHB1Ymxpc2hpbmcgdHJhY2tzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVHJhY2tQdWJsaXNoT3B0aW9ucyBleHRlbmRzIFRyYWNrUHVibGlzaERlZmF1bHRzIHtcbiAgLyoqXG4gICAqIHNldCBhIHRyYWNrIG5hbWVcbiAgICovXG4gIG5hbWU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFNvdXJjZSBvZiB0cmFjaywgY2FtZXJhLCBtaWNyb3Bob25lLCBvciBzY3JlZW5cbiAgICovXG4gIHNvdXJjZT86IFRyYWNrLlNvdXJjZTtcblxuICAvKipcbiAgICogU2V0IHN0cmVhbSBuYW1lIGZvciB0aGUgdHJhY2suIEF1ZGlvIGFuZCB2aWRlbyB0cmFja3Mgd2l0aCB0aGUgc2FtZSBzdHJlYW0gbmFtZVxuICAgKiB3aWxsIGJlIHBsYWNlZCBpbiB0aGUgc2FtZSBgTWVkaWFTdHJlYW1gIGFuZCBvZmZlciBiZXR0ZXIgc3luY2hyb25pemF0aW9uLlxuICAgKiBCeSBkZWZhdWx0LCBjYW1lcmEgYW5kIG1pY3JvcGhvbmUgd2lsbCBiZSBwbGFjZWQgaW4gYSBzdHJlYW07IGFzIHdvdWxkIHNjcmVlbl9zaGFyZSBhbmQgc2NyZWVuX3NoYXJlX2F1ZGlvXG4gICAqL1xuICBzdHJlYW0/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ3JlYXRlTG9jYWxUcmFja3NPcHRpb25zIHtcbiAgLyoqXG4gICAqIGF1ZGlvIHRyYWNrIG9wdGlvbnMsIHRydWUgdG8gY3JlYXRlIHdpdGggZGVmYXVsdHMuIGZhbHNlIGlmIGF1ZGlvIHNob3VsZG4ndCBiZSBjcmVhdGVkXG4gICAqIGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgYXVkaW8/OiBib29sZWFuIHwgQXVkaW9DYXB0dXJlT3B0aW9ucztcblxuICAvKipcbiAgICogdmlkZW8gdHJhY2sgb3B0aW9ucywgdHJ1ZSB0byBjcmVhdGUgd2l0aCBkZWZhdWx0cy4gZmFsc2UgaWYgdmlkZW8gc2hvdWxkbid0IGJlIGNyZWF0ZWRcbiAgICogZGVmYXVsdCB0cnVlXG4gICAqL1xuICB2aWRlbz86IGJvb2xlYW4gfCBWaWRlb0NhcHR1cmVPcHRpb25zO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFZpZGVvQ2FwdHVyZU9wdGlvbnMge1xuICAvKipcbiAgICogQSBDb25zdHJhaW5ET01TdHJpbmcgb2JqZWN0IHNwZWNpZnlpbmcgYSBkZXZpY2UgSUQgb3IgYW4gYXJyYXkgb2YgZGV2aWNlXG4gICAqIElEcyB3aGljaCBhcmUgYWNjZXB0YWJsZSBhbmQvb3IgcmVxdWlyZWQuXG4gICAqL1xuICBkZXZpY2VJZD86IENvbnN0cmFpbkRPTVN0cmluZztcblxuICAvKipcbiAgICogYSBmYWNpbmcgb3IgYW4gYXJyYXkgb2YgZmFjaW5ncyB3aGljaCBhcmUgYWNjZXB0YWJsZSBhbmQvb3IgcmVxdWlyZWQuXG4gICAqL1xuICBmYWNpbmdNb2RlPzogJ3VzZXInIHwgJ2Vudmlyb25tZW50JyB8ICdsZWZ0JyB8ICdyaWdodCc7XG5cbiAgcmVzb2x1dGlvbj86IFZpZGVvUmVzb2x1dGlvbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTY3JlZW5TaGFyZUNhcHR1cmVPcHRpb25zIHtcbiAgLyoqXG4gICAqIHRydWUgdG8gY2FwdHVyZSBhdWRpbyBzaGFyZWQuIGJyb3dzZXIgc3VwcG9ydCBmb3IgYXVkaW8gY2FwdHVyaW5nIGluXG4gICAqIHNjcmVlbnNoYXJlIGlzIGxpbWl0ZWQ6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9NZWRpYURldmljZXMvZ2V0RGlzcGxheU1lZGlhI2Jyb3dzZXJfY29tcGF0aWJpbGl0eVxuICAgKi9cbiAgYXVkaW8/OiBib29sZWFuIHwgQXVkaW9DYXB0dXJlT3B0aW9ucztcblxuICAvKipcbiAgICogb25seSBhbGxvd3MgZm9yICd0cnVlJyBhbmQgY2hyb21lIGFsbG93cyBmb3IgYWRkaXRpb25hbCBvcHRpb25zIHRvIGJlIHBhc3NlZCBpblxuICAgKiBodHRwczovL2RldmVsb3Blci5jaHJvbWUuY29tL2RvY3Mvd2ViLXBsYXRmb3JtL3NjcmVlbi1zaGFyaW5nLWNvbnRyb2xzLyNkaXNwbGF5U3VyZmFjZVxuICAgKi9cbiAgdmlkZW8/OiB0cnVlIHwgeyBkaXNwbGF5U3VyZmFjZT86ICd3aW5kb3cnIHwgJ2Jyb3dzZXInIHwgJ21vbml0b3InIH07XG5cbiAgLyoqXG4gICAqIGNhcHR1cmUgcmVzb2x1dGlvbiwgZGVmYXVsdHMgdG8gMTA4MCBmb3IgYWxsIGJyb3dzZXJzIG90aGVyIHRoYW4gU2FmYXJpXG4gICAqIE9uIFNhZmFyaSAxNywgZGVmYXVsdCByZXNvbHV0aW9uIGlzIG5vdCBjYXBwZWQsIGR1ZSB0byBhIGJ1Zywgc3BlY2lmeWluZ1xuICAgKiBhbnkgcmVzb2x1dGlvbiBhdCBhbGwgd291bGQgbGVhZCB0byBhIGxvdy1yZXNvbHV0aW9uIGNhcHR1cmUuXG4gICAqIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yNjMwMTVcbiAgICovXG4gIHJlc29sdXRpb24/OiBWaWRlb1Jlc29sdXRpb247XG5cbiAgLyoqIGEgQ2FwdHVyZUNvbnRyb2xsZXIgb2JqZWN0IGluc3RhbmNlIGNvbnRhaW5pbmcgbWV0aG9kcyB0aGF0IGNhbiBiZSB1c2VkIHRvIGZ1cnRoZXIgbWFuaXB1bGF0ZSB0aGUgY2FwdHVyZSBzZXNzaW9uIGlmIGluY2x1ZGVkLiAqL1xuICBjb250cm9sbGVyPzogdW5rbm93bjsgLy8gVE9ETyByZXBsYWNlIHR5cGUgd2l0aCBDYXB0dXJlQ29udHJvbGxlciBvbmNlIGl0IGxhbmRzIGluIFR5cGVTY3JpcHRcblxuICAvKiogc3BlY2lmaWVzIHdoZXRoZXIgdGhlIGJyb3dzZXIgc2hvdWxkIGFsbG93IHRoZSB1c2VyIHRvIHNlbGVjdCB0aGUgY3VycmVudCB0YWIgZm9yIGNhcHR1cmUgKi9cbiAgc2VsZkJyb3dzZXJTdXJmYWNlPzogJ2luY2x1ZGUnIHwgJ2V4Y2x1ZGUnO1xuXG4gIC8qKiBzcGVjaWZpZXMgd2hldGhlciB0aGUgYnJvd3NlciBzaG91bGQgZGlzcGxheSBhIGNvbnRyb2wgdG8gYWxsb3cgdGhlIHVzZXIgdG8gZHluYW1pY2FsbHkgc3dpdGNoIHRoZSBzaGFyZWQgdGFiIGR1cmluZyBzY3JlZW4tc2hhcmluZy4gKi9cbiAgc3VyZmFjZVN3aXRjaGluZz86ICdpbmNsdWRlJyB8ICdleGNsdWRlJztcblxuICAvKiogc3BlY2lmaWVzIHdoZXRoZXIgdGhlIGJyb3dzZXIgc2hvdWxkIGluY2x1ZGUgdGhlIHN5c3RlbSBhdWRpbyBhbW9uZyB0aGUgcG9zc2libGUgYXVkaW8gc291cmNlcyBvZmZlcmVkIHRvIHRoZSB1c2VyICovXG4gIHN5c3RlbUF1ZGlvPzogJ2luY2x1ZGUnIHwgJ2V4Y2x1ZGUnO1xuXG4gIC8qKiBzcGVjaWZ5IHRoZSB0eXBlIG9mIGNvbnRlbnQsIHNlZTogaHR0cHM6Ly93d3cudzMub3JnL1RSL21zdC1jb250ZW50LWhpbnQvI3ZpZGVvLWNvbnRlbnQtaGludHMgKi9cbiAgY29udGVudEhpbnQ/OiAnZGV0YWlsJyB8ICd0ZXh0JyB8ICdtb3Rpb24nO1xuXG4gIC8qKlxuICAgKiBFeHBlcmltZW50YWwgb3B0aW9uIHRvIGNvbnRyb2wgd2hldGhlciB0aGUgYXVkaW8gcGxheWluZyBpbiBhIHRhYiB3aWxsIGNvbnRpbnVlIHRvIGJlIHBsYXllZCBvdXQgb2YgYSB1c2VyJ3NcbiAgICogbG9jYWwgc3BlYWtlcnMgd2hlbiB0aGUgdGFiIGlzIGNhcHR1cmVkLlxuICAgKi9cbiAgc3VwcHJlc3NMb2NhbEF1ZGlvUGxheWJhY2s/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEF1ZGlvQ2FwdHVyZU9wdGlvbnMge1xuICAvKipcbiAgICogc3BlY2lmaWVzIHdoZXRoZXIgYXV0b21hdGljIGdhaW4gY29udHJvbCBpcyBwcmVmZXJyZWQgYW5kL29yIHJlcXVpcmVkXG4gICAqL1xuICBhdXRvR2FpbkNvbnRyb2w/OiBDb25zdHJhaW5Cb29sZWFuO1xuXG4gIC8qKlxuICAgKiB0aGUgY2hhbm5lbCBjb3VudCBvciByYW5nZSBvZiBjaGFubmVsIGNvdW50cyB3aGljaCBhcmUgYWNjZXB0YWJsZSBhbmQvb3IgcmVxdWlyZWRcbiAgICovXG4gIGNoYW5uZWxDb3VudD86IENvbnN0cmFpblVMb25nO1xuXG4gIC8qKlxuICAgKiBBIENvbnN0cmFpbkRPTVN0cmluZyBvYmplY3Qgc3BlY2lmeWluZyBhIGRldmljZSBJRCBvciBhbiBhcnJheSBvZiBkZXZpY2VcbiAgICogSURzIHdoaWNoIGFyZSBhY2NlcHRhYmxlIGFuZC9vciByZXF1aXJlZC5cbiAgICovXG4gIGRldmljZUlkPzogQ29uc3RyYWluRE9NU3RyaW5nO1xuXG4gIC8qKlxuICAgKiB3aGV0aGVyIG9yIG5vdCBlY2hvIGNhbmNlbGxhdGlvbiBpcyBwcmVmZXJyZWQgYW5kL29yIHJlcXVpcmVkXG4gICAqL1xuICBlY2hvQ2FuY2VsbGF0aW9uPzogQ29uc3RyYWluQm9vbGVhbjtcblxuICAvKipcbiAgICogdGhlIGxhdGVuY3kgb3IgcmFuZ2Ugb2YgbGF0ZW5jaWVzIHdoaWNoIGFyZSBhY2NlcHRhYmxlIGFuZC9vciByZXF1aXJlZC5cbiAgICovXG4gIGxhdGVuY3k/OiBDb25zdHJhaW5Eb3VibGU7XG5cbiAgLyoqXG4gICAqIHdoZXRoZXIgbm9pc2Ugc3VwcHJlc3Npb24gaXMgcHJlZmVycmVkIGFuZC9vciByZXF1aXJlZC5cbiAgICovXG4gIG5vaXNlU3VwcHJlc3Npb24/OiBDb25zdHJhaW5Cb29sZWFuO1xuXG4gIC8qKlxuICAgKiB0aGUgc2FtcGxlIHJhdGUgb3IgcmFuZ2Ugb2Ygc2FtcGxlIHJhdGVzIHdoaWNoIGFyZSBhY2NlcHRhYmxlIGFuZC9vciByZXF1aXJlZC5cbiAgICovXG4gIHNhbXBsZVJhdGU/OiBDb25zdHJhaW5VTG9uZztcblxuICAvKipcbiAgICogc2FtcGxlIHNpemUgb3IgcmFuZ2Ugb2Ygc2FtcGxlIHNpemVzIHdoaWNoIGFyZSBhY2NlcHRhYmxlIGFuZC9vciByZXF1aXJlZC5cbiAgICovXG4gIHNhbXBsZVNpemU/OiBDb25zdHJhaW5VTG9uZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBdWRpb091dHB1dE9wdGlvbnMge1xuICAvKipcbiAgICogZGV2aWNlSWQgdG8gb3V0cHV0IGF1ZGlvXG4gICAqXG4gICAqIE9ubHkgc3VwcG9ydGVkIG9uIGJyb3dzZXJzIHdoZXJlIGBzZXRTaW5rSWRgIGlzIGF2YWlsYWJsZVxuICAgKi9cbiAgZGV2aWNlSWQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmlkZW9SZXNvbHV0aW9uIHtcbiAgd2lkdGg6IG51bWJlcjtcbiAgaGVpZ2h0OiBudW1iZXI7XG4gIGZyYW1lUmF0ZT86IG51bWJlcjtcbiAgYXNwZWN0UmF0aW8/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmlkZW9FbmNvZGluZyB7XG4gIG1heEJpdHJhdGU6IG51bWJlcjtcbiAgbWF4RnJhbWVyYXRlPzogbnVtYmVyO1xuICBwcmlvcml0eT86IFJUQ1ByaW9yaXR5VHlwZTtcbn1cblxuZXhwb3J0IGNsYXNzIFZpZGVvUHJlc2V0IHtcbiAgZW5jb2Rpbmc6IFZpZGVvRW5jb2Rpbmc7XG5cbiAgd2lkdGg6IG51bWJlcjtcblxuICBoZWlnaHQ6IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICB3aWR0aDogbnVtYmVyLFxuICAgIGhlaWdodDogbnVtYmVyLFxuICAgIG1heEJpdHJhdGU6IG51bWJlcixcbiAgICBtYXhGcmFtZXJhdGU/OiBudW1iZXIsXG4gICAgcHJpb3JpdHk/OiBSVENQcmlvcml0eVR5cGUsXG4gICkge1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLmVuY29kaW5nID0ge1xuICAgICAgbWF4Qml0cmF0ZSxcbiAgICAgIG1heEZyYW1lcmF0ZSxcbiAgICAgIHByaW9yaXR5LFxuICAgIH07XG4gIH1cblxuICBnZXQgcmVzb2x1dGlvbigpOiBWaWRlb1Jlc29sdXRpb24ge1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICBmcmFtZVJhdGU6IHRoaXMuZW5jb2RpbmcubWF4RnJhbWVyYXRlLFxuICAgICAgYXNwZWN0UmF0aW86IHRoaXMud2lkdGggLyB0aGlzLmhlaWdodCxcbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXVkaW9QcmVzZXQge1xuICBtYXhCaXRyYXRlOiBudW1iZXI7XG4gIHByaW9yaXR5PzogUlRDUHJpb3JpdHlUeXBlO1xufVxuXG5jb25zdCBiYWNrdXBDb2RlY3MgPSBbJ3ZwOCcsICdoMjY0J10gYXMgY29uc3Q7XG5cbmV4cG9ydCBjb25zdCB2aWRlb0NvZGVjcyA9IFsndnA4JywgJ2gyNjQnLCAndnA5JywgJ2F2MSddIGFzIGNvbnN0O1xuXG5leHBvcnQgdHlwZSBWaWRlb0NvZGVjID0gKHR5cGVvZiB2aWRlb0NvZGVjcylbbnVtYmVyXTtcblxuZXhwb3J0IHR5cGUgQmFja3VwVmlkZW9Db2RlYyA9ICh0eXBlb2YgYmFja3VwQ29kZWNzKVtudW1iZXJdO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNCYWNrdXBDb2RlYyhjb2RlYzogc3RyaW5nKTogY29kZWMgaXMgQmFja3VwVmlkZW9Db2RlYyB7XG4gIHJldHVybiAhIWJhY2t1cENvZGVjcy5maW5kKChiYWNrdXApID0+IGJhY2t1cCA9PT0gY29kZWMpO1xufVxuXG4vKipcbiAqIHNjYWxhYmlsaXR5IG1vZGVzIGZvciBzdmMuXG4gKi9cbmV4cG9ydCB0eXBlIFNjYWxhYmlsaXR5TW9kZSA9ICdMMVQzJyB8ICdMMlQzJyB8ICdMMlQzX0tFWScgfCAnTDNUMycgfCAnTDNUM19LRVknO1xuXG5leHBvcnQgbmFtZXNwYWNlIEF1ZGlvUHJlc2V0cyB7XG4gIGV4cG9ydCBjb25zdCB0ZWxlcGhvbmU6IEF1ZGlvUHJlc2V0ID0ge1xuICAgIG1heEJpdHJhdGU6IDEyXzAwMCxcbiAgfTtcbiAgZXhwb3J0IGNvbnN0IHNwZWVjaDogQXVkaW9QcmVzZXQgPSB7XG4gICAgbWF4Qml0cmF0ZTogMjBfMDAwLFxuICB9O1xuICBleHBvcnQgY29uc3QgbXVzaWM6IEF1ZGlvUHJlc2V0ID0ge1xuICAgIG1heEJpdHJhdGU6IDMyXzAwMCxcbiAgfTtcbiAgZXhwb3J0IGNvbnN0IG11c2ljU3RlcmVvOiBBdWRpb1ByZXNldCA9IHtcbiAgICBtYXhCaXRyYXRlOiA0OF8wMDAsXG4gIH07XG4gIGV4cG9ydCBjb25zdCBtdXNpY0hpZ2hRdWFsaXR5OiBBdWRpb1ByZXNldCA9IHtcbiAgICBtYXhCaXRyYXRlOiA2NF8wMDAsXG4gIH07XG4gIGV4cG9ydCBjb25zdCBtdXNpY0hpZ2hRdWFsaXR5U3RlcmVvOiBBdWRpb1ByZXNldCA9IHtcbiAgICBtYXhCaXRyYXRlOiA5Nl8wMDAsXG4gIH07XG59XG5cbi8qKlxuICogU2FuZSBwcmVzZXRzIGZvciB2aWRlbyByZXNvbHV0aW9uL2VuY29kaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBWaWRlb1ByZXNldHMgPSB7XG4gIGg5MDogbmV3IFZpZGVvUHJlc2V0KDE2MCwgOTAsIDkwXzAwMCwgMjApLFxuICBoMTgwOiBuZXcgVmlkZW9QcmVzZXQoMzIwLCAxODAsIDE2MF8wMDAsIDIwKSxcbiAgaDIxNjogbmV3IFZpZGVvUHJlc2V0KDM4NCwgMjE2LCAxODBfMDAwLCAyMCksXG4gIGgzNjA6IG5ldyBWaWRlb1ByZXNldCg2NDAsIDM2MCwgNDUwXzAwMCwgMjApLFxuICBoNTQwOiBuZXcgVmlkZW9QcmVzZXQoOTYwLCA1NDAsIDgwMF8wMDAsIDI1KSxcbiAgaDcyMDogbmV3IFZpZGVvUHJlc2V0KDEyODAsIDcyMCwgMV83MDBfMDAwLCAzMCksXG4gIGgxMDgwOiBuZXcgVmlkZW9QcmVzZXQoMTkyMCwgMTA4MCwgM18wMDBfMDAwLCAzMCksXG4gIGgxNDQwOiBuZXcgVmlkZW9QcmVzZXQoMjU2MCwgMTQ0MCwgNV8wMDBfMDAwLCAzMCksXG4gIGgyMTYwOiBuZXcgVmlkZW9QcmVzZXQoMzg0MCwgMjE2MCwgOF8wMDBfMDAwLCAzMCksXG59IGFzIGNvbnN0O1xuXG4vKipcbiAqIEZvdXIgYnkgdGhyZWUgcHJlc2V0c1xuICovXG5leHBvcnQgY29uc3QgVmlkZW9QcmVzZXRzNDMgPSB7XG4gIGgxMjA6IG5ldyBWaWRlb1ByZXNldCgxNjAsIDEyMCwgNzBfMDAwLCAyMCksXG4gIGgxODA6IG5ldyBWaWRlb1ByZXNldCgyNDAsIDE4MCwgMTI1XzAwMCwgMjApLFxuICBoMjQwOiBuZXcgVmlkZW9QcmVzZXQoMzIwLCAyNDAsIDE0MF8wMDAsIDIwKSxcbiAgaDM2MDogbmV3IFZpZGVvUHJlc2V0KDQ4MCwgMzYwLCAzMzBfMDAwLCAyMCksXG4gIGg0ODA6IG5ldyBWaWRlb1ByZXNldCg2NDAsIDQ4MCwgNTAwXzAwMCwgMjApLFxuICBoNTQwOiBuZXcgVmlkZW9QcmVzZXQoNzIwLCA1NDAsIDYwMF8wMDAsIDI1KSxcbiAgaDcyMDogbmV3IFZpZGVvUHJlc2V0KDk2MCwgNzIwLCAxXzMwMF8wMDAsIDMwKSxcbiAgaDEwODA6IG5ldyBWaWRlb1ByZXNldCgxNDQwLCAxMDgwLCAyXzMwMF8wMDAsIDMwKSxcbiAgaDE0NDA6IG5ldyBWaWRlb1ByZXNldCgxOTIwLCAxNDQwLCAzXzgwMF8wMDAsIDMwKSxcbn0gYXMgY29uc3Q7XG5cbmV4cG9ydCBjb25zdCBTY3JlZW5TaGFyZVByZXNldHMgPSB7XG4gIGgzNjBmcHMzOiBuZXcgVmlkZW9QcmVzZXQoNjQwLCAzNjAsIDIwMF8wMDAsIDMsICdtZWRpdW0nKSxcbiAgaDM2MGZwczE1OiBuZXcgVmlkZW9QcmVzZXQoNjQwLCAzNjAsIDQwMF8wMDAsIDE1LCAnbWVkaXVtJyksXG4gIGg3MjBmcHM1OiBuZXcgVmlkZW9QcmVzZXQoMTI4MCwgNzIwLCA4MDBfMDAwLCA1LCAnbWVkaXVtJyksXG4gIGg3MjBmcHMxNTogbmV3IFZpZGVvUHJlc2V0KDEyODAsIDcyMCwgMV81MDBfMDAwLCAxNSwgJ21lZGl1bScpLFxuICBoNzIwZnBzMzA6IG5ldyBWaWRlb1ByZXNldCgxMjgwLCA3MjAsIDJfMDAwXzAwMCwgMzAsICdtZWRpdW0nKSxcbiAgaDEwODBmcHMxNTogbmV3IFZpZGVvUHJlc2V0KDE5MjAsIDEwODAsIDJfNTAwXzAwMCwgMTUsICdtZWRpdW0nKSxcbiAgaDEwODBmcHMzMDogbmV3IFZpZGVvUHJlc2V0KDE5MjAsIDEwODAsIDVfMDAwXzAwMCwgMzAsICdtZWRpdW0nKSxcbiAgLy8gb3JpZ2luYWwgcmVzb2x1dGlvbiwgd2l0aG91dCByZXNpemluZ1xuICBvcmlnaW5hbDogbmV3IFZpZGVvUHJlc2V0KDAsIDAsIDdfMDAwXzAwMCwgMzAsICdtZWRpdW0nKSxcbn0gYXMgY29uc3Q7XG4iLCIvLyBDb3B5cmlnaHQgMjAyMyBMaXZlS2l0LCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4vLyBAZ2VuZXJhdGVkIGJ5IHByb3RvYy1nZW4tZXMgdjEuNC4yIHdpdGggcGFyYW1ldGVyIFwidGFyZ2V0PXRzXCJcbi8vIEBnZW5lcmF0ZWQgZnJvbSBmaWxlIGxpdmVraXRfcnRjLnByb3RvIChwYWNrYWdlIGxpdmVraXQsIHN5bnRheCBwcm90bzMpXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLy8gQHRzLW5vY2hlY2tcblxuaW1wb3J0IHR5cGUgeyBCaW5hcnlSZWFkT3B0aW9ucywgRmllbGRMaXN0LCBKc29uUmVhZE9wdGlvbnMsIEpzb25WYWx1ZSwgUGFydGlhbE1lc3NhZ2UsIFBsYWluTWVzc2FnZSB9IGZyb20gXCJAYnVmYnVpbGQvcHJvdG9idWZcIjtcbmltcG9ydCB7IE1lc3NhZ2UsIHByb3RvMywgcHJvdG9JbnQ2NCB9IGZyb20gXCJAYnVmYnVpbGQvcHJvdG9idWZcIjtcbmltcG9ydCB7IENsaWVudENvbmZpZ3VyYXRpb24sIENvbm5lY3Rpb25RdWFsaXR5LCBEaXNjb25uZWN0UmVhc29uLCBFbmNyeXB0aW9uX1R5cGUsIFBhcnRpY2lwYW50SW5mbywgUGFydGljaXBhbnRUcmFja3MsIFJvb20sIFNlcnZlckluZm8sIFNwZWFrZXJJbmZvLCBTdWJzY3JpcHRpb25FcnJvciwgVHJhY2tJbmZvLCBUcmFja1NvdXJjZSwgVHJhY2tUeXBlLCBWaWRlb0xheWVyLCBWaWRlb1F1YWxpdHkgfSBmcm9tIFwiLi9saXZla2l0X21vZGVsc19wYi5qc1wiO1xuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIGxpdmVraXQuU2lnbmFsVGFyZ2V0XG4gKi9cbmV4cG9ydCBlbnVtIFNpZ25hbFRhcmdldCB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogUFVCTElTSEVSID0gMDtcbiAgICovXG4gIFBVQkxJU0hFUiA9IDAsXG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBTVUJTQ1JJQkVSID0gMTtcbiAgICovXG4gIFNVQlNDUklCRVIgPSAxLFxufVxuLy8gUmV0cmlldmUgZW51bSBtZXRhZGF0YSB3aXRoOiBwcm90bzMuZ2V0RW51bVR5cGUoU2lnbmFsVGFyZ2V0KVxucHJvdG8zLnV0aWwuc2V0RW51bVR5cGUoU2lnbmFsVGFyZ2V0LCBcImxpdmVraXQuU2lnbmFsVGFyZ2V0XCIsIFtcbiAgeyBubzogMCwgbmFtZTogXCJQVUJMSVNIRVJcIiB9LFxuICB7IG5vOiAxLCBuYW1lOiBcIlNVQlNDUklCRVJcIiB9LFxuXSk7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIGVudW0gbGl2ZWtpdC5TdHJlYW1TdGF0ZVxuICovXG5leHBvcnQgZW51bSBTdHJlYW1TdGF0ZSB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogQUNUSVZFID0gMDtcbiAgICovXG4gIEFDVElWRSA9IDAsXG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBQQVVTRUQgPSAxO1xuICAgKi9cbiAgUEFVU0VEID0gMSxcbn1cbi8vIFJldHJpZXZlIGVudW0gbWV0YWRhdGEgd2l0aDogcHJvdG8zLmdldEVudW1UeXBlKFN0cmVhbVN0YXRlKVxucHJvdG8zLnV0aWwuc2V0RW51bVR5cGUoU3RyZWFtU3RhdGUsIFwibGl2ZWtpdC5TdHJlYW1TdGF0ZVwiLCBbXG4gIHsgbm86IDAsIG5hbWU6IFwiQUNUSVZFXCIgfSxcbiAgeyBubzogMSwgbmFtZTogXCJQQVVTRURcIiB9LFxuXSk7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIGVudW0gbGl2ZWtpdC5DYW5kaWRhdGVQcm90b2NvbFxuICovXG5leHBvcnQgZW51bSBDYW5kaWRhdGVQcm90b2NvbCB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogVURQID0gMDtcbiAgICovXG4gIFVEUCA9IDAsXG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBUQ1AgPSAxO1xuICAgKi9cbiAgVENQID0gMSxcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFRMUyA9IDI7XG4gICAqL1xuICBUTFMgPSAyLFxufVxuLy8gUmV0cmlldmUgZW51bSBtZXRhZGF0YSB3aXRoOiBwcm90bzMuZ2V0RW51bVR5cGUoQ2FuZGlkYXRlUHJvdG9jb2wpXG5wcm90bzMudXRpbC5zZXRFbnVtVHlwZShDYW5kaWRhdGVQcm90b2NvbCwgXCJsaXZla2l0LkNhbmRpZGF0ZVByb3RvY29sXCIsIFtcbiAgeyBubzogMCwgbmFtZTogXCJVRFBcIiB9LFxuICB7IG5vOiAxLCBuYW1lOiBcIlRDUFwiIH0sXG4gIHsgbm86IDIsIG5hbWU6IFwiVExTXCIgfSxcbl0pO1xuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuU2lnbmFsUmVxdWVzdFxuICovXG5leHBvcnQgY2xhc3MgU2lnbmFsUmVxdWVzdCBleHRlbmRzIE1lc3NhZ2U8U2lnbmFsUmVxdWVzdD4ge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIG9uZW9mIGxpdmVraXQuU2lnbmFsUmVxdWVzdC5tZXNzYWdlXG4gICAqL1xuICBtZXNzYWdlOiB7XG4gICAgLyoqXG4gICAgICogaW5pdGlhbCBqb2luIGV4Y2hhbmdlLCBmb3IgcHVibGlzaGVyXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuU2Vzc2lvbkRlc2NyaXB0aW9uIG9mZmVyID0gMTtcbiAgICAgKi9cbiAgICB2YWx1ZTogU2Vzc2lvbkRlc2NyaXB0aW9uO1xuICAgIGNhc2U6IFwib2ZmZXJcIjtcbiAgfSB8IHtcbiAgICAvKipcbiAgICAgKiBwYXJ0aWNpcGFudCBhbnN3ZXJpbmcgcHVibGlzaGVyIG9mZmVyXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuU2Vzc2lvbkRlc2NyaXB0aW9uIGFuc3dlciA9IDI7XG4gICAgICovXG4gICAgdmFsdWU6IFNlc3Npb25EZXNjcmlwdGlvbjtcbiAgICBjYXNlOiBcImFuc3dlclwiO1xuICB9IHwge1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5Ucmlja2xlUmVxdWVzdCB0cmlja2xlID0gMztcbiAgICAgKi9cbiAgICB2YWx1ZTogVHJpY2tsZVJlcXVlc3Q7XG4gICAgY2FzZTogXCJ0cmlja2xlXCI7XG4gIH0gfCB7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LkFkZFRyYWNrUmVxdWVzdCBhZGRfdHJhY2sgPSA0O1xuICAgICAqL1xuICAgIHZhbHVlOiBBZGRUcmFja1JlcXVlc3Q7XG4gICAgY2FzZTogXCJhZGRUcmFja1wiO1xuICB9IHwge1xuICAgIC8qKlxuICAgICAqIG11dGUgdGhlIHBhcnRpY2lwYW50J3MgcHVibGlzaGVkIHRyYWNrc1xuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0Lk11dGVUcmFja1JlcXVlc3QgbXV0ZSA9IDU7XG4gICAgICovXG4gICAgdmFsdWU6IE11dGVUcmFja1JlcXVlc3Q7XG4gICAgY2FzZTogXCJtdXRlXCI7XG4gIH0gfCB7XG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlIG9yIHVuc3Vic2NyaWJlIGZyb20gdHJhY2tzXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuVXBkYXRlU3Vic2NyaXB0aW9uIHN1YnNjcmlwdGlvbiA9IDY7XG4gICAgICovXG4gICAgdmFsdWU6IFVwZGF0ZVN1YnNjcmlwdGlvbjtcbiAgICBjYXNlOiBcInN1YnNjcmlwdGlvblwiO1xuICB9IHwge1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBzZXR0aW5ncyBvZiBzdWJzY3JpYmVkIHRyYWNrc1xuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LlVwZGF0ZVRyYWNrU2V0dGluZ3MgdHJhY2tfc2V0dGluZyA9IDc7XG4gICAgICovXG4gICAgdmFsdWU6IFVwZGF0ZVRyYWNrU2V0dGluZ3M7XG4gICAgY2FzZTogXCJ0cmFja1NldHRpbmdcIjtcbiAgfSB8IHtcbiAgICAvKipcbiAgICAgKiBJbW1lZGlhdGVseSB0ZXJtaW5hdGUgc2Vzc2lvblxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LkxlYXZlUmVxdWVzdCBsZWF2ZSA9IDg7XG4gICAgICovXG4gICAgdmFsdWU6IExlYXZlUmVxdWVzdDtcbiAgICBjYXNlOiBcImxlYXZlXCI7XG4gIH0gfCB7XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHB1Ymxpc2hlZCB2aWRlbyBsYXllcnNcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5VcGRhdGVWaWRlb0xheWVycyB1cGRhdGVfbGF5ZXJzID0gMTA7XG4gICAgICovXG4gICAgdmFsdWU6IFVwZGF0ZVZpZGVvTGF5ZXJzO1xuICAgIGNhc2U6IFwidXBkYXRlTGF5ZXJzXCI7XG4gIH0gfCB7XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHN1YnNjcmliZXIgcGVybWlzc2lvbnNcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5TdWJzY3JpcHRpb25QZXJtaXNzaW9uIHN1YnNjcmlwdGlvbl9wZXJtaXNzaW9uID0gMTE7XG4gICAgICovXG4gICAgdmFsdWU6IFN1YnNjcmlwdGlvblBlcm1pc3Npb247XG4gICAgY2FzZTogXCJzdWJzY3JpcHRpb25QZXJtaXNzaW9uXCI7XG4gIH0gfCB7XG4gICAgLyoqXG4gICAgICogc3luYyBjbGllbnQncyBzdWJzY3JpYmUgc3RhdGUgdG8gc2VydmVyIGR1cmluZyByZWNvbm5lY3RcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5TeW5jU3RhdGUgc3luY19zdGF0ZSA9IDEyO1xuICAgICAqL1xuICAgIHZhbHVlOiBTeW5jU3RhdGU7XG4gICAgY2FzZTogXCJzeW5jU3RhdGVcIjtcbiAgfSB8IHtcbiAgICAvKipcbiAgICAgKiBTaW11bGF0ZSBjb25kaXRpb25zLCBmb3IgY2xpZW50IHZhbGlkYXRpb25zXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuU2ltdWxhdGVTY2VuYXJpbyBzaW11bGF0ZSA9IDEzO1xuICAgICAqL1xuICAgIHZhbHVlOiBTaW11bGF0ZVNjZW5hcmlvO1xuICAgIGNhc2U6IFwic2ltdWxhdGVcIjtcbiAgfSB8IHtcbiAgICAvKipcbiAgICAgKiBjbGllbnQgdHJpZ2dlcmVkIHBpbmcgdG8gc2VydmVyXG4gICAgICpcbiAgICAgKiBkZXByZWNhdGVkIGJ5IHBpbmdfcmVxIChtZXNzYWdlIFBpbmcpXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGludDY0IHBpbmcgPSAxNDtcbiAgICAgKi9cbiAgICB2YWx1ZTogYmlnaW50O1xuICAgIGNhc2U6IFwicGluZ1wiO1xuICB9IHwge1xuICAgIC8qKlxuICAgICAqIHVwZGF0ZSBhIHBhcnRpY2lwYW50J3Mgb3duIG1ldGFkYXRhIGFuZC9vciBuYW1lXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuVXBkYXRlUGFydGljaXBhbnRNZXRhZGF0YSB1cGRhdGVfbWV0YWRhdGEgPSAxNTtcbiAgICAgKi9cbiAgICB2YWx1ZTogVXBkYXRlUGFydGljaXBhbnRNZXRhZGF0YTtcbiAgICBjYXNlOiBcInVwZGF0ZU1ldGFkYXRhXCI7XG4gIH0gfCB7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LlBpbmcgcGluZ19yZXEgPSAxNjtcbiAgICAgKi9cbiAgICB2YWx1ZTogUGluZztcbiAgICBjYXNlOiBcInBpbmdSZXFcIjtcbiAgfSB8IHsgY2FzZTogdW5kZWZpbmVkOyB2YWx1ZT86IHVuZGVmaW5lZCB9ID0geyBjYXNlOiB1bmRlZmluZWQgfTtcblxuICBjb25zdHJ1Y3RvcihkYXRhPzogUGFydGlhbE1lc3NhZ2U8U2lnbmFsUmVxdWVzdD4pIHtcbiAgICBzdXBlcigpO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG5cbiAgc3RhdGljIHJlYWRvbmx5IHJ1bnRpbWU6IHR5cGVvZiBwcm90bzMgPSBwcm90bzM7XG4gIHN0YXRpYyByZWFkb25seSB0eXBlTmFtZSA9IFwibGl2ZWtpdC5TaWduYWxSZXF1ZXN0XCI7XG4gIHN0YXRpYyByZWFkb25seSBmaWVsZHM6IEZpZWxkTGlzdCA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJvZmZlclwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU2Vzc2lvbkRlc2NyaXB0aW9uLCBvbmVvZjogXCJtZXNzYWdlXCIgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcImFuc3dlclwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU2Vzc2lvbkRlc2NyaXB0aW9uLCBvbmVvZjogXCJtZXNzYWdlXCIgfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcInRyaWNrbGVcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFRyaWNrbGVSZXF1ZXN0LCBvbmVvZjogXCJtZXNzYWdlXCIgfSxcbiAgICB7IG5vOiA0LCBuYW1lOiBcImFkZF90cmFja1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogQWRkVHJhY2tSZXF1ZXN0LCBvbmVvZjogXCJtZXNzYWdlXCIgfSxcbiAgICB7IG5vOiA1LCBuYW1lOiBcIm11dGVcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IE11dGVUcmFja1JlcXVlc3QsIG9uZW9mOiBcIm1lc3NhZ2VcIiB9LFxuICAgIHsgbm86IDYsIG5hbWU6IFwic3Vic2NyaXB0aW9uXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBVcGRhdGVTdWJzY3JpcHRpb24sIG9uZW9mOiBcIm1lc3NhZ2VcIiB9LFxuICAgIHsgbm86IDcsIG5hbWU6IFwidHJhY2tfc2V0dGluZ1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVXBkYXRlVHJhY2tTZXR0aW5ncywgb25lb2Y6IFwibWVzc2FnZVwiIH0sXG4gICAgeyBubzogOCwgbmFtZTogXCJsZWF2ZVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogTGVhdmVSZXF1ZXN0LCBvbmVvZjogXCJtZXNzYWdlXCIgfSxcbiAgICB7IG5vOiAxMCwgbmFtZTogXCJ1cGRhdGVfbGF5ZXJzXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBVcGRhdGVWaWRlb0xheWVycywgb25lb2Y6IFwibWVzc2FnZVwiIH0sXG4gICAgeyBubzogMTEsIG5hbWU6IFwic3Vic2NyaXB0aW9uX3Blcm1pc3Npb25cIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFN1YnNjcmlwdGlvblBlcm1pc3Npb24sIG9uZW9mOiBcIm1lc3NhZ2VcIiB9LFxuICAgIHsgbm86IDEyLCBuYW1lOiBcInN5bmNfc3RhdGVcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFN5bmNTdGF0ZSwgb25lb2Y6IFwibWVzc2FnZVwiIH0sXG4gICAgeyBubzogMTMsIG5hbWU6IFwic2ltdWxhdGVcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFNpbXVsYXRlU2NlbmFyaW8sIG9uZW9mOiBcIm1lc3NhZ2VcIiB9LFxuICAgIHsgbm86IDE0LCBuYW1lOiBcInBpbmdcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMyAvKiBTY2FsYXJUeXBlLklOVDY0ICovLCBvbmVvZjogXCJtZXNzYWdlXCIgfSxcbiAgICB7IG5vOiAxNSwgbmFtZTogXCJ1cGRhdGVfbWV0YWRhdGFcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFVwZGF0ZVBhcnRpY2lwYW50TWV0YWRhdGEsIG9uZW9mOiBcIm1lc3NhZ2VcIiB9LFxuICAgIHsgbm86IDE2LCBuYW1lOiBcInBpbmdfcmVxXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBQaW5nLCBvbmVvZjogXCJtZXNzYWdlXCIgfSxcbiAgXSk7XG5cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXM6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBQYXJ0aWFsPEJpbmFyeVJlYWRPcHRpb25zPik6IFNpZ25hbFJlcXVlc3Qge1xuICAgIHJldHVybiBuZXcgU2lnbmFsUmVxdWVzdCgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZTogSnNvblZhbHVlLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogU2lnbmFsUmVxdWVzdCB7XG4gICAgcmV0dXJuIG5ldyBTaWduYWxSZXF1ZXN0KCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nOiBzdHJpbmcsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBTaWduYWxSZXF1ZXN0IHtcbiAgICByZXR1cm4gbmV3IFNpZ25hbFJlcXVlc3QoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBlcXVhbHMoYTogU2lnbmFsUmVxdWVzdCB8IFBsYWluTWVzc2FnZTxTaWduYWxSZXF1ZXN0PiB8IHVuZGVmaW5lZCwgYjogU2lnbmFsUmVxdWVzdCB8IFBsYWluTWVzc2FnZTxTaWduYWxSZXF1ZXN0PiB8IHVuZGVmaW5lZCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoU2lnbmFsUmVxdWVzdCwgYSwgYik7XG4gIH1cbn1cblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlNpZ25hbFJlc3BvbnNlXG4gKi9cbmV4cG9ydCBjbGFzcyBTaWduYWxSZXNwb25zZSBleHRlbmRzIE1lc3NhZ2U8U2lnbmFsUmVzcG9uc2U+IHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBvbmVvZiBsaXZla2l0LlNpZ25hbFJlc3BvbnNlLm1lc3NhZ2VcbiAgICovXG4gIG1lc3NhZ2U6IHtcbiAgICAvKipcbiAgICAgKiBzZW50IHdoZW4gam9pbiBpcyBhY2NlcHRlZFxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LkpvaW5SZXNwb25zZSBqb2luID0gMTtcbiAgICAgKi9cbiAgICB2YWx1ZTogSm9pblJlc3BvbnNlO1xuICAgIGNhc2U6IFwiam9pblwiO1xuICB9IHwge1xuICAgIC8qKlxuICAgICAqIHNlbnQgd2hlbiBzZXJ2ZXIgYW5zd2VycyBwdWJsaXNoZXJcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5TZXNzaW9uRGVzY3JpcHRpb24gYW5zd2VyID0gMjtcbiAgICAgKi9cbiAgICB2YWx1ZTogU2Vzc2lvbkRlc2NyaXB0aW9uO1xuICAgIGNhc2U6IFwiYW5zd2VyXCI7XG4gIH0gfCB7XG4gICAgLyoqXG4gICAgICogc2VudCB3aGVuIHNlcnZlciBpcyBzZW5kaW5nIHN1YnNjcmliZXIgYW4gb2ZmZXJcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5TZXNzaW9uRGVzY3JpcHRpb24gb2ZmZXIgPSAzO1xuICAgICAqL1xuICAgIHZhbHVlOiBTZXNzaW9uRGVzY3JpcHRpb247XG4gICAgY2FzZTogXCJvZmZlclwiO1xuICB9IHwge1xuICAgIC8qKlxuICAgICAqIHNlbnQgd2hlbiBhbiBJQ0UgY2FuZGlkYXRlIGlzIGF2YWlsYWJsZVxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LlRyaWNrbGVSZXF1ZXN0IHRyaWNrbGUgPSA0O1xuICAgICAqL1xuICAgIHZhbHVlOiBUcmlja2xlUmVxdWVzdDtcbiAgICBjYXNlOiBcInRyaWNrbGVcIjtcbiAgfSB8IHtcbiAgICAvKipcbiAgICAgKiBzZW50IHdoZW4gcGFydGljaXBhbnRzIGluIHRoZSByb29tIGhhcyBjaGFuZ2VkXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuUGFydGljaXBhbnRVcGRhdGUgdXBkYXRlID0gNTtcbiAgICAgKi9cbiAgICB2YWx1ZTogUGFydGljaXBhbnRVcGRhdGU7XG4gICAgY2FzZTogXCJ1cGRhdGVcIjtcbiAgfSB8IHtcbiAgICAvKipcbiAgICAgKiBzZW50IHRvIHRoZSBwYXJ0aWNpcGFudCB3aGVuIHRoZWlyIHRyYWNrIGhhcyBiZWVuIHB1Ymxpc2hlZFxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LlRyYWNrUHVibGlzaGVkUmVzcG9uc2UgdHJhY2tfcHVibGlzaGVkID0gNjtcbiAgICAgKi9cbiAgICB2YWx1ZTogVHJhY2tQdWJsaXNoZWRSZXNwb25zZTtcbiAgICBjYXNlOiBcInRyYWNrUHVibGlzaGVkXCI7XG4gIH0gfCB7XG4gICAgLyoqXG4gICAgICogSW1tZWRpYXRlbHkgdGVybWluYXRlIHNlc3Npb25cbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5MZWF2ZVJlcXVlc3QgbGVhdmUgPSA4O1xuICAgICAqL1xuICAgIHZhbHVlOiBMZWF2ZVJlcXVlc3Q7XG4gICAgY2FzZTogXCJsZWF2ZVwiO1xuICB9IHwge1xuICAgIC8qKlxuICAgICAqIHNlcnZlciBpbml0aWF0ZWQgbXV0ZVxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0Lk11dGVUcmFja1JlcXVlc3QgbXV0ZSA9IDk7XG4gICAgICovXG4gICAgdmFsdWU6IE11dGVUcmFja1JlcXVlc3Q7XG4gICAgY2FzZTogXCJtdXRlXCI7XG4gIH0gfCB7XG4gICAgLyoqXG4gICAgICogaW5kaWNhdGVzIGNoYW5nZXMgdG8gc3BlYWtlciBzdGF0dXMsIGluY2x1ZGluZyB3aGVuIHRoZXkndmUgZ29uZSB0byBub3Qgc3BlYWtpbmdcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5TcGVha2Vyc0NoYW5nZWQgc3BlYWtlcnNfY2hhbmdlZCA9IDEwO1xuICAgICAqL1xuICAgIHZhbHVlOiBTcGVha2Vyc0NoYW5nZWQ7XG4gICAgY2FzZTogXCJzcGVha2Vyc0NoYW5nZWRcIjtcbiAgfSB8IHtcbiAgICAvKipcbiAgICAgKiBzZW50IHdoZW4gbWV0YWRhdGEgb2YgdGhlIHJvb20gaGFzIGNoYW5nZWRcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5Sb29tVXBkYXRlIHJvb21fdXBkYXRlID0gMTE7XG4gICAgICovXG4gICAgdmFsdWU6IFJvb21VcGRhdGU7XG4gICAgY2FzZTogXCJyb29tVXBkYXRlXCI7XG4gIH0gfCB7XG4gICAgLyoqXG4gICAgICogd2hlbiBjb25uZWN0aW9uIHF1YWxpdHkgY2hhbmdlZFxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LkNvbm5lY3Rpb25RdWFsaXR5VXBkYXRlIGNvbm5lY3Rpb25fcXVhbGl0eSA9IDEyO1xuICAgICAqL1xuICAgIHZhbHVlOiBDb25uZWN0aW9uUXVhbGl0eVVwZGF0ZTtcbiAgICBjYXNlOiBcImNvbm5lY3Rpb25RdWFsaXR5XCI7XG4gIH0gfCB7XG4gICAgLyoqXG4gICAgICogd2hlbiBzdHJlYW1lZCB0cmFja3Mgc3RhdGUgY2hhbmdlZCwgdXNlZCB0byBub3RpZnkgd2hlbiBhbnkgb2YgdGhlIHN0cmVhbXMgd2VyZSBwYXVzZWQgZHVlIHRvXG4gICAgICogY29uZ2VzdGlvblxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LlN0cmVhbVN0YXRlVXBkYXRlIHN0cmVhbV9zdGF0ZV91cGRhdGUgPSAxMztcbiAgICAgKi9cbiAgICB2YWx1ZTogU3RyZWFtU3RhdGVVcGRhdGU7XG4gICAgY2FzZTogXCJzdHJlYW1TdGF0ZVVwZGF0ZVwiO1xuICB9IHwge1xuICAgIC8qKlxuICAgICAqIHdoZW4gbWF4IHN1YnNjcmliZSBxdWFsaXR5IGNoYW5nZWQsIHVzZWQgYnkgZHluYW1pYyBicm9hZGNhc3RpbmcgdG8gZGlzYWJsZSB1bnVzZWQgbGF5ZXJzXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUgc3Vic2NyaWJlZF9xdWFsaXR5X3VwZGF0ZSA9IDE0O1xuICAgICAqL1xuICAgIHZhbHVlOiBTdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZTtcbiAgICBjYXNlOiBcInN1YnNjcmliZWRRdWFsaXR5VXBkYXRlXCI7XG4gIH0gfCB7XG4gICAgLyoqXG4gICAgICogd2hlbiBzdWJzY3JpcHRpb24gcGVybWlzc2lvbiBjaGFuZ2VkXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSBzdWJzY3JpcHRpb25fcGVybWlzc2lvbl91cGRhdGUgPSAxNTtcbiAgICAgKi9cbiAgICB2YWx1ZTogU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZTtcbiAgICBjYXNlOiBcInN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGVcIjtcbiAgfSB8IHtcbiAgICAvKipcbiAgICAgKiB1cGRhdGUgdGhlIHRva2VuIHRoZSBjbGllbnQgd2FzIHVzaW5nLCB0byBwcmV2ZW50IGFuIGFjdGl2ZSBjbGllbnQgZnJvbSB1c2luZyBhbiBleHBpcmVkIHRva2VuXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyByZWZyZXNoX3Rva2VuID0gMTY7XG4gICAgICovXG4gICAgdmFsdWU6IHN0cmluZztcbiAgICBjYXNlOiBcInJlZnJlc2hUb2tlblwiO1xuICB9IHwge1xuICAgIC8qKlxuICAgICAqIHNlcnZlciBpbml0aWF0ZWQgdHJhY2sgdW5wdWJsaXNoXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuVHJhY2tVbnB1Ymxpc2hlZFJlc3BvbnNlIHRyYWNrX3VucHVibGlzaGVkID0gMTc7XG4gICAgICovXG4gICAgdmFsdWU6IFRyYWNrVW5wdWJsaXNoZWRSZXNwb25zZTtcbiAgICBjYXNlOiBcInRyYWNrVW5wdWJsaXNoZWRcIjtcbiAgfSB8IHtcbiAgICAvKipcbiAgICAgKiByZXNwb25kIHRvIHBpbmdcbiAgICAgKlxuICAgICAqIGRlcHJlY2F0ZWQgYnkgcG9uZ19yZXNwIChtZXNzYWdlIFBvbmcpXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGludDY0IHBvbmcgPSAxODtcbiAgICAgKi9cbiAgICB2YWx1ZTogYmlnaW50O1xuICAgIGNhc2U6IFwicG9uZ1wiO1xuICB9IHwge1xuICAgIC8qKlxuICAgICAqIHNlbnQgd2hlbiBjbGllbnQgcmVjb25uZWN0c1xuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LlJlY29ubmVjdFJlc3BvbnNlIHJlY29ubmVjdCA9IDE5O1xuICAgICAqL1xuICAgIHZhbHVlOiBSZWNvbm5lY3RSZXNwb25zZTtcbiAgICBjYXNlOiBcInJlY29ubmVjdFwiO1xuICB9IHwge1xuICAgIC8qKlxuICAgICAqIHJlc3BvbmQgdG8gUGluZ1xuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LlBvbmcgcG9uZ19yZXNwID0gMjA7XG4gICAgICovXG4gICAgdmFsdWU6IFBvbmc7XG4gICAgY2FzZTogXCJwb25nUmVzcFwiO1xuICB9IHwge1xuICAgIC8qKlxuICAgICAqIFN1YnNjcmlwdGlvbiByZXNwb25zZSwgY2xpZW50IHNob3VsZCBub3QgZXhwZWN0IGFueSBtZWRpYSBmcm9tIHRoaXMgc3Vic2NyaXB0aW9uIGlmIGl0IGZhaWxzXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuU3Vic2NyaXB0aW9uUmVzcG9uc2Ugc3Vic2NyaXB0aW9uX3Jlc3BvbnNlID0gMjE7XG4gICAgICovXG4gICAgdmFsdWU6IFN1YnNjcmlwdGlvblJlc3BvbnNlO1xuICAgIGNhc2U6IFwic3Vic2NyaXB0aW9uUmVzcG9uc2VcIjtcbiAgfSB8IHsgY2FzZTogdW5kZWZpbmVkOyB2YWx1ZT86IHVuZGVmaW5lZCB9ID0geyBjYXNlOiB1bmRlZmluZWQgfTtcblxuICBjb25zdHJ1Y3RvcihkYXRhPzogUGFydGlhbE1lc3NhZ2U8U2lnbmFsUmVzcG9uc2U+KSB7XG4gICAgc3VwZXIoKTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuXG4gIHN0YXRpYyByZWFkb25seSBydW50aW1lOiB0eXBlb2YgcHJvdG8zID0gcHJvdG8zO1xuICBzdGF0aWMgcmVhZG9ubHkgdHlwZU5hbWUgPSBcImxpdmVraXQuU2lnbmFsUmVzcG9uc2VcIjtcbiAgc3RhdGljIHJlYWRvbmx5IGZpZWxkczogRmllbGRMaXN0ID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcImpvaW5cIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IEpvaW5SZXNwb25zZSwgb25lb2Y6IFwibWVzc2FnZVwiIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJhbnN3ZXJcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFNlc3Npb25EZXNjcmlwdGlvbiwgb25lb2Y6IFwibWVzc2FnZVwiIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJvZmZlclwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU2Vzc2lvbkRlc2NyaXB0aW9uLCBvbmVvZjogXCJtZXNzYWdlXCIgfSxcbiAgICB7IG5vOiA0LCBuYW1lOiBcInRyaWNrbGVcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFRyaWNrbGVSZXF1ZXN0LCBvbmVvZjogXCJtZXNzYWdlXCIgfSxcbiAgICB7IG5vOiA1LCBuYW1lOiBcInVwZGF0ZVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogUGFydGljaXBhbnRVcGRhdGUsIG9uZW9mOiBcIm1lc3NhZ2VcIiB9LFxuICAgIHsgbm86IDYsIG5hbWU6IFwidHJhY2tfcHVibGlzaGVkXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBUcmFja1B1Ymxpc2hlZFJlc3BvbnNlLCBvbmVvZjogXCJtZXNzYWdlXCIgfSxcbiAgICB7IG5vOiA4LCBuYW1lOiBcImxlYXZlXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBMZWF2ZVJlcXVlc3QsIG9uZW9mOiBcIm1lc3NhZ2VcIiB9LFxuICAgIHsgbm86IDksIG5hbWU6IFwibXV0ZVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogTXV0ZVRyYWNrUmVxdWVzdCwgb25lb2Y6IFwibWVzc2FnZVwiIH0sXG4gICAgeyBubzogMTAsIG5hbWU6IFwic3BlYWtlcnNfY2hhbmdlZFwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU3BlYWtlcnNDaGFuZ2VkLCBvbmVvZjogXCJtZXNzYWdlXCIgfSxcbiAgICB7IG5vOiAxMSwgbmFtZTogXCJyb29tX3VwZGF0ZVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogUm9vbVVwZGF0ZSwgb25lb2Y6IFwibWVzc2FnZVwiIH0sXG4gICAgeyBubzogMTIsIG5hbWU6IFwiY29ubmVjdGlvbl9xdWFsaXR5XCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBDb25uZWN0aW9uUXVhbGl0eVVwZGF0ZSwgb25lb2Y6IFwibWVzc2FnZVwiIH0sXG4gICAgeyBubzogMTMsIG5hbWU6IFwic3RyZWFtX3N0YXRlX3VwZGF0ZVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU3RyZWFtU3RhdGVVcGRhdGUsIG9uZW9mOiBcIm1lc3NhZ2VcIiB9LFxuICAgIHsgbm86IDE0LCBuYW1lOiBcInN1YnNjcmliZWRfcXVhbGl0eV91cGRhdGVcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFN1YnNjcmliZWRRdWFsaXR5VXBkYXRlLCBvbmVvZjogXCJtZXNzYWdlXCIgfSxcbiAgICB7IG5vOiAxNSwgbmFtZTogXCJzdWJzY3JpcHRpb25fcGVybWlzc2lvbl91cGRhdGVcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUsIG9uZW9mOiBcIm1lc3NhZ2VcIiB9LFxuICAgIHsgbm86IDE2LCBuYW1lOiBcInJlZnJlc2hfdG9rZW5cIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLywgb25lb2Y6IFwibWVzc2FnZVwiIH0sXG4gICAgeyBubzogMTcsIG5hbWU6IFwidHJhY2tfdW5wdWJsaXNoZWRcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFRyYWNrVW5wdWJsaXNoZWRSZXNwb25zZSwgb25lb2Y6IFwibWVzc2FnZVwiIH0sXG4gICAgeyBubzogMTgsIG5hbWU6IFwicG9uZ1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiAzIC8qIFNjYWxhclR5cGUuSU5UNjQgKi8sIG9uZW9mOiBcIm1lc3NhZ2VcIiB9LFxuICAgIHsgbm86IDE5LCBuYW1lOiBcInJlY29ubmVjdFwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogUmVjb25uZWN0UmVzcG9uc2UsIG9uZW9mOiBcIm1lc3NhZ2VcIiB9LFxuICAgIHsgbm86IDIwLCBuYW1lOiBcInBvbmdfcmVzcFwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogUG9uZywgb25lb2Y6IFwibWVzc2FnZVwiIH0sXG4gICAgeyBubzogMjEsIG5hbWU6IFwic3Vic2NyaXB0aW9uX3Jlc3BvbnNlXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBTdWJzY3JpcHRpb25SZXNwb25zZSwgb25lb2Y6IFwibWVzc2FnZVwiIH0sXG4gIF0pO1xuXG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzOiBVaW50OEFycmF5LCBvcHRpb25zPzogUGFydGlhbDxCaW5hcnlSZWFkT3B0aW9ucz4pOiBTaWduYWxSZXNwb25zZSB7XG4gICAgcmV0dXJuIG5ldyBTaWduYWxSZXNwb25zZSgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZTogSnNvblZhbHVlLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogU2lnbmFsUmVzcG9uc2Uge1xuICAgIHJldHVybiBuZXcgU2lnbmFsUmVzcG9uc2UoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmc6IHN0cmluZywgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IFNpZ25hbFJlc3BvbnNlIHtcbiAgICByZXR1cm4gbmV3IFNpZ25hbFJlc3BvbnNlKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZXF1YWxzKGE6IFNpZ25hbFJlc3BvbnNlIHwgUGxhaW5NZXNzYWdlPFNpZ25hbFJlc3BvbnNlPiB8IHVuZGVmaW5lZCwgYjogU2lnbmFsUmVzcG9uc2UgfCBQbGFpbk1lc3NhZ2U8U2lnbmFsUmVzcG9uc2U+IHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhTaWduYWxSZXNwb25zZSwgYSwgYik7XG4gIH1cbn1cblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlNpbXVsY2FzdENvZGVjXG4gKi9cbmV4cG9ydCBjbGFzcyBTaW11bGNhc3RDb2RlYyBleHRlbmRzIE1lc3NhZ2U8U2ltdWxjYXN0Q29kZWM+IHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIGNvZGVjID0gMTtcbiAgICovXG4gIGNvZGVjID0gXCJcIjtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgY2lkID0gMjtcbiAgICovXG4gIGNpZCA9IFwiXCI7XG5cbiAgY29uc3RydWN0b3IoZGF0YT86IFBhcnRpYWxNZXNzYWdlPFNpbXVsY2FzdENvZGVjPikge1xuICAgIHN1cGVyKCk7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cblxuICBzdGF0aWMgcmVhZG9ubHkgcnVudGltZTogdHlwZW9mIHByb3RvMyA9IHByb3RvMztcbiAgc3RhdGljIHJlYWRvbmx5IHR5cGVOYW1lID0gXCJsaXZla2l0LlNpbXVsY2FzdENvZGVjXCI7XG4gIHN0YXRpYyByZWFkb25seSBmaWVsZHM6IEZpZWxkTGlzdCA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJjb2RlY1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJjaWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICBdKTtcblxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlczogVWludDhBcnJheSwgb3B0aW9ucz86IFBhcnRpYWw8QmluYXJ5UmVhZE9wdGlvbnM+KTogU2ltdWxjYXN0Q29kZWMge1xuICAgIHJldHVybiBuZXcgU2ltdWxjYXN0Q29kZWMoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWU6IEpzb25WYWx1ZSwgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IFNpbXVsY2FzdENvZGVjIHtcbiAgICByZXR1cm4gbmV3IFNpbXVsY2FzdENvZGVjKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nOiBzdHJpbmcsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBTaW11bGNhc3RDb2RlYyB7XG4gICAgcmV0dXJuIG5ldyBTaW11bGNhc3RDb2RlYygpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGVxdWFscyhhOiBTaW11bGNhc3RDb2RlYyB8IFBsYWluTWVzc2FnZTxTaW11bGNhc3RDb2RlYz4gfCB1bmRlZmluZWQsIGI6IFNpbXVsY2FzdENvZGVjIHwgUGxhaW5NZXNzYWdlPFNpbXVsY2FzdENvZGVjPiB8IHVuZGVmaW5lZCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoU2ltdWxjYXN0Q29kZWMsIGEsIGIpO1xuICB9XG59XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5BZGRUcmFja1JlcXVlc3RcbiAqL1xuZXhwb3J0IGNsYXNzIEFkZFRyYWNrUmVxdWVzdCBleHRlbmRzIE1lc3NhZ2U8QWRkVHJhY2tSZXF1ZXN0PiB7XG4gIC8qKlxuICAgKiBjbGllbnQgSUQgb2YgdHJhY2ssIHRvIG1hdGNoIGl0IHdoZW4gUlRDIHRyYWNrIGlzIHJlY2VpdmVkXG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIGNpZCA9IDE7XG4gICAqL1xuICBjaWQgPSBcIlwiO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBuYW1lID0gMjtcbiAgICovXG4gIG5hbWUgPSBcIlwiO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuVHJhY2tUeXBlIHR5cGUgPSAzO1xuICAgKi9cbiAgdHlwZSA9IFRyYWNrVHlwZS5BVURJTztcblxuICAvKipcbiAgICogdG8gYmUgZGVwcmVjYXRlZCBpbiBmYXZvciBvZiBsYXllcnNcbiAgICpcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50MzIgd2lkdGggPSA0O1xuICAgKi9cbiAgd2lkdGggPSAwO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiBoZWlnaHQgPSA1O1xuICAgKi9cbiAgaGVpZ2h0ID0gMDtcblxuICAvKipcbiAgICogdHJ1ZSB0byBhZGQgdHJhY2sgYW5kIGluaXRpYWxpemUgdG8gbXV0ZWRcbiAgICpcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBib29sIG11dGVkID0gNjtcbiAgICovXG4gIG11dGVkID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIHRydWUgaWYgRFRYIChEaXNjb250aW51b3VzIFRyYW5zbWlzc2lvbikgaXMgZGlzYWJsZWQgZm9yIGF1ZGlvXG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYm9vbCBkaXNhYmxlX2R0eCA9IDc7XG4gICAqL1xuICBkaXNhYmxlRHR4ID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5UcmFja1NvdXJjZSBzb3VyY2UgPSA4O1xuICAgKi9cbiAgc291cmNlID0gVHJhY2tTb3VyY2UuVU5LTk9XTjtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBsaXZla2l0LlZpZGVvTGF5ZXIgbGF5ZXJzID0gOTtcbiAgICovXG4gIGxheWVyczogVmlkZW9MYXllcltdID0gW107XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgbGl2ZWtpdC5TaW11bGNhc3RDb2RlYyBzaW11bGNhc3RfY29kZWNzID0gMTA7XG4gICAqL1xuICBzaW11bGNhc3RDb2RlY3M6IFNpbXVsY2FzdENvZGVjW10gPSBbXTtcblxuICAvKipcbiAgICogc2VydmVyIElEIG9mIHRyYWNrLCBwdWJsaXNoIG5ldyBjb2RlYyB0byBleGlzdCB0cmFja1xuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBzaWQgPSAxMTtcbiAgICovXG4gIHNpZCA9IFwiXCI7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYm9vbCBzdGVyZW8gPSAxMjtcbiAgICovXG4gIHN0ZXJlbyA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiB0cnVlIGlmIFJFRCAoUmVkdW5kYW50IEVuY29kaW5nKSBpcyBkaXNhYmxlZCBmb3IgYXVkaW9cbiAgICpcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBib29sIGRpc2FibGVfcmVkID0gMTM7XG4gICAqL1xuICBkaXNhYmxlUmVkID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5FbmNyeXB0aW9uLlR5cGUgZW5jcnlwdGlvbiA9IDE0O1xuICAgKi9cbiAgZW5jcnlwdGlvbiA9IEVuY3J5cHRpb25fVHlwZS5OT05FO1xuXG4gIC8qKlxuICAgKiB3aGljaCBzdHJlYW0gdGhlIHRyYWNrIGJlbG9uZ3MgdG8sIHVzZWQgdG8gZ3JvdXAgdHJhY2tzIHRvZ2V0aGVyLlxuICAgKiBpZiBub3Qgc3BlY2lmaWVkLCBzZXJ2ZXIgd2lsbCBpbmZlciBpdCBmcm9tIHRyYWNrIHNvdXJjZSB0byBidW5kbGUgY2FtZXJhL21pY3JvcGhvbmUsIHNjcmVlbnNoYXJlL2F1ZGlvIHRvZ2V0aGVyXG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHN0cmVhbSA9IDE1O1xuICAgKi9cbiAgc3RyZWFtID0gXCJcIjtcblxuICBjb25zdHJ1Y3RvcihkYXRhPzogUGFydGlhbE1lc3NhZ2U8QWRkVHJhY2tSZXF1ZXN0Pikge1xuICAgIHN1cGVyKCk7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cblxuICBzdGF0aWMgcmVhZG9ubHkgcnVudGltZTogdHlwZW9mIHByb3RvMyA9IHByb3RvMztcbiAgc3RhdGljIHJlYWRvbmx5IHR5cGVOYW1lID0gXCJsaXZla2l0LkFkZFRyYWNrUmVxdWVzdFwiO1xuICBzdGF0aWMgcmVhZG9ubHkgZmllbGRzOiBGaWVsZExpc3QgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwiY2lkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcIm5hbWVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwidHlwZVwiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLmdldEVudW1UeXBlKFRyYWNrVHlwZSkgfSxcbiAgICB7IG5vOiA0LCBuYW1lOiBcIndpZHRoXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovIH0sXG4gICAgeyBubzogNSwgbmFtZTogXCJoZWlnaHRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi8gfSxcbiAgICB7IG5vOiA2LCBuYW1lOiBcIm11dGVkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovIH0sXG4gICAgeyBubzogNywgbmFtZTogXCJkaXNhYmxlX2R0eFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLyB9LFxuICAgIHsgbm86IDgsIG5hbWU6IFwic291cmNlXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoVHJhY2tTb3VyY2UpIH0sXG4gICAgeyBubzogOSwgbmFtZTogXCJsYXllcnNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFZpZGVvTGF5ZXIsIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAgeyBubzogMTAsIG5hbWU6IFwic2ltdWxjYXN0X2NvZGVjc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU2ltdWxjYXN0Q29kZWMsIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAgeyBubzogMTEsIG5hbWU6IFwic2lkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAxMiwgbmFtZTogXCJzdGVyZW9cIiwga2luZDogXCJzY2FsYXJcIiwgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi8gfSxcbiAgICB7IG5vOiAxMywgbmFtZTogXCJkaXNhYmxlX3JlZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLyB9LFxuICAgIHsgbm86IDE0LCBuYW1lOiBcImVuY3J5cHRpb25cIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShFbmNyeXB0aW9uX1R5cGUpIH0sXG4gICAgeyBubzogMTUsIG5hbWU6IFwic3RyZWFtXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgXSk7XG5cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXM6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBQYXJ0aWFsPEJpbmFyeVJlYWRPcHRpb25zPik6IEFkZFRyYWNrUmVxdWVzdCB7XG4gICAgcmV0dXJuIG5ldyBBZGRUcmFja1JlcXVlc3QoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWU6IEpzb25WYWx1ZSwgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IEFkZFRyYWNrUmVxdWVzdCB7XG4gICAgcmV0dXJuIG5ldyBBZGRUcmFja1JlcXVlc3QoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmc6IHN0cmluZywgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IEFkZFRyYWNrUmVxdWVzdCB7XG4gICAgcmV0dXJuIG5ldyBBZGRUcmFja1JlcXVlc3QoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBlcXVhbHMoYTogQWRkVHJhY2tSZXF1ZXN0IHwgUGxhaW5NZXNzYWdlPEFkZFRyYWNrUmVxdWVzdD4gfCB1bmRlZmluZWQsIGI6IEFkZFRyYWNrUmVxdWVzdCB8IFBsYWluTWVzc2FnZTxBZGRUcmFja1JlcXVlc3Q+IHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhBZGRUcmFja1JlcXVlc3QsIGEsIGIpO1xuICB9XG59XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5Ucmlja2xlUmVxdWVzdFxuICovXG5leHBvcnQgY2xhc3MgVHJpY2tsZVJlcXVlc3QgZXh0ZW5kcyBNZXNzYWdlPFRyaWNrbGVSZXF1ZXN0PiB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBjYW5kaWRhdGVJbml0ID0gMTtcbiAgICovXG4gIGNhbmRpZGF0ZUluaXQgPSBcIlwiO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuU2lnbmFsVGFyZ2V0IHRhcmdldCA9IDI7XG4gICAqL1xuICB0YXJnZXQgPSBTaWduYWxUYXJnZXQuUFVCTElTSEVSO1xuXG4gIGNvbnN0cnVjdG9yKGRhdGE/OiBQYXJ0aWFsTWVzc2FnZTxUcmlja2xlUmVxdWVzdD4pIHtcbiAgICBzdXBlcigpO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG5cbiAgc3RhdGljIHJlYWRvbmx5IHJ1bnRpbWU6IHR5cGVvZiBwcm90bzMgPSBwcm90bzM7XG4gIHN0YXRpYyByZWFkb25seSB0eXBlTmFtZSA9IFwibGl2ZWtpdC5Ucmlja2xlUmVxdWVzdFwiO1xuICBzdGF0aWMgcmVhZG9ubHkgZmllbGRzOiBGaWVsZExpc3QgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwiY2FuZGlkYXRlSW5pdFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJ0YXJnZXRcIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShTaWduYWxUYXJnZXQpIH0sXG4gIF0pO1xuXG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzOiBVaW50OEFycmF5LCBvcHRpb25zPzogUGFydGlhbDxCaW5hcnlSZWFkT3B0aW9ucz4pOiBUcmlja2xlUmVxdWVzdCB7XG4gICAgcmV0dXJuIG5ldyBUcmlja2xlUmVxdWVzdCgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZTogSnNvblZhbHVlLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogVHJpY2tsZVJlcXVlc3Qge1xuICAgIHJldHVybiBuZXcgVHJpY2tsZVJlcXVlc3QoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmc6IHN0cmluZywgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IFRyaWNrbGVSZXF1ZXN0IHtcbiAgICByZXR1cm4gbmV3IFRyaWNrbGVSZXF1ZXN0KCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZXF1YWxzKGE6IFRyaWNrbGVSZXF1ZXN0IHwgUGxhaW5NZXNzYWdlPFRyaWNrbGVSZXF1ZXN0PiB8IHVuZGVmaW5lZCwgYjogVHJpY2tsZVJlcXVlc3QgfCBQbGFpbk1lc3NhZ2U8VHJpY2tsZVJlcXVlc3Q+IHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhUcmlja2xlUmVxdWVzdCwgYSwgYik7XG4gIH1cbn1cblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0Lk11dGVUcmFja1JlcXVlc3RcbiAqL1xuZXhwb3J0IGNsYXNzIE11dGVUcmFja1JlcXVlc3QgZXh0ZW5kcyBNZXNzYWdlPE11dGVUcmFja1JlcXVlc3Q+IHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHNpZCA9IDE7XG4gICAqL1xuICBzaWQgPSBcIlwiO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGJvb2wgbXV0ZWQgPSAyO1xuICAgKi9cbiAgbXV0ZWQgPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihkYXRhPzogUGFydGlhbE1lc3NhZ2U8TXV0ZVRyYWNrUmVxdWVzdD4pIHtcbiAgICBzdXBlcigpO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG5cbiAgc3RhdGljIHJlYWRvbmx5IHJ1bnRpbWU6IHR5cGVvZiBwcm90bzMgPSBwcm90bzM7XG4gIHN0YXRpYyByZWFkb25seSB0eXBlTmFtZSA9IFwibGl2ZWtpdC5NdXRlVHJhY2tSZXF1ZXN0XCI7XG4gIHN0YXRpYyByZWFkb25seSBmaWVsZHM6IEZpZWxkTGlzdCA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJzaWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwibXV0ZWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi8gfSxcbiAgXSk7XG5cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXM6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBQYXJ0aWFsPEJpbmFyeVJlYWRPcHRpb25zPik6IE11dGVUcmFja1JlcXVlc3Qge1xuICAgIHJldHVybiBuZXcgTXV0ZVRyYWNrUmVxdWVzdCgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZTogSnNvblZhbHVlLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogTXV0ZVRyYWNrUmVxdWVzdCB7XG4gICAgcmV0dXJuIG5ldyBNdXRlVHJhY2tSZXF1ZXN0KCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nOiBzdHJpbmcsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBNdXRlVHJhY2tSZXF1ZXN0IHtcbiAgICByZXR1cm4gbmV3IE11dGVUcmFja1JlcXVlc3QoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBlcXVhbHMoYTogTXV0ZVRyYWNrUmVxdWVzdCB8IFBsYWluTWVzc2FnZTxNdXRlVHJhY2tSZXF1ZXN0PiB8IHVuZGVmaW5lZCwgYjogTXV0ZVRyYWNrUmVxdWVzdCB8IFBsYWluTWVzc2FnZTxNdXRlVHJhY2tSZXF1ZXN0PiB8IHVuZGVmaW5lZCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoTXV0ZVRyYWNrUmVxdWVzdCwgYSwgYik7XG4gIH1cbn1cblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LkpvaW5SZXNwb25zZVxuICovXG5leHBvcnQgY2xhc3MgSm9pblJlc3BvbnNlIGV4dGVuZHMgTWVzc2FnZTxKb2luUmVzcG9uc2U+IHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5Sb29tIHJvb20gPSAxO1xuICAgKi9cbiAgcm9vbT86IFJvb207XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5QYXJ0aWNpcGFudEluZm8gcGFydGljaXBhbnQgPSAyO1xuICAgKi9cbiAgcGFydGljaXBhbnQ/OiBQYXJ0aWNpcGFudEluZm87XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgbGl2ZWtpdC5QYXJ0aWNpcGFudEluZm8gb3RoZXJfcGFydGljaXBhbnRzID0gMztcbiAgICovXG4gIG90aGVyUGFydGljaXBhbnRzOiBQYXJ0aWNpcGFudEluZm9bXSA9IFtdO1xuXG4gIC8qKlxuICAgKiBkZXByZWNhdGVkLiB1c2Ugc2VydmVyX2luZm8udmVyc2lvbiBpbnN0ZWFkLlxuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBzZXJ2ZXJfdmVyc2lvbiA9IDQ7XG4gICAqL1xuICBzZXJ2ZXJWZXJzaW9uID0gXCJcIjtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBsaXZla2l0LklDRVNlcnZlciBpY2Vfc2VydmVycyA9IDU7XG4gICAqL1xuICBpY2VTZXJ2ZXJzOiBJQ0VTZXJ2ZXJbXSA9IFtdO1xuXG4gIC8qKlxuICAgKiB1c2Ugc3Vic2NyaWJlciBhcyB0aGUgcHJpbWFyeSBQZWVyQ29ubmVjdGlvblxuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGJvb2wgc3Vic2NyaWJlcl9wcmltYXJ5ID0gNjtcbiAgICovXG4gIHN1YnNjcmliZXJQcmltYXJ5ID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIHdoZW4gdGhlIGN1cnJlbnQgc2VydmVyIGlzbid0IGF2YWlsYWJsZSwgcmV0dXJuIGFsdGVybmF0ZSB1cmwgdG8gcmV0cnkgY29ubmVjdGlvblxuICAgKiB3aGVuIHRoaXMgaXMgc2V0LCB0aGUgb3RoZXIgZmllbGRzIHdpbGwgYmUgbGFyZ2VseSBlbXB0eVxuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBhbHRlcm5hdGl2ZV91cmwgPSA3O1xuICAgKi9cbiAgYWx0ZXJuYXRpdmVVcmwgPSBcIlwiO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuQ2xpZW50Q29uZmlndXJhdGlvbiBjbGllbnRfY29uZmlndXJhdGlvbiA9IDg7XG4gICAqL1xuICBjbGllbnRDb25maWd1cmF0aW9uPzogQ2xpZW50Q29uZmlndXJhdGlvbjtcblxuICAvKipcbiAgICogZGVwcmVjYXRlZC4gdXNlIHNlcnZlcl9pbmZvLnJlZ2lvbiBpbnN0ZWFkLlxuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBzZXJ2ZXJfcmVnaW9uID0gOTtcbiAgICovXG4gIHNlcnZlclJlZ2lvbiA9IFwiXCI7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogaW50MzIgcGluZ190aW1lb3V0ID0gMTA7XG4gICAqL1xuICBwaW5nVGltZW91dCA9IDA7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogaW50MzIgcGluZ19pbnRlcnZhbCA9IDExO1xuICAgKi9cbiAgcGluZ0ludGVydmFsID0gMDtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LlNlcnZlckluZm8gc2VydmVyX2luZm8gPSAxMjtcbiAgICovXG4gIHNlcnZlckluZm8/OiBTZXJ2ZXJJbmZvO1xuXG4gIC8qKlxuICAgKiBTZXJ2ZXItSW5qZWN0ZWQtRnJhbWUgYnl0ZSB0cmFpbGVyLCB1c2VkIHRvIGlkZW50aWZ5IHVuZW5jcnlwdGVkIGZyYW1lcyB3aGVuIGUyZWUgaXMgZW5hYmxlZFxuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGJ5dGVzIHNpZl90cmFpbGVyID0gMTM7XG4gICAqL1xuICBzaWZUcmFpbGVyID0gbmV3IFVpbnQ4QXJyYXkoMCk7XG5cbiAgY29uc3RydWN0b3IoZGF0YT86IFBhcnRpYWxNZXNzYWdlPEpvaW5SZXNwb25zZT4pIHtcbiAgICBzdXBlcigpO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG5cbiAgc3RhdGljIHJlYWRvbmx5IHJ1bnRpbWU6IHR5cGVvZiBwcm90bzMgPSBwcm90bzM7XG4gIHN0YXRpYyByZWFkb25seSB0eXBlTmFtZSA9IFwibGl2ZWtpdC5Kb2luUmVzcG9uc2VcIjtcbiAgc3RhdGljIHJlYWRvbmx5IGZpZWxkczogRmllbGRMaXN0ID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInJvb21cIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFJvb20gfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcInBhcnRpY2lwYW50XCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBQYXJ0aWNpcGFudEluZm8gfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcIm90aGVyX3BhcnRpY2lwYW50c1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogUGFydGljaXBhbnRJbmZvLCByZXBlYXRlZDogdHJ1ZSB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwic2VydmVyX3ZlcnNpb25cIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDUsIG5hbWU6IFwiaWNlX3NlcnZlcnNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IElDRVNlcnZlciwgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgICB7IG5vOiA2LCBuYW1lOiBcInN1YnNjcmliZXJfcHJpbWFyeVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLyB9LFxuICAgIHsgbm86IDcsIG5hbWU6IFwiYWx0ZXJuYXRpdmVfdXJsXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiA4LCBuYW1lOiBcImNsaWVudF9jb25maWd1cmF0aW9uXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBDbGllbnRDb25maWd1cmF0aW9uIH0sXG4gICAgeyBubzogOSwgbmFtZTogXCJzZXJ2ZXJfcmVnaW9uXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAxMCwgbmFtZTogXCJwaW5nX3RpbWVvdXRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogNSAvKiBTY2FsYXJUeXBlLklOVDMyICovIH0sXG4gICAgeyBubzogMTEsIG5hbWU6IFwicGluZ19pbnRlcnZhbFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA1IC8qIFNjYWxhclR5cGUuSU5UMzIgKi8gfSxcbiAgICB7IG5vOiAxMiwgbmFtZTogXCJzZXJ2ZXJfaW5mb1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU2VydmVySW5mbyB9LFxuICAgIHsgbm86IDEzLCBuYW1lOiBcInNpZl90cmFpbGVyXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEyIC8qIFNjYWxhclR5cGUuQllURVMgKi8gfSxcbiAgXSk7XG5cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXM6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBQYXJ0aWFsPEJpbmFyeVJlYWRPcHRpb25zPik6IEpvaW5SZXNwb25zZSB7XG4gICAgcmV0dXJuIG5ldyBKb2luUmVzcG9uc2UoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWU6IEpzb25WYWx1ZSwgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IEpvaW5SZXNwb25zZSB7XG4gICAgcmV0dXJuIG5ldyBKb2luUmVzcG9uc2UoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmc6IHN0cmluZywgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IEpvaW5SZXNwb25zZSB7XG4gICAgcmV0dXJuIG5ldyBKb2luUmVzcG9uc2UoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBlcXVhbHMoYTogSm9pblJlc3BvbnNlIHwgUGxhaW5NZXNzYWdlPEpvaW5SZXNwb25zZT4gfCB1bmRlZmluZWQsIGI6IEpvaW5SZXNwb25zZSB8IFBsYWluTWVzc2FnZTxKb2luUmVzcG9uc2U+IHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhKb2luUmVzcG9uc2UsIGEsIGIpO1xuICB9XG59XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5SZWNvbm5lY3RSZXNwb25zZVxuICovXG5leHBvcnQgY2xhc3MgUmVjb25uZWN0UmVzcG9uc2UgZXh0ZW5kcyBNZXNzYWdlPFJlY29ubmVjdFJlc3BvbnNlPiB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGxpdmVraXQuSUNFU2VydmVyIGljZV9zZXJ2ZXJzID0gMTtcbiAgICovXG4gIGljZVNlcnZlcnM6IElDRVNlcnZlcltdID0gW107XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5DbGllbnRDb25maWd1cmF0aW9uIGNsaWVudF9jb25maWd1cmF0aW9uID0gMjtcbiAgICovXG4gIGNsaWVudENvbmZpZ3VyYXRpb24/OiBDbGllbnRDb25maWd1cmF0aW9uO1xuXG4gIGNvbnN0cnVjdG9yKGRhdGE/OiBQYXJ0aWFsTWVzc2FnZTxSZWNvbm5lY3RSZXNwb25zZT4pIHtcbiAgICBzdXBlcigpO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG5cbiAgc3RhdGljIHJlYWRvbmx5IHJ1bnRpbWU6IHR5cGVvZiBwcm90bzMgPSBwcm90bzM7XG4gIHN0YXRpYyByZWFkb25seSB0eXBlTmFtZSA9IFwibGl2ZWtpdC5SZWNvbm5lY3RSZXNwb25zZVwiO1xuICBzdGF0aWMgcmVhZG9ubHkgZmllbGRzOiBGaWVsZExpc3QgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwiaWNlX3NlcnZlcnNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IElDRVNlcnZlciwgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcImNsaWVudF9jb25maWd1cmF0aW9uXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBDbGllbnRDb25maWd1cmF0aW9uIH0sXG4gIF0pO1xuXG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzOiBVaW50OEFycmF5LCBvcHRpb25zPzogUGFydGlhbDxCaW5hcnlSZWFkT3B0aW9ucz4pOiBSZWNvbm5lY3RSZXNwb25zZSB7XG4gICAgcmV0dXJuIG5ldyBSZWNvbm5lY3RSZXNwb25zZSgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZTogSnNvblZhbHVlLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogUmVjb25uZWN0UmVzcG9uc2Uge1xuICAgIHJldHVybiBuZXcgUmVjb25uZWN0UmVzcG9uc2UoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmc6IHN0cmluZywgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IFJlY29ubmVjdFJlc3BvbnNlIHtcbiAgICByZXR1cm4gbmV3IFJlY29ubmVjdFJlc3BvbnNlKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZXF1YWxzKGE6IFJlY29ubmVjdFJlc3BvbnNlIHwgUGxhaW5NZXNzYWdlPFJlY29ubmVjdFJlc3BvbnNlPiB8IHVuZGVmaW5lZCwgYjogUmVjb25uZWN0UmVzcG9uc2UgfCBQbGFpbk1lc3NhZ2U8UmVjb25uZWN0UmVzcG9uc2U+IHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhSZWNvbm5lY3RSZXNwb25zZSwgYSwgYik7XG4gIH1cbn1cblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlRyYWNrUHVibGlzaGVkUmVzcG9uc2VcbiAqL1xuZXhwb3J0IGNsYXNzIFRyYWNrUHVibGlzaGVkUmVzcG9uc2UgZXh0ZW5kcyBNZXNzYWdlPFRyYWNrUHVibGlzaGVkUmVzcG9uc2U+IHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIGNpZCA9IDE7XG4gICAqL1xuICBjaWQgPSBcIlwiO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuVHJhY2tJbmZvIHRyYWNrID0gMjtcbiAgICovXG4gIHRyYWNrPzogVHJhY2tJbmZvO1xuXG4gIGNvbnN0cnVjdG9yKGRhdGE/OiBQYXJ0aWFsTWVzc2FnZTxUcmFja1B1Ymxpc2hlZFJlc3BvbnNlPikge1xuICAgIHN1cGVyKCk7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cblxuICBzdGF0aWMgcmVhZG9ubHkgcnVudGltZTogdHlwZW9mIHByb3RvMyA9IHByb3RvMztcbiAgc3RhdGljIHJlYWRvbmx5IHR5cGVOYW1lID0gXCJsaXZla2l0LlRyYWNrUHVibGlzaGVkUmVzcG9uc2VcIjtcbiAgc3RhdGljIHJlYWRvbmx5IGZpZWxkczogRmllbGRMaXN0ID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcImNpZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJ0cmFja1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVHJhY2tJbmZvIH0sXG4gIF0pO1xuXG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzOiBVaW50OEFycmF5LCBvcHRpb25zPzogUGFydGlhbDxCaW5hcnlSZWFkT3B0aW9ucz4pOiBUcmFja1B1Ymxpc2hlZFJlc3BvbnNlIHtcbiAgICByZXR1cm4gbmV3IFRyYWNrUHVibGlzaGVkUmVzcG9uc2UoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWU6IEpzb25WYWx1ZSwgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IFRyYWNrUHVibGlzaGVkUmVzcG9uc2Uge1xuICAgIHJldHVybiBuZXcgVHJhY2tQdWJsaXNoZWRSZXNwb25zZSgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZzogc3RyaW5nLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogVHJhY2tQdWJsaXNoZWRSZXNwb25zZSB7XG4gICAgcmV0dXJuIG5ldyBUcmFja1B1Ymxpc2hlZFJlc3BvbnNlKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZXF1YWxzKGE6IFRyYWNrUHVibGlzaGVkUmVzcG9uc2UgfCBQbGFpbk1lc3NhZ2U8VHJhY2tQdWJsaXNoZWRSZXNwb25zZT4gfCB1bmRlZmluZWQsIGI6IFRyYWNrUHVibGlzaGVkUmVzcG9uc2UgfCBQbGFpbk1lc3NhZ2U8VHJhY2tQdWJsaXNoZWRSZXNwb25zZT4gfCB1bmRlZmluZWQpOiBib29sZWFuIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFRyYWNrUHVibGlzaGVkUmVzcG9uc2UsIGEsIGIpO1xuICB9XG59XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5UcmFja1VucHVibGlzaGVkUmVzcG9uc2VcbiAqL1xuZXhwb3J0IGNsYXNzIFRyYWNrVW5wdWJsaXNoZWRSZXNwb25zZSBleHRlbmRzIE1lc3NhZ2U8VHJhY2tVbnB1Ymxpc2hlZFJlc3BvbnNlPiB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyB0cmFja19zaWQgPSAxO1xuICAgKi9cbiAgdHJhY2tTaWQgPSBcIlwiO1xuXG4gIGNvbnN0cnVjdG9yKGRhdGE/OiBQYXJ0aWFsTWVzc2FnZTxUcmFja1VucHVibGlzaGVkUmVzcG9uc2U+KSB7XG4gICAgc3VwZXIoKTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuXG4gIHN0YXRpYyByZWFkb25seSBydW50aW1lOiB0eXBlb2YgcHJvdG8zID0gcHJvdG8zO1xuICBzdGF0aWMgcmVhZG9ubHkgdHlwZU5hbWUgPSBcImxpdmVraXQuVHJhY2tVbnB1Ymxpc2hlZFJlc3BvbnNlXCI7XG4gIHN0YXRpYyByZWFkb25seSBmaWVsZHM6IEZpZWxkTGlzdCA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJ0cmFja19zaWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICBdKTtcblxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlczogVWludDhBcnJheSwgb3B0aW9ucz86IFBhcnRpYWw8QmluYXJ5UmVhZE9wdGlvbnM+KTogVHJhY2tVbnB1Ymxpc2hlZFJlc3BvbnNlIHtcbiAgICByZXR1cm4gbmV3IFRyYWNrVW5wdWJsaXNoZWRSZXNwb25zZSgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZTogSnNvblZhbHVlLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogVHJhY2tVbnB1Ymxpc2hlZFJlc3BvbnNlIHtcbiAgICByZXR1cm4gbmV3IFRyYWNrVW5wdWJsaXNoZWRSZXNwb25zZSgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZzogc3RyaW5nLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogVHJhY2tVbnB1Ymxpc2hlZFJlc3BvbnNlIHtcbiAgICByZXR1cm4gbmV3IFRyYWNrVW5wdWJsaXNoZWRSZXNwb25zZSgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGVxdWFscyhhOiBUcmFja1VucHVibGlzaGVkUmVzcG9uc2UgfCBQbGFpbk1lc3NhZ2U8VHJhY2tVbnB1Ymxpc2hlZFJlc3BvbnNlPiB8IHVuZGVmaW5lZCwgYjogVHJhY2tVbnB1Ymxpc2hlZFJlc3BvbnNlIHwgUGxhaW5NZXNzYWdlPFRyYWNrVW5wdWJsaXNoZWRSZXNwb25zZT4gfCB1bmRlZmluZWQpOiBib29sZWFuIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFRyYWNrVW5wdWJsaXNoZWRSZXNwb25zZSwgYSwgYik7XG4gIH1cbn1cblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlNlc3Npb25EZXNjcmlwdGlvblxuICovXG5leHBvcnQgY2xhc3MgU2Vzc2lvbkRlc2NyaXB0aW9uIGV4dGVuZHMgTWVzc2FnZTxTZXNzaW9uRGVzY3JpcHRpb24+IHtcbiAgLyoqXG4gICAqIFwiYW5zd2VyXCIgfCBcIm9mZmVyXCIgfCBcInByYW5zd2VyXCIgfCBcInJvbGxiYWNrXCJcbiAgICpcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgdHlwZSA9IDE7XG4gICAqL1xuICB0eXBlID0gXCJcIjtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgc2RwID0gMjtcbiAgICovXG4gIHNkcCA9IFwiXCI7XG5cbiAgY29uc3RydWN0b3IoZGF0YT86IFBhcnRpYWxNZXNzYWdlPFNlc3Npb25EZXNjcmlwdGlvbj4pIHtcbiAgICBzdXBlcigpO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG5cbiAgc3RhdGljIHJlYWRvbmx5IHJ1bnRpbWU6IHR5cGVvZiBwcm90bzMgPSBwcm90bzM7XG4gIHN0YXRpYyByZWFkb25seSB0eXBlTmFtZSA9IFwibGl2ZWtpdC5TZXNzaW9uRGVzY3JpcHRpb25cIjtcbiAgc3RhdGljIHJlYWRvbmx5IGZpZWxkczogRmllbGRMaXN0ID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInR5cGVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwic2RwXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgXSk7XG5cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXM6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBQYXJ0aWFsPEJpbmFyeVJlYWRPcHRpb25zPik6IFNlc3Npb25EZXNjcmlwdGlvbiB7XG4gICAgcmV0dXJuIG5ldyBTZXNzaW9uRGVzY3JpcHRpb24oKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWU6IEpzb25WYWx1ZSwgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IFNlc3Npb25EZXNjcmlwdGlvbiB7XG4gICAgcmV0dXJuIG5ldyBTZXNzaW9uRGVzY3JpcHRpb24oKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmc6IHN0cmluZywgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IFNlc3Npb25EZXNjcmlwdGlvbiB7XG4gICAgcmV0dXJuIG5ldyBTZXNzaW9uRGVzY3JpcHRpb24oKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBlcXVhbHMoYTogU2Vzc2lvbkRlc2NyaXB0aW9uIHwgUGxhaW5NZXNzYWdlPFNlc3Npb25EZXNjcmlwdGlvbj4gfCB1bmRlZmluZWQsIGI6IFNlc3Npb25EZXNjcmlwdGlvbiB8IFBsYWluTWVzc2FnZTxTZXNzaW9uRGVzY3JpcHRpb24+IHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhTZXNzaW9uRGVzY3JpcHRpb24sIGEsIGIpO1xuICB9XG59XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5QYXJ0aWNpcGFudFVwZGF0ZVxuICovXG5leHBvcnQgY2xhc3MgUGFydGljaXBhbnRVcGRhdGUgZXh0ZW5kcyBNZXNzYWdlPFBhcnRpY2lwYW50VXBkYXRlPiB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGxpdmVraXQuUGFydGljaXBhbnRJbmZvIHBhcnRpY2lwYW50cyA9IDE7XG4gICAqL1xuICBwYXJ0aWNpcGFudHM6IFBhcnRpY2lwYW50SW5mb1tdID0gW107XG5cbiAgY29uc3RydWN0b3IoZGF0YT86IFBhcnRpYWxNZXNzYWdlPFBhcnRpY2lwYW50VXBkYXRlPikge1xuICAgIHN1cGVyKCk7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cblxuICBzdGF0aWMgcmVhZG9ubHkgcnVudGltZTogdHlwZW9mIHByb3RvMyA9IHByb3RvMztcbiAgc3RhdGljIHJlYWRvbmx5IHR5cGVOYW1lID0gXCJsaXZla2l0LlBhcnRpY2lwYW50VXBkYXRlXCI7XG4gIHN0YXRpYyByZWFkb25seSBmaWVsZHM6IEZpZWxkTGlzdCA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJwYXJ0aWNpcGFudHNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFBhcnRpY2lwYW50SW5mbywgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgXSk7XG5cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXM6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBQYXJ0aWFsPEJpbmFyeVJlYWRPcHRpb25zPik6IFBhcnRpY2lwYW50VXBkYXRlIHtcbiAgICByZXR1cm4gbmV3IFBhcnRpY2lwYW50VXBkYXRlKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlOiBKc29uVmFsdWUsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBQYXJ0aWNpcGFudFVwZGF0ZSB7XG4gICAgcmV0dXJuIG5ldyBQYXJ0aWNpcGFudFVwZGF0ZSgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZzogc3RyaW5nLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogUGFydGljaXBhbnRVcGRhdGUge1xuICAgIHJldHVybiBuZXcgUGFydGljaXBhbnRVcGRhdGUoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBlcXVhbHMoYTogUGFydGljaXBhbnRVcGRhdGUgfCBQbGFpbk1lc3NhZ2U8UGFydGljaXBhbnRVcGRhdGU+IHwgdW5kZWZpbmVkLCBiOiBQYXJ0aWNpcGFudFVwZGF0ZSB8IFBsYWluTWVzc2FnZTxQYXJ0aWNpcGFudFVwZGF0ZT4gfCB1bmRlZmluZWQpOiBib29sZWFuIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFBhcnRpY2lwYW50VXBkYXRlLCBhLCBiKTtcbiAgfVxufVxuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuVXBkYXRlU3Vic2NyaXB0aW9uXG4gKi9cbmV4cG9ydCBjbGFzcyBVcGRhdGVTdWJzY3JpcHRpb24gZXh0ZW5kcyBNZXNzYWdlPFVwZGF0ZVN1YnNjcmlwdGlvbj4ge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBzdHJpbmcgdHJhY2tfc2lkcyA9IDE7XG4gICAqL1xuICB0cmFja1NpZHM6IHN0cmluZ1tdID0gW107XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYm9vbCBzdWJzY3JpYmUgPSAyO1xuICAgKi9cbiAgc3Vic2NyaWJlID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgbGl2ZWtpdC5QYXJ0aWNpcGFudFRyYWNrcyBwYXJ0aWNpcGFudF90cmFja3MgPSAzO1xuICAgKi9cbiAgcGFydGljaXBhbnRUcmFja3M6IFBhcnRpY2lwYW50VHJhY2tzW10gPSBbXTtcblxuICBjb25zdHJ1Y3RvcihkYXRhPzogUGFydGlhbE1lc3NhZ2U8VXBkYXRlU3Vic2NyaXB0aW9uPikge1xuICAgIHN1cGVyKCk7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cblxuICBzdGF0aWMgcmVhZG9ubHkgcnVudGltZTogdHlwZW9mIHByb3RvMyA9IHByb3RvMztcbiAgc3RhdGljIHJlYWRvbmx5IHR5cGVOYW1lID0gXCJsaXZla2l0LlVwZGF0ZVN1YnNjcmlwdGlvblwiO1xuICBzdGF0aWMgcmVhZG9ubHkgZmllbGRzOiBGaWVsZExpc3QgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwidHJhY2tfc2lkc1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovLCByZXBlYXRlZDogdHJ1ZSB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwic3Vic2NyaWJlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJwYXJ0aWNpcGFudF90cmFja3NcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFBhcnRpY2lwYW50VHJhY2tzLCByZXBlYXRlZDogdHJ1ZSB9LFxuICBdKTtcblxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlczogVWludDhBcnJheSwgb3B0aW9ucz86IFBhcnRpYWw8QmluYXJ5UmVhZE9wdGlvbnM+KTogVXBkYXRlU3Vic2NyaXB0aW9uIHtcbiAgICByZXR1cm4gbmV3IFVwZGF0ZVN1YnNjcmlwdGlvbigpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZTogSnNvblZhbHVlLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogVXBkYXRlU3Vic2NyaXB0aW9uIHtcbiAgICByZXR1cm4gbmV3IFVwZGF0ZVN1YnNjcmlwdGlvbigpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZzogc3RyaW5nLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogVXBkYXRlU3Vic2NyaXB0aW9uIHtcbiAgICByZXR1cm4gbmV3IFVwZGF0ZVN1YnNjcmlwdGlvbigpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGVxdWFscyhhOiBVcGRhdGVTdWJzY3JpcHRpb24gfCBQbGFpbk1lc3NhZ2U8VXBkYXRlU3Vic2NyaXB0aW9uPiB8IHVuZGVmaW5lZCwgYjogVXBkYXRlU3Vic2NyaXB0aW9uIHwgUGxhaW5NZXNzYWdlPFVwZGF0ZVN1YnNjcmlwdGlvbj4gfCB1bmRlZmluZWQpOiBib29sZWFuIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFVwZGF0ZVN1YnNjcmlwdGlvbiwgYSwgYik7XG4gIH1cbn1cblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlVwZGF0ZVRyYWNrU2V0dGluZ3NcbiAqL1xuZXhwb3J0IGNsYXNzIFVwZGF0ZVRyYWNrU2V0dGluZ3MgZXh0ZW5kcyBNZXNzYWdlPFVwZGF0ZVRyYWNrU2V0dGluZ3M+IHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgc3RyaW5nIHRyYWNrX3NpZHMgPSAxO1xuICAgKi9cbiAgdHJhY2tTaWRzOiBzdHJpbmdbXSA9IFtdO1xuXG4gIC8qKlxuICAgKiB3aGVuIHRydWUsIHRoZSB0cmFjayBpcyBwbGFjZWQgaW4gYSBwYXVzZWQgc3RhdGUsIHdpdGggbm8gbmV3IGRhdGEgcmV0dXJuZWRcbiAgICpcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBib29sIGRpc2FibGVkID0gMztcbiAgICovXG4gIGRpc2FibGVkID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2Ygd2lkdGggJiBoZWlnaHRcbiAgICpcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LlZpZGVvUXVhbGl0eSBxdWFsaXR5ID0gNDtcbiAgICovXG4gIHF1YWxpdHkgPSBWaWRlb1F1YWxpdHkuTE9XO1xuXG4gIC8qKlxuICAgKiBmb3IgdmlkZW8sIHdpZHRoIHRvIHJlY2VpdmVcbiAgICpcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50MzIgd2lkdGggPSA1O1xuICAgKi9cbiAgd2lkdGggPSAwO1xuXG4gIC8qKlxuICAgKiBmb3IgdmlkZW8sIGhlaWdodCB0byByZWNlaXZlXG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIGhlaWdodCA9IDY7XG4gICAqL1xuICBoZWlnaHQgPSAwO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiBmcHMgPSA3O1xuICAgKi9cbiAgZnBzID0gMDtcblxuICAvKipcbiAgICogc3Vic2NyaXB0aW9uIHByaW9yaXR5LiAxIGJlaW5nIHRoZSBoaWdoZXN0ICgwIGlzIHVuc2V0KVxuICAgKiB3aGVuIHVuc2V0LCBzZXJ2ZXIgc2lsbCBhc3NpZ24gcHJpb3JpdHkgYmFzZWQgb24gdGhlIG9yZGVyIG9mIHN1YnNjcmlwdGlvblxuICAgKiBzZXJ2ZXIgd2lsbCB1c2UgcHJpb3JpdHkgaW4gdGhlIGZvbGxvd2luZyB3YXlzOlxuICAgKiAxLiB3aGVuIHN1YnNjcmliZWQgdHJhY2tzIGV4Y2VlZCBwZXItcGFydGljaXBhbnQgc3Vic2NyaXB0aW9uIGxpbWl0LCBzZXJ2ZXIgd2lsbFxuICAgKiAgICBwYXVzZSB0aGUgbG93ZXN0IHByaW9yaXR5IHRyYWNrc1xuICAgKiAyLiB3aGVuIHRoZSBuZXR3b3JrIGlzIGNvbmdlc3RlZCwgc2VydmVyIHdpbGwgYXNzaWduIGF2YWlsYWJsZSBiYW5kd2lkdGggdG9cbiAgICogICAgaGlnaGVyIHByaW9yaXR5IHRyYWNrcyBmaXJzdC4gbG93ZXN0IHByaW9yaXR5IHRyYWNrcyBjYW4gYmUgcGF1c2VkXG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIHByaW9yaXR5ID0gODtcbiAgICovXG4gIHByaW9yaXR5ID0gMDtcblxuICBjb25zdHJ1Y3RvcihkYXRhPzogUGFydGlhbE1lc3NhZ2U8VXBkYXRlVHJhY2tTZXR0aW5ncz4pIHtcbiAgICBzdXBlcigpO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG5cbiAgc3RhdGljIHJlYWRvbmx5IHJ1bnRpbWU6IHR5cGVvZiBwcm90bzMgPSBwcm90bzM7XG4gIHN0YXRpYyByZWFkb25seSB0eXBlTmFtZSA9IFwibGl2ZWtpdC5VcGRhdGVUcmFja1NldHRpbmdzXCI7XG4gIHN0YXRpYyByZWFkb25seSBmaWVsZHM6IEZpZWxkTGlzdCA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJ0cmFja19zaWRzXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8sIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJkaXNhYmxlZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLyB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwicXVhbGl0eVwiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLmdldEVudW1UeXBlKFZpZGVvUXVhbGl0eSkgfSxcbiAgICB7IG5vOiA1LCBuYW1lOiBcIndpZHRoXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovIH0sXG4gICAgeyBubzogNiwgbmFtZTogXCJoZWlnaHRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi8gfSxcbiAgICB7IG5vOiA3LCBuYW1lOiBcImZwc1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqLyB9LFxuICAgIHsgbm86IDgsIG5hbWU6IFwicHJpb3JpdHlcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi8gfSxcbiAgXSk7XG5cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXM6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBQYXJ0aWFsPEJpbmFyeVJlYWRPcHRpb25zPik6IFVwZGF0ZVRyYWNrU2V0dGluZ3Mge1xuICAgIHJldHVybiBuZXcgVXBkYXRlVHJhY2tTZXR0aW5ncygpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZTogSnNvblZhbHVlLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogVXBkYXRlVHJhY2tTZXR0aW5ncyB7XG4gICAgcmV0dXJuIG5ldyBVcGRhdGVUcmFja1NldHRpbmdzKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nOiBzdHJpbmcsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBVcGRhdGVUcmFja1NldHRpbmdzIHtcbiAgICByZXR1cm4gbmV3IFVwZGF0ZVRyYWNrU2V0dGluZ3MoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBlcXVhbHMoYTogVXBkYXRlVHJhY2tTZXR0aW5ncyB8IFBsYWluTWVzc2FnZTxVcGRhdGVUcmFja1NldHRpbmdzPiB8IHVuZGVmaW5lZCwgYjogVXBkYXRlVHJhY2tTZXR0aW5ncyB8IFBsYWluTWVzc2FnZTxVcGRhdGVUcmFja1NldHRpbmdzPiB8IHVuZGVmaW5lZCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoVXBkYXRlVHJhY2tTZXR0aW5ncywgYSwgYik7XG4gIH1cbn1cblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LkxlYXZlUmVxdWVzdFxuICovXG5leHBvcnQgY2xhc3MgTGVhdmVSZXF1ZXN0IGV4dGVuZHMgTWVzc2FnZTxMZWF2ZVJlcXVlc3Q+IHtcbiAgLyoqXG4gICAqIHNlbnQgd2hlbiBzZXJ2ZXIgaW5pdGlhdGVzIHRoZSBkaXNjb25uZWN0IGR1ZSB0byBzZXJ2ZXItcmVzdGFydFxuICAgKiBpbmRpY2F0ZXMgY2xpZW50cyBzaG91bGQgYXR0ZW1wdCBmdWxsLXJlY29ubmVjdCBzZXF1ZW5jZVxuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGJvb2wgY2FuX3JlY29ubmVjdCA9IDE7XG4gICAqL1xuICBjYW5SZWNvbm5lY3QgPSBmYWxzZTtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LkRpc2Nvbm5lY3RSZWFzb24gcmVhc29uID0gMjtcbiAgICovXG4gIHJlYXNvbiA9IERpc2Nvbm5lY3RSZWFzb24uVU5LTk9XTl9SRUFTT047XG5cbiAgY29uc3RydWN0b3IoZGF0YT86IFBhcnRpYWxNZXNzYWdlPExlYXZlUmVxdWVzdD4pIHtcbiAgICBzdXBlcigpO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG5cbiAgc3RhdGljIHJlYWRvbmx5IHJ1bnRpbWU6IHR5cGVvZiBwcm90bzMgPSBwcm90bzM7XG4gIHN0YXRpYyByZWFkb25seSB0eXBlTmFtZSA9IFwibGl2ZWtpdC5MZWF2ZVJlcXVlc3RcIjtcbiAgc3RhdGljIHJlYWRvbmx5IGZpZWxkczogRmllbGRMaXN0ID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcImNhbl9yZWNvbm5lY3RcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi8gfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcInJlYXNvblwiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLmdldEVudW1UeXBlKERpc2Nvbm5lY3RSZWFzb24pIH0sXG4gIF0pO1xuXG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzOiBVaW50OEFycmF5LCBvcHRpb25zPzogUGFydGlhbDxCaW5hcnlSZWFkT3B0aW9ucz4pOiBMZWF2ZVJlcXVlc3Qge1xuICAgIHJldHVybiBuZXcgTGVhdmVSZXF1ZXN0KCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlOiBKc29uVmFsdWUsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBMZWF2ZVJlcXVlc3Qge1xuICAgIHJldHVybiBuZXcgTGVhdmVSZXF1ZXN0KCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nOiBzdHJpbmcsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBMZWF2ZVJlcXVlc3Qge1xuICAgIHJldHVybiBuZXcgTGVhdmVSZXF1ZXN0KCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZXF1YWxzKGE6IExlYXZlUmVxdWVzdCB8IFBsYWluTWVzc2FnZTxMZWF2ZVJlcXVlc3Q+IHwgdW5kZWZpbmVkLCBiOiBMZWF2ZVJlcXVlc3QgfCBQbGFpbk1lc3NhZ2U8TGVhdmVSZXF1ZXN0PiB8IHVuZGVmaW5lZCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoTGVhdmVSZXF1ZXN0LCBhLCBiKTtcbiAgfVxufVxuXG4vKipcbiAqIG1lc3NhZ2UgdG8gaW5kaWNhdGUgcHVibGlzaGVkIHZpZGVvIHRyYWNrIGRpbWVuc2lvbnMgYXJlIGNoYW5naW5nXG4gKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5VcGRhdGVWaWRlb0xheWVyc1xuICovXG5leHBvcnQgY2xhc3MgVXBkYXRlVmlkZW9MYXllcnMgZXh0ZW5kcyBNZXNzYWdlPFVwZGF0ZVZpZGVvTGF5ZXJzPiB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyB0cmFja19zaWQgPSAxO1xuICAgKi9cbiAgdHJhY2tTaWQgPSBcIlwiO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGxpdmVraXQuVmlkZW9MYXllciBsYXllcnMgPSAyO1xuICAgKi9cbiAgbGF5ZXJzOiBWaWRlb0xheWVyW10gPSBbXTtcblxuICBjb25zdHJ1Y3RvcihkYXRhPzogUGFydGlhbE1lc3NhZ2U8VXBkYXRlVmlkZW9MYXllcnM+KSB7XG4gICAgc3VwZXIoKTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuXG4gIHN0YXRpYyByZWFkb25seSBydW50aW1lOiB0eXBlb2YgcHJvdG8zID0gcHJvdG8zO1xuICBzdGF0aWMgcmVhZG9ubHkgdHlwZU5hbWUgPSBcImxpdmVraXQuVXBkYXRlVmlkZW9MYXllcnNcIjtcbiAgc3RhdGljIHJlYWRvbmx5IGZpZWxkczogRmllbGRMaXN0ID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInRyYWNrX3NpZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJsYXllcnNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFZpZGVvTGF5ZXIsIHJlcGVhdGVkOiB0cnVlIH0sXG4gIF0pO1xuXG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzOiBVaW50OEFycmF5LCBvcHRpb25zPzogUGFydGlhbDxCaW5hcnlSZWFkT3B0aW9ucz4pOiBVcGRhdGVWaWRlb0xheWVycyB7XG4gICAgcmV0dXJuIG5ldyBVcGRhdGVWaWRlb0xheWVycygpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZTogSnNvblZhbHVlLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogVXBkYXRlVmlkZW9MYXllcnMge1xuICAgIHJldHVybiBuZXcgVXBkYXRlVmlkZW9MYXllcnMoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmc6IHN0cmluZywgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IFVwZGF0ZVZpZGVvTGF5ZXJzIHtcbiAgICByZXR1cm4gbmV3IFVwZGF0ZVZpZGVvTGF5ZXJzKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZXF1YWxzKGE6IFVwZGF0ZVZpZGVvTGF5ZXJzIHwgUGxhaW5NZXNzYWdlPFVwZGF0ZVZpZGVvTGF5ZXJzPiB8IHVuZGVmaW5lZCwgYjogVXBkYXRlVmlkZW9MYXllcnMgfCBQbGFpbk1lc3NhZ2U8VXBkYXRlVmlkZW9MYXllcnM+IHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhVcGRhdGVWaWRlb0xheWVycywgYSwgYik7XG4gIH1cbn1cblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlVwZGF0ZVBhcnRpY2lwYW50TWV0YWRhdGFcbiAqL1xuZXhwb3J0IGNsYXNzIFVwZGF0ZVBhcnRpY2lwYW50TWV0YWRhdGEgZXh0ZW5kcyBNZXNzYWdlPFVwZGF0ZVBhcnRpY2lwYW50TWV0YWRhdGE+IHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIG1ldGFkYXRhID0gMTtcbiAgICovXG4gIG1ldGFkYXRhID0gXCJcIjtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgbmFtZSA9IDI7XG4gICAqL1xuICBuYW1lID0gXCJcIjtcblxuICBjb25zdHJ1Y3RvcihkYXRhPzogUGFydGlhbE1lc3NhZ2U8VXBkYXRlUGFydGljaXBhbnRNZXRhZGF0YT4pIHtcbiAgICBzdXBlcigpO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG5cbiAgc3RhdGljIHJlYWRvbmx5IHJ1bnRpbWU6IHR5cGVvZiBwcm90bzMgPSBwcm90bzM7XG4gIHN0YXRpYyByZWFkb25seSB0eXBlTmFtZSA9IFwibGl2ZWtpdC5VcGRhdGVQYXJ0aWNpcGFudE1ldGFkYXRhXCI7XG4gIHN0YXRpYyByZWFkb25seSBmaWVsZHM6IEZpZWxkTGlzdCA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJtZXRhZGF0YVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJuYW1lXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgXSk7XG5cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXM6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBQYXJ0aWFsPEJpbmFyeVJlYWRPcHRpb25zPik6IFVwZGF0ZVBhcnRpY2lwYW50TWV0YWRhdGEge1xuICAgIHJldHVybiBuZXcgVXBkYXRlUGFydGljaXBhbnRNZXRhZGF0YSgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZTogSnNvblZhbHVlLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogVXBkYXRlUGFydGljaXBhbnRNZXRhZGF0YSB7XG4gICAgcmV0dXJuIG5ldyBVcGRhdGVQYXJ0aWNpcGFudE1ldGFkYXRhKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nOiBzdHJpbmcsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBVcGRhdGVQYXJ0aWNpcGFudE1ldGFkYXRhIHtcbiAgICByZXR1cm4gbmV3IFVwZGF0ZVBhcnRpY2lwYW50TWV0YWRhdGEoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBlcXVhbHMoYTogVXBkYXRlUGFydGljaXBhbnRNZXRhZGF0YSB8IFBsYWluTWVzc2FnZTxVcGRhdGVQYXJ0aWNpcGFudE1ldGFkYXRhPiB8IHVuZGVmaW5lZCwgYjogVXBkYXRlUGFydGljaXBhbnRNZXRhZGF0YSB8IFBsYWluTWVzc2FnZTxVcGRhdGVQYXJ0aWNpcGFudE1ldGFkYXRhPiB8IHVuZGVmaW5lZCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoVXBkYXRlUGFydGljaXBhbnRNZXRhZGF0YSwgYSwgYik7XG4gIH1cbn1cblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LklDRVNlcnZlclxuICovXG5leHBvcnQgY2xhc3MgSUNFU2VydmVyIGV4dGVuZHMgTWVzc2FnZTxJQ0VTZXJ2ZXI+IHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgc3RyaW5nIHVybHMgPSAxO1xuICAgKi9cbiAgdXJsczogc3RyaW5nW10gPSBbXTtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgdXNlcm5hbWUgPSAyO1xuICAgKi9cbiAgdXNlcm5hbWUgPSBcIlwiO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBjcmVkZW50aWFsID0gMztcbiAgICovXG4gIGNyZWRlbnRpYWwgPSBcIlwiO1xuXG4gIGNvbnN0cnVjdG9yKGRhdGE/OiBQYXJ0aWFsTWVzc2FnZTxJQ0VTZXJ2ZXI+KSB7XG4gICAgc3VwZXIoKTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuXG4gIHN0YXRpYyByZWFkb25seSBydW50aW1lOiB0eXBlb2YgcHJvdG8zID0gcHJvdG8zO1xuICBzdGF0aWMgcmVhZG9ubHkgdHlwZU5hbWUgPSBcImxpdmVraXQuSUNFU2VydmVyXCI7XG4gIHN0YXRpYyByZWFkb25seSBmaWVsZHM6IEZpZWxkTGlzdCA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJ1cmxzXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8sIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJ1c2VybmFtZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJjcmVkZW50aWFsXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgXSk7XG5cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXM6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBQYXJ0aWFsPEJpbmFyeVJlYWRPcHRpb25zPik6IElDRVNlcnZlciB7XG4gICAgcmV0dXJuIG5ldyBJQ0VTZXJ2ZXIoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWU6IEpzb25WYWx1ZSwgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IElDRVNlcnZlciB7XG4gICAgcmV0dXJuIG5ldyBJQ0VTZXJ2ZXIoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmc6IHN0cmluZywgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IElDRVNlcnZlciB7XG4gICAgcmV0dXJuIG5ldyBJQ0VTZXJ2ZXIoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBlcXVhbHMoYTogSUNFU2VydmVyIHwgUGxhaW5NZXNzYWdlPElDRVNlcnZlcj4gfCB1bmRlZmluZWQsIGI6IElDRVNlcnZlciB8IFBsYWluTWVzc2FnZTxJQ0VTZXJ2ZXI+IHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhJQ0VTZXJ2ZXIsIGEsIGIpO1xuICB9XG59XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5TcGVha2Vyc0NoYW5nZWRcbiAqL1xuZXhwb3J0IGNsYXNzIFNwZWFrZXJzQ2hhbmdlZCBleHRlbmRzIE1lc3NhZ2U8U3BlYWtlcnNDaGFuZ2VkPiB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGxpdmVraXQuU3BlYWtlckluZm8gc3BlYWtlcnMgPSAxO1xuICAgKi9cbiAgc3BlYWtlcnM6IFNwZWFrZXJJbmZvW10gPSBbXTtcblxuICBjb25zdHJ1Y3RvcihkYXRhPzogUGFydGlhbE1lc3NhZ2U8U3BlYWtlcnNDaGFuZ2VkPikge1xuICAgIHN1cGVyKCk7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cblxuICBzdGF0aWMgcmVhZG9ubHkgcnVudGltZTogdHlwZW9mIHByb3RvMyA9IHByb3RvMztcbiAgc3RhdGljIHJlYWRvbmx5IHR5cGVOYW1lID0gXCJsaXZla2l0LlNwZWFrZXJzQ2hhbmdlZFwiO1xuICBzdGF0aWMgcmVhZG9ubHkgZmllbGRzOiBGaWVsZExpc3QgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwic3BlYWtlcnNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFNwZWFrZXJJbmZvLCByZXBlYXRlZDogdHJ1ZSB9LFxuICBdKTtcblxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlczogVWludDhBcnJheSwgb3B0aW9ucz86IFBhcnRpYWw8QmluYXJ5UmVhZE9wdGlvbnM+KTogU3BlYWtlcnNDaGFuZ2VkIHtcbiAgICByZXR1cm4gbmV3IFNwZWFrZXJzQ2hhbmdlZCgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZTogSnNvblZhbHVlLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogU3BlYWtlcnNDaGFuZ2VkIHtcbiAgICByZXR1cm4gbmV3IFNwZWFrZXJzQ2hhbmdlZCgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZzogc3RyaW5nLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogU3BlYWtlcnNDaGFuZ2VkIHtcbiAgICByZXR1cm4gbmV3IFNwZWFrZXJzQ2hhbmdlZCgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGVxdWFscyhhOiBTcGVha2Vyc0NoYW5nZWQgfCBQbGFpbk1lc3NhZ2U8U3BlYWtlcnNDaGFuZ2VkPiB8IHVuZGVmaW5lZCwgYjogU3BlYWtlcnNDaGFuZ2VkIHwgUGxhaW5NZXNzYWdlPFNwZWFrZXJzQ2hhbmdlZD4gfCB1bmRlZmluZWQpOiBib29sZWFuIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFNwZWFrZXJzQ2hhbmdlZCwgYSwgYik7XG4gIH1cbn1cblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlJvb21VcGRhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIFJvb21VcGRhdGUgZXh0ZW5kcyBNZXNzYWdlPFJvb21VcGRhdGU+IHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5Sb29tIHJvb20gPSAxO1xuICAgKi9cbiAgcm9vbT86IFJvb207XG5cbiAgY29uc3RydWN0b3IoZGF0YT86IFBhcnRpYWxNZXNzYWdlPFJvb21VcGRhdGU+KSB7XG4gICAgc3VwZXIoKTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuXG4gIHN0YXRpYyByZWFkb25seSBydW50aW1lOiB0eXBlb2YgcHJvdG8zID0gcHJvdG8zO1xuICBzdGF0aWMgcmVhZG9ubHkgdHlwZU5hbWUgPSBcImxpdmVraXQuUm9vbVVwZGF0ZVwiO1xuICBzdGF0aWMgcmVhZG9ubHkgZmllbGRzOiBGaWVsZExpc3QgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwicm9vbVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogUm9vbSB9LFxuICBdKTtcblxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlczogVWludDhBcnJheSwgb3B0aW9ucz86IFBhcnRpYWw8QmluYXJ5UmVhZE9wdGlvbnM+KTogUm9vbVVwZGF0ZSB7XG4gICAgcmV0dXJuIG5ldyBSb29tVXBkYXRlKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlOiBKc29uVmFsdWUsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBSb29tVXBkYXRlIHtcbiAgICByZXR1cm4gbmV3IFJvb21VcGRhdGUoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmc6IHN0cmluZywgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IFJvb21VcGRhdGUge1xuICAgIHJldHVybiBuZXcgUm9vbVVwZGF0ZSgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGVxdWFscyhhOiBSb29tVXBkYXRlIHwgUGxhaW5NZXNzYWdlPFJvb21VcGRhdGU+IHwgdW5kZWZpbmVkLCBiOiBSb29tVXBkYXRlIHwgUGxhaW5NZXNzYWdlPFJvb21VcGRhdGU+IHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhSb29tVXBkYXRlLCBhLCBiKTtcbiAgfVxufVxuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuQ29ubmVjdGlvblF1YWxpdHlJbmZvXG4gKi9cbmV4cG9ydCBjbGFzcyBDb25uZWN0aW9uUXVhbGl0eUluZm8gZXh0ZW5kcyBNZXNzYWdlPENvbm5lY3Rpb25RdWFsaXR5SW5mbz4ge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgcGFydGljaXBhbnRfc2lkID0gMTtcbiAgICovXG4gIHBhcnRpY2lwYW50U2lkID0gXCJcIjtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LkNvbm5lY3Rpb25RdWFsaXR5IHF1YWxpdHkgPSAyO1xuICAgKi9cbiAgcXVhbGl0eSA9IENvbm5lY3Rpb25RdWFsaXR5LlBPT1I7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogZmxvYXQgc2NvcmUgPSAzO1xuICAgKi9cbiAgc2NvcmUgPSAwO1xuXG4gIGNvbnN0cnVjdG9yKGRhdGE/OiBQYXJ0aWFsTWVzc2FnZTxDb25uZWN0aW9uUXVhbGl0eUluZm8+KSB7XG4gICAgc3VwZXIoKTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuXG4gIHN0YXRpYyByZWFkb25seSBydW50aW1lOiB0eXBlb2YgcHJvdG8zID0gcHJvdG8zO1xuICBzdGF0aWMgcmVhZG9ubHkgdHlwZU5hbWUgPSBcImxpdmVraXQuQ29ubmVjdGlvblF1YWxpdHlJbmZvXCI7XG4gIHN0YXRpYyByZWFkb25seSBmaWVsZHM6IEZpZWxkTGlzdCA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJwYXJ0aWNpcGFudF9zaWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwicXVhbGl0eVwiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLmdldEVudW1UeXBlKENvbm5lY3Rpb25RdWFsaXR5KSB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwic2NvcmVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMiAvKiBTY2FsYXJUeXBlLkZMT0FUICovIH0sXG4gIF0pO1xuXG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzOiBVaW50OEFycmF5LCBvcHRpb25zPzogUGFydGlhbDxCaW5hcnlSZWFkT3B0aW9ucz4pOiBDb25uZWN0aW9uUXVhbGl0eUluZm8ge1xuICAgIHJldHVybiBuZXcgQ29ubmVjdGlvblF1YWxpdHlJbmZvKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlOiBKc29uVmFsdWUsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBDb25uZWN0aW9uUXVhbGl0eUluZm8ge1xuICAgIHJldHVybiBuZXcgQ29ubmVjdGlvblF1YWxpdHlJbmZvKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nOiBzdHJpbmcsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBDb25uZWN0aW9uUXVhbGl0eUluZm8ge1xuICAgIHJldHVybiBuZXcgQ29ubmVjdGlvblF1YWxpdHlJbmZvKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZXF1YWxzKGE6IENvbm5lY3Rpb25RdWFsaXR5SW5mbyB8IFBsYWluTWVzc2FnZTxDb25uZWN0aW9uUXVhbGl0eUluZm8+IHwgdW5kZWZpbmVkLCBiOiBDb25uZWN0aW9uUXVhbGl0eUluZm8gfCBQbGFpbk1lc3NhZ2U8Q29ubmVjdGlvblF1YWxpdHlJbmZvPiB8IHVuZGVmaW5lZCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoQ29ubmVjdGlvblF1YWxpdHlJbmZvLCBhLCBiKTtcbiAgfVxufVxuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuQ29ubmVjdGlvblF1YWxpdHlVcGRhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIENvbm5lY3Rpb25RdWFsaXR5VXBkYXRlIGV4dGVuZHMgTWVzc2FnZTxDb25uZWN0aW9uUXVhbGl0eVVwZGF0ZT4ge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBsaXZla2l0LkNvbm5lY3Rpb25RdWFsaXR5SW5mbyB1cGRhdGVzID0gMTtcbiAgICovXG4gIHVwZGF0ZXM6IENvbm5lY3Rpb25RdWFsaXR5SW5mb1tdID0gW107XG5cbiAgY29uc3RydWN0b3IoZGF0YT86IFBhcnRpYWxNZXNzYWdlPENvbm5lY3Rpb25RdWFsaXR5VXBkYXRlPikge1xuICAgIHN1cGVyKCk7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cblxuICBzdGF0aWMgcmVhZG9ubHkgcnVudGltZTogdHlwZW9mIHByb3RvMyA9IHByb3RvMztcbiAgc3RhdGljIHJlYWRvbmx5IHR5cGVOYW1lID0gXCJsaXZla2l0LkNvbm5lY3Rpb25RdWFsaXR5VXBkYXRlXCI7XG4gIHN0YXRpYyByZWFkb25seSBmaWVsZHM6IEZpZWxkTGlzdCA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJ1cGRhdGVzXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBDb25uZWN0aW9uUXVhbGl0eUluZm8sIHJlcGVhdGVkOiB0cnVlIH0sXG4gIF0pO1xuXG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzOiBVaW50OEFycmF5LCBvcHRpb25zPzogUGFydGlhbDxCaW5hcnlSZWFkT3B0aW9ucz4pOiBDb25uZWN0aW9uUXVhbGl0eVVwZGF0ZSB7XG4gICAgcmV0dXJuIG5ldyBDb25uZWN0aW9uUXVhbGl0eVVwZGF0ZSgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZTogSnNvblZhbHVlLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogQ29ubmVjdGlvblF1YWxpdHlVcGRhdGUge1xuICAgIHJldHVybiBuZXcgQ29ubmVjdGlvblF1YWxpdHlVcGRhdGUoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmc6IHN0cmluZywgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IENvbm5lY3Rpb25RdWFsaXR5VXBkYXRlIHtcbiAgICByZXR1cm4gbmV3IENvbm5lY3Rpb25RdWFsaXR5VXBkYXRlKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZXF1YWxzKGE6IENvbm5lY3Rpb25RdWFsaXR5VXBkYXRlIHwgUGxhaW5NZXNzYWdlPENvbm5lY3Rpb25RdWFsaXR5VXBkYXRlPiB8IHVuZGVmaW5lZCwgYjogQ29ubmVjdGlvblF1YWxpdHlVcGRhdGUgfCBQbGFpbk1lc3NhZ2U8Q29ubmVjdGlvblF1YWxpdHlVcGRhdGU+IHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhDb25uZWN0aW9uUXVhbGl0eVVwZGF0ZSwgYSwgYik7XG4gIH1cbn1cblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlN0cmVhbVN0YXRlSW5mb1xuICovXG5leHBvcnQgY2xhc3MgU3RyZWFtU3RhdGVJbmZvIGV4dGVuZHMgTWVzc2FnZTxTdHJlYW1TdGF0ZUluZm8+IHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHBhcnRpY2lwYW50X3NpZCA9IDE7XG4gICAqL1xuICBwYXJ0aWNpcGFudFNpZCA9IFwiXCI7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHRyYWNrX3NpZCA9IDI7XG4gICAqL1xuICB0cmFja1NpZCA9IFwiXCI7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5TdHJlYW1TdGF0ZSBzdGF0ZSA9IDM7XG4gICAqL1xuICBzdGF0ZSA9IFN0cmVhbVN0YXRlLkFDVElWRTtcblxuICBjb25zdHJ1Y3RvcihkYXRhPzogUGFydGlhbE1lc3NhZ2U8U3RyZWFtU3RhdGVJbmZvPikge1xuICAgIHN1cGVyKCk7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cblxuICBzdGF0aWMgcmVhZG9ubHkgcnVudGltZTogdHlwZW9mIHByb3RvMyA9IHByb3RvMztcbiAgc3RhdGljIHJlYWRvbmx5IHR5cGVOYW1lID0gXCJsaXZla2l0LlN0cmVhbVN0YXRlSW5mb1wiO1xuICBzdGF0aWMgcmVhZG9ubHkgZmllbGRzOiBGaWVsZExpc3QgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwicGFydGljaXBhbnRfc2lkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcInRyYWNrX3NpZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJzdGF0ZVwiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLmdldEVudW1UeXBlKFN0cmVhbVN0YXRlKSB9LFxuICBdKTtcblxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlczogVWludDhBcnJheSwgb3B0aW9ucz86IFBhcnRpYWw8QmluYXJ5UmVhZE9wdGlvbnM+KTogU3RyZWFtU3RhdGVJbmZvIHtcbiAgICByZXR1cm4gbmV3IFN0cmVhbVN0YXRlSW5mbygpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZTogSnNvblZhbHVlLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogU3RyZWFtU3RhdGVJbmZvIHtcbiAgICByZXR1cm4gbmV3IFN0cmVhbVN0YXRlSW5mbygpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZzogc3RyaW5nLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogU3RyZWFtU3RhdGVJbmZvIHtcbiAgICByZXR1cm4gbmV3IFN0cmVhbVN0YXRlSW5mbygpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGVxdWFscyhhOiBTdHJlYW1TdGF0ZUluZm8gfCBQbGFpbk1lc3NhZ2U8U3RyZWFtU3RhdGVJbmZvPiB8IHVuZGVmaW5lZCwgYjogU3RyZWFtU3RhdGVJbmZvIHwgUGxhaW5NZXNzYWdlPFN0cmVhbVN0YXRlSW5mbz4gfCB1bmRlZmluZWQpOiBib29sZWFuIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFN0cmVhbVN0YXRlSW5mbywgYSwgYik7XG4gIH1cbn1cblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlN0cmVhbVN0YXRlVXBkYXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBTdHJlYW1TdGF0ZVVwZGF0ZSBleHRlbmRzIE1lc3NhZ2U8U3RyZWFtU3RhdGVVcGRhdGU+IHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgbGl2ZWtpdC5TdHJlYW1TdGF0ZUluZm8gc3RyZWFtX3N0YXRlcyA9IDE7XG4gICAqL1xuICBzdHJlYW1TdGF0ZXM6IFN0cmVhbVN0YXRlSW5mb1tdID0gW107XG5cbiAgY29uc3RydWN0b3IoZGF0YT86IFBhcnRpYWxNZXNzYWdlPFN0cmVhbVN0YXRlVXBkYXRlPikge1xuICAgIHN1cGVyKCk7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cblxuICBzdGF0aWMgcmVhZG9ubHkgcnVudGltZTogdHlwZW9mIHByb3RvMyA9IHByb3RvMztcbiAgc3RhdGljIHJlYWRvbmx5IHR5cGVOYW1lID0gXCJsaXZla2l0LlN0cmVhbVN0YXRlVXBkYXRlXCI7XG4gIHN0YXRpYyByZWFkb25seSBmaWVsZHM6IEZpZWxkTGlzdCA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJzdHJlYW1fc3RhdGVzXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBTdHJlYW1TdGF0ZUluZm8sIHJlcGVhdGVkOiB0cnVlIH0sXG4gIF0pO1xuXG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzOiBVaW50OEFycmF5LCBvcHRpb25zPzogUGFydGlhbDxCaW5hcnlSZWFkT3B0aW9ucz4pOiBTdHJlYW1TdGF0ZVVwZGF0ZSB7XG4gICAgcmV0dXJuIG5ldyBTdHJlYW1TdGF0ZVVwZGF0ZSgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZTogSnNvblZhbHVlLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogU3RyZWFtU3RhdGVVcGRhdGUge1xuICAgIHJldHVybiBuZXcgU3RyZWFtU3RhdGVVcGRhdGUoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmc6IHN0cmluZywgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IFN0cmVhbVN0YXRlVXBkYXRlIHtcbiAgICByZXR1cm4gbmV3IFN0cmVhbVN0YXRlVXBkYXRlKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZXF1YWxzKGE6IFN0cmVhbVN0YXRlVXBkYXRlIHwgUGxhaW5NZXNzYWdlPFN0cmVhbVN0YXRlVXBkYXRlPiB8IHVuZGVmaW5lZCwgYjogU3RyZWFtU3RhdGVVcGRhdGUgfCBQbGFpbk1lc3NhZ2U8U3RyZWFtU3RhdGVVcGRhdGU+IHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhTdHJlYW1TdGF0ZVVwZGF0ZSwgYSwgYik7XG4gIH1cbn1cblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlN1YnNjcmliZWRRdWFsaXR5XG4gKi9cbmV4cG9ydCBjbGFzcyBTdWJzY3JpYmVkUXVhbGl0eSBleHRlbmRzIE1lc3NhZ2U8U3Vic2NyaWJlZFF1YWxpdHk+IHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5WaWRlb1F1YWxpdHkgcXVhbGl0eSA9IDE7XG4gICAqL1xuICBxdWFsaXR5ID0gVmlkZW9RdWFsaXR5LkxPVztcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBib29sIGVuYWJsZWQgPSAyO1xuICAgKi9cbiAgZW5hYmxlZCA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKGRhdGE/OiBQYXJ0aWFsTWVzc2FnZTxTdWJzY3JpYmVkUXVhbGl0eT4pIHtcbiAgICBzdXBlcigpO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG5cbiAgc3RhdGljIHJlYWRvbmx5IHJ1bnRpbWU6IHR5cGVvZiBwcm90bzMgPSBwcm90bzM7XG4gIHN0YXRpYyByZWFkb25seSB0eXBlTmFtZSA9IFwibGl2ZWtpdC5TdWJzY3JpYmVkUXVhbGl0eVwiO1xuICBzdGF0aWMgcmVhZG9ubHkgZmllbGRzOiBGaWVsZExpc3QgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwicXVhbGl0eVwiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLmdldEVudW1UeXBlKFZpZGVvUXVhbGl0eSkgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcImVuYWJsZWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi8gfSxcbiAgXSk7XG5cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXM6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBQYXJ0aWFsPEJpbmFyeVJlYWRPcHRpb25zPik6IFN1YnNjcmliZWRRdWFsaXR5IHtcbiAgICByZXR1cm4gbmV3IFN1YnNjcmliZWRRdWFsaXR5KCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlOiBKc29uVmFsdWUsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBTdWJzY3JpYmVkUXVhbGl0eSB7XG4gICAgcmV0dXJuIG5ldyBTdWJzY3JpYmVkUXVhbGl0eSgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZzogc3RyaW5nLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogU3Vic2NyaWJlZFF1YWxpdHkge1xuICAgIHJldHVybiBuZXcgU3Vic2NyaWJlZFF1YWxpdHkoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBlcXVhbHMoYTogU3Vic2NyaWJlZFF1YWxpdHkgfCBQbGFpbk1lc3NhZ2U8U3Vic2NyaWJlZFF1YWxpdHk+IHwgdW5kZWZpbmVkLCBiOiBTdWJzY3JpYmVkUXVhbGl0eSB8IFBsYWluTWVzc2FnZTxTdWJzY3JpYmVkUXVhbGl0eT4gfCB1bmRlZmluZWQpOiBib29sZWFuIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFN1YnNjcmliZWRRdWFsaXR5LCBhLCBiKTtcbiAgfVxufVxuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuU3Vic2NyaWJlZENvZGVjXG4gKi9cbmV4cG9ydCBjbGFzcyBTdWJzY3JpYmVkQ29kZWMgZXh0ZW5kcyBNZXNzYWdlPFN1YnNjcmliZWRDb2RlYz4ge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgY29kZWMgPSAxO1xuICAgKi9cbiAgY29kZWMgPSBcIlwiO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGxpdmVraXQuU3Vic2NyaWJlZFF1YWxpdHkgcXVhbGl0aWVzID0gMjtcbiAgICovXG4gIHF1YWxpdGllczogU3Vic2NyaWJlZFF1YWxpdHlbXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKGRhdGE/OiBQYXJ0aWFsTWVzc2FnZTxTdWJzY3JpYmVkQ29kZWM+KSB7XG4gICAgc3VwZXIoKTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuXG4gIHN0YXRpYyByZWFkb25seSBydW50aW1lOiB0eXBlb2YgcHJvdG8zID0gcHJvdG8zO1xuICBzdGF0aWMgcmVhZG9ubHkgdHlwZU5hbWUgPSBcImxpdmVraXQuU3Vic2NyaWJlZENvZGVjXCI7XG4gIHN0YXRpYyByZWFkb25seSBmaWVsZHM6IEZpZWxkTGlzdCA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJjb2RlY1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJxdWFsaXRpZXNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFN1YnNjcmliZWRRdWFsaXR5LCByZXBlYXRlZDogdHJ1ZSB9LFxuICBdKTtcblxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlczogVWludDhBcnJheSwgb3B0aW9ucz86IFBhcnRpYWw8QmluYXJ5UmVhZE9wdGlvbnM+KTogU3Vic2NyaWJlZENvZGVjIHtcbiAgICByZXR1cm4gbmV3IFN1YnNjcmliZWRDb2RlYygpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZTogSnNvblZhbHVlLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogU3Vic2NyaWJlZENvZGVjIHtcbiAgICByZXR1cm4gbmV3IFN1YnNjcmliZWRDb2RlYygpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZzogc3RyaW5nLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogU3Vic2NyaWJlZENvZGVjIHtcbiAgICByZXR1cm4gbmV3IFN1YnNjcmliZWRDb2RlYygpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGVxdWFscyhhOiBTdWJzY3JpYmVkQ29kZWMgfCBQbGFpbk1lc3NhZ2U8U3Vic2NyaWJlZENvZGVjPiB8IHVuZGVmaW5lZCwgYjogU3Vic2NyaWJlZENvZGVjIHwgUGxhaW5NZXNzYWdlPFN1YnNjcmliZWRDb2RlYz4gfCB1bmRlZmluZWQpOiBib29sZWFuIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFN1YnNjcmliZWRDb2RlYywgYSwgYik7XG4gIH1cbn1cblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlN1YnNjcmliZWRRdWFsaXR5VXBkYXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBTdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSBleHRlbmRzIE1lc3NhZ2U8U3Vic2NyaWJlZFF1YWxpdHlVcGRhdGU+IHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHRyYWNrX3NpZCA9IDE7XG4gICAqL1xuICB0cmFja1NpZCA9IFwiXCI7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgbGl2ZWtpdC5TdWJzY3JpYmVkUXVhbGl0eSBzdWJzY3JpYmVkX3F1YWxpdGllcyA9IDI7XG4gICAqL1xuICBzdWJzY3JpYmVkUXVhbGl0aWVzOiBTdWJzY3JpYmVkUXVhbGl0eVtdID0gW107XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgbGl2ZWtpdC5TdWJzY3JpYmVkQ29kZWMgc3Vic2NyaWJlZF9jb2RlY3MgPSAzO1xuICAgKi9cbiAgc3Vic2NyaWJlZENvZGVjczogU3Vic2NyaWJlZENvZGVjW10gPSBbXTtcblxuICBjb25zdHJ1Y3RvcihkYXRhPzogUGFydGlhbE1lc3NhZ2U8U3Vic2NyaWJlZFF1YWxpdHlVcGRhdGU+KSB7XG4gICAgc3VwZXIoKTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuXG4gIHN0YXRpYyByZWFkb25seSBydW50aW1lOiB0eXBlb2YgcHJvdG8zID0gcHJvdG8zO1xuICBzdGF0aWMgcmVhZG9ubHkgdHlwZU5hbWUgPSBcImxpdmVraXQuU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGVcIjtcbiAgc3RhdGljIHJlYWRvbmx5IGZpZWxkczogRmllbGRMaXN0ID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInRyYWNrX3NpZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJzdWJzY3JpYmVkX3F1YWxpdGllc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU3Vic2NyaWJlZFF1YWxpdHksIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJzdWJzY3JpYmVkX2NvZGVjc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU3Vic2NyaWJlZENvZGVjLCByZXBlYXRlZDogdHJ1ZSB9LFxuICBdKTtcblxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlczogVWludDhBcnJheSwgb3B0aW9ucz86IFBhcnRpYWw8QmluYXJ5UmVhZE9wdGlvbnM+KTogU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUge1xuICAgIHJldHVybiBuZXcgU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWU6IEpzb25WYWx1ZSwgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IFN1YnNjcmliZWRRdWFsaXR5VXBkYXRlIHtcbiAgICByZXR1cm4gbmV3IFN1YnNjcmliZWRRdWFsaXR5VXBkYXRlKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nOiBzdHJpbmcsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBTdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSB7XG4gICAgcmV0dXJuIG5ldyBTdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGVxdWFscyhhOiBTdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSB8IFBsYWluTWVzc2FnZTxTdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZT4gfCB1bmRlZmluZWQsIGI6IFN1YnNjcmliZWRRdWFsaXR5VXBkYXRlIHwgUGxhaW5NZXNzYWdlPFN1YnNjcmliZWRRdWFsaXR5VXBkYXRlPiB8IHVuZGVmaW5lZCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUsIGEsIGIpO1xuICB9XG59XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5UcmFja1Blcm1pc3Npb25cbiAqL1xuZXhwb3J0IGNsYXNzIFRyYWNrUGVybWlzc2lvbiBleHRlbmRzIE1lc3NhZ2U8VHJhY2tQZXJtaXNzaW9uPiB7XG4gIC8qKlxuICAgKiBwZXJtaXNzaW9uIGNvdWxkIGJlIGdyYW50ZWQgZWl0aGVyIGJ5IHBhcnRpY2lwYW50IHNpZCBvciBpZGVudGl0eVxuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBwYXJ0aWNpcGFudF9zaWQgPSAxO1xuICAgKi9cbiAgcGFydGljaXBhbnRTaWQgPSBcIlwiO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGJvb2wgYWxsX3RyYWNrcyA9IDI7XG4gICAqL1xuICBhbGxUcmFja3MgPSBmYWxzZTtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBzdHJpbmcgdHJhY2tfc2lkcyA9IDM7XG4gICAqL1xuICB0cmFja1NpZHM6IHN0cmluZ1tdID0gW107XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHBhcnRpY2lwYW50X2lkZW50aXR5ID0gNDtcbiAgICovXG4gIHBhcnRpY2lwYW50SWRlbnRpdHkgPSBcIlwiO1xuXG4gIGNvbnN0cnVjdG9yKGRhdGE/OiBQYXJ0aWFsTWVzc2FnZTxUcmFja1Blcm1pc3Npb24+KSB7XG4gICAgc3VwZXIoKTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuXG4gIHN0YXRpYyByZWFkb25seSBydW50aW1lOiB0eXBlb2YgcHJvdG8zID0gcHJvdG8zO1xuICBzdGF0aWMgcmVhZG9ubHkgdHlwZU5hbWUgPSBcImxpdmVraXQuVHJhY2tQZXJtaXNzaW9uXCI7XG4gIHN0YXRpYyByZWFkb25seSBmaWVsZHM6IEZpZWxkTGlzdCA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJwYXJ0aWNpcGFudF9zaWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwiYWxsX3RyYWNrc1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLyB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwidHJhY2tfc2lkc1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovLCByZXBlYXRlZDogdHJ1ZSB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwicGFydGljaXBhbnRfaWRlbnRpdHlcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICBdKTtcblxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlczogVWludDhBcnJheSwgb3B0aW9ucz86IFBhcnRpYWw8QmluYXJ5UmVhZE9wdGlvbnM+KTogVHJhY2tQZXJtaXNzaW9uIHtcbiAgICByZXR1cm4gbmV3IFRyYWNrUGVybWlzc2lvbigpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZTogSnNvblZhbHVlLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogVHJhY2tQZXJtaXNzaW9uIHtcbiAgICByZXR1cm4gbmV3IFRyYWNrUGVybWlzc2lvbigpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZzogc3RyaW5nLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogVHJhY2tQZXJtaXNzaW9uIHtcbiAgICByZXR1cm4gbmV3IFRyYWNrUGVybWlzc2lvbigpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGVxdWFscyhhOiBUcmFja1Blcm1pc3Npb24gfCBQbGFpbk1lc3NhZ2U8VHJhY2tQZXJtaXNzaW9uPiB8IHVuZGVmaW5lZCwgYjogVHJhY2tQZXJtaXNzaW9uIHwgUGxhaW5NZXNzYWdlPFRyYWNrUGVybWlzc2lvbj4gfCB1bmRlZmluZWQpOiBib29sZWFuIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFRyYWNrUGVybWlzc2lvbiwgYSwgYik7XG4gIH1cbn1cblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlN1YnNjcmlwdGlvblBlcm1pc3Npb25cbiAqL1xuZXhwb3J0IGNsYXNzIFN1YnNjcmlwdGlvblBlcm1pc3Npb24gZXh0ZW5kcyBNZXNzYWdlPFN1YnNjcmlwdGlvblBlcm1pc3Npb24+IHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYm9vbCBhbGxfcGFydGljaXBhbnRzID0gMTtcbiAgICovXG4gIGFsbFBhcnRpY2lwYW50cyA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGxpdmVraXQuVHJhY2tQZXJtaXNzaW9uIHRyYWNrX3Blcm1pc3Npb25zID0gMjtcbiAgICovXG4gIHRyYWNrUGVybWlzc2lvbnM6IFRyYWNrUGVybWlzc2lvbltdID0gW107XG5cbiAgY29uc3RydWN0b3IoZGF0YT86IFBhcnRpYWxNZXNzYWdlPFN1YnNjcmlwdGlvblBlcm1pc3Npb24+KSB7XG4gICAgc3VwZXIoKTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuXG4gIHN0YXRpYyByZWFkb25seSBydW50aW1lOiB0eXBlb2YgcHJvdG8zID0gcHJvdG8zO1xuICBzdGF0aWMgcmVhZG9ubHkgdHlwZU5hbWUgPSBcImxpdmVraXQuU3Vic2NyaXB0aW9uUGVybWlzc2lvblwiO1xuICBzdGF0aWMgcmVhZG9ubHkgZmllbGRzOiBGaWVsZExpc3QgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwiYWxsX3BhcnRpY2lwYW50c1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLyB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwidHJhY2tfcGVybWlzc2lvbnNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFRyYWNrUGVybWlzc2lvbiwgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgXSk7XG5cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXM6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBQYXJ0aWFsPEJpbmFyeVJlYWRPcHRpb25zPik6IFN1YnNjcmlwdGlvblBlcm1pc3Npb24ge1xuICAgIHJldHVybiBuZXcgU3Vic2NyaXB0aW9uUGVybWlzc2lvbigpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZTogSnNvblZhbHVlLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogU3Vic2NyaXB0aW9uUGVybWlzc2lvbiB7XG4gICAgcmV0dXJuIG5ldyBTdWJzY3JpcHRpb25QZXJtaXNzaW9uKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nOiBzdHJpbmcsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBTdWJzY3JpcHRpb25QZXJtaXNzaW9uIHtcbiAgICByZXR1cm4gbmV3IFN1YnNjcmlwdGlvblBlcm1pc3Npb24oKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBlcXVhbHMoYTogU3Vic2NyaXB0aW9uUGVybWlzc2lvbiB8IFBsYWluTWVzc2FnZTxTdWJzY3JpcHRpb25QZXJtaXNzaW9uPiB8IHVuZGVmaW5lZCwgYjogU3Vic2NyaXB0aW9uUGVybWlzc2lvbiB8IFBsYWluTWVzc2FnZTxTdWJzY3JpcHRpb25QZXJtaXNzaW9uPiB8IHVuZGVmaW5lZCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoU3Vic2NyaXB0aW9uUGVybWlzc2lvbiwgYSwgYik7XG4gIH1cbn1cblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIFN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUgZXh0ZW5kcyBNZXNzYWdlPFN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGU+IHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHBhcnRpY2lwYW50X3NpZCA9IDE7XG4gICAqL1xuICBwYXJ0aWNpcGFudFNpZCA9IFwiXCI7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHRyYWNrX3NpZCA9IDI7XG4gICAqL1xuICB0cmFja1NpZCA9IFwiXCI7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYm9vbCBhbGxvd2VkID0gMztcbiAgICovXG4gIGFsbG93ZWQgPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihkYXRhPzogUGFydGlhbE1lc3NhZ2U8U3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZT4pIHtcbiAgICBzdXBlcigpO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG5cbiAgc3RhdGljIHJlYWRvbmx5IHJ1bnRpbWU6IHR5cGVvZiBwcm90bzMgPSBwcm90bzM7XG4gIHN0YXRpYyByZWFkb25seSB0eXBlTmFtZSA9IFwibGl2ZWtpdC5TdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlXCI7XG4gIHN0YXRpYyByZWFkb25seSBmaWVsZHM6IEZpZWxkTGlzdCA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJwYXJ0aWNpcGFudF9zaWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwidHJhY2tfc2lkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcImFsbG93ZWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi8gfSxcbiAgXSk7XG5cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXM6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBQYXJ0aWFsPEJpbmFyeVJlYWRPcHRpb25zPik6IFN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUge1xuICAgIHJldHVybiBuZXcgU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZTogSnNvblZhbHVlLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSB7XG4gICAgcmV0dXJuIG5ldyBTdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nOiBzdHJpbmcsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBTdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlIHtcbiAgICByZXR1cm4gbmV3IFN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBlcXVhbHMoYTogU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSB8IFBsYWluTWVzc2FnZTxTdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlPiB8IHVuZGVmaW5lZCwgYjogU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSB8IFBsYWluTWVzc2FnZTxTdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlPiB8IHVuZGVmaW5lZCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSwgYSwgYik7XG4gIH1cbn1cblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlN5bmNTdGF0ZVxuICovXG5leHBvcnQgY2xhc3MgU3luY1N0YXRlIGV4dGVuZHMgTWVzc2FnZTxTeW5jU3RhdGU+IHtcbiAgLyoqXG4gICAqIGxhc3Qgc3Vic2NyaWJlIGFuc3dlciBiZWZvcmUgcmVjb25uZWN0aW5nXG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5TZXNzaW9uRGVzY3JpcHRpb24gYW5zd2VyID0gMTtcbiAgICovXG4gIGFuc3dlcj86IFNlc3Npb25EZXNjcmlwdGlvbjtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LlVwZGF0ZVN1YnNjcmlwdGlvbiBzdWJzY3JpcHRpb24gPSAyO1xuICAgKi9cbiAgc3Vic2NyaXB0aW9uPzogVXBkYXRlU3Vic2NyaXB0aW9uO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGxpdmVraXQuVHJhY2tQdWJsaXNoZWRSZXNwb25zZSBwdWJsaXNoX3RyYWNrcyA9IDM7XG4gICAqL1xuICBwdWJsaXNoVHJhY2tzOiBUcmFja1B1Ymxpc2hlZFJlc3BvbnNlW10gPSBbXTtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBsaXZla2l0LkRhdGFDaGFubmVsSW5mbyBkYXRhX2NoYW5uZWxzID0gNDtcbiAgICovXG4gIGRhdGFDaGFubmVsczogRGF0YUNoYW5uZWxJbmZvW10gPSBbXTtcblxuICAvKipcbiAgICogbGFzdCByZWNlaXZlZCBzZXJ2ZXIgc2lkZSBvZmZlciBiZWZvcmUgcmVjb25uZWN0aW5nXG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5TZXNzaW9uRGVzY3JpcHRpb24gb2ZmZXIgPSA1O1xuICAgKi9cbiAgb2ZmZXI/OiBTZXNzaW9uRGVzY3JpcHRpb247XG5cbiAgY29uc3RydWN0b3IoZGF0YT86IFBhcnRpYWxNZXNzYWdlPFN5bmNTdGF0ZT4pIHtcbiAgICBzdXBlcigpO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG5cbiAgc3RhdGljIHJlYWRvbmx5IHJ1bnRpbWU6IHR5cGVvZiBwcm90bzMgPSBwcm90bzM7XG4gIHN0YXRpYyByZWFkb25seSB0eXBlTmFtZSA9IFwibGl2ZWtpdC5TeW5jU3RhdGVcIjtcbiAgc3RhdGljIHJlYWRvbmx5IGZpZWxkczogRmllbGRMaXN0ID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcImFuc3dlclwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU2Vzc2lvbkRlc2NyaXB0aW9uIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJzdWJzY3JpcHRpb25cIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFVwZGF0ZVN1YnNjcmlwdGlvbiB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwicHVibGlzaF90cmFja3NcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFRyYWNrUHVibGlzaGVkUmVzcG9uc2UsIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAgeyBubzogNCwgbmFtZTogXCJkYXRhX2NoYW5uZWxzXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBEYXRhQ2hhbm5lbEluZm8sIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAgeyBubzogNSwgbmFtZTogXCJvZmZlclwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU2Vzc2lvbkRlc2NyaXB0aW9uIH0sXG4gIF0pO1xuXG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzOiBVaW50OEFycmF5LCBvcHRpb25zPzogUGFydGlhbDxCaW5hcnlSZWFkT3B0aW9ucz4pOiBTeW5jU3RhdGUge1xuICAgIHJldHVybiBuZXcgU3luY1N0YXRlKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlOiBKc29uVmFsdWUsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBTeW5jU3RhdGUge1xuICAgIHJldHVybiBuZXcgU3luY1N0YXRlKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nOiBzdHJpbmcsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBTeW5jU3RhdGUge1xuICAgIHJldHVybiBuZXcgU3luY1N0YXRlKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZXF1YWxzKGE6IFN5bmNTdGF0ZSB8IFBsYWluTWVzc2FnZTxTeW5jU3RhdGU+IHwgdW5kZWZpbmVkLCBiOiBTeW5jU3RhdGUgfCBQbGFpbk1lc3NhZ2U8U3luY1N0YXRlPiB8IHVuZGVmaW5lZCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoU3luY1N0YXRlLCBhLCBiKTtcbiAgfVxufVxuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuRGF0YUNoYW5uZWxJbmZvXG4gKi9cbmV4cG9ydCBjbGFzcyBEYXRhQ2hhbm5lbEluZm8gZXh0ZW5kcyBNZXNzYWdlPERhdGFDaGFubmVsSW5mbz4ge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgbGFiZWwgPSAxO1xuICAgKi9cbiAgbGFiZWwgPSBcIlwiO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiBpZCA9IDI7XG4gICAqL1xuICBpZCA9IDA7XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5TaWduYWxUYXJnZXQgdGFyZ2V0ID0gMztcbiAgICovXG4gIHRhcmdldCA9IFNpZ25hbFRhcmdldC5QVUJMSVNIRVI7XG5cbiAgY29uc3RydWN0b3IoZGF0YT86IFBhcnRpYWxNZXNzYWdlPERhdGFDaGFubmVsSW5mbz4pIHtcbiAgICBzdXBlcigpO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG5cbiAgc3RhdGljIHJlYWRvbmx5IHJ1bnRpbWU6IHR5cGVvZiBwcm90bzMgPSBwcm90bzM7XG4gIHN0YXRpYyByZWFkb25seSB0eXBlTmFtZSA9IFwibGl2ZWtpdC5EYXRhQ2hhbm5lbEluZm9cIjtcbiAgc3RhdGljIHJlYWRvbmx5IGZpZWxkczogRmllbGRMaXN0ID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcImxhYmVsXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcImlkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJ0YXJnZXRcIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShTaWduYWxUYXJnZXQpIH0sXG4gIF0pO1xuXG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzOiBVaW50OEFycmF5LCBvcHRpb25zPzogUGFydGlhbDxCaW5hcnlSZWFkT3B0aW9ucz4pOiBEYXRhQ2hhbm5lbEluZm8ge1xuICAgIHJldHVybiBuZXcgRGF0YUNoYW5uZWxJbmZvKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlOiBKc29uVmFsdWUsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBEYXRhQ2hhbm5lbEluZm8ge1xuICAgIHJldHVybiBuZXcgRGF0YUNoYW5uZWxJbmZvKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nOiBzdHJpbmcsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBEYXRhQ2hhbm5lbEluZm8ge1xuICAgIHJldHVybiBuZXcgRGF0YUNoYW5uZWxJbmZvKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZXF1YWxzKGE6IERhdGFDaGFubmVsSW5mbyB8IFBsYWluTWVzc2FnZTxEYXRhQ2hhbm5lbEluZm8+IHwgdW5kZWZpbmVkLCBiOiBEYXRhQ2hhbm5lbEluZm8gfCBQbGFpbk1lc3NhZ2U8RGF0YUNoYW5uZWxJbmZvPiB8IHVuZGVmaW5lZCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoRGF0YUNoYW5uZWxJbmZvLCBhLCBiKTtcbiAgfVxufVxuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuU2ltdWxhdGVTY2VuYXJpb1xuICovXG5leHBvcnQgY2xhc3MgU2ltdWxhdGVTY2VuYXJpbyBleHRlbmRzIE1lc3NhZ2U8U2ltdWxhdGVTY2VuYXJpbz4ge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIG9uZW9mIGxpdmVraXQuU2ltdWxhdGVTY2VuYXJpby5zY2VuYXJpb1xuICAgKi9cbiAgc2NlbmFyaW86IHtcbiAgICAvKipcbiAgICAgKiBzaW11bGF0ZSBOIHNlY29uZHMgb2Ygc3BlYWtlciBhY3Rpdml0eVxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBpbnQzMiBzcGVha2VyX3VwZGF0ZSA9IDE7XG4gICAgICovXG4gICAgdmFsdWU6IG51bWJlcjtcbiAgICBjYXNlOiBcInNwZWFrZXJVcGRhdGVcIjtcbiAgfSB8IHtcbiAgICAvKipcbiAgICAgKiBzaW11bGF0ZSBsb2NhbCBub2RlIGZhaWx1cmVcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYm9vbCBub2RlX2ZhaWx1cmUgPSAyO1xuICAgICAqL1xuICAgIHZhbHVlOiBib29sZWFuO1xuICAgIGNhc2U6IFwibm9kZUZhaWx1cmVcIjtcbiAgfSB8IHtcbiAgICAvKipcbiAgICAgKiBzaW11bGF0ZSBtaWdyYXRpb25cbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYm9vbCBtaWdyYXRpb24gPSAzO1xuICAgICAqL1xuICAgIHZhbHVlOiBib29sZWFuO1xuICAgIGNhc2U6IFwibWlncmF0aW9uXCI7XG4gIH0gfCB7XG4gICAgLyoqXG4gICAgICogc2VydmVyIHRvIHNlbmQgbGVhdmVcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYm9vbCBzZXJ2ZXJfbGVhdmUgPSA0O1xuICAgICAqL1xuICAgIHZhbHVlOiBib29sZWFuO1xuICAgIGNhc2U6IFwic2VydmVyTGVhdmVcIjtcbiAgfSB8IHtcbiAgICAvKipcbiAgICAgKiBzd2l0Y2ggY2FuZGlkYXRlIHByb3RvY29sIHRvIHRjcFxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LkNhbmRpZGF0ZVByb3RvY29sIHN3aXRjaF9jYW5kaWRhdGVfcHJvdG9jb2wgPSA1O1xuICAgICAqL1xuICAgIHZhbHVlOiBDYW5kaWRhdGVQcm90b2NvbDtcbiAgICBjYXNlOiBcInN3aXRjaENhbmRpZGF0ZVByb3RvY29sXCI7XG4gIH0gfCB7XG4gICAgLyoqXG4gICAgICogbWF4aW11bSBiYW5kd2lkdGggZm9yIHN1YnNjcmliZXJzLCBpbiBicHNcbiAgICAgKiB3aGVuIHplcm8sIGNsZWFycyBhcnRpZmljaWFsIGJhbmR3aWR0aCBsaW1pdFxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBpbnQ2NCBzdWJzY3JpYmVyX2JhbmR3aWR0aCA9IDY7XG4gICAgICovXG4gICAgdmFsdWU6IGJpZ2ludDtcbiAgICBjYXNlOiBcInN1YnNjcmliZXJCYW5kd2lkdGhcIjtcbiAgfSB8IHtcbiAgICAvKipcbiAgICAgKiBkaXNjb25uZWN0IHNpZ25hbCBvbiByZXN1bWVcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYm9vbCBkaXNjb25uZWN0X3NpZ25hbF9vbl9yZXN1bWUgPSA3O1xuICAgICAqL1xuICAgIHZhbHVlOiBib29sZWFuO1xuICAgIGNhc2U6IFwiZGlzY29ubmVjdFNpZ25hbE9uUmVzdW1lXCI7XG4gIH0gfCB7XG4gICAgLyoqXG4gICAgICogZGlzY29ubmVjdCBzaWduYWwgb24gcmVzdW1lIGJlZm9yZSBzZW5kaW5nIGFueSBtZXNzYWdlcyBmcm9tIHNlcnZlclxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBib29sIGRpc2Nvbm5lY3Rfc2lnbmFsX29uX3Jlc3VtZV9ub19tZXNzYWdlcyA9IDg7XG4gICAgICovXG4gICAgdmFsdWU6IGJvb2xlYW47XG4gICAgY2FzZTogXCJkaXNjb25uZWN0U2lnbmFsT25SZXN1bWVOb01lc3NhZ2VzXCI7XG4gIH0gfCB7IGNhc2U6IHVuZGVmaW5lZDsgdmFsdWU/OiB1bmRlZmluZWQgfSA9IHsgY2FzZTogdW5kZWZpbmVkIH07XG5cbiAgY29uc3RydWN0b3IoZGF0YT86IFBhcnRpYWxNZXNzYWdlPFNpbXVsYXRlU2NlbmFyaW8+KSB7XG4gICAgc3VwZXIoKTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuXG4gIHN0YXRpYyByZWFkb25seSBydW50aW1lOiB0eXBlb2YgcHJvdG8zID0gcHJvdG8zO1xuICBzdGF0aWMgcmVhZG9ubHkgdHlwZU5hbWUgPSBcImxpdmVraXQuU2ltdWxhdGVTY2VuYXJpb1wiO1xuICBzdGF0aWMgcmVhZG9ubHkgZmllbGRzOiBGaWVsZExpc3QgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwic3BlYWtlcl91cGRhdGVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogNSAvKiBTY2FsYXJUeXBlLklOVDMyICovLCBvbmVvZjogXCJzY2VuYXJpb1wiIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJub2RlX2ZhaWx1cmVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi8sIG9uZW9mOiBcInNjZW5hcmlvXCIgfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcIm1pZ3JhdGlvblwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLywgb25lb2Y6IFwic2NlbmFyaW9cIiB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwic2VydmVyX2xlYXZlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovLCBvbmVvZjogXCJzY2VuYXJpb1wiIH0sXG4gICAgeyBubzogNSwgbmFtZTogXCJzd2l0Y2hfY2FuZGlkYXRlX3Byb3RvY29sXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoQ2FuZGlkYXRlUHJvdG9jb2wpLCBvbmVvZjogXCJzY2VuYXJpb1wiIH0sXG4gICAgeyBubzogNiwgbmFtZTogXCJzdWJzY3JpYmVyX2JhbmR3aWR0aFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAzIC8qIFNjYWxhclR5cGUuSU5UNjQgKi8sIG9uZW9mOiBcInNjZW5hcmlvXCIgfSxcbiAgICB7IG5vOiA3LCBuYW1lOiBcImRpc2Nvbm5lY3Rfc2lnbmFsX29uX3Jlc3VtZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLywgb25lb2Y6IFwic2NlbmFyaW9cIiB9LFxuICAgIHsgbm86IDgsIG5hbWU6IFwiZGlzY29ubmVjdF9zaWduYWxfb25fcmVzdW1lX25vX21lc3NhZ2VzXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovLCBvbmVvZjogXCJzY2VuYXJpb1wiIH0sXG4gIF0pO1xuXG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzOiBVaW50OEFycmF5LCBvcHRpb25zPzogUGFydGlhbDxCaW5hcnlSZWFkT3B0aW9ucz4pOiBTaW11bGF0ZVNjZW5hcmlvIHtcbiAgICByZXR1cm4gbmV3IFNpbXVsYXRlU2NlbmFyaW8oKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWU6IEpzb25WYWx1ZSwgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IFNpbXVsYXRlU2NlbmFyaW8ge1xuICAgIHJldHVybiBuZXcgU2ltdWxhdGVTY2VuYXJpbygpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZzogc3RyaW5nLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogU2ltdWxhdGVTY2VuYXJpbyB7XG4gICAgcmV0dXJuIG5ldyBTaW11bGF0ZVNjZW5hcmlvKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZXF1YWxzKGE6IFNpbXVsYXRlU2NlbmFyaW8gfCBQbGFpbk1lc3NhZ2U8U2ltdWxhdGVTY2VuYXJpbz4gfCB1bmRlZmluZWQsIGI6IFNpbXVsYXRlU2NlbmFyaW8gfCBQbGFpbk1lc3NhZ2U8U2ltdWxhdGVTY2VuYXJpbz4gfCB1bmRlZmluZWQpOiBib29sZWFuIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFNpbXVsYXRlU2NlbmFyaW8sIGEsIGIpO1xuICB9XG59XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5QaW5nXG4gKi9cbmV4cG9ydCBjbGFzcyBQaW5nIGV4dGVuZHMgTWVzc2FnZTxQaW5nPiB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGludDY0IHRpbWVzdGFtcCA9IDE7XG4gICAqL1xuICB0aW1lc3RhbXAgPSBwcm90b0ludDY0Lnplcm87XG5cbiAgLyoqXG4gICAqIHJ0dCBpbiBtaWxsaXNlY29uZHMgY2FsY3VsYXRlZCBieSBjbGllbnRcbiAgICpcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBpbnQ2NCBydHQgPSAyO1xuICAgKi9cbiAgcnR0ID0gcHJvdG9JbnQ2NC56ZXJvO1xuXG4gIGNvbnN0cnVjdG9yKGRhdGE/OiBQYXJ0aWFsTWVzc2FnZTxQaW5nPikge1xuICAgIHN1cGVyKCk7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cblxuICBzdGF0aWMgcmVhZG9ubHkgcnVudGltZTogdHlwZW9mIHByb3RvMyA9IHByb3RvMztcbiAgc3RhdGljIHJlYWRvbmx5IHR5cGVOYW1lID0gXCJsaXZla2l0LlBpbmdcIjtcbiAgc3RhdGljIHJlYWRvbmx5IGZpZWxkczogRmllbGRMaXN0ID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInRpbWVzdGFtcFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAzIC8qIFNjYWxhclR5cGUuSU5UNjQgKi8gfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcInJ0dFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAzIC8qIFNjYWxhclR5cGUuSU5UNjQgKi8gfSxcbiAgXSk7XG5cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXM6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBQYXJ0aWFsPEJpbmFyeVJlYWRPcHRpb25zPik6IFBpbmcge1xuICAgIHJldHVybiBuZXcgUGluZygpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZTogSnNvblZhbHVlLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogUGluZyB7XG4gICAgcmV0dXJuIG5ldyBQaW5nKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nOiBzdHJpbmcsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBQaW5nIHtcbiAgICByZXR1cm4gbmV3IFBpbmcoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBlcXVhbHMoYTogUGluZyB8IFBsYWluTWVzc2FnZTxQaW5nPiB8IHVuZGVmaW5lZCwgYjogUGluZyB8IFBsYWluTWVzc2FnZTxQaW5nPiB8IHVuZGVmaW5lZCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoUGluZywgYSwgYik7XG4gIH1cbn1cblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlBvbmdcbiAqL1xuZXhwb3J0IGNsYXNzIFBvbmcgZXh0ZW5kcyBNZXNzYWdlPFBvbmc+IHtcbiAgLyoqXG4gICAqIHRpbWVzdGFtcCBmaWVsZCBvZiBsYXN0IHJlY2VpdmVkIHBpbmcgcmVxdWVzdFxuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGludDY0IGxhc3RfcGluZ190aW1lc3RhbXAgPSAxO1xuICAgKi9cbiAgbGFzdFBpbmdUaW1lc3RhbXAgPSBwcm90b0ludDY0Lnplcm87XG5cbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogaW50NjQgdGltZXN0YW1wID0gMjtcbiAgICovXG4gIHRpbWVzdGFtcCA9IHByb3RvSW50NjQuemVybztcblxuICBjb25zdHJ1Y3RvcihkYXRhPzogUGFydGlhbE1lc3NhZ2U8UG9uZz4pIHtcbiAgICBzdXBlcigpO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG5cbiAgc3RhdGljIHJlYWRvbmx5IHJ1bnRpbWU6IHR5cGVvZiBwcm90bzMgPSBwcm90bzM7XG4gIHN0YXRpYyByZWFkb25seSB0eXBlTmFtZSA9IFwibGl2ZWtpdC5Qb25nXCI7XG4gIHN0YXRpYyByZWFkb25seSBmaWVsZHM6IEZpZWxkTGlzdCA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJsYXN0X3BpbmdfdGltZXN0YW1wXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDMgLyogU2NhbGFyVHlwZS5JTlQ2NCAqLyB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwidGltZXN0YW1wXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDMgLyogU2NhbGFyVHlwZS5JTlQ2NCAqLyB9LFxuICBdKTtcblxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlczogVWludDhBcnJheSwgb3B0aW9ucz86IFBhcnRpYWw8QmluYXJ5UmVhZE9wdGlvbnM+KTogUG9uZyB7XG4gICAgcmV0dXJuIG5ldyBQb25nKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlOiBKc29uVmFsdWUsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBQb25nIHtcbiAgICByZXR1cm4gbmV3IFBvbmcoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmc6IHN0cmluZywgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IFBvbmcge1xuICAgIHJldHVybiBuZXcgUG9uZygpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGVxdWFscyhhOiBQb25nIHwgUGxhaW5NZXNzYWdlPFBvbmc+IHwgdW5kZWZpbmVkLCBiOiBQb25nIHwgUGxhaW5NZXNzYWdlPFBvbmc+IHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhQb25nLCBhLCBiKTtcbiAgfVxufVxuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuUmVnaW9uU2V0dGluZ3NcbiAqL1xuZXhwb3J0IGNsYXNzIFJlZ2lvblNldHRpbmdzIGV4dGVuZHMgTWVzc2FnZTxSZWdpb25TZXR0aW5ncz4ge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBsaXZla2l0LlJlZ2lvbkluZm8gcmVnaW9ucyA9IDE7XG4gICAqL1xuICByZWdpb25zOiBSZWdpb25JbmZvW10gPSBbXTtcblxuICBjb25zdHJ1Y3RvcihkYXRhPzogUGFydGlhbE1lc3NhZ2U8UmVnaW9uU2V0dGluZ3M+KSB7XG4gICAgc3VwZXIoKTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuXG4gIHN0YXRpYyByZWFkb25seSBydW50aW1lOiB0eXBlb2YgcHJvdG8zID0gcHJvdG8zO1xuICBzdGF0aWMgcmVhZG9ubHkgdHlwZU5hbWUgPSBcImxpdmVraXQuUmVnaW9uU2V0dGluZ3NcIjtcbiAgc3RhdGljIHJlYWRvbmx5IGZpZWxkczogRmllbGRMaXN0ID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInJlZ2lvbnNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFJlZ2lvbkluZm8sIHJlcGVhdGVkOiB0cnVlIH0sXG4gIF0pO1xuXG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzOiBVaW50OEFycmF5LCBvcHRpb25zPzogUGFydGlhbDxCaW5hcnlSZWFkT3B0aW9ucz4pOiBSZWdpb25TZXR0aW5ncyB7XG4gICAgcmV0dXJuIG5ldyBSZWdpb25TZXR0aW5ncygpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZTogSnNvblZhbHVlLCBvcHRpb25zPzogUGFydGlhbDxKc29uUmVhZE9wdGlvbnM+KTogUmVnaW9uU2V0dGluZ3Mge1xuICAgIHJldHVybiBuZXcgUmVnaW9uU2V0dGluZ3MoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmc6IHN0cmluZywgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IFJlZ2lvblNldHRpbmdzIHtcbiAgICByZXR1cm4gbmV3IFJlZ2lvblNldHRpbmdzKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZXF1YWxzKGE6IFJlZ2lvblNldHRpbmdzIHwgUGxhaW5NZXNzYWdlPFJlZ2lvblNldHRpbmdzPiB8IHVuZGVmaW5lZCwgYjogUmVnaW9uU2V0dGluZ3MgfCBQbGFpbk1lc3NhZ2U8UmVnaW9uU2V0dGluZ3M+IHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhSZWdpb25TZXR0aW5ncywgYSwgYik7XG4gIH1cbn1cblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlJlZ2lvbkluZm9cbiAqL1xuZXhwb3J0IGNsYXNzIFJlZ2lvbkluZm8gZXh0ZW5kcyBNZXNzYWdlPFJlZ2lvbkluZm8+IHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHJlZ2lvbiA9IDE7XG4gICAqL1xuICByZWdpb24gPSBcIlwiO1xuXG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyB1cmwgPSAyO1xuICAgKi9cbiAgdXJsID0gXCJcIjtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBpbnQ2NCBkaXN0YW5jZSA9IDM7XG4gICAqL1xuICBkaXN0YW5jZSA9IHByb3RvSW50NjQuemVybztcblxuICBjb25zdHJ1Y3RvcihkYXRhPzogUGFydGlhbE1lc3NhZ2U8UmVnaW9uSW5mbz4pIHtcbiAgICBzdXBlcigpO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG5cbiAgc3RhdGljIHJlYWRvbmx5IHJ1bnRpbWU6IHR5cGVvZiBwcm90bzMgPSBwcm90bzM7XG4gIHN0YXRpYyByZWFkb25seSB0eXBlTmFtZSA9IFwibGl2ZWtpdC5SZWdpb25JbmZvXCI7XG4gIHN0YXRpYyByZWFkb25seSBmaWVsZHM6IEZpZWxkTGlzdCA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJyZWdpb25cIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwidXJsXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcImRpc3RhbmNlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDMgLyogU2NhbGFyVHlwZS5JTlQ2NCAqLyB9LFxuICBdKTtcblxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlczogVWludDhBcnJheSwgb3B0aW9ucz86IFBhcnRpYWw8QmluYXJ5UmVhZE9wdGlvbnM+KTogUmVnaW9uSW5mbyB7XG4gICAgcmV0dXJuIG5ldyBSZWdpb25JbmZvKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlOiBKc29uVmFsdWUsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBSZWdpb25JbmZvIHtcbiAgICByZXR1cm4gbmV3IFJlZ2lvbkluZm8oKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmc6IHN0cmluZywgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IFJlZ2lvbkluZm8ge1xuICAgIHJldHVybiBuZXcgUmVnaW9uSW5mbygpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGVxdWFscyhhOiBSZWdpb25JbmZvIHwgUGxhaW5NZXNzYWdlPFJlZ2lvbkluZm8+IHwgdW5kZWZpbmVkLCBiOiBSZWdpb25JbmZvIHwgUGxhaW5NZXNzYWdlPFJlZ2lvbkluZm8+IHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhSZWdpb25JbmZvLCBhLCBiKTtcbiAgfVxufVxuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuU3Vic2NyaXB0aW9uUmVzcG9uc2VcbiAqL1xuZXhwb3J0IGNsYXNzIFN1YnNjcmlwdGlvblJlc3BvbnNlIGV4dGVuZHMgTWVzc2FnZTxTdWJzY3JpcHRpb25SZXNwb25zZT4ge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgdHJhY2tfc2lkID0gMTtcbiAgICovXG4gIHRyYWNrU2lkID0gXCJcIjtcblxuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LlN1YnNjcmlwdGlvbkVycm9yIGVyciA9IDI7XG4gICAqL1xuICBlcnIgPSBTdWJzY3JpcHRpb25FcnJvci5TRV9VTktOT1dOO1xuXG4gIGNvbnN0cnVjdG9yKGRhdGE/OiBQYXJ0aWFsTWVzc2FnZTxTdWJzY3JpcHRpb25SZXNwb25zZT4pIHtcbiAgICBzdXBlcigpO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG5cbiAgc3RhdGljIHJlYWRvbmx5IHJ1bnRpbWU6IHR5cGVvZiBwcm90bzMgPSBwcm90bzM7XG4gIHN0YXRpYyByZWFkb25seSB0eXBlTmFtZSA9IFwibGl2ZWtpdC5TdWJzY3JpcHRpb25SZXNwb25zZVwiO1xuICBzdGF0aWMgcmVhZG9ubHkgZmllbGRzOiBGaWVsZExpc3QgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwidHJhY2tfc2lkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcImVyclwiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLmdldEVudW1UeXBlKFN1YnNjcmlwdGlvbkVycm9yKSB9LFxuICBdKTtcblxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlczogVWludDhBcnJheSwgb3B0aW9ucz86IFBhcnRpYWw8QmluYXJ5UmVhZE9wdGlvbnM+KTogU3Vic2NyaXB0aW9uUmVzcG9uc2Uge1xuICAgIHJldHVybiBuZXcgU3Vic2NyaXB0aW9uUmVzcG9uc2UoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWU6IEpzb25WYWx1ZSwgb3B0aW9ucz86IFBhcnRpYWw8SnNvblJlYWRPcHRpb25zPik6IFN1YnNjcmlwdGlvblJlc3BvbnNlIHtcbiAgICByZXR1cm4gbmV3IFN1YnNjcmlwdGlvblJlc3BvbnNlKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nOiBzdHJpbmcsIG9wdGlvbnM/OiBQYXJ0aWFsPEpzb25SZWFkT3B0aW9ucz4pOiBTdWJzY3JpcHRpb25SZXNwb25zZSB7XG4gICAgcmV0dXJuIG5ldyBTdWJzY3JpcHRpb25SZXNwb25zZSgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGVxdWFscyhhOiBTdWJzY3JpcHRpb25SZXNwb25zZSB8IFBsYWluTWVzc2FnZTxTdWJzY3JpcHRpb25SZXNwb25zZT4gfCB1bmRlZmluZWQsIGI6IFN1YnNjcmlwdGlvblJlc3BvbnNlIHwgUGxhaW5NZXNzYWdlPFN1YnNjcmlwdGlvblJlc3BvbnNlPiB8IHVuZGVmaW5lZCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoU3Vic2NyaXB0aW9uUmVzcG9uc2UsIGEsIGIpO1xuICB9XG59XG5cbiIsImV4cG9ydCBmdW5jdGlvbiBjbG9uZURlZXA8VD4odmFsdWU6IFQpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodHlwZW9mIHN0cnVjdHVyZWRDbG9uZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBzdHJ1Y3R1cmVkQ2xvbmUodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHZhbHVlKSkgYXMgVDtcbiAgfVxufVxuIiwiaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRzJztcbmltcG9ydCB0eXBlIFR5cGVkRXZlbnRFbWl0dGVyIGZyb20gJ3R5cGVkLWVtaXR0ZXInO1xuaW1wb3J0IHR5cGUgeyBTaWduYWxDbGllbnQgfSBmcm9tICcuLi8uLi9hcGkvU2lnbmFsQ2xpZW50JztcbmltcG9ydCBsb2csIHsgTG9nZ2VyTmFtZXMsIFN0cnVjdHVyZWRMb2dnZXIsIGdldExvZ2dlciB9IGZyb20gJy4uLy4uL2xvZ2dlcic7XG5pbXBvcnQgeyBUcmFja1NvdXJjZSwgVHJhY2tUeXBlIH0gZnJvbSAnLi4vLi4vcHJvdG8vbGl2ZWtpdF9tb2RlbHNfcGInO1xuaW1wb3J0IHsgU3RyZWFtU3RhdGUgYXMgUHJvdG9TdHJlYW1TdGF0ZSB9IGZyb20gJy4uLy4uL3Byb3RvL2xpdmVraXRfcnRjX3BiJztcbmltcG9ydCB7IFRyYWNrRXZlbnQgfSBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IHR5cGUgeyBMb2dnZXJPcHRpb25zIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgaXNGaXJlRm94LCBpc1NhZmFyaSwgaXNXZWIgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBnZXRMb2dDb250ZXh0RnJvbVRyYWNrIH0gZnJvbSAnLi91dGlscyc7XG5cbmNvbnN0IEJBQ0tHUk9VTkRfUkVBQ1RJT05fREVMQVkgPSA1MDAwO1xuXG4vLyBrZWVwIG9sZCBhdWRpbyBlbGVtZW50cyB3aGVuIGRldGFjaGVkLCB3ZSB3b3VsZCByZS11c2UgdGhlbSBzaW5jZSBvbiBpT1Ncbi8vIFNhZmFyaSB0cmFja3Mgd2hpY2ggYXVkaW8gZWxlbWVudHMgaGF2ZSBiZWVuIFwiYmxlc3NlZFwiIGJ5IHRoZSB1c2VyLlxuY29uc3QgcmVjeWNsZWRFbGVtZW50czogQXJyYXk8SFRNTEF1ZGlvRWxlbWVudD4gPSBbXTtcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFRyYWNrIGV4dGVuZHMgKEV2ZW50RW1pdHRlciBhcyBuZXcgKCkgPT4gVHlwZWRFdmVudEVtaXR0ZXI8VHJhY2tFdmVudENhbGxiYWNrcz4pIHtcbiAga2luZDogVHJhY2suS2luZDtcblxuICBhdHRhY2hlZEVsZW1lbnRzOiBIVE1MTWVkaWFFbGVtZW50W10gPSBbXTtcblxuICBpc011dGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgc291cmNlOiBUcmFjay5Tb3VyY2U7XG5cbiAgLyoqXG4gICAqIHNpZCBpcyBzZXQgYWZ0ZXIgdHJhY2sgaXMgcHVibGlzaGVkIHRvIHNlcnZlciwgb3IgaWYgaXQncyBhIHJlbW90ZSB0cmFja1xuICAgKi9cbiAgc2lkPzogVHJhY2suU0lEO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG1lZGlhU3RyZWFtPzogTWVkaWFTdHJlYW07XG5cbiAgLyoqXG4gICAqIGluZGljYXRlcyBjdXJyZW50IHN0YXRlIG9mIHN0cmVhbSwgaXQnbGwgaW5kaWNhdGUgYHBhdXNlZGAgaWYgdGhlIHRyYWNrXG4gICAqIGhhcyBiZWVuIHBhdXNlZCBieSBjb25nZXN0aW9uIGNvbnRyb2xsZXJcbiAgICovXG4gIHN0cmVhbVN0YXRlOiBUcmFjay5TdHJlYW1TdGF0ZSA9IFRyYWNrLlN0cmVhbVN0YXRlLkFjdGl2ZTtcblxuICBwcm90ZWN0ZWQgX21lZGlhU3RyZWFtVHJhY2s6IE1lZGlhU3RyZWFtVHJhY2s7XG5cbiAgcHJvdGVjdGVkIF9tZWRpYVN0cmVhbUlEOiBzdHJpbmc7XG5cbiAgcHJvdGVjdGVkIGlzSW5CYWNrZ3JvdW5kOiBib29sZWFuID0gZmFsc2U7XG5cbiAgcHJpdmF0ZSBiYWNrZ3JvdW5kVGltZW91dDogUmV0dXJuVHlwZTx0eXBlb2Ygc2V0VGltZW91dD4gfCB1bmRlZmluZWQ7XG5cbiAgcHJpdmF0ZSBsb2dnZXJDb250ZXh0Q2I6IExvZ2dlck9wdGlvbnNbJ2xvZ2dlckNvbnRleHRDYiddO1xuXG4gIHByb3RlY3RlZCBfY3VycmVudEJpdHJhdGU6IG51bWJlciA9IDA7XG5cbiAgcHJvdGVjdGVkIG1vbml0b3JJbnRlcnZhbD86IFJldHVyblR5cGU8dHlwZW9mIHNldEludGVydmFsPjtcblxuICBwcm90ZWN0ZWQgbG9nOiBTdHJ1Y3R1cmVkTG9nZ2VyID0gbG9nO1xuXG4gIHByb3RlY3RlZCBjb25zdHJ1Y3RvcihcbiAgICBtZWRpYVRyYWNrOiBNZWRpYVN0cmVhbVRyYWNrLFxuICAgIGtpbmQ6IFRyYWNrLktpbmQsXG4gICAgbG9nZ2VyT3B0aW9uczogTG9nZ2VyT3B0aW9ucyA9IHt9LFxuICApIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubG9nID0gZ2V0TG9nZ2VyKGxvZ2dlck9wdGlvbnMubG9nZ2VyTmFtZSA/PyBMb2dnZXJOYW1lcy5UcmFjayk7XG4gICAgdGhpcy5sb2dnZXJDb250ZXh0Q2IgPSBsb2dnZXJPcHRpb25zLmxvZ2dlckNvbnRleHRDYjtcblxuICAgIHRoaXMuc2V0TWF4TGlzdGVuZXJzKDEwMCk7XG4gICAgdGhpcy5raW5kID0ga2luZDtcbiAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrID0gbWVkaWFUcmFjaztcbiAgICB0aGlzLl9tZWRpYVN0cmVhbUlEID0gbWVkaWFUcmFjay5pZDtcbiAgICB0aGlzLnNvdXJjZSA9IFRyYWNrLlNvdXJjZS5Vbmtub3duO1xuICB9XG5cbiAgcHJvdGVjdGVkIGdldCBsb2dDb250ZXh0KCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi50aGlzLmxvZ2dlckNvbnRleHRDYj8uKCksXG4gICAgICAuLi5nZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRoaXMpLFxuICAgIH07XG4gIH1cblxuICAvKiogY3VycmVudCByZWNlaXZlIGJpdHMgcGVyIHNlY29uZCAqL1xuICBnZXQgY3VycmVudEJpdHJhdGUoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudEJpdHJhdGU7XG4gIH1cblxuICBnZXQgbWVkaWFTdHJlYW1UcmFjaygpIHtcbiAgICByZXR1cm4gdGhpcy5fbWVkaWFTdHJlYW1UcmFjaztcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogdXNlZCBmb3Iga2VlcCBtZWRpYVN0cmVhbSdzIGZpcnN0IGlkLCBzaW5jZSBpdCdzIGlkIG1pZ2h0IGNoYW5nZVxuICAgKiBpZiB3ZSBkaXNhYmxlL2VuYWJsZSBhIHRyYWNrXG4gICAqL1xuICBnZXQgbWVkaWFTdHJlYW1JRCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9tZWRpYVN0cmVhbUlEO1xuICB9XG5cbiAgLyoqXG4gICAqIGNyZWF0ZXMgYSBuZXcgSFRNTEF1ZGlvRWxlbWVudCBvciBIVE1MVmlkZW9FbGVtZW50LCBhdHRhY2hlcyB0byBpdCwgYW5kIHJldHVybnMgaXRcbiAgICovXG4gIGF0dGFjaCgpOiBIVE1MTWVkaWFFbGVtZW50O1xuXG4gIC8qKlxuICAgKiBhdHRhY2hlcyB0cmFjayB0byBhbiBleGlzdGluZyBIVE1MQXVkaW9FbGVtZW50IG9yIEhUTUxWaWRlb0VsZW1lbnRcbiAgICovXG4gIGF0dGFjaChlbGVtZW50OiBIVE1MTWVkaWFFbGVtZW50KTogSFRNTE1lZGlhRWxlbWVudDtcbiAgYXR0YWNoKGVsZW1lbnQ/OiBIVE1MTWVkaWFFbGVtZW50KTogSFRNTE1lZGlhRWxlbWVudCB7XG4gICAgbGV0IGVsZW1lbnRUeXBlID0gJ2F1ZGlvJztcbiAgICBpZiAodGhpcy5raW5kID09PSBUcmFjay5LaW5kLlZpZGVvKSB7XG4gICAgICBlbGVtZW50VHlwZSA9ICd2aWRlbyc7XG4gICAgfVxuICAgIGlmICh0aGlzLmF0dGFjaGVkRWxlbWVudHMubGVuZ3RoID09PSAwICYmIFRyYWNrLktpbmQuVmlkZW8pIHtcbiAgICAgIHRoaXMuYWRkQXBwVmlzaWJpbGl0eUxpc3RlbmVyKCk7XG4gICAgfVxuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgaWYgKGVsZW1lbnRUeXBlID09PSAnYXVkaW8nKSB7XG4gICAgICAgIHJlY3ljbGVkRWxlbWVudHMuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgICAgIGlmIChlLnBhcmVudEVsZW1lbnQgPT09IG51bGwgJiYgIWVsZW1lbnQpIHtcbiAgICAgICAgICAgIGVsZW1lbnQgPSBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgLy8gcmVtb3ZlIGl0IGZyb20gcG9vbFxuICAgICAgICAgIHJlY3ljbGVkRWxlbWVudHMuc3BsaWNlKHJlY3ljbGVkRWxlbWVudHMuaW5kZXhPZihlbGVtZW50KSwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICBlbGVtZW50ID0gPEhUTUxNZWRpYUVsZW1lbnQ+ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChlbGVtZW50VHlwZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmF0dGFjaGVkRWxlbWVudHMuaW5jbHVkZXMoZWxlbWVudCkpIHtcbiAgICAgIHRoaXMuYXR0YWNoZWRFbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIC8vIGV2ZW4gaWYgd2UgYmVsaWV2ZSBpdCdzIGFscmVhZHkgYXR0YWNoZWQgdG8gdGhlIGVsZW1lbnQsIGl0J3MgcG9zc2libGVcbiAgICAvLyB0aGUgZWxlbWVudCdzIHNyY09iamVjdCB3YXMgc2V0IHRvIHNvbWV0aGluZyBlbHNlIG91dCBvZiBiYW5kLlxuICAgIC8vIHdlJ2xsIHdhbnQgdG8gcmUtYXR0YWNoIGl0IGluIHRoYXQgY2FzZVxuICAgIGF0dGFjaFRvRWxlbWVudCh0aGlzLm1lZGlhU3RyZWFtVHJhY2ssIGVsZW1lbnQpO1xuXG4gICAgLy8gaGFuZGxlIGF1dG8gcGxheWJhY2sgZmFpbHVyZXNcbiAgICBjb25zdCBhbGxNZWRpYVN0cmVhbVRyYWNrcyA9IChlbGVtZW50LnNyY09iamVjdCBhcyBNZWRpYVN0cmVhbSkuZ2V0VHJhY2tzKCk7XG4gICAgY29uc3QgaGFzQXVkaW8gPSBhbGxNZWRpYVN0cmVhbVRyYWNrcy5zb21lKCh0cikgPT4gdHIua2luZCA9PT0gJ2F1ZGlvJyk7XG5cbiAgICAvLyBtYW51YWxseSBwbGF5IG1lZGlhIHRvIGRldGVjdCBhdXRvIHBsYXliYWNrIHN0YXR1c1xuICAgIGVsZW1lbnRcbiAgICAgIC5wbGF5KClcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgdGhpcy5lbWl0KGhhc0F1ZGlvID8gVHJhY2tFdmVudC5BdWRpb1BsYXliYWNrU3RhcnRlZCA6IFRyYWNrRXZlbnQuVmlkZW9QbGF5YmFja1N0YXJ0ZWQpO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICBpZiAoZS5uYW1lID09PSAnTm90QWxsb3dlZEVycm9yJykge1xuICAgICAgICAgIHRoaXMuZW1pdChoYXNBdWRpbyA/IFRyYWNrRXZlbnQuQXVkaW9QbGF5YmFja0ZhaWxlZCA6IFRyYWNrRXZlbnQuVmlkZW9QbGF5YmFja0ZhaWxlZCwgZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZS5uYW1lID09PSAnQWJvcnRFcnJvcicpIHtcbiAgICAgICAgICAvLyBjb21tb25seSB0cmlnZ2VyZWQgYnkgYW5vdGhlciBgcGxheWAgcmVxdWVzdCwgb25seSBsb2cgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlc1xuICAgICAgICAgIGxvZy5kZWJ1ZyhcbiAgICAgICAgICAgIGAke2hhc0F1ZGlvID8gJ2F1ZGlvJyA6ICd2aWRlbyd9IHBsYXliYWNrIGFib3J0ZWQsIGxpa2VseSBkdWUgdG8gbmV3IHBsYXkgcmVxdWVzdGAsXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2cud2FybihgY291bGQgbm90IHBsYXliYWNrICR7aGFzQXVkaW8gPyAnYXVkaW8nIDogJ3ZpZGVvJ31gLCBlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBhdWRpbyBwbGF5YmFjayBpc24ndCBhbGxvd2VkIG1ha2Ugc3VyZSB3ZSBzdGlsbCBwbGF5IGJhY2sgdGhlIHZpZGVvXG4gICAgICAgIGlmIChcbiAgICAgICAgICBoYXNBdWRpbyAmJlxuICAgICAgICAgIGVsZW1lbnQgJiZcbiAgICAgICAgICBhbGxNZWRpYVN0cmVhbVRyYWNrcy5zb21lKCh0cikgPT4gdHIua2luZCA9PT0gJ3ZpZGVvJykgJiZcbiAgICAgICAgICBlLm5hbWUgPT09ICdOb3RBbGxvd2VkRXJyb3InXG4gICAgICAgICkge1xuICAgICAgICAgIGVsZW1lbnQubXV0ZWQgPSB0cnVlO1xuICAgICAgICAgIGVsZW1lbnQucGxheSgpLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgIC8vIGNhdGNoIGZvciBTYWZhcmksIGV4Y2VlZGVkIG9wdGlvbnMgYXQgdGhpcyBwb2ludCB0byBhdXRvbWF0aWNhbGx5IHBsYXkgdGhlIG1lZGlhIGVsZW1lbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5FbGVtZW50QXR0YWNoZWQsIGVsZW1lbnQpO1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIERldGFjaGVzIGZyb20gYWxsIGF0dGFjaGVkIGVsZW1lbnRzXG4gICAqL1xuICBkZXRhY2goKTogSFRNTE1lZGlhRWxlbWVudFtdO1xuXG4gIC8qKlxuICAgKiBEZXRhY2ggZnJvbSBhIHNpbmdsZSBlbGVtZW50XG4gICAqIEBwYXJhbSBlbGVtZW50XG4gICAqL1xuICBkZXRhY2goZWxlbWVudDogSFRNTE1lZGlhRWxlbWVudCk6IEhUTUxNZWRpYUVsZW1lbnQ7XG4gIGRldGFjaChlbGVtZW50PzogSFRNTE1lZGlhRWxlbWVudCk6IEhUTUxNZWRpYUVsZW1lbnQgfCBIVE1MTWVkaWFFbGVtZW50W10ge1xuICAgIHRyeSB7XG4gICAgICAvLyBkZXRhY2ggZnJvbSBhIHNpbmdsZSBlbGVtZW50XG4gICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICBkZXRhY2hUcmFjayh0aGlzLm1lZGlhU3RyZWFtVHJhY2ssIGVsZW1lbnQpO1xuICAgICAgICBjb25zdCBpZHggPSB0aGlzLmF0dGFjaGVkRWxlbWVudHMuaW5kZXhPZihlbGVtZW50KTtcbiAgICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgdGhpcy5hdHRhY2hlZEVsZW1lbnRzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgIHRoaXMucmVjeWNsZUVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuRWxlbWVudERldGFjaGVkLCBlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGV0YWNoZWQ6IEhUTUxNZWRpYUVsZW1lbnRbXSA9IFtdO1xuICAgICAgdGhpcy5hdHRhY2hlZEVsZW1lbnRzLmZvckVhY2goKGVsbSkgPT4ge1xuICAgICAgICBkZXRhY2hUcmFjayh0aGlzLm1lZGlhU3RyZWFtVHJhY2ssIGVsbSk7XG4gICAgICAgIGRldGFjaGVkLnB1c2goZWxtKTtcbiAgICAgICAgdGhpcy5yZWN5Y2xlRWxlbWVudChlbG0pO1xuICAgICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5FbGVtZW50RGV0YWNoZWQsIGVsbSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gcmVtb3ZlIGFsbCB0cmFja3NcbiAgICAgIHRoaXMuYXR0YWNoZWRFbGVtZW50cyA9IFtdO1xuICAgICAgcmV0dXJuIGRldGFjaGVkO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAodGhpcy5hdHRhY2hlZEVsZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLnJlbW92ZUFwcFZpc2liaWxpdHlMaXN0ZW5lcigpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHN0b3AoKSB7XG4gICAgdGhpcy5zdG9wTW9uaXRvcigpO1xuICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suc3RvcCgpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGVuYWJsZSgpIHtcbiAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLmVuYWJsZWQgPSB0cnVlO1xuICB9XG5cbiAgcHJvdGVjdGVkIGRpc2FibGUoKSB7XG4gICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5lbmFibGVkID0gZmFsc2U7XG4gIH1cblxuICAvKiBAaW50ZXJuYWwgKi9cbiAgYWJzdHJhY3Qgc3RhcnRNb25pdG9yKHNpZ25hbENsaWVudD86IFNpZ25hbENsaWVudCk6IHZvaWQ7XG5cbiAgLyogQGludGVybmFsICovXG4gIHN0b3BNb25pdG9yKCkge1xuICAgIGlmICh0aGlzLm1vbml0b3JJbnRlcnZhbCkge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLm1vbml0b3JJbnRlcnZhbCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICB1cGRhdGVMb2dnZXJPcHRpb25zKGxvZ2dlck9wdGlvbnM6IExvZ2dlck9wdGlvbnMpIHtcbiAgICBpZiAobG9nZ2VyT3B0aW9ucy5sb2dnZXJOYW1lKSB7XG4gICAgICB0aGlzLmxvZyA9IGdldExvZ2dlcihsb2dnZXJPcHRpb25zLmxvZ2dlck5hbWUpO1xuICAgIH1cbiAgICBpZiAobG9nZ2VyT3B0aW9ucy5sb2dnZXJDb250ZXh0Q2IpIHtcbiAgICAgIHRoaXMubG9nZ2VyQ29udGV4dENiID0gbG9nZ2VyT3B0aW9ucy5sb2dnZXJDb250ZXh0Q2I7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSByZWN5Y2xlRWxlbWVudChlbGVtZW50OiBIVE1MTWVkaWFFbGVtZW50KSB7XG4gICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MQXVkaW9FbGVtZW50KSB7XG4gICAgICAvLyB3ZSBvbmx5IG5lZWQgdG8gcmUtdXNlIGEgc2luZ2xlIGVsZW1lbnRcbiAgICAgIGxldCBzaG91bGRDYWNoZSA9IHRydWU7XG4gICAgICBlbGVtZW50LnBhdXNlKCk7XG4gICAgICByZWN5Y2xlZEVsZW1lbnRzLmZvckVhY2goKGUpID0+IHtcbiAgICAgICAgaWYgKCFlLnBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICBzaG91bGRDYWNoZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChzaG91bGRDYWNoZSkge1xuICAgICAgICByZWN5Y2xlZEVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIGFwcFZpc2liaWxpdHlDaGFuZ2VkTGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgaWYgKHRoaXMuYmFja2dyb3VuZFRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmJhY2tncm91bmRUaW1lb3V0KTtcbiAgICB9XG4gICAgLy8gZGVsYXkgYXBwIHZpc2liaWxpdHkgdXBkYXRlIGlmIGl0IGdvZXMgdG8gaGlkZGVuXG4gICAgLy8gdXBkYXRlIGltbWVkaWF0ZWx5IGlmIGl0IGNvbWVzIGJhY2sgdG8gZm9jdXNcbiAgICBpZiAoZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSAnaGlkZGVuJykge1xuICAgICAgdGhpcy5iYWNrZ3JvdW5kVGltZW91dCA9IHNldFRpbWVvdXQoXG4gICAgICAgICgpID0+IHRoaXMuaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWQoKSxcbiAgICAgICAgQkFDS0dST1VORF9SRUFDVElPTl9ERUxBWSxcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWQoKTtcbiAgICB9XG4gIH07XG5cbiAgcHJvdGVjdGVkIGFzeW5jIGhhbmRsZUFwcFZpc2liaWxpdHlDaGFuZ2VkKCkge1xuICAgIHRoaXMuaXNJbkJhY2tncm91bmQgPSBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09ICdoaWRkZW4nO1xuICB9XG5cbiAgcHJvdGVjdGVkIGFkZEFwcFZpc2liaWxpdHlMaXN0ZW5lcigpIHtcbiAgICBpZiAoaXNXZWIoKSkge1xuICAgICAgdGhpcy5pc0luQmFja2dyb3VuZCA9IGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gJ2hpZGRlbic7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgdGhpcy5hcHBWaXNpYmlsaXR5Q2hhbmdlZExpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pc0luQmFja2dyb3VuZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCByZW1vdmVBcHBWaXNpYmlsaXR5TGlzdGVuZXIoKSB7XG4gICAgaWYgKGlzV2ViKCkpIHtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCB0aGlzLmFwcFZpc2liaWxpdHlDaGFuZ2VkTGlzdGVuZXIpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXR0YWNoVG9FbGVtZW50KHRyYWNrOiBNZWRpYVN0cmVhbVRyYWNrLCBlbGVtZW50OiBIVE1MTWVkaWFFbGVtZW50KSB7XG4gIGxldCBtZWRpYVN0cmVhbTogTWVkaWFTdHJlYW07XG4gIGlmIChlbGVtZW50LnNyY09iamVjdCBpbnN0YW5jZW9mIE1lZGlhU3RyZWFtKSB7XG4gICAgbWVkaWFTdHJlYW0gPSBlbGVtZW50LnNyY09iamVjdDtcbiAgfSBlbHNlIHtcbiAgICBtZWRpYVN0cmVhbSA9IG5ldyBNZWRpYVN0cmVhbSgpO1xuICB9XG5cbiAgLy8gY2hlY2sgaWYgdHJhY2sgbWF0Y2hlcyBleGlzdGluZyB0cmFja1xuICBsZXQgZXhpc3RpbmdUcmFja3M6IE1lZGlhU3RyZWFtVHJhY2tbXTtcbiAgaWYgKHRyYWNrLmtpbmQgPT09ICdhdWRpbycpIHtcbiAgICBleGlzdGluZ1RyYWNrcyA9IG1lZGlhU3RyZWFtLmdldEF1ZGlvVHJhY2tzKCk7XG4gIH0gZWxzZSB7XG4gICAgZXhpc3RpbmdUcmFja3MgPSBtZWRpYVN0cmVhbS5nZXRWaWRlb1RyYWNrcygpO1xuICB9XG4gIGlmICghZXhpc3RpbmdUcmFja3MuaW5jbHVkZXModHJhY2spKSB7XG4gICAgZXhpc3RpbmdUcmFja3MuZm9yRWFjaCgoZXQpID0+IHtcbiAgICAgIG1lZGlhU3RyZWFtLnJlbW92ZVRyYWNrKGV0KTtcbiAgICB9KTtcbiAgICBtZWRpYVN0cmVhbS5hZGRUcmFjayh0cmFjayk7XG4gIH1cblxuICBpZiAoIWlzU2FmYXJpKCkgfHwgIShlbGVtZW50IGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCkpIHtcbiAgICAvLyB3aGVuIGluIGxvdyBwb3dlciBtb2RlIChhcHBsaWVzIHRvIGJvdGggbWFjT1MgYW5kIGlPUyksIFNhZmFyaSB3aWxsIHNob3cgYSBwbGF5L3BhdXNlIG92ZXJsYXlcbiAgICAvLyB3aGVuIGEgdmlkZW8gc3RhcnRzIHRoYXQgaGFzIHRoZSBgYXV0b3BsYXlgIGF0dHJpYnV0ZSBpcyBzZXQuXG4gICAgLy8gd2Ugd29yayBhcm91bmQgdGhpcyBieSBfbm90XyBzZXR0aW5nIHRoZSBhdXRvcGxheSBhdHRyaWJ1dGUgb24gc2FmYXJpIGFuZCBpbnN0ZWFkIGNhbGwgYHNldFRpbWVvdXQoKCkgPT4gZWwucGxheSgpLDApYCBmdXJ0aGVyIGRvd25cbiAgICBlbGVtZW50LmF1dG9wbGF5ID0gdHJ1ZTtcbiAgfVxuICAvLyBJbiBjYXNlIHRoZXJlIGFyZSBubyBhdWRpbyB0cmFja3MgcHJlc2VudCBvbiB0aGUgbWVkaWFzdHJlYW0sIHdlIHNldCB0aGUgZWxlbWVudCBhcyBtdXRlZCB0byBlbnN1cmUgYXV0b3BsYXkgd29ya3NcbiAgZWxlbWVudC5tdXRlZCA9IG1lZGlhU3RyZWFtLmdldEF1ZGlvVHJhY2tzKCkubGVuZ3RoID09PSAwO1xuICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQpIHtcbiAgICBlbGVtZW50LnBsYXlzSW5saW5lID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGF2b2lkIGZsaWNrZXJcbiAgaWYgKGVsZW1lbnQuc3JjT2JqZWN0ICE9PSBtZWRpYVN0cmVhbSkge1xuICAgIGVsZW1lbnQuc3JjT2JqZWN0ID0gbWVkaWFTdHJlYW07XG4gICAgaWYgKChpc1NhZmFyaSgpIHx8IGlzRmlyZUZveCgpKSAmJiBlbGVtZW50IGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCkge1xuICAgICAgLy8gRmlyZWZveCBhbHNvIGhhcyBhIHRpbWluZyBpc3N1ZSB3aGVyZSB2aWRlbyBkb2Vzbid0IGFjdHVhbGx5IGdldCBhdHRhY2hlZCB1bmxlc3NcbiAgICAgIC8vIHBlcmZvcm1lZCBvdXQtb2YtYmFuZFxuICAgICAgLy8gU2FmYXJpIDE1IGhhcyBhIGJ1ZyB3aGVyZSBpbiBjZXJ0YWluIGxheW91dHMsIHZpZGVvIGVsZW1lbnQgcmVuZGVyc1xuICAgICAgLy8gYmxhY2sgdW50aWwgdGhlIHBhZ2UgaXMgcmVzaXplZCBvciBvdGhlciBjaGFuZ2VzIHRha2UgcGxhY2UuXG4gICAgICAvLyBSZXNldHRpbmcgdGhlIHNyYyB0cmlnZ2VycyBpdCB0byByZW5kZXIuXG4gICAgICAvLyBodHRwczovL2RldmVsb3Blci5hcHBsZS5jb20vZm9ydW1zL3RocmVhZC82OTA1MjNcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBlbGVtZW50LnNyY09iamVjdCA9IG1lZGlhU3RyZWFtO1xuICAgICAgICAvLyBTYWZhcmkgMTUgc29tZXRpbWVzIGZhaWxzIHRvIHN0YXJ0IGEgdmlkZW9cbiAgICAgICAgLy8gd2hlbiB0aGUgd2luZG93IGlzIGJhY2tncm91bmRlZCBiZWZvcmUgdGhlIGZpcnN0IGZyYW1lIGlzIGRyYXduXG4gICAgICAgIC8vIG1hbnVhbGx5IGNhbGxpbmcgcGxheSBoZXJlIHNlZW1zIHRvIGZpeCB0aGF0XG4gICAgICAgIGVsZW1lbnQucGxheSgpLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAvKiogZG8gbm90aGluZyAqL1xuICAgICAgICB9KTtcbiAgICAgIH0sIDApO1xuICAgIH1cbiAgfVxufVxuXG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZGV0YWNoVHJhY2sodHJhY2s6IE1lZGlhU3RyZWFtVHJhY2ssIGVsZW1lbnQ6IEhUTUxNZWRpYUVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQuc3JjT2JqZWN0IGluc3RhbmNlb2YgTWVkaWFTdHJlYW0pIHtcbiAgICBjb25zdCBtZWRpYVN0cmVhbSA9IGVsZW1lbnQuc3JjT2JqZWN0O1xuICAgIG1lZGlhU3RyZWFtLnJlbW92ZVRyYWNrKHRyYWNrKTtcbiAgICBpZiAobWVkaWFTdHJlYW0uZ2V0VHJhY2tzKCkubGVuZ3RoID4gMCkge1xuICAgICAgZWxlbWVudC5zcmNPYmplY3QgPSBtZWRpYVN0cmVhbTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5zcmNPYmplY3QgPSBudWxsO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgbmFtZXNwYWNlIFRyYWNrIHtcbiAgZXhwb3J0IGVudW0gS2luZCB7XG4gICAgQXVkaW8gPSAnYXVkaW8nLFxuICAgIFZpZGVvID0gJ3ZpZGVvJyxcbiAgICBVbmtub3duID0gJ3Vua25vd24nLFxuICB9XG4gIGV4cG9ydCB0eXBlIFNJRCA9IHN0cmluZztcbiAgZXhwb3J0IGVudW0gU291cmNlIHtcbiAgICBDYW1lcmEgPSAnY2FtZXJhJyxcbiAgICBNaWNyb3Bob25lID0gJ21pY3JvcGhvbmUnLFxuICAgIFNjcmVlblNoYXJlID0gJ3NjcmVlbl9zaGFyZScsXG4gICAgU2NyZWVuU2hhcmVBdWRpbyA9ICdzY3JlZW5fc2hhcmVfYXVkaW8nLFxuICAgIFVua25vd24gPSAndW5rbm93bicsXG4gIH1cblxuICBleHBvcnQgZW51bSBTdHJlYW1TdGF0ZSB7XG4gICAgQWN0aXZlID0gJ2FjdGl2ZScsXG4gICAgUGF1c2VkID0gJ3BhdXNlZCcsXG4gICAgVW5rbm93biA9ICd1bmtub3duJyxcbiAgfVxuXG4gIGV4cG9ydCBpbnRlcmZhY2UgRGltZW5zaW9ucyB7XG4gICAgd2lkdGg6IG51bWJlcjtcbiAgICBoZWlnaHQ6IG51bWJlcjtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIGtpbmRUb1Byb3RvKGs6IEtpbmQpOiBUcmFja1R5cGUge1xuICAgIHN3aXRjaCAoaykge1xuICAgICAgY2FzZSBLaW5kLkF1ZGlvOlxuICAgICAgICByZXR1cm4gVHJhY2tUeXBlLkFVRElPO1xuICAgICAgY2FzZSBLaW5kLlZpZGVvOlxuICAgICAgICByZXR1cm4gVHJhY2tUeXBlLlZJREVPO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gRklYTUUgdGhpcyB3YXMgVU5SRUNPR05JWkVEIGJlZm9yZVxuICAgICAgICByZXR1cm4gVHJhY2tUeXBlLkRBVEE7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBleHBvcnQgZnVuY3Rpb24ga2luZEZyb21Qcm90byh0OiBUcmFja1R5cGUpOiBLaW5kIHwgdW5kZWZpbmVkIHtcbiAgICBzd2l0Y2ggKHQpIHtcbiAgICAgIGNhc2UgVHJhY2tUeXBlLkFVRElPOlxuICAgICAgICByZXR1cm4gS2luZC5BdWRpbztcbiAgICAgIGNhc2UgVHJhY2tUeXBlLlZJREVPOlxuICAgICAgICByZXR1cm4gS2luZC5WaWRlbztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBLaW5kLlVua25vd247XG4gICAgfVxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBleHBvcnQgZnVuY3Rpb24gc291cmNlVG9Qcm90byhzOiBTb3VyY2UpOiBUcmFja1NvdXJjZSB7XG4gICAgc3dpdGNoIChzKSB7XG4gICAgICBjYXNlIFNvdXJjZS5DYW1lcmE6XG4gICAgICAgIHJldHVybiBUcmFja1NvdXJjZS5DQU1FUkE7XG4gICAgICBjYXNlIFNvdXJjZS5NaWNyb3Bob25lOlxuICAgICAgICByZXR1cm4gVHJhY2tTb3VyY2UuTUlDUk9QSE9ORTtcbiAgICAgIGNhc2UgU291cmNlLlNjcmVlblNoYXJlOlxuICAgICAgICByZXR1cm4gVHJhY2tTb3VyY2UuU0NSRUVOX1NIQVJFO1xuICAgICAgY2FzZSBTb3VyY2UuU2NyZWVuU2hhcmVBdWRpbzpcbiAgICAgICAgcmV0dXJuIFRyYWNrU291cmNlLlNDUkVFTl9TSEFSRV9BVURJTztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBUcmFja1NvdXJjZS5VTktOT1dOO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHNvdXJjZUZyb21Qcm90byhzOiBUcmFja1NvdXJjZSk6IFNvdXJjZSB7XG4gICAgc3dpdGNoIChzKSB7XG4gICAgICBjYXNlIFRyYWNrU291cmNlLkNBTUVSQTpcbiAgICAgICAgcmV0dXJuIFNvdXJjZS5DYW1lcmE7XG4gICAgICBjYXNlIFRyYWNrU291cmNlLk1JQ1JPUEhPTkU6XG4gICAgICAgIHJldHVybiBTb3VyY2UuTWljcm9waG9uZTtcbiAgICAgIGNhc2UgVHJhY2tTb3VyY2UuU0NSRUVOX1NIQVJFOlxuICAgICAgICByZXR1cm4gU291cmNlLlNjcmVlblNoYXJlO1xuICAgICAgY2FzZSBUcmFja1NvdXJjZS5TQ1JFRU5fU0hBUkVfQVVESU86XG4gICAgICAgIHJldHVybiBTb3VyY2UuU2NyZWVuU2hhcmVBdWRpbztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBTb3VyY2UuVW5rbm93bjtcbiAgICB9XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIGV4cG9ydCBmdW5jdGlvbiBzdHJlYW1TdGF0ZUZyb21Qcm90byhzOiBQcm90b1N0cmVhbVN0YXRlKTogU3RyZWFtU3RhdGUge1xuICAgIHN3aXRjaCAocykge1xuICAgICAgY2FzZSBQcm90b1N0cmVhbVN0YXRlLkFDVElWRTpcbiAgICAgICAgcmV0dXJuIFN0cmVhbVN0YXRlLkFjdGl2ZTtcbiAgICAgIGNhc2UgUHJvdG9TdHJlYW1TdGF0ZS5QQVVTRUQ6XG4gICAgICAgIHJldHVybiBTdHJlYW1TdGF0ZS5QYXVzZWQ7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gU3RyZWFtU3RhdGUuVW5rbm93bjtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgVHJhY2tFdmVudENhbGxiYWNrcyA9IHtcbiAgbWVzc2FnZTogKCkgPT4gdm9pZDtcbiAgbXV0ZWQ6ICh0cmFjaz86IGFueSkgPT4gdm9pZDtcbiAgdW5tdXRlZDogKHRyYWNrPzogYW55KSA9PiB2b2lkO1xuICByZXN0YXJ0ZWQ6ICh0cmFjaz86IGFueSkgPT4gdm9pZDtcbiAgZW5kZWQ6ICh0cmFjaz86IGFueSkgPT4gdm9pZDtcbiAgdXBkYXRlU2V0dGluZ3M6ICgpID0+IHZvaWQ7XG4gIHVwZGF0ZVN1YnNjcmlwdGlvbjogKCkgPT4gdm9pZDtcbiAgYXVkaW9QbGF5YmFja1N0YXJ0ZWQ6ICgpID0+IHZvaWQ7XG4gIGF1ZGlvUGxheWJhY2tGYWlsZWQ6IChlcnJvcj86IEVycm9yKSA9PiB2b2lkO1xuICBhdWRpb1NpbGVuY2VEZXRlY3RlZDogKCkgPT4gdm9pZDtcbiAgdmlzaWJpbGl0eUNoYW5nZWQ6ICh2aXNpYmxlOiBib29sZWFuLCB0cmFjaz86IGFueSkgPT4gdm9pZDtcbiAgdmlkZW9EaW1lbnNpb25zQ2hhbmdlZDogKGRpbWVuc2lvbnM6IFRyYWNrLkRpbWVuc2lvbnMsIHRyYWNrPzogYW55KSA9PiB2b2lkO1xuICB2aWRlb1BsYXliYWNrU3RhcnRlZDogKCkgPT4gdm9pZDtcbiAgdmlkZW9QbGF5YmFja0ZhaWxlZDogKGVycm9yPzogRXJyb3IpID0+IHZvaWQ7XG4gIGVsZW1lbnRBdHRhY2hlZDogKGVsZW1lbnQ6IEhUTUxNZWRpYUVsZW1lbnQpID0+IHZvaWQ7XG4gIGVsZW1lbnREZXRhY2hlZDogKGVsZW1lbnQ6IEhUTUxNZWRpYUVsZW1lbnQpID0+IHZvaWQ7XG4gIHVwc3RyZWFtUGF1c2VkOiAodHJhY2s6IGFueSkgPT4gdm9pZDtcbiAgdXBzdHJlYW1SZXN1bWVkOiAodHJhY2s6IGFueSkgPT4gdm9pZDtcbn07XG4iLCJpbXBvcnQgeyBUcmFja1B1Ymxpc2hlZFJlc3BvbnNlIH0gZnJvbSAnLi4vLi4vcHJvdG8vbGl2ZWtpdF9ydGNfcGInO1xuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnLi4vLi4vdXRpbHMvY2xvbmVEZWVwJztcbmltcG9ydCB7IGlzU2FmYXJpLCBzbGVlcCB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IFRyYWNrIH0gZnJvbSAnLi9UcmFjayc7XG5pbXBvcnQgdHlwZSB7IFRyYWNrUHVibGljYXRpb24gfSBmcm9tICcuL1RyYWNrUHVibGljYXRpb24nO1xuaW1wb3J0IHtcbiAgdHlwZSBBdWRpb0NhcHR1cmVPcHRpb25zLFxuICB0eXBlIENyZWF0ZUxvY2FsVHJhY2tzT3B0aW9ucyxcbiAgdHlwZSBTY3JlZW5TaGFyZUNhcHR1cmVPcHRpb25zLFxuICB0eXBlIFZpZGVvQ2FwdHVyZU9wdGlvbnMsXG4gIFZpZGVvQ29kZWMsXG4gIHZpZGVvQ29kZWNzLFxufSBmcm9tICcuL29wdGlvbnMnO1xuaW1wb3J0IHR5cGUgeyBBdWRpb1RyYWNrIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZURlZmF1bHRPcHRpb25zKFxuICBvcHRpb25zPzogQ3JlYXRlTG9jYWxUcmFja3NPcHRpb25zLFxuICBhdWRpb0RlZmF1bHRzPzogQXVkaW9DYXB0dXJlT3B0aW9ucyxcbiAgdmlkZW9EZWZhdWx0cz86IFZpZGVvQ2FwdHVyZU9wdGlvbnMsXG4pOiBDcmVhdGVMb2NhbFRyYWNrc09wdGlvbnMge1xuICBjb25zdCBvcHRzOiBDcmVhdGVMb2NhbFRyYWNrc09wdGlvbnMgPSBjbG9uZURlZXAob3B0aW9ucykgPz8ge307XG4gIGlmIChvcHRzLmF1ZGlvID09PSB0cnVlKSBvcHRzLmF1ZGlvID0ge307XG4gIGlmIChvcHRzLnZpZGVvID09PSB0cnVlKSBvcHRzLnZpZGVvID0ge307XG5cbiAgLy8gdXNlIGRlZmF1bHRzXG4gIGlmIChvcHRzLmF1ZGlvKSB7XG4gICAgbWVyZ2VPYmplY3RXaXRob3V0T3ZlcndyaXRpbmcoXG4gICAgICBvcHRzLmF1ZGlvIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuICAgICAgYXVkaW9EZWZhdWx0cyBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPixcbiAgICApO1xuICB9XG4gIGlmIChvcHRzLnZpZGVvKSB7XG4gICAgbWVyZ2VPYmplY3RXaXRob3V0T3ZlcndyaXRpbmcoXG4gICAgICBvcHRzLnZpZGVvIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuICAgICAgdmlkZW9EZWZhdWx0cyBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPixcbiAgICApO1xuICB9XG4gIHJldHVybiBvcHRzO1xufVxuXG5mdW5jdGlvbiBtZXJnZU9iamVjdFdpdGhvdXRPdmVyd3JpdGluZyhcbiAgbWFpbk9iamVjdDogUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4gIG9iamVjdFRvTWVyZ2U6IFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuKTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4ge1xuICBPYmplY3Qua2V5cyhvYmplY3RUb01lcmdlKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBpZiAobWFpbk9iamVjdFtrZXldID09PSB1bmRlZmluZWQpIG1haW5PYmplY3Rba2V5XSA9IG9iamVjdFRvTWVyZ2Vba2V5XTtcbiAgfSk7XG4gIHJldHVybiBtYWluT2JqZWN0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29uc3RyYWludHNGb3JPcHRpb25zKG9wdGlvbnM6IENyZWF0ZUxvY2FsVHJhY2tzT3B0aW9ucyk6IE1lZGlhU3RyZWFtQ29uc3RyYWludHMge1xuICBjb25zdCBjb25zdHJhaW50czogTWVkaWFTdHJlYW1Db25zdHJhaW50cyA9IHt9O1xuXG4gIGlmIChvcHRpb25zLnZpZGVvKSB7XG4gICAgLy8gZGVmYXVsdCB2aWRlbyBvcHRpb25zXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnZpZGVvID09PSAnb2JqZWN0Jykge1xuICAgICAgY29uc3QgdmlkZW9PcHRpb25zOiBNZWRpYVRyYWNrQ29uc3RyYWludHMgPSB7fTtcbiAgICAgIGNvbnN0IHRhcmdldCA9IHZpZGVvT3B0aW9ucyBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IG9wdGlvbnMudmlkZW8gYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG4gICAgICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgIGNhc2UgJ3Jlc29sdXRpb24nOlxuICAgICAgICAgICAgLy8gZmxhdHRlbiBWaWRlb1Jlc29sdXRpb24gZmllbGRzXG4gICAgICAgICAgICBtZXJnZU9iamVjdFdpdGhvdXRPdmVyd3JpdGluZyh0YXJnZXQsIHNvdXJjZS5yZXNvbHV0aW9uIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0cmFpbnRzLnZpZGVvID0gdmlkZW9PcHRpb25zO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdHJhaW50cy52aWRlbyA9IG9wdGlvbnMudmlkZW87XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0cmFpbnRzLnZpZGVvID0gZmFsc2U7XG4gIH1cblxuICBpZiAob3B0aW9ucy5hdWRpbykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5hdWRpbyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGNvbnN0cmFpbnRzLmF1ZGlvID0gb3B0aW9ucy5hdWRpbztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3RyYWludHMuYXVkaW8gPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdHJhaW50cy5hdWRpbyA9IGZhbHNlO1xuICB9XG4gIHJldHVybiBjb25zdHJhaW50cztcbn1cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBkZXRlY3RzIHNpbGVuY2Ugb24gYSBnaXZlbiBbW1RyYWNrXV0gaW5zdGFuY2UuXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHRyYWNrIHNlZW1zIHRvIGJlIGVudGlyZWx5IHNpbGVudC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRldGVjdFNpbGVuY2UodHJhY2s6IEF1ZGlvVHJhY2ssIHRpbWVPZmZzZXQgPSAyMDApOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgY29uc3QgY3R4ID0gZ2V0TmV3QXVkaW9Db250ZXh0KCk7XG4gIGlmIChjdHgpIHtcbiAgICBjb25zdCBhbmFseXNlciA9IGN0eC5jcmVhdGVBbmFseXNlcigpO1xuICAgIGFuYWx5c2VyLmZmdFNpemUgPSAyMDQ4O1xuXG4gICAgY29uc3QgYnVmZmVyTGVuZ3RoID0gYW5hbHlzZXIuZnJlcXVlbmN5QmluQ291bnQ7XG4gICAgY29uc3QgZGF0YUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyTGVuZ3RoKTtcbiAgICBjb25zdCBzb3VyY2UgPSBjdHguY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2UobmV3IE1lZGlhU3RyZWFtKFt0cmFjay5tZWRpYVN0cmVhbVRyYWNrXSkpO1xuXG4gICAgc291cmNlLmNvbm5lY3QoYW5hbHlzZXIpO1xuICAgIGF3YWl0IHNsZWVwKHRpbWVPZmZzZXQpO1xuICAgIGFuYWx5c2VyLmdldEJ5dGVUaW1lRG9tYWluRGF0YShkYXRhQXJyYXkpO1xuICAgIGNvbnN0IHNvbWVOb2lzZSA9IGRhdGFBcnJheS5zb21lKChzYW1wbGUpID0+IHNhbXBsZSAhPT0gMTI4ICYmIHNhbXBsZSAhPT0gMCk7XG4gICAgY3R4LmNsb3NlKCk7XG4gICAgcmV0dXJuICFzb21lTm9pc2U7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TmV3QXVkaW9Db250ZXh0KCk6IEF1ZGlvQ29udGV4dCB8IHZvaWQge1xuICBjb25zdCBBdWRpb0NvbnRleHQgPVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAod2luZG93LkF1ZGlvQ29udGV4dCB8fCB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0KTtcbiAgaWYgKEF1ZGlvQ29udGV4dCkge1xuICAgIHJldHVybiBuZXcgQXVkaW9Db250ZXh0KHsgbGF0ZW5jeUhpbnQ6ICdpbnRlcmFjdGl2ZScgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGtpbmRUb1NvdXJjZShraW5kOiBNZWRpYURldmljZUtpbmQpIHtcbiAgaWYgKGtpbmQgPT09ICdhdWRpb2lucHV0Jykge1xuICAgIHJldHVybiBUcmFjay5Tb3VyY2UuTWljcm9waG9uZTtcbiAgfSBlbHNlIGlmIChraW5kID09PSAndmlkZW9pbnB1dCcpIHtcbiAgICByZXR1cm4gVHJhY2suU291cmNlLkNhbWVyYTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gVHJhY2suU291cmNlLlVua25vd247XG4gIH1cbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNvdXJjZVRvS2luZChzb3VyY2U6IFRyYWNrLlNvdXJjZSk6IE1lZGlhRGV2aWNlS2luZCB8IHVuZGVmaW5lZCB7XG4gIGlmIChzb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lKSB7XG4gICAgcmV0dXJuICdhdWRpb2lucHV0JztcbiAgfSBlbHNlIGlmIChzb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5DYW1lcmEpIHtcbiAgICByZXR1cm4gJ3ZpZGVvaW5wdXQnO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjcmVlbkNhcHR1cmVUb0Rpc3BsYXlNZWRpYVN0cmVhbU9wdGlvbnMoXG4gIG9wdGlvbnM6IFNjcmVlblNoYXJlQ2FwdHVyZU9wdGlvbnMsXG4pOiBEaXNwbGF5TWVkaWFTdHJlYW1PcHRpb25zIHtcbiAgbGV0IHZpZGVvQ29uc3RyYWludHM6IE1lZGlhVHJhY2tDb25zdHJhaW50cyB8IGJvb2xlYW4gPSBvcHRpb25zLnZpZGVvID8/IHRydWU7XG4gIC8vIHRyZWF0IDAgYXMgdW5jYXBwZWRcbiAgaWYgKG9wdGlvbnMucmVzb2x1dGlvbiAmJiBvcHRpb25zLnJlc29sdXRpb24ud2lkdGggPiAwICYmIG9wdGlvbnMucmVzb2x1dGlvbi5oZWlnaHQgPiAwKSB7XG4gICAgdmlkZW9Db25zdHJhaW50cyA9IHR5cGVvZiB2aWRlb0NvbnN0cmFpbnRzID09PSAnYm9vbGVhbicgPyB7fSA6IHZpZGVvQ29uc3RyYWludHM7XG4gICAgaWYgKGlzU2FmYXJpKCkpIHtcbiAgICAgIHZpZGVvQ29uc3RyYWludHMgPSB7XG4gICAgICAgIC4uLnZpZGVvQ29uc3RyYWludHMsXG4gICAgICAgIHdpZHRoOiB7IG1heDogb3B0aW9ucy5yZXNvbHV0aW9uLndpZHRoIH0sXG4gICAgICAgIGhlaWdodDogeyBtYXg6IG9wdGlvbnMucmVzb2x1dGlvbi5oZWlnaHQgfSxcbiAgICAgICAgZnJhbWVSYXRlOiBvcHRpb25zLnJlc29sdXRpb24uZnJhbWVSYXRlLFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmlkZW9Db25zdHJhaW50cyA9IHtcbiAgICAgICAgLi4udmlkZW9Db25zdHJhaW50cyxcbiAgICAgICAgd2lkdGg6IHsgaWRlYWw6IG9wdGlvbnMucmVzb2x1dGlvbi53aWR0aCB9LFxuICAgICAgICBoZWlnaHQ6IHsgaWRlYWw6IG9wdGlvbnMucmVzb2x1dGlvbi5oZWlnaHQgfSxcbiAgICAgICAgZnJhbWVSYXRlOiBvcHRpb25zLnJlc29sdXRpb24uZnJhbWVSYXRlLFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGF1ZGlvOiBvcHRpb25zLmF1ZGlvID8/IGZhbHNlLFxuICAgIHZpZGVvOiB2aWRlb0NvbnN0cmFpbnRzLFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3Igc3VwcG9ydCBmb3IgZXhwZXJpbWVudGFsIGRpc3BsYXkgbWVkaWEgZmVhdHVyZXNcbiAgICBjb250cm9sbGVyOiBvcHRpb25zLmNvbnRyb2xsZXIsXG4gICAgc2VsZkJyb3dzZXJTdXJmYWNlOiBvcHRpb25zLnNlbGZCcm93c2VyU3VyZmFjZSxcbiAgICBzdXJmYWNlU3dpdGNoaW5nOiBvcHRpb25zLnN1cmZhY2VTd2l0Y2hpbmcsXG4gICAgc3lzdGVtQXVkaW86IG9wdGlvbnMuc3lzdGVtQXVkaW8sXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtaW1lVHlwZVRvVmlkZW9Db2RlY1N0cmluZyhtaW1lVHlwZTogc3RyaW5nKSB7XG4gIGNvbnN0IGNvZGVjID0gbWltZVR5cGUuc3BsaXQoJy8nKVsxXS50b0xvd2VyQ2FzZSgpIGFzIFZpZGVvQ29kZWM7XG4gIGlmICghdmlkZW9Db2RlY3MuaW5jbHVkZXMoY29kZWMpKSB7XG4gICAgdGhyb3cgRXJyb3IoYFZpZGVvIGNvZGVjIG5vdCBzdXBwb3J0ZWQ6ICR7Y29kZWN9YCk7XG4gIH1cbiAgcmV0dXJuIGNvZGVjO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VHJhY2tQdWJsaWNhdGlvbkluZm88VCBleHRlbmRzIFRyYWNrUHVibGljYXRpb24+KFxuICB0cmFja3M6IFRbXSxcbik6IFRyYWNrUHVibGlzaGVkUmVzcG9uc2VbXSB7XG4gIGNvbnN0IGluZm9zOiBUcmFja1B1Ymxpc2hlZFJlc3BvbnNlW10gPSBbXTtcbiAgdHJhY2tzLmZvckVhY2goKHRyYWNrOiBUcmFja1B1YmxpY2F0aW9uKSA9PiB7XG4gICAgaWYgKHRyYWNrLnRyYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGluZm9zLnB1c2goXG4gICAgICAgIG5ldyBUcmFja1B1Ymxpc2hlZFJlc3BvbnNlKHtcbiAgICAgICAgICBjaWQ6IHRyYWNrLnRyYWNrLm1lZGlhU3RyZWFtSUQsXG4gICAgICAgICAgdHJhY2s6IHRyYWNrLnRyYWNrSW5mbyxcbiAgICAgICAgfSksXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBpbmZvcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2s6IFRyYWNrIHwgVHJhY2tQdWJsaWNhdGlvbik6IFJlY29yZDxzdHJpbmcsIHVua25vd24+IHtcbiAgaWYgKHRyYWNrIGluc3RhbmNlb2YgVHJhY2spIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHJhY2tTaWQ6IHRyYWNrLnNpZCxcbiAgICAgIHRyYWNrU291cmNlOiB0cmFjay5zb3VyY2UsXG4gICAgICB0cmFja011dGVkOiB0cmFjay5pc011dGVkLFxuICAgICAgdHJhY2tFbmFibGVkOiB0cmFjay5tZWRpYVN0cmVhbVRyYWNrLmVuYWJsZWQsXG4gICAgICB0cmFja0tpbmQ6IHRyYWNrLmtpbmQsXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHJhY2tTaWQ6IHRyYWNrLnRyYWNrU2lkLFxuICAgICAgdHJhY2tOYW1lOiB0cmFjay50cmFja05hbWUsXG4gICAgICB0cmFjazogdHJhY2sudHJhY2sgPyBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrLnRyYWNrKSA6IHVuZGVmaW5lZCxcbiAgICAgIHRyYWNrRW5hYmxlZDogdHJhY2suaXNFbmFibGVkLFxuICAgICAgdHJhY2tFbmNyeXB0ZWQ6IHRyYWNrLmlzRW5jcnlwdGVkLFxuICAgICAgdHJhY2tNaW1lVHlwZTogdHJhY2subWltZVR5cGUsXG4gICAgfTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgQ2xpZW50SW5mbywgQ2xpZW50SW5mb19TREsgfSBmcm9tICcuLi9wcm90by9saXZla2l0X21vZGVsc19wYic7XG5pbXBvcnQgdHlwZSB7IERldGVjdGFibGVCcm93c2VyIH0gZnJvbSAnLi4vdXRpbHMvYnJvd3NlclBhcnNlcic7XG5pbXBvcnQgeyBnZXRCcm93c2VyIH0gZnJvbSAnLi4vdXRpbHMvYnJvd3NlclBhcnNlcic7XG5pbXBvcnQgeyBwcm90b2NvbFZlcnNpb24sIHZlcnNpb24gfSBmcm9tICcuLi92ZXJzaW9uJztcbmltcG9ydCBDcml0aWNhbFRpbWVycyBmcm9tICcuL3RpbWVycyc7XG5pbXBvcnQgdHlwZSBMb2NhbEF1ZGlvVHJhY2sgZnJvbSAnLi90cmFjay9Mb2NhbEF1ZGlvVHJhY2snO1xuaW1wb3J0IHR5cGUgUmVtb3RlQXVkaW9UcmFjayBmcm9tICcuL3RyYWNrL1JlbW90ZUF1ZGlvVHJhY2snO1xuaW1wb3J0IHsgVmlkZW9Db2RlYywgdmlkZW9Db2RlY3MgfSBmcm9tICcuL3RyYWNrL29wdGlvbnMnO1xuaW1wb3J0IHsgZ2V0TmV3QXVkaW9Db250ZXh0IH0gZnJvbSAnLi90cmFjay91dGlscyc7XG5pbXBvcnQgdHlwZSB7IExpdmVLaXRSZWFjdE5hdGl2ZUluZm8gfSBmcm9tICcuL3R5cGVzJztcblxuY29uc3Qgc2VwYXJhdG9yID0gJ3wnO1xuZXhwb3J0IGNvbnN0IGRkRXh0ZW5zaW9uVVJJID1cbiAgJ2h0dHBzOi8vYW9tZWRpYWNvZGVjLmdpdGh1Yi5pby9hdjEtcnRwLXNwZWMvI2RlcGVuZGVuY3ktZGVzY3JpcHRvci1ydHAtaGVhZGVyLWV4dGVuc2lvbic7XG5cbmV4cG9ydCBmdW5jdGlvbiB1bnBhY2tTdHJlYW1JZChwYWNrZWQ6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgY29uc3QgcGFydHMgPSBwYWNrZWQuc3BsaXQoc2VwYXJhdG9yKTtcbiAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICByZXR1cm4gW3BhcnRzWzBdLCBwYWNrZWQuc3Vic3RyKHBhcnRzWzBdLmxlbmd0aCArIDEpXTtcbiAgfVxuICByZXR1cm4gW3BhY2tlZCwgJyddO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2xlZXAoZHVyYXRpb246IG51bWJlcik6IFByb21pc2U8dm9pZD4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IENyaXRpY2FsVGltZXJzLnNldFRpbWVvdXQocmVzb2x2ZSwgZHVyYXRpb24pKTtcbn1cblxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN1cHBvcnRzVHJhbnNjZWl2ZXIoKSB7XG4gIHJldHVybiAnYWRkVHJhbnNjZWl2ZXInIGluIFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZTtcbn1cblxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN1cHBvcnRzQWRkVHJhY2soKSB7XG4gIHJldHVybiAnYWRkVHJhY2snIGluIFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN1cHBvcnRzQWRhcHRpdmVTdHJlYW0oKSB7XG4gIHJldHVybiB0eXBlb2YgUmVzaXplT2JzZXJ2ZXIgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgIT09IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN1cHBvcnRzRHluYWNhc3QoKSB7XG4gIHJldHVybiBzdXBwb3J0c1RyYW5zY2VpdmVyKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdXBwb3J0c0FWMSgpOiBib29sZWFuIHtcbiAgaWYgKCEoJ2dldENhcGFiaWxpdGllcycgaW4gUlRDUnRwU2VuZGVyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoaXNTYWZhcmkoKSkge1xuICAgIC8vIFNhZmFyaSAxNyBvbiBpUGhvbmUxNCByZXBvcnRzIEFWMSBjYXBhYmlsaXR5LCBidXQgZG9lcyBub3QgYWN0dWFsbHkgc3VwcG9ydCBpdFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBjYXBhYmlsaXRpZXMgPSBSVENSdHBTZW5kZXIuZ2V0Q2FwYWJpbGl0aWVzKCd2aWRlbycpO1xuICBsZXQgaGFzQVYxID0gZmFsc2U7XG4gIGlmIChjYXBhYmlsaXRpZXMpIHtcbiAgICBmb3IgKGNvbnN0IGNvZGVjIG9mIGNhcGFiaWxpdGllcy5jb2RlY3MpIHtcbiAgICAgIGlmIChjb2RlYy5taW1lVHlwZSA9PT0gJ3ZpZGVvL0FWMScpIHtcbiAgICAgICAgaGFzQVYxID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBoYXNBVjE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdXBwb3J0c1ZQOSgpOiBib29sZWFuIHtcbiAgaWYgKCEoJ2dldENhcGFiaWxpdGllcycgaW4gUlRDUnRwU2VuZGVyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoaXNGaXJlRm94KCkpIHtcbiAgICAvLyB0ZWNobmljYWxseSBzcGVha2luZyBGaXJlRm94IHN1cHBvcnRzIFZQOSwgYnV0IFNWQyBwdWJsaXNoaW5nIGlzIGJyb2tlblxuICAgIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE2MzM4NzZcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGlzU2FmYXJpKCkpIHtcbiAgICBjb25zdCBicm93c2VyID0gZ2V0QnJvd3NlcigpO1xuICAgIGlmIChicm93c2VyPy52ZXJzaW9uICYmIGNvbXBhcmVWZXJzaW9ucyhicm93c2VyLnZlcnNpb24sICcxNicpIDwgMCkge1xuICAgICAgLy8gU2FmYXJpIDE2IGFuZCBiZWxvdyBkb2VzIG5vdCBzdXBwb3J0IFZQOVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBjb25zdCBjYXBhYmlsaXRpZXMgPSBSVENSdHBTZW5kZXIuZ2V0Q2FwYWJpbGl0aWVzKCd2aWRlbycpO1xuICBsZXQgaGFzVlA5ID0gZmFsc2U7XG4gIGlmIChjYXBhYmlsaXRpZXMpIHtcbiAgICBmb3IgKGNvbnN0IGNvZGVjIG9mIGNhcGFiaWxpdGllcy5jb2RlY3MpIHtcbiAgICAgIGlmIChjb2RlYy5taW1lVHlwZSA9PT0gJ3ZpZGVvL1ZQOScpIHtcbiAgICAgICAgaGFzVlA5ID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBoYXNWUDk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1NWQ0NvZGVjKGNvZGVjPzogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiBjb2RlYyA9PT0gJ2F2MScgfHwgY29kZWMgPT09ICd2cDknO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3VwcG9ydHNTZXRTaW5rSWQoZWxtPzogSFRNTE1lZGlhRWxlbWVudCk6IGJvb2xlYW4ge1xuICBpZiAoIWRvY3VtZW50KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghZWxtKSB7XG4gICAgZWxtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYXVkaW8nKTtcbiAgfVxuICByZXR1cm4gJ3NldFNpbmtJZCcgaW4gZWxtO1xufVxuXG5jb25zdCBzZXRDb2RlY1ByZWZlcmVuY2VzVmVyc2lvbnM6IFJlY29yZDxEZXRlY3RhYmxlQnJvd3Nlciwgc3RyaW5nPiA9IHtcbiAgQ2hyb21lOiAnMTAwJyxcbiAgU2FmYXJpOiAnMTUnLFxuICBGaXJlZm94OiAnMTAwJyxcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBzdXBwb3J0c1NldENvZGVjUHJlZmVyZW5jZXModHJhbnNjZWl2ZXI6IFJUQ1J0cFRyYW5zY2VpdmVyKTogYm9vbGVhbiB7XG4gIGlmICghaXNXZWIoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoISgnc2V0Q29kZWNQcmVmZXJlbmNlcycgaW4gdHJhbnNjZWl2ZXIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGJyb3dzZXIgPSBnZXRCcm93c2VyKCk7XG4gIGlmICghYnJvd3Nlcj8ubmFtZSB8fCAhYnJvd3Nlci52ZXJzaW9uKSB7XG4gICAgLy8gdmVyc2lvbiBpcyByZXF1aXJlZFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCB2ID0gc2V0Q29kZWNQcmVmZXJlbmNlc1ZlcnNpb25zW2Jyb3dzZXIubmFtZV07XG4gIGlmICh2KSB7XG4gICAgcmV0dXJuIGNvbXBhcmVWZXJzaW9ucyhicm93c2VyLnZlcnNpb24sIHYpID49IDA7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNCcm93c2VyU3VwcG9ydGVkKCkge1xuICByZXR1cm4gc3VwcG9ydHNUcmFuc2NlaXZlcigpIHx8IHN1cHBvcnRzQWRkVHJhY2soKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRmlyZUZveCgpOiBib29sZWFuIHtcbiAgcmV0dXJuIGdldEJyb3dzZXIoKT8ubmFtZSA9PT0gJ0ZpcmVmb3gnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNDaHJvbWl1bUJhc2VkKCk6IGJvb2xlYW4ge1xuICByZXR1cm4gZ2V0QnJvd3NlcigpPy5uYW1lID09PSAnQ2hyb21lJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU2FmYXJpKCk6IGJvb2xlYW4ge1xuICByZXR1cm4gZ2V0QnJvd3NlcigpPy5uYW1lID09PSAnU2FmYXJpJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU2FmYXJpMTcoKTogYm9vbGVhbiB7XG4gIGNvbnN0IGIgPSBnZXRCcm93c2VyKCk7XG4gIHJldHVybiBiPy5uYW1lID09PSAnU2FmYXJpJyAmJiBiLnZlcnNpb24uc3RhcnRzV2l0aCgnMTcuJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc01vYmlsZSgpOiBib29sZWFuIHtcbiAgaWYgKCFpc1dlYigpKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiAvVGFibGV0fGlQYWR8TW9iaWxlfEFuZHJvaWR8QmxhY2tCZXJyeS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzV2ViKCk6IGJvb2xlYW4ge1xuICByZXR1cm4gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUmVhY3ROYXRpdmUoKTogYm9vbGVhbiB7XG4gIC8vIG5hdmlnYXRvci5wcm9kdWN0IGlzIGRlcHJlY2F0ZWQgb24gYnJvd3NlcnMsIGJ1dCB3aWxsIGJlIHNldCBhcHByb3ByaWF0ZWx5IGZvciByZWFjdC1uYXRpdmUuXG4gIHJldHVybiBuYXZpZ2F0b3IucHJvZHVjdCA9PSAnUmVhY3ROYXRpdmUnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNDbG91ZChzZXJ2ZXJVcmw6IFVSTCkge1xuICByZXR1cm4gKFxuICAgIHNlcnZlclVybC5ob3N0bmFtZS5lbmRzV2l0aCgnLmxpdmVraXQuY2xvdWQnKSB8fCBzZXJ2ZXJVcmwuaG9zdG5hbWUuZW5kc1dpdGgoJy5saXZla2l0LnJ1bicpXG4gICk7XG59XG5cbmZ1bmN0aW9uIGdldExLUmVhY3ROYXRpdmVJbmZvKCk6IExpdmVLaXRSZWFjdE5hdGl2ZUluZm8gfCB1bmRlZmluZWQge1xuICAvLyBnbG9iYWwgZGVmaW5lZCBvbmx5IGZvciBSZWFjdE5hdGl2ZS5cbiAgLy8gQHRzLWlnbm9yZVxuICBpZiAoZ2xvYmFsICYmIGdsb2JhbC5MaXZlS2l0UmVhY3ROYXRpdmVHbG9iYWwpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuIGdsb2JhbC5MaXZlS2l0UmVhY3ROYXRpdmVHbG9iYWwgYXMgTGl2ZUtpdFJlYWN0TmF0aXZlSW5mbztcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSZWFjdE5hdGl2ZU9zKCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIGlmICghaXNSZWFjdE5hdGl2ZSgpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGxldCBpbmZvID0gZ2V0TEtSZWFjdE5hdGl2ZUluZm8oKTtcbiAgaWYgKGluZm8pIHtcbiAgICByZXR1cm4gaW5mby5wbGF0Zm9ybTtcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREZXZpY2VQaXhlbFJhdGlvKCk6IG51bWJlciB7XG4gIGlmIChpc1dlYigpKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICB9XG5cbiAgaWYgKGlzUmVhY3ROYXRpdmUoKSkge1xuICAgIGxldCBpbmZvID0gZ2V0TEtSZWFjdE5hdGl2ZUluZm8oKTtcbiAgICBpZiAoaW5mbykge1xuICAgICAgcmV0dXJuIGluZm8uZGV2aWNlUGl4ZWxSYXRpbztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVWZXJzaW9ucyh2MTogc3RyaW5nLCB2Mjogc3RyaW5nKTogbnVtYmVyIHtcbiAgY29uc3QgcGFydHMxID0gdjEuc3BsaXQoJy4nKTtcbiAgY29uc3QgcGFydHMyID0gdjIuc3BsaXQoJy4nKTtcbiAgY29uc3QgayA9IE1hdGgubWluKHBhcnRzMS5sZW5ndGgsIHBhcnRzMi5sZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGs7ICsraSkge1xuICAgIGNvbnN0IHAxID0gcGFyc2VJbnQocGFydHMxW2ldLCAxMCk7XG4gICAgY29uc3QgcDIgPSBwYXJzZUludChwYXJ0czJbaV0sIDEwKTtcbiAgICBpZiAocDEgPiBwMikgcmV0dXJuIDE7XG4gICAgaWYgKHAxIDwgcDIpIHJldHVybiAtMTtcbiAgICBpZiAoaSA9PT0gayAtIDEgJiYgcDEgPT09IHAyKSByZXR1cm4gMDtcbiAgfVxuICBpZiAodjEgPT09ICcnICYmIHYyICE9PSAnJykge1xuICAgIHJldHVybiAtMTtcbiAgfSBlbHNlIGlmICh2MiA9PT0gJycpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gcGFydHMxLmxlbmd0aCA9PSBwYXJ0czIubGVuZ3RoID8gMCA6IHBhcnRzMS5sZW5ndGggPCBwYXJ0czIubGVuZ3RoID8gLTEgOiAxO1xufVxuXG5mdW5jdGlvbiByb0Rpc3BhdGNoQ2FsbGJhY2soZW50cmllczogUmVzaXplT2JzZXJ2ZXJFbnRyeVtdKSB7XG4gIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgIChlbnRyeS50YXJnZXQgYXMgT2JzZXJ2YWJsZU1lZGlhRWxlbWVudCkuaGFuZGxlUmVzaXplKGVudHJ5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpb0Rpc3BhdGNoQ2FsbGJhY2soZW50cmllczogSW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeVtdKSB7XG4gIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgIChlbnRyeS50YXJnZXQgYXMgT2JzZXJ2YWJsZU1lZGlhRWxlbWVudCkuaGFuZGxlVmlzaWJpbGl0eUNoYW5nZWQoZW50cnkpO1xuICB9XG59XG5cbmxldCByZXNpemVPYnNlcnZlcjogUmVzaXplT2JzZXJ2ZXIgfCBudWxsID0gbnVsbDtcbmV4cG9ydCBjb25zdCBnZXRSZXNpemVPYnNlcnZlciA9ICgpID0+IHtcbiAgaWYgKCFyZXNpemVPYnNlcnZlcikgcmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIocm9EaXNwYXRjaENhbGxiYWNrKTtcbiAgcmV0dXJuIHJlc2l6ZU9ic2VydmVyO1xufTtcblxubGV0IGludGVyc2VjdGlvbk9ic2VydmVyOiBJbnRlcnNlY3Rpb25PYnNlcnZlciB8IG51bGwgPSBudWxsO1xuZXhwb3J0IGNvbnN0IGdldEludGVyc2VjdGlvbk9ic2VydmVyID0gKCkgPT4ge1xuICBpZiAoIWludGVyc2VjdGlvbk9ic2VydmVyKSB7XG4gICAgaW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoaW9EaXNwYXRjaENhbGxiYWNrLCB7XG4gICAgICByb290OiBudWxsLFxuICAgICAgcm9vdE1hcmdpbjogJzBweCcsXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGludGVyc2VjdGlvbk9ic2VydmVyO1xufTtcblxuZXhwb3J0IGludGVyZmFjZSBPYnNlcnZhYmxlTWVkaWFFbGVtZW50IGV4dGVuZHMgSFRNTE1lZGlhRWxlbWVudCB7XG4gIGhhbmRsZVJlc2l6ZTogKGVudHJ5OiBSZXNpemVPYnNlcnZlckVudHJ5KSA9PiB2b2lkO1xuICBoYW5kbGVWaXNpYmlsaXR5Q2hhbmdlZDogKGVudHJ5OiBJbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5KSA9PiB2b2lkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2xpZW50SW5mbygpOiBDbGllbnRJbmZvIHtcbiAgY29uc3QgaW5mbyA9IG5ldyBDbGllbnRJbmZvKHtcbiAgICBzZGs6IENsaWVudEluZm9fU0RLLkpTLFxuICAgIHByb3RvY29sOiBwcm90b2NvbFZlcnNpb24sXG4gICAgdmVyc2lvbixcbiAgfSk7XG5cbiAgaWYgKGlzUmVhY3ROYXRpdmUoKSkge1xuICAgIGluZm8ub3MgPSBnZXRSZWFjdE5hdGl2ZU9zKCkgPz8gJyc7XG4gIH1cbiAgcmV0dXJuIGluZm87XG59XG5cbmxldCBlbXB0eVZpZGVvU3RyZWFtVHJhY2s6IE1lZGlhU3RyZWFtVHJhY2sgfCB1bmRlZmluZWQ7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRFbXB0eVZpZGVvU3RyZWFtVHJhY2soKSB7XG4gIGlmICghZW1wdHlWaWRlb1N0cmVhbVRyYWNrKSB7XG4gICAgZW1wdHlWaWRlb1N0cmVhbVRyYWNrID0gY3JlYXRlRHVtbXlWaWRlb1N0cmVhbVRyYWNrKCk7XG4gIH1cbiAgcmV0dXJuIGVtcHR5VmlkZW9TdHJlYW1UcmFjay5jbG9uZSgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRHVtbXlWaWRlb1N0cmVhbVRyYWNrKFxuICB3aWR0aDogbnVtYmVyID0gMTYsXG4gIGhlaWdodDogbnVtYmVyID0gMTYsXG4gIGVuYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZSxcbiAgcGFpbnRDb250ZW50OiBib29sZWFuID0gZmFsc2UsXG4pIHtcbiAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gIC8vIHRoZSBjYW52YXMgc2l6ZSBpcyBzZXQgdG8gMTYgYnkgZGVmYXVsdCwgYmVjYXVzZSBlbGVjdHJvbiBhcHBzIHNlZW0gdG8gZmFpbCB3aXRoIHNtYWxsZXIgdmFsdWVzXG4gIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgY3R4Py5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICBpZiAocGFpbnRDb250ZW50ICYmIGN0eCkge1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHguYXJjKHdpZHRoIC8gMiwgaGVpZ2h0IC8gMiwgNTAsIDAsIE1hdGguUEkgKiAyLCB0cnVlKTtcbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgY3R4LmZpbGxTdHlsZSA9ICdncmV5JztcbiAgICBjdHguZmlsbCgpO1xuICB9XG4gIC8vIEB0cy1pZ25vcmVcbiAgY29uc3QgZHVtbXlTdHJlYW0gPSBjYW52YXMuY2FwdHVyZVN0cmVhbSgpO1xuICBjb25zdCBbZHVtbXlUcmFja10gPSBkdW1teVN0cmVhbS5nZXRUcmFja3MoKTtcbiAgaWYgKCFkdW1teVRyYWNrKSB7XG4gICAgdGhyb3cgRXJyb3IoJ0NvdWxkIG5vdCBnZXQgZW1wdHkgbWVkaWEgc3RyZWFtIHZpZGVvIHRyYWNrJyk7XG4gIH1cbiAgZHVtbXlUcmFjay5lbmFibGVkID0gZW5hYmxlZDtcblxuICByZXR1cm4gZHVtbXlUcmFjaztcbn1cblxubGV0IGVtcHR5QXVkaW9TdHJlYW1UcmFjazogTWVkaWFTdHJlYW1UcmFjayB8IHVuZGVmaW5lZDtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEVtcHR5QXVkaW9TdHJlYW1UcmFjaygpIHtcbiAgaWYgKCFlbXB0eUF1ZGlvU3RyZWFtVHJhY2spIHtcbiAgICAvLyBpbXBsZW1lbnRhdGlvbiBhZGFwdGVkIGZyb20gaHR0cHM6Ly9ibG9nLm1vemlsbGEub3JnL3dlYnJ0Yy93YXJtLXVwLXdpdGgtcmVwbGFjZXRyYWNrL1xuICAgIGNvbnN0IGN0eCA9IG5ldyBBdWRpb0NvbnRleHQoKTtcbiAgICBjb25zdCBvc2NpbGxhdG9yID0gY3R4LmNyZWF0ZU9zY2lsbGF0b3IoKTtcbiAgICBjb25zdCBnYWluID0gY3R4LmNyZWF0ZUdhaW4oKTtcbiAgICBnYWluLmdhaW4uc2V0VmFsdWVBdFRpbWUoMCwgMCk7XG4gICAgY29uc3QgZHN0ID0gY3R4LmNyZWF0ZU1lZGlhU3RyZWFtRGVzdGluYXRpb24oKTtcbiAgICBvc2NpbGxhdG9yLmNvbm5lY3QoZ2Fpbik7XG4gICAgZ2Fpbi5jb25uZWN0KGRzdCk7XG4gICAgb3NjaWxsYXRvci5zdGFydCgpO1xuICAgIFtlbXB0eUF1ZGlvU3RyZWFtVHJhY2tdID0gZHN0LnN0cmVhbS5nZXRBdWRpb1RyYWNrcygpO1xuICAgIGlmICghZW1wdHlBdWRpb1N0cmVhbVRyYWNrKSB7XG4gICAgICB0aHJvdyBFcnJvcignQ291bGQgbm90IGdldCBlbXB0eSBtZWRpYSBzdHJlYW0gYXVkaW8gdHJhY2snKTtcbiAgICB9XG4gICAgZW1wdHlBdWRpb1N0cmVhbVRyYWNrLmVuYWJsZWQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gZW1wdHlBdWRpb1N0cmVhbVRyYWNrLmNsb25lKCk7XG59XG5cbmV4cG9ydCBjbGFzcyBGdXR1cmU8VD4ge1xuICBwcm9taXNlOiBQcm9taXNlPFQ+O1xuXG4gIHJlc29sdmU/OiAoYXJnOiBUKSA9PiB2b2lkO1xuXG4gIHJlamVjdD86IChlOiBhbnkpID0+IHZvaWQ7XG5cbiAgb25GaW5hbGx5PzogKCkgPT4gdm9pZDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBmdXR1cmVCYXNlPzogKHJlc29sdmU6IChhcmc6IFQpID0+IHZvaWQsIHJlamVjdDogKGU6IGFueSkgPT4gdm9pZCkgPT4gdm9pZCxcbiAgICBvbkZpbmFsbHk/OiAoKSA9PiB2b2lkLFxuICApIHtcbiAgICB0aGlzLm9uRmluYWxseSA9IG9uRmluYWxseTtcbiAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZTxUPihhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgdGhpcy5yZWplY3QgPSByZWplY3Q7XG4gICAgICBpZiAoZnV0dXJlQmFzZSkge1xuICAgICAgICBhd2FpdCBmdXR1cmVCYXNlKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9XG4gICAgfSkuZmluYWxseSgoKSA9PiB0aGlzLm9uRmluYWxseT8uKCkpO1xuICB9XG59XG5cbmV4cG9ydCB0eXBlIEF1ZGlvQW5hbHlzZXJPcHRpb25zID0ge1xuICAvKipcbiAgICogSWYgc2V0IHRvIHRydWUsIHRoZSBhbmFseXNlciB3aWxsIHVzZSBhIGNsb25lZCB2ZXJzaW9uIG9mIHRoZSB1bmRlcmx5aW5nIG1lZGlhc3RyZWFtdHJhY2ssIHdoaWNoIHdvbid0IGJlIGltcGFjdGVkIGJ5IG11dGluZyB0aGUgdHJhY2suXG4gICAqIFVzZWZ1bCBmb3IgbG9jYWwgdHJhY2tzIHdoZW4gaW1wbGVtZW50aW5nIHRoaW5ncyBsaWtlIFwic2VlbXMgbGlrZSB5b3UncmUgbXV0ZWQsIGJ1dCB0cnlpbmcgdG8gc3BlYWtcIi5cbiAgICogRGVmYXVsdHMgdG8gZmFsc2VcbiAgICovXG4gIGNsb25lVHJhY2s/OiBib29sZWFuO1xuICAvKipcbiAgICogc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BbmFseXNlck5vZGUvZmZ0U2l6ZVxuICAgKi9cbiAgZmZ0U2l6ZT86IG51bWJlcjtcbiAgLyoqXG4gICAqIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQW5hbHlzZXJOb2RlL3Ntb290aGluZ1RpbWVDb25zdGFudFxuICAgKi9cbiAgc21vb3RoaW5nVGltZUNvbnN0YW50PzogbnVtYmVyO1xuICAvKipcbiAgICogc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BbmFseXNlck5vZGUvbWluRGVjaWJlbHNcbiAgICovXG4gIG1pbkRlY2liZWxzPzogbnVtYmVyO1xuICAvKipcbiAgICogc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BbmFseXNlck5vZGUvbWF4RGVjaWJlbHNcbiAgICovXG4gIG1heERlY2liZWxzPzogbnVtYmVyO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuZCByZXR1cm5zIGFuIGFuYWx5c2VyIHdlYiBhdWRpbyBub2RlIHRoYXQgaXMgYXR0YWNoZWQgdG8gdGhlIHByb3ZpZGVkIHRyYWNrLlxuICogQWRkaXRpb25hbGx5IHJldHVybnMgYSBjb252ZW5pZW5jZSBtZXRob2QgYGNhbGN1bGF0ZVZvbHVtZWAgdG8gcGVyZm9ybSBpbnN0YW50IHZvbHVtZSByZWFkaW5ncyBvbiB0aGF0IHRyYWNrLlxuICogQ2FsbCB0aGUgcmV0dXJuZWQgYGNsZWFudXBgIGZ1bmN0aW9uIHRvIGNsb3NlIHRoZSBhdWRpb0NvbnRleHQgdGhhdCBoYXMgYmVlbiBjcmVhdGVkIGZvciB0aGUgaW5zdGFuY2Ugb2YgdGhpcyBoZWxwZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUF1ZGlvQW5hbHlzZXIoXG4gIHRyYWNrOiBMb2NhbEF1ZGlvVHJhY2sgfCBSZW1vdGVBdWRpb1RyYWNrLFxuICBvcHRpb25zPzogQXVkaW9BbmFseXNlck9wdGlvbnMsXG4pIHtcbiAgY29uc3Qgb3B0cyA9IHtcbiAgICBjbG9uZVRyYWNrOiBmYWxzZSxcbiAgICBmZnRTaXplOiAyMDQ4LFxuICAgIHNtb290aGluZ1RpbWVDb25zdGFudDogMC44LFxuICAgIG1pbkRlY2liZWxzOiAtMTAwLFxuICAgIG1heERlY2liZWxzOiAtODAsXG4gICAgLi4ub3B0aW9ucyxcbiAgfTtcbiAgY29uc3QgYXVkaW9Db250ZXh0ID0gZ2V0TmV3QXVkaW9Db250ZXh0KCk7XG5cbiAgaWYgKCFhdWRpb0NvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0F1ZGlvIENvbnRleHQgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGJyb3dzZXInKTtcbiAgfVxuICBjb25zdCBzdHJlYW1UcmFjayA9IG9wdHMuY2xvbmVUcmFjayA/IHRyYWNrLm1lZGlhU3RyZWFtVHJhY2suY2xvbmUoKSA6IHRyYWNrLm1lZGlhU3RyZWFtVHJhY2s7XG4gIGNvbnN0IG1lZGlhU3RyZWFtU291cmNlID0gYXVkaW9Db250ZXh0LmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKG5ldyBNZWRpYVN0cmVhbShbc3RyZWFtVHJhY2tdKSk7XG4gIGNvbnN0IGFuYWx5c2VyID0gYXVkaW9Db250ZXh0LmNyZWF0ZUFuYWx5c2VyKCk7XG4gIGFuYWx5c2VyLm1pbkRlY2liZWxzID0gb3B0cy5taW5EZWNpYmVscztcbiAgYW5hbHlzZXIubWF4RGVjaWJlbHMgPSBvcHRzLm1heERlY2liZWxzO1xuICBhbmFseXNlci5mZnRTaXplID0gb3B0cy5mZnRTaXplO1xuICBhbmFseXNlci5zbW9vdGhpbmdUaW1lQ29uc3RhbnQgPSBvcHRzLnNtb290aGluZ1RpbWVDb25zdGFudDtcblxuICBtZWRpYVN0cmVhbVNvdXJjZS5jb25uZWN0KGFuYWx5c2VyKTtcbiAgY29uc3QgZGF0YUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYW5hbHlzZXIuZnJlcXVlbmN5QmluQ291bnQpO1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBjdXJyZW50IHZvbHVtZSBvZiB0aGUgdHJhY2sgaW4gdGhlIHJhbmdlIGZyb20gMCB0byAxXG4gICAqL1xuICBjb25zdCBjYWxjdWxhdGVWb2x1bWUgPSAoKSA9PiB7XG4gICAgYW5hbHlzZXIuZ2V0Qnl0ZUZyZXF1ZW5jeURhdGEoZGF0YUFycmF5KTtcbiAgICBsZXQgc3VtID0gMDtcbiAgICBmb3IgKGNvbnN0IGFtcGxpdHVkZSBvZiBkYXRhQXJyYXkpIHtcbiAgICAgIHN1bSArPSBNYXRoLnBvdyhhbXBsaXR1ZGUgLyAyNTUsIDIpO1xuICAgIH1cbiAgICBjb25zdCB2b2x1bWUgPSBNYXRoLnNxcnQoc3VtIC8gZGF0YUFycmF5Lmxlbmd0aCk7XG4gICAgcmV0dXJuIHZvbHVtZTtcbiAgfTtcblxuICBjb25zdCBjbGVhbnVwID0gYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IGF1ZGlvQ29udGV4dC5jbG9zZSgpO1xuICAgIGlmIChvcHRzLmNsb25lVHJhY2spIHtcbiAgICAgIHN0cmVhbVRyYWNrLnN0b3AoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHsgY2FsY3VsYXRlVm9sdW1lLCBhbmFseXNlciwgY2xlYW51cCB9O1xufVxuXG5leHBvcnQgY2xhc3MgTXV0ZXgge1xuICBwcml2YXRlIF9sb2NraW5nOiBQcm9taXNlPHZvaWQ+O1xuXG4gIHByaXZhdGUgX2xvY2tzOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fbG9ja2luZyA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIHRoaXMuX2xvY2tzID0gMDtcbiAgfVxuXG4gIGlzTG9ja2VkKCkge1xuICAgIHJldHVybiB0aGlzLl9sb2NrcyA+IDA7XG4gIH1cblxuICBsb2NrKCkge1xuICAgIHRoaXMuX2xvY2tzICs9IDE7XG5cbiAgICBsZXQgdW5sb2NrTmV4dDogKCkgPT4gdm9pZDtcblxuICAgIGNvbnN0IHdpbGxMb2NrID0gbmV3IFByb21pc2U8dm9pZD4oXG4gICAgICAocmVzb2x2ZSkgPT5cbiAgICAgICAgKHVubG9ja05leHQgPSAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fbG9ja3MgLT0gMTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pLFxuICAgICk7XG5cbiAgICBjb25zdCB3aWxsVW5sb2NrID0gdGhpcy5fbG9ja2luZy50aGVuKCgpID0+IHVubG9ja05leHQpO1xuXG4gICAgdGhpcy5fbG9ja2luZyA9IHRoaXMuX2xvY2tpbmcudGhlbigoKSA9PiB3aWxsTG9jayk7XG5cbiAgICByZXR1cm4gd2lsbFVubG9jaztcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNWaWRlb0NvZGVjKG1heWJlQ29kZWM6IHN0cmluZyk6IG1heWJlQ29kZWMgaXMgVmlkZW9Db2RlYyB7XG4gIHJldHVybiB2aWRlb0NvZGVjcy5pbmNsdWRlcyhtYXliZUNvZGVjIGFzIFZpZGVvQ29kZWMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdW53cmFwQ29uc3RyYWludChjb25zdHJhaW50OiBDb25zdHJhaW5ET01TdHJpbmcpOiBzdHJpbmcge1xuICBpZiAodHlwZW9mIGNvbnN0cmFpbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGNvbnN0cmFpbnQ7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShjb25zdHJhaW50KSkge1xuICAgIHJldHVybiBjb25zdHJhaW50WzBdO1xuICB9XG4gIGlmIChjb25zdHJhaW50LmV4YWN0KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29uc3RyYWludC5leGFjdCkpIHtcbiAgICAgIHJldHVybiBjb25zdHJhaW50LmV4YWN0WzBdO1xuICAgIH1cbiAgICByZXR1cm4gY29uc3RyYWludC5leGFjdDtcbiAgfVxuICBpZiAoY29uc3RyYWludC5pZGVhbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNvbnN0cmFpbnQuaWRlYWwpKSB7XG4gICAgICByZXR1cm4gY29uc3RyYWludC5pZGVhbFswXTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnN0cmFpbnQuaWRlYWw7XG4gIH1cbiAgdGhyb3cgRXJyb3IoJ2NvdWxkIG5vdCB1bndyYXAgY29uc3RyYWludCcpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9XZWJzb2NrZXRVcmwodXJsOiBzdHJpbmcpOiBzdHJpbmcge1xuICBpZiAodXJsLnN0YXJ0c1dpdGgoJ2h0dHAnKSkge1xuICAgIHJldHVybiB1cmwucmVwbGFjZSgvXihodHRwKS8sICd3cycpO1xuICB9XG4gIHJldHVybiB1cmw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b0h0dHBVcmwodXJsOiBzdHJpbmcpOiBzdHJpbmcge1xuICBpZiAodXJsLnN0YXJ0c1dpdGgoJ3dzJykpIHtcbiAgICByZXR1cm4gdXJsLnJlcGxhY2UoL14od3MpLywgJ2h0dHAnKTtcbiAgfVxuICByZXR1cm4gdXJsO1xufVxuIiwiaW1wb3J0IGxvZyBmcm9tICcuLi9sb2dnZXInO1xuaW1wb3J0IHsgaXNTYWZhcmkgfSBmcm9tICcuL3V0aWxzJztcblxuY29uc3QgZGVmYXVsdElkID0gJ2RlZmF1bHQnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZXZpY2VNYW5hZ2VyIHtcbiAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2U/OiBEZXZpY2VNYW5hZ2VyO1xuXG4gIHN0YXRpYyBtZWRpYURldmljZUtpbmRzOiBNZWRpYURldmljZUtpbmRbXSA9IFsnYXVkaW9pbnB1dCcsICdhdWRpb291dHB1dCcsICd2aWRlb2lucHV0J107XG5cbiAgc3RhdGljIGdldEluc3RhbmNlKCk6IERldmljZU1hbmFnZXIge1xuICAgIGlmICh0aGlzLmluc3RhbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuaW5zdGFuY2UgPSBuZXcgRGV2aWNlTWFuYWdlcigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5pbnN0YW5jZTtcbiAgfVxuXG4gIHN0YXRpYyB1c2VyTWVkaWFQcm9taXNlTWFwOiBNYXA8TWVkaWFEZXZpY2VLaW5kLCBQcm9taXNlPE1lZGlhU3RyZWFtPj4gPSBuZXcgTWFwKCk7XG5cbiAgYXN5bmMgZ2V0RGV2aWNlcyhcbiAgICBraW5kPzogTWVkaWFEZXZpY2VLaW5kLFxuICAgIHJlcXVlc3RQZXJtaXNzaW9uczogYm9vbGVhbiA9IHRydWUsXG4gICk6IFByb21pc2U8TWVkaWFEZXZpY2VJbmZvW10+IHtcbiAgICBpZiAoRGV2aWNlTWFuYWdlci51c2VyTWVkaWFQcm9taXNlTWFwPy5zaXplID4gMCkge1xuICAgICAgbG9nLmRlYnVnKCdhd2FpdGluZyBnZXRVc2VyTWVkaWEgcHJvbWlzZScpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGtpbmQpIHtcbiAgICAgICAgICBhd2FpdCBEZXZpY2VNYW5hZ2VyLnVzZXJNZWRpYVByb21pc2VNYXAuZ2V0KGtpbmQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKERldmljZU1hbmFnZXIudXNlck1lZGlhUHJvbWlzZU1hcC52YWx1ZXMoKSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgICBsb2cud2FybignZXJyb3Igd2FpdGluZyBmb3IgbWVkaWEgcGVybWlzc29ucycpO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgZGV2aWNlcyA9IGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcygpO1xuXG4gICAgaWYgKFxuICAgICAgcmVxdWVzdFBlcm1pc3Npb25zICYmXG4gICAgICAvLyBmb3Igc2FmYXJpIHdlIG5lZWQgdG8gc2tpcCB0aGlzIGNoZWNrLCBhcyBvdGhlcndpc2UgaXQgd2lsbCByZS1hY3F1aXJlIHVzZXIgbWVkaWEgYW5kIGZhaWwgb24gaU9TIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNzkzNjNcbiAgICAgICEoaXNTYWZhcmkoKSAmJiB0aGlzLmhhc0RldmljZUluVXNlKGtpbmQpKVxuICAgICkge1xuICAgICAgY29uc3QgaXNEdW1teURldmljZU9yRW1wdHkgPVxuICAgICAgICBkZXZpY2VzLmxlbmd0aCA9PT0gMCB8fFxuICAgICAgICBkZXZpY2VzLnNvbWUoKGRldmljZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IG5vTGFiZWwgPSBkZXZpY2UubGFiZWwgPT09ICcnO1xuICAgICAgICAgIGNvbnN0IGlzUmVsZXZhbnQgPSBraW5kID8gZGV2aWNlLmtpbmQgPT09IGtpbmQgOiB0cnVlO1xuICAgICAgICAgIHJldHVybiBub0xhYmVsICYmIGlzUmVsZXZhbnQ7XG4gICAgICAgIH0pO1xuXG4gICAgICBpZiAoaXNEdW1teURldmljZU9yRW1wdHkpIHtcbiAgICAgICAgY29uc3QgcGVybWlzc2lvbnNUb0FjcXVpcmUgPSB7XG4gICAgICAgICAgdmlkZW86IGtpbmQgIT09ICdhdWRpb2lucHV0JyAmJiBraW5kICE9PSAnYXVkaW9vdXRwdXQnLFxuICAgICAgICAgIGF1ZGlvOiBraW5kICE9PSAndmlkZW9pbnB1dCcsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHBlcm1pc3Npb25zVG9BY3F1aXJlKTtcbiAgICAgICAgZGV2aWNlcyA9IGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcygpO1xuICAgICAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCgodHJhY2spID0+IHtcbiAgICAgICAgICB0cmFjay5zdG9wKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoa2luZCkge1xuICAgICAgZGV2aWNlcyA9IGRldmljZXMuZmlsdGVyKChkZXZpY2UpID0+IGRldmljZS5raW5kID09PSBraW5kKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGV2aWNlcztcbiAgfVxuXG4gIGFzeW5jIG5vcm1hbGl6ZURldmljZUlkKFxuICAgIGtpbmQ6IE1lZGlhRGV2aWNlS2luZCxcbiAgICBkZXZpY2VJZD86IHN0cmluZyxcbiAgICBncm91cElkPzogc3RyaW5nLFxuICApOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xuICAgIGlmIChkZXZpY2VJZCAhPT0gZGVmYXVsdElkKSB7XG4gICAgICByZXR1cm4gZGV2aWNlSWQ7XG4gICAgfVxuXG4gICAgLy8gcmVzb2x2ZSBhY3R1YWwgZGV2aWNlIGlkIGlmIGl0J3MgJ2RlZmF1bHQnOiBDaHJvbWUgcmV0dXJucyBpdCB3aGVuIG5vXG4gICAgLy8gZGV2aWNlIGhhcyBiZWVuIGNob3NlblxuICAgIGNvbnN0IGRldmljZXMgPSBhd2FpdCB0aGlzLmdldERldmljZXMoa2luZCk7XG5cbiAgICBjb25zdCBkZXZpY2UgPSBkZXZpY2VzLmZpbmQoKGQpID0+IGQuZ3JvdXBJZCA9PT0gZ3JvdXBJZCAmJiBkLmRldmljZUlkICE9PSBkZWZhdWx0SWQpO1xuXG4gICAgcmV0dXJuIGRldmljZT8uZGV2aWNlSWQ7XG4gIH1cblxuICBwcml2YXRlIGhhc0RldmljZUluVXNlKGtpbmQ/OiBNZWRpYURldmljZUtpbmQpOiBib29sZWFuIHtcbiAgICByZXR1cm4ga2luZFxuICAgICAgPyBEZXZpY2VNYW5hZ2VyLnVzZXJNZWRpYVByb21pc2VNYXAuaGFzKGtpbmQpXG4gICAgICA6IERldmljZU1hbmFnZXIudXNlck1lZGlhUHJvbWlzZU1hcC5zaXplID4gMDtcbiAgfVxufVxuIiwiaW1wb3J0IHsgZGVib3VuY2UgfSBmcm9tICd0cy1kZWJvdW5jZSc7XG5pbXBvcnQgeyBnZXRCcm93c2VyIH0gZnJvbSAnLi4vLi4vdXRpbHMvYnJvd3NlclBhcnNlcic7XG5pbXBvcnQgRGV2aWNlTWFuYWdlciBmcm9tICcuLi9EZXZpY2VNYW5hZ2VyJztcbmltcG9ydCB7IERldmljZVVuc3VwcG9ydGVkRXJyb3IsIFRyYWNrSW52YWxpZEVycm9yIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IFRyYWNrRXZlbnQgfSBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IHR5cGUgeyBMb2dnZXJPcHRpb25zIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgTXV0ZXgsIGNvbXBhcmVWZXJzaW9ucywgaXNNb2JpbGUsIHNsZWVwIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgVHJhY2ssIGF0dGFjaFRvRWxlbWVudCwgZGV0YWNoVHJhY2sgfSBmcm9tICcuL1RyYWNrJztcbmltcG9ydCB0eXBlIHsgVmlkZW9Db2RlYyB9IGZyb20gJy4vb3B0aW9ucyc7XG5pbXBvcnQgdHlwZSB7IFRyYWNrUHJvY2Vzc29yIH0gZnJvbSAnLi9wcm9jZXNzb3IvdHlwZXMnO1xuXG5jb25zdCBkZWZhdWx0RGltZW5zaW9uc1RpbWVvdXQgPSAxMDAwO1xuXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBMb2NhbFRyYWNrIGV4dGVuZHMgVHJhY2sge1xuICAvKiogQGludGVybmFsICovXG4gIHNlbmRlcj86IFJUQ1J0cFNlbmRlcjtcblxuICAvKiogQGludGVybmFsICovXG4gIGNvZGVjPzogVmlkZW9Db2RlYztcblxuICBnZXQgY29uc3RyYWludHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnN0cmFpbnRzO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9jb25zdHJhaW50czogTWVkaWFUcmFja0NvbnN0cmFpbnRzO1xuXG4gIHByb3RlY3RlZCByZWFjcXVpcmVUcmFjazogYm9vbGVhbjtcblxuICBwcm90ZWN0ZWQgcHJvdmlkZWRCeVVzZXI6IGJvb2xlYW47XG5cbiAgcHJvdGVjdGVkIG11dGVMb2NrOiBNdXRleDtcblxuICBwcm90ZWN0ZWQgcGF1c2VVcHN0cmVhbUxvY2s6IE11dGV4O1xuXG4gIHByb3RlY3RlZCBwcm9jZXNzb3JFbGVtZW50PzogSFRNTE1lZGlhRWxlbWVudDtcblxuICBwcm90ZWN0ZWQgcHJvY2Vzc29yPzogVHJhY2tQcm9jZXNzb3I8dGhpc1sna2luZCddPjtcblxuICBwcm90ZWN0ZWQgcHJvY2Vzc29yTG9jazogTXV0ZXg7XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSBtZWRpYVRyYWNrXG4gICAqIEBwYXJhbSBraW5kXG4gICAqIEBwYXJhbSBjb25zdHJhaW50cyBNZWRpYVRyYWNrQ29uc3RyYWludHMgdGhhdCBhcmUgYmVpbmcgdXNlZCB3aGVuIHJlc3RhcnRpbmcgb3IgcmVhY3F1aXJpbmcgdHJhY2tzXG4gICAqIEBwYXJhbSB1c2VyUHJvdmlkZWRUcmFjayBTaWduYWxzIHRvIHRoZSBTREsgd2hldGhlciBvciBub3QgdGhlIG1lZGlhVHJhY2sgc2hvdWxkIGJlIG1hbmFnZWQgKGkuZS4gcmVsZWFzZWQgYW5kIHJlYWNxdWlyZWQpIGludGVybmFsbHkgYnkgdGhlIFNES1xuICAgKi9cbiAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKFxuICAgIG1lZGlhVHJhY2s6IE1lZGlhU3RyZWFtVHJhY2ssXG4gICAga2luZDogVHJhY2suS2luZCxcbiAgICBjb25zdHJhaW50cz86IE1lZGlhVHJhY2tDb25zdHJhaW50cyxcbiAgICB1c2VyUHJvdmlkZWRUcmFjayA9IGZhbHNlLFxuICAgIGxvZ2dlck9wdGlvbnM/OiBMb2dnZXJPcHRpb25zLFxuICApIHtcbiAgICBzdXBlcihtZWRpYVRyYWNrLCBraW5kLCBsb2dnZXJPcHRpb25zKTtcbiAgICB0aGlzLnJlYWNxdWlyZVRyYWNrID0gZmFsc2U7XG4gICAgdGhpcy5wcm92aWRlZEJ5VXNlciA9IHVzZXJQcm92aWRlZFRyYWNrO1xuICAgIHRoaXMubXV0ZUxvY2sgPSBuZXcgTXV0ZXgoKTtcbiAgICB0aGlzLnBhdXNlVXBzdHJlYW1Mb2NrID0gbmV3IE11dGV4KCk7XG4gICAgdGhpcy5wcm9jZXNzb3JMb2NrID0gbmV3IE11dGV4KCk7XG4gICAgdGhpcy5zZXRNZWRpYVN0cmVhbVRyYWNrKG1lZGlhVHJhY2ssIHRydWUpO1xuXG4gICAgLy8gYWRkZWQgdG8gc2F0aXNmeSBUUyBjb21waWxlciwgY29uc3RyYWludHMgYXJlIHN5bmNlZCB3aXRoIE1lZGlhU3RyZWFtVHJhY2tcbiAgICB0aGlzLl9jb25zdHJhaW50cyA9IG1lZGlhVHJhY2suZ2V0Q29uc3RyYWludHMoKTtcbiAgICBpZiAoY29uc3RyYWludHMpIHtcbiAgICAgIHRoaXMuX2NvbnN0cmFpbnRzID0gY29uc3RyYWludHM7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGlkKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suaWQ7XG4gIH1cblxuICBnZXQgZGltZW5zaW9ucygpOiBUcmFjay5EaW1lbnNpb25zIHwgdW5kZWZpbmVkIHtcbiAgICBpZiAodGhpcy5raW5kICE9PSBUcmFjay5LaW5kLlZpZGVvKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5nZXRTZXR0aW5ncygpO1xuICAgIGlmICh3aWR0aCAmJiBoZWlnaHQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgcHJpdmF0ZSBfaXNVcHN0cmVhbVBhdXNlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIGdldCBpc1Vwc3RyZWFtUGF1c2VkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1Vwc3RyZWFtUGF1c2VkO1xuICB9XG5cbiAgZ2V0IGlzVXNlclByb3ZpZGVkKCkge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVkQnlVc2VyO1xuICB9XG5cbiAgZ2V0IG1lZGlhU3RyZWFtVHJhY2soKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvY2Vzc29yPy5wcm9jZXNzZWRUcmFjayA/PyB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBzZXRNZWRpYVN0cmVhbVRyYWNrKG5ld1RyYWNrOiBNZWRpYVN0cmVhbVRyYWNrLCBmb3JjZT86IGJvb2xlYW4pIHtcbiAgICBpZiAobmV3VHJhY2sgPT09IHRoaXMuX21lZGlhU3RyZWFtVHJhY2sgJiYgIWZvcmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9tZWRpYVN0cmVhbVRyYWNrKSB7XG4gICAgICAvLyBkZXRhY2hcbiAgICAgIHRoaXMuYXR0YWNoZWRFbGVtZW50cy5mb3JFYWNoKChlbCkgPT4ge1xuICAgICAgICBkZXRhY2hUcmFjayh0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLCBlbCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZGVib3VuY2VkVHJhY2tNdXRlSGFuZGxlci5jYW5jZWwoJ25ldy10cmFjaycpO1xuICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMuaGFuZGxlRW5kZWQpO1xuICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCdtdXRlJywgdGhpcy5oYW5kbGVUcmFja011dGVFdmVudCk7XG4gICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3VubXV0ZScsIHRoaXMuaGFuZGxlVHJhY2tVbm11dGVFdmVudCk7XG4gICAgfVxuXG4gICAgdGhpcy5tZWRpYVN0cmVhbSA9IG5ldyBNZWRpYVN0cmVhbShbbmV3VHJhY2tdKTtcbiAgICBpZiAobmV3VHJhY2spIHtcbiAgICAgIG5ld1RyYWNrLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgdGhpcy5oYW5kbGVFbmRlZCk7XG4gICAgICAvLyB3aGVuIHVuZGVybHlpbmcgdHJhY2sgZW1pdHMgbXV0ZSwgaXQgaW5kaWNhdGVzIHRoYXQgdGhlIGRldmljZSBpcyB1bmFibGVcbiAgICAgIC8vIHRvIHByb2R1Y2UgbWVkaWEuIEluIHRoaXMgY2FzZSB3ZSdsbCBuZWVkIHRvIHNpZ25hbCB3aXRoIHJlbW90ZSB0aGF0XG4gICAgICAvLyB0aGUgdHJhY2sgaXMgXCJtdXRlZFwiXG4gICAgICAvLyBub3RlIHRoaXMgaXMgZGlmZmVyZW50IGZyb20gTG9jYWxUcmFjay5tdXRlIGJlY2F1c2Ugd2UgZG8gbm90IHdhbnQgdG9cbiAgICAgIC8vIHRvdWNoIE1lZGlhU3RyZWFtVHJhY2suZW5hYmxlZFxuICAgICAgbmV3VHJhY2suYWRkRXZlbnRMaXN0ZW5lcignbXV0ZScsIHRoaXMuaGFuZGxlVHJhY2tNdXRlRXZlbnQpO1xuICAgICAgbmV3VHJhY2suYWRkRXZlbnRMaXN0ZW5lcigndW5tdXRlJywgdGhpcy5oYW5kbGVUcmFja1VubXV0ZUV2ZW50KTtcbiAgICAgIHRoaXMuX2NvbnN0cmFpbnRzID0gbmV3VHJhY2suZ2V0Q29uc3RyYWludHMoKTtcbiAgICB9XG4gICAgbGV0IHByb2Nlc3NlZFRyYWNrOiBNZWRpYVN0cmVhbVRyYWNrIHwgdW5kZWZpbmVkO1xuICAgIGlmICh0aGlzLnByb2Nlc3NvciAmJiBuZXdUcmFjayAmJiB0aGlzLnByb2Nlc3NvckVsZW1lbnQpIHtcbiAgICAgIHRoaXMubG9nLmRlYnVnKCdyZXN0YXJ0aW5nIHByb2Nlc3NvcicsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICBpZiAodGhpcy5raW5kID09PSAndW5rbm93bicpIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdjYW5ub3Qgc2V0IHByb2Nlc3NvciBvbiB0cmFjayBvZiB1bmtub3duIGtpbmQnKTtcbiAgICAgIH1cblxuICAgICAgYXR0YWNoVG9FbGVtZW50KG5ld1RyYWNrLCB0aGlzLnByb2Nlc3NvckVsZW1lbnQpO1xuICAgICAgLy8gZW5zdXJlIHRoZSBwcm9jZXNzb3JFbGVtZW50IGl0c2VsZiBzdGF5cyBtdXRlZFxuICAgICAgdGhpcy5wcm9jZXNzb3JFbGVtZW50Lm11dGVkID0gdHJ1ZTtcbiAgICAgIGF3YWl0IHRoaXMucHJvY2Vzc29yLnJlc3RhcnQoe1xuICAgICAgICB0cmFjazogbmV3VHJhY2ssXG4gICAgICAgIGtpbmQ6IHRoaXMua2luZCxcbiAgICAgICAgZWxlbWVudDogdGhpcy5wcm9jZXNzb3JFbGVtZW50LFxuICAgICAgfSk7XG4gICAgICBwcm9jZXNzZWRUcmFjayA9IHRoaXMucHJvY2Vzc29yLnByb2Nlc3NlZFRyYWNrO1xuICAgIH1cbiAgICBpZiAodGhpcy5zZW5kZXIpIHtcbiAgICAgIGF3YWl0IHRoaXMuc2VuZGVyLnJlcGxhY2VUcmFjayhwcm9jZXNzZWRUcmFjayA/PyBuZXdUcmFjayk7XG4gICAgfVxuICAgIC8vIGlmIGBuZXdUcmFja2AgaXMgZGlmZmVyZW50IGZyb20gdGhlIGV4aXN0aW5nIHRyYWNrLCBzdG9wIHRoZVxuICAgIC8vIG9sZGVyIHRyYWNrIGp1c3QgYmVmb3JlIHJlcGxhY2luZyBpdFxuICAgIGlmICghdGhpcy5wcm92aWRlZEJ5VXNlciAmJiB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrICE9PSBuZXdUcmFjaykge1xuICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5zdG9wKCk7XG4gICAgfVxuICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2sgPSBuZXdUcmFjaztcbiAgICBpZiAobmV3VHJhY2spIHtcbiAgICAgIC8vIHN5bmMgbXV0ZWQgc3RhdGUgd2l0aCB0aGUgZW5hYmxlZCBzdGF0ZSBvZiB0aGUgbmV3bHkgcHJvdmlkZWQgdHJhY2tcbiAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suZW5hYmxlZCA9ICF0aGlzLmlzTXV0ZWQ7XG4gICAgICAvLyB3aGVuIGEgdmFsaWQgdHJhY2sgaXMgcmVwbGFjZSwgd2UnZCB3YW50IHRvIHN0YXJ0IHByb2R1Y2luZ1xuICAgICAgYXdhaXQgdGhpcy5yZXN1bWVVcHN0cmVhbSgpO1xuICAgICAgdGhpcy5hdHRhY2hlZEVsZW1lbnRzLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICAgIGF0dGFjaFRvRWxlbWVudChwcm9jZXNzZWRUcmFjayA/PyBuZXdUcmFjaywgZWwpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgd2FpdEZvckRpbWVuc2lvbnModGltZW91dCA9IGRlZmF1bHREaW1lbnNpb25zVGltZW91dCk6IFByb21pc2U8VHJhY2suRGltZW5zaW9ucz4ge1xuICAgIGlmICh0aGlzLmtpbmQgPT09IFRyYWNrLktpbmQuQXVkaW8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IGdldCBkaW1lbnNpb25zIGZvciBhdWRpbyB0cmFja3MnKTtcbiAgICB9XG5cbiAgICBpZiAoZ2V0QnJvd3NlcigpPy5vcyA9PT0gJ2lPUycpIHtcbiAgICAgIC8vIGJyb3dzZXJzIHJlcG9ydCB3cm9uZyBpbml0aWFsIHJlc29sdXRpb24gb24gaU9TLlxuICAgICAgLy8gd2hlbiBzbGlnaHRseSBkZWxheWluZyB0aGUgY2FsbCB0byAuZ2V0U2V0dGluZ3MoKSwgdGhlIGNvcnJlY3QgcmVzb2x1dGlvbiBpcyBiZWluZyByZXBvcnRlZFxuICAgICAgYXdhaXQgc2xlZXAoMTApO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXJ0ZWQgPSBEYXRlLm5vdygpO1xuICAgIHdoaWxlIChEYXRlLm5vdygpIC0gc3RhcnRlZCA8IHRpbWVvdXQpIHtcbiAgICAgIGNvbnN0IGRpbXMgPSB0aGlzLmRpbWVuc2lvbnM7XG4gICAgICBpZiAoZGltcykge1xuICAgICAgICByZXR1cm4gZGltcztcbiAgICAgIH1cbiAgICAgIGF3YWl0IHNsZWVwKDUwKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFRyYWNrSW52YWxpZEVycm9yKCd1bmFibGUgdG8gZ2V0IHRyYWNrIGRpbWVuc2lvbnMgYWZ0ZXIgdGltZW91dCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIERldmljZUlEIG9mIHRoZSBkZXZpY2UgdGhhdCBpcyBjdXJyZW50bHkgYmVpbmcgdXNlZCBmb3IgdGhpcyB0cmFja1xuICAgKi9cbiAgYXN5bmMgZ2V0RGV2aWNlSWQoKTogUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+IHtcbiAgICAvLyBzY3JlZW4gc2hhcmUgZG9lc24ndCBoYXZlIGEgdXNhYmxlIGRldmljZSBpZFxuICAgIGlmICh0aGlzLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgZGV2aWNlSWQsIGdyb3VwSWQgfSA9IHRoaXMuX21lZGlhU3RyZWFtVHJhY2suZ2V0U2V0dGluZ3MoKTtcbiAgICBjb25zdCBraW5kID0gdGhpcy5raW5kID09PSBUcmFjay5LaW5kLkF1ZGlvID8gJ2F1ZGlvaW5wdXQnIDogJ3ZpZGVvaW5wdXQnO1xuXG4gICAgcmV0dXJuIERldmljZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKS5ub3JtYWxpemVEZXZpY2VJZChraW5kLCBkZXZpY2VJZCwgZ3JvdXBJZCk7XG4gIH1cblxuICBhc3luYyBtdXRlKCk6IFByb21pc2U8TG9jYWxUcmFjaz4ge1xuICAgIHRoaXMuc2V0VHJhY2tNdXRlZCh0cnVlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGFzeW5jIHVubXV0ZSgpOiBQcm9taXNlPExvY2FsVHJhY2s+IHtcbiAgICB0aGlzLnNldFRyYWNrTXV0ZWQoZmFsc2UpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgYXN5bmMgcmVwbGFjZVRyYWNrKHRyYWNrOiBNZWRpYVN0cmVhbVRyYWNrLCB1c2VyUHJvdmlkZWRUcmFjayA9IHRydWUpOiBQcm9taXNlPExvY2FsVHJhY2s+IHtcbiAgICBpZiAoIXRoaXMuc2VuZGVyKSB7XG4gICAgICB0aHJvdyBuZXcgVHJhY2tJbnZhbGlkRXJyb3IoJ3VuYWJsZSB0byByZXBsYWNlIGFuIHVucHVibGlzaGVkIHRyYWNrJyk7XG4gICAgfVxuXG4gICAgdGhpcy5sb2cuZGVidWcoJ3JlcGxhY2UgTWVkaWFTdHJlYW1UcmFjaycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgYXdhaXQgdGhpcy5zZXRNZWRpYVN0cmVhbVRyYWNrKHRyYWNrKTtcbiAgICAvLyB0aGlzIG11c3QgYmUgc3luY2VkICphZnRlciogc2V0dGluZyBtZWRpYVN0cmVhbVRyYWNrIGFib3ZlLCBzaW5jZSBpdCByZWxpZXNcbiAgICAvLyBvbiB0aGUgcHJldmlvdXMgc3RhdGUgaW4gb3JkZXIgdG8gY2xlYW51cFxuICAgIHRoaXMucHJvdmlkZWRCeVVzZXIgPSB1c2VyUHJvdmlkZWRUcmFjaztcblxuICAgIGlmICh0aGlzLnByb2Nlc3Nvcikge1xuICAgICAgYXdhaXQgdGhpcy5zdG9wUHJvY2Vzc29yKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcHJvdGVjdGVkIGFzeW5jIHJlc3RhcnQoY29uc3RyYWludHM/OiBNZWRpYVRyYWNrQ29uc3RyYWludHMpOiBQcm9taXNlPExvY2FsVHJhY2s+IHtcbiAgICBpZiAoIWNvbnN0cmFpbnRzKSB7XG4gICAgICBjb25zdHJhaW50cyA9IHRoaXMuX2NvbnN0cmFpbnRzO1xuICAgIH1cbiAgICB0aGlzLmxvZy5kZWJ1ZygncmVzdGFydGluZyB0cmFjayB3aXRoIGNvbnN0cmFpbnRzJywgeyAuLi50aGlzLmxvZ0NvbnRleHQsIGNvbnN0cmFpbnRzIH0pO1xuXG4gICAgY29uc3Qgc3RyZWFtQ29uc3RyYWludHM6IE1lZGlhU3RyZWFtQ29uc3RyYWludHMgPSB7XG4gICAgICBhdWRpbzogZmFsc2UsXG4gICAgICB2aWRlbzogZmFsc2UsXG4gICAgfTtcblxuICAgIGlmICh0aGlzLmtpbmQgPT09IFRyYWNrLktpbmQuVmlkZW8pIHtcbiAgICAgIHN0cmVhbUNvbnN0cmFpbnRzLnZpZGVvID0gY29uc3RyYWludHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0cmVhbUNvbnN0cmFpbnRzLmF1ZGlvID0gY29uc3RyYWludHM7XG4gICAgfVxuXG4gICAgLy8gdGhlc2Ugc3RlcHMgYXJlIGR1cGxpY2F0ZWQgZnJvbSBzZXRNZWRpYVN0cmVhbVRyYWNrIGJlY2F1c2Ugd2UgbXVzdCBzdG9wXG4gICAgLy8gdGhlIHByZXZpb3VzIHRyYWNrcyBiZWZvcmUgbmV3IHRyYWNrcyBjYW4gYmUgYWNxdWlyZWRcbiAgICB0aGlzLmF0dGFjaGVkRWxlbWVudHMuZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgIGRldGFjaFRyYWNrKHRoaXMubWVkaWFTdHJlYW1UcmFjaywgZWwpO1xuICAgIH0pO1xuICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2sucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLmhhbmRsZUVuZGVkKTtcbiAgICAvLyBvbiBTYWZhcmksIHRoZSBvbGQgYXVkaW8gdHJhY2sgbXVzdCBiZSBzdG9wcGVkIGJlZm9yZSBhdHRlbXB0aW5nIHRvIGFjcXVpcmVcbiAgICAvLyB0aGUgbmV3IHRyYWNrLCBvdGhlcndpc2UgdGhlIG5ldyB0cmFjayB3aWxsIHN0b3Agd2l0aFxuICAgIC8vICdBIE1lZGlhU3RyZWFtVHJhY2sgZW5kZWQgZHVlIHRvIGEgY2FwdHVyZSBmYWlsdXJlYFxuICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suc3RvcCgpO1xuXG4gICAgLy8gY3JlYXRlIG5ldyB0cmFjayBhbmQgYXR0YWNoXG4gICAgY29uc3QgbWVkaWFTdHJlYW0gPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShzdHJlYW1Db25zdHJhaW50cyk7XG4gICAgY29uc3QgbmV3VHJhY2sgPSBtZWRpYVN0cmVhbS5nZXRUcmFja3MoKVswXTtcbiAgICBuZXdUcmFjay5hZGRFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMuaGFuZGxlRW5kZWQpO1xuICAgIHRoaXMubG9nLmRlYnVnKCdyZS1hY3F1aXJlZCBNZWRpYVN0cmVhbVRyYWNrJywgdGhpcy5sb2dDb250ZXh0KTtcblxuICAgIGF3YWl0IHRoaXMuc2V0TWVkaWFTdHJlYW1UcmFjayhuZXdUcmFjayk7XG4gICAgdGhpcy5fY29uc3RyYWludHMgPSBjb25zdHJhaW50cztcblxuICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlJlc3RhcnRlZCwgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBwcm90ZWN0ZWQgc2V0VHJhY2tNdXRlZChtdXRlZDogYm9vbGVhbikge1xuICAgIHRoaXMubG9nLmRlYnVnKGBzZXR0aW5nICR7dGhpcy5raW5kfSB0cmFjayAke211dGVkID8gJ211dGVkJyA6ICd1bm11dGVkJ31gLCB0aGlzLmxvZ0NvbnRleHQpO1xuXG4gICAgaWYgKHRoaXMuaXNNdXRlZCA9PT0gbXV0ZWQgJiYgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5lbmFibGVkICE9PSBtdXRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuaXNNdXRlZCA9IG11dGVkO1xuICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suZW5hYmxlZCA9ICFtdXRlZDtcbiAgICB0aGlzLmVtaXQobXV0ZWQgPyBUcmFja0V2ZW50Lk11dGVkIDogVHJhY2tFdmVudC5Vbm11dGVkLCB0aGlzKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBnZXQgbmVlZHNSZUFjcXVpc2l0aW9uKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnJlYWR5U3RhdGUgIT09ICdsaXZlJyB8fFxuICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5tdXRlZCB8fFxuICAgICAgIXRoaXMuX21lZGlhU3RyZWFtVHJhY2suZW5hYmxlZCB8fFxuICAgICAgdGhpcy5yZWFjcXVpcmVUcmFja1xuICAgICk7XG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWQoKSB7XG4gICAgYXdhaXQgc3VwZXIuaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWQoKTtcbiAgICBpZiAoIWlzTW9iaWxlKCkpIHJldHVybjtcbiAgICB0aGlzLmxvZy5kZWJ1ZyhgdmlzaWJpbGl0eSBjaGFuZ2VkLCBpcyBpbiBCYWNrZ3JvdW5kOiAke3RoaXMuaXNJbkJhY2tncm91bmR9YCwgdGhpcy5sb2dDb250ZXh0KTtcblxuICAgIGlmICghdGhpcy5pc0luQmFja2dyb3VuZCAmJiB0aGlzLm5lZWRzUmVBY3F1aXNpdGlvbiAmJiAhdGhpcy5pc1VzZXJQcm92aWRlZCAmJiAhdGhpcy5pc011dGVkKSB7XG4gICAgICB0aGlzLmxvZy5kZWJ1ZyhgdHJhY2sgbmVlZHMgdG8gYmUgcmVhY3F1aXJlZCwgcmVzdGFydGluZyAke3RoaXMuc291cmNlfWAsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICBhd2FpdCB0aGlzLnJlc3RhcnQoKTtcbiAgICAgIHRoaXMucmVhY3F1aXJlVHJhY2sgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZVRyYWNrTXV0ZUV2ZW50ID0gKCkgPT5cbiAgICB0aGlzLmRlYm91bmNlZFRyYWNrTXV0ZUhhbmRsZXIoKS5jYXRjaCgoKSA9PlxuICAgICAgdGhpcy5sb2cuZGVidWcoJ3RyYWNrIG11dGUgYm91bmNlIGdvdCBjYW5jZWxsZWQgYnkgYW4gdW5tdXRlIGV2ZW50JywgdGhpcy5sb2dDb250ZXh0KSxcbiAgICApO1xuXG4gIHByaXZhdGUgZGVib3VuY2VkVHJhY2tNdXRlSGFuZGxlciA9IGRlYm91bmNlKGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCB0aGlzLnBhdXNlVXBzdHJlYW0oKTtcbiAgfSwgNTAwMCk7XG5cbiAgcHJpdmF0ZSBoYW5kbGVUcmFja1VubXV0ZUV2ZW50ID0gYXN5bmMgKCkgPT4ge1xuICAgIHRoaXMuZGVib3VuY2VkVHJhY2tNdXRlSGFuZGxlci5jYW5jZWwoJ3VubXV0ZScpO1xuICAgIGF3YWl0IHRoaXMucmVzdW1lVXBzdHJlYW0oKTtcbiAgfTtcblxuICBwcml2YXRlIGhhbmRsZUVuZGVkID0gKCkgPT4ge1xuICAgIGlmICh0aGlzLmlzSW5CYWNrZ3JvdW5kKSB7XG4gICAgICB0aGlzLnJlYWNxdWlyZVRyYWNrID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCdtdXRlJywgdGhpcy5oYW5kbGVUcmFja011dGVFdmVudCk7XG4gICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCd1bm11dGUnLCB0aGlzLmhhbmRsZVRyYWNrVW5tdXRlRXZlbnQpO1xuICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LkVuZGVkLCB0aGlzKTtcbiAgfTtcblxuICBzdG9wKCkge1xuICAgIHN1cGVyLnN0b3AoKTtcblxuICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2sucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLmhhbmRsZUVuZGVkKTtcbiAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ211dGUnLCB0aGlzLmhhbmRsZVRyYWNrTXV0ZUV2ZW50KTtcbiAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3VubXV0ZScsIHRoaXMuaGFuZGxlVHJhY2tVbm11dGVFdmVudCk7XG4gICAgdGhpcy5wcm9jZXNzb3I/LmRlc3Ryb3koKTtcbiAgICB0aGlzLnByb2Nlc3NvciA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBwYXVzZXMgcHVibGlzaGluZyB0byB0aGUgc2VydmVyIHdpdGhvdXQgZGlzYWJsaW5nIHRoZSBsb2NhbCBNZWRpYVN0cmVhbVRyYWNrXG4gICAqIHRoaXMgaXMgdXNlZCB0byBkaXNwbGF5IGEgdXNlcidzIG93biB2aWRlbyBsb2NhbGx5IHdoaWxlIHBhdXNpbmcgcHVibGlzaGluZyB0b1xuICAgKiB0aGUgc2VydmVyLlxuICAgKiB0aGlzIEFQSSBpcyB1bnN1cHBvcnRlZCBvbiBTYWZhcmkgPCAxMiBkdWUgdG8gYSBidWdcbiAgICoqL1xuICBhc3luYyBwYXVzZVVwc3RyZWFtKCkge1xuICAgIGNvbnN0IHVubG9jayA9IGF3YWl0IHRoaXMucGF1c2VVcHN0cmVhbUxvY2subG9jaygpO1xuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy5faXNVcHN0cmVhbVBhdXNlZCA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuc2VuZGVyKSB7XG4gICAgICAgIHRoaXMubG9nLndhcm4oJ3VuYWJsZSB0byBwYXVzZSB1cHN0cmVhbSBmb3IgYW4gdW5wdWJsaXNoZWQgdHJhY2snLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2lzVXBzdHJlYW1QYXVzZWQgPSB0cnVlO1xuICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuVXBzdHJlYW1QYXVzZWQsIHRoaXMpO1xuICAgICAgY29uc3QgYnJvd3NlciA9IGdldEJyb3dzZXIoKTtcbiAgICAgIGlmIChicm93c2VyPy5uYW1lID09PSAnU2FmYXJpJyAmJiBjb21wYXJlVmVyc2lvbnMoYnJvd3Nlci52ZXJzaW9uLCAnMTIuMCcpIDwgMCkge1xuICAgICAgICAvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTg0OTExXG4gICAgICAgIHRocm93IG5ldyBEZXZpY2VVbnN1cHBvcnRlZEVycm9yKCdwYXVzZVVwc3RyZWFtIGlzIG5vdCBzdXBwb3J0ZWQgb24gU2FmYXJpIDwgMTIuJyk7XG4gICAgICB9XG4gICAgICBhd2FpdCB0aGlzLnNlbmRlci5yZXBsYWNlVHJhY2sobnVsbCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHVubG9jaygpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHJlc3VtZVVwc3RyZWFtKCkge1xuICAgIGNvbnN0IHVubG9jayA9IGF3YWl0IHRoaXMucGF1c2VVcHN0cmVhbUxvY2subG9jaygpO1xuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy5faXNVcHN0cmVhbVBhdXNlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnNlbmRlcikge1xuICAgICAgICB0aGlzLmxvZy53YXJuKCd1bmFibGUgdG8gcmVzdW1lIHVwc3RyZWFtIGZvciBhbiB1bnB1Ymxpc2hlZCB0cmFjaycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2lzVXBzdHJlYW1QYXVzZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlVwc3RyZWFtUmVzdW1lZCwgdGhpcyk7XG5cbiAgICAgIC8vIHRoaXMgb3BlcmF0aW9uIGlzIG5vb3AgaWYgbWVkaWFzdHJlYW10cmFjayBpcyBhbHJlYWR5IGJlaW5nIHNlbnRcbiAgICAgIGF3YWl0IHRoaXMuc2VuZGVyLnJlcGxhY2VUcmFjayh0aGlzLl9tZWRpYVN0cmVhbVRyYWNrKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdW5sb2NrKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIFJUQ1N0YXRzUmVwb3J0IGZvciB0aGUgTG9jYWxUcmFjaydzIHVuZGVybHlpbmcgUlRDUnRwU2VuZGVyXG4gICAqIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUlRDU3RhdHNSZXBvcnRcbiAgICpcbiAgICogQHJldHVybnMgUHJvbWlzZTxSVENTdGF0c1JlcG9ydD4gfCB1bmRlZmluZWRcbiAgICovXG4gIGFzeW5jIGdldFJUQ1N0YXRzUmVwb3J0KCk6IFByb21pc2U8UlRDU3RhdHNSZXBvcnQgfCB1bmRlZmluZWQ+IHtcbiAgICBpZiAoIXRoaXMuc2VuZGVyPy5nZXRTdGF0cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzdGF0c1JlcG9ydCA9IGF3YWl0IHRoaXMuc2VuZGVyLmdldFN0YXRzKCk7XG4gICAgcmV0dXJuIHN0YXRzUmVwb3J0O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBwcm9jZXNzb3Igb24gdGhpcyB0cmFjay5cbiAgICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9saXZla2l0L3RyYWNrLXByb2Nlc3NvcnMtanMgZm9yIGV4YW1wbGUgdXNhZ2VcbiAgICpcbiAgICogQGV4cGVyaW1lbnRhbFxuICAgKlxuICAgKiBAcGFyYW0gcHJvY2Vzc29yXG4gICAqIEBwYXJhbSBzaG93UHJvY2Vzc2VkU3RyZWFtTG9jYWxseVxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgYXN5bmMgc2V0UHJvY2Vzc29yKHByb2Nlc3NvcjogVHJhY2tQcm9jZXNzb3I8dGhpc1sna2luZCddPiwgc2hvd1Byb2Nlc3NlZFN0cmVhbUxvY2FsbHkgPSB0cnVlKSB7XG4gICAgY29uc3QgdW5sb2NrID0gYXdhaXQgdGhpcy5wcm9jZXNzb3JMb2NrLmxvY2soKTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5sb2cuZGVidWcoJ3NldHRpbmcgdXAgcHJvY2Vzc29yJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIGlmICh0aGlzLnByb2Nlc3Nvcikge1xuICAgICAgICBhd2FpdCB0aGlzLnN0b3BQcm9jZXNzb3IoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmtpbmQgPT09ICd1bmtub3duJykge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ2Nhbm5vdCBzZXQgcHJvY2Vzc29yIG9uIHRyYWNrIG9mIHVua25vd24ga2luZCcpO1xuICAgICAgfVxuICAgICAgdGhpcy5wcm9jZXNzb3JFbGVtZW50ID0gdGhpcy5wcm9jZXNzb3JFbGVtZW50ID8/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5raW5kKTtcblxuICAgICAgYXR0YWNoVG9FbGVtZW50KHRoaXMuX21lZGlhU3RyZWFtVHJhY2ssIHRoaXMucHJvY2Vzc29yRWxlbWVudCk7XG4gICAgICB0aGlzLnByb2Nlc3NvckVsZW1lbnQubXV0ZWQgPSB0cnVlO1xuXG4gICAgICB0aGlzLnByb2Nlc3NvckVsZW1lbnRcbiAgICAgICAgLnBsYXkoKVxuICAgICAgICAuY2F0Y2goKGVycm9yKSA9PlxuICAgICAgICAgIHRoaXMubG9nLmVycm9yKCdmYWlsZWQgdG8gcGxheSBwcm9jZXNzb3IgZWxlbWVudCcsIHsgLi4udGhpcy5sb2dDb250ZXh0LCBlcnJvciB9KSxcbiAgICAgICAgKTtcblxuICAgICAgY29uc3QgcHJvY2Vzc29yT3B0aW9ucyA9IHtcbiAgICAgICAga2luZDogdGhpcy5raW5kLFxuICAgICAgICB0cmFjazogdGhpcy5fbWVkaWFTdHJlYW1UcmFjayxcbiAgICAgICAgZWxlbWVudDogdGhpcy5wcm9jZXNzb3JFbGVtZW50LFxuICAgICAgfTtcblxuICAgICAgYXdhaXQgcHJvY2Vzc29yLmluaXQocHJvY2Vzc29yT3B0aW9ucyk7XG4gICAgICB0aGlzLnByb2Nlc3NvciA9IHByb2Nlc3NvcjtcbiAgICAgIGlmICh0aGlzLnByb2Nlc3Nvci5wcm9jZXNzZWRUcmFjaykge1xuICAgICAgICBmb3IgKGNvbnN0IGVsIG9mIHRoaXMuYXR0YWNoZWRFbGVtZW50cykge1xuICAgICAgICAgIGlmIChlbCAhPT0gdGhpcy5wcm9jZXNzb3JFbGVtZW50ICYmIHNob3dQcm9jZXNzZWRTdHJlYW1Mb2NhbGx5KSB7XG4gICAgICAgICAgICBkZXRhY2hUcmFjayh0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLCBlbCk7XG4gICAgICAgICAgICBhdHRhY2hUb0VsZW1lbnQodGhpcy5wcm9jZXNzb3IucHJvY2Vzc2VkVHJhY2ssIGVsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kZXI/LnJlcGxhY2VUcmFjayh0aGlzLnByb2Nlc3Nvci5wcm9jZXNzZWRUcmFjayk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHVubG9jaygpO1xuICAgIH1cbiAgfVxuXG4gIGdldFByb2Nlc3NvcigpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9jZXNzb3I7XG4gIH1cblxuICAvKipcbiAgICogU3RvcHMgdGhlIHRyYWNrIHByb2Nlc3NvclxuICAgKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2xpdmVraXQvdHJhY2stcHJvY2Vzc29ycy1qcyBmb3IgZXhhbXBsZSB1c2FnZVxuICAgKlxuICAgKiBAZXhwZXJpbWVudGFsXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBhc3luYyBzdG9wUHJvY2Vzc29yKCkge1xuICAgIGlmICghdGhpcy5wcm9jZXNzb3IpIHJldHVybjtcblxuICAgIHRoaXMubG9nLmRlYnVnKCdzdG9wcGluZyBwcm9jZXNzb3InLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgIHRoaXMucHJvY2Vzc29yLnByb2Nlc3NlZFRyYWNrPy5zdG9wKCk7XG4gICAgYXdhaXQgdGhpcy5wcm9jZXNzb3IuZGVzdHJveSgpO1xuICAgIHRoaXMucHJvY2Vzc29yID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucHJvY2Vzc29yRWxlbWVudD8ucmVtb3ZlKCk7XG4gICAgdGhpcy5wcm9jZXNzb3JFbGVtZW50ID0gdW5kZWZpbmVkO1xuXG4gICAgYXdhaXQgdGhpcy5yZXN0YXJ0KCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgbW9uaXRvclNlbmRlcigpOiB2b2lkO1xufVxuIiwiaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRzJztcbmltcG9ydCB0eXBlIFR5cGVkRXZlbnRFbWl0dGVyIGZyb20gJ3R5cGVkLWVtaXR0ZXInO1xuaW1wb3J0IGxvZyBmcm9tICcuLi9sb2dnZXInO1xuaW1wb3J0IHsgRW5jcnlwdGlvbl9UeXBlLCBUcmFja0luZm8gfSBmcm9tICcuLi9wcm90by9saXZla2l0X21vZGVsc19wYic7XG5pbXBvcnQgdHlwZSBSVENFbmdpbmUgZnJvbSAnLi4vcm9vbS9SVENFbmdpbmUnO1xuaW1wb3J0IHR5cGUgUm9vbSBmcm9tICcuLi9yb29tL1Jvb20nO1xuaW1wb3J0IHsgQ29ubmVjdGlvblN0YXRlIH0gZnJvbSAnLi4vcm9vbS9Sb29tJztcbmltcG9ydCB7IERldmljZVVuc3VwcG9ydGVkRXJyb3IgfSBmcm9tICcuLi9yb29tL2Vycm9ycyc7XG5pbXBvcnQgeyBFbmdpbmVFdmVudCwgUGFydGljaXBhbnRFdmVudCwgUm9vbUV2ZW50IH0gZnJvbSAnLi4vcm9vbS9ldmVudHMnO1xuaW1wb3J0IExvY2FsVHJhY2sgZnJvbSAnLi4vcm9vbS90cmFjay9Mb2NhbFRyYWNrJztcbmltcG9ydCB0eXBlIFJlbW90ZVRyYWNrIGZyb20gJy4uL3Jvb20vdHJhY2svUmVtb3RlVHJhY2snO1xuaW1wb3J0IHR5cGUgeyBUcmFjayB9IGZyb20gJy4uL3Jvb20vdHJhY2svVHJhY2snO1xuaW1wb3J0IHR5cGUgeyBWaWRlb0NvZGVjIH0gZnJvbSAnLi4vcm9vbS90cmFjay9vcHRpb25zJztcbmltcG9ydCB7IG1pbWVUeXBlVG9WaWRlb0NvZGVjU3RyaW5nIH0gZnJvbSAnLi4vcm9vbS90cmFjay91dGlscyc7XG5pbXBvcnQgdHlwZSB7IEJhc2VLZXlQcm92aWRlciB9IGZyb20gJy4vS2V5UHJvdmlkZXInO1xuaW1wb3J0IHsgRTJFRV9GTEFHIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgdHlwZSBFMkVFTWFuYWdlckNhbGxiYWNrcywgRW5jcnlwdGlvbkV2ZW50LCBLZXlQcm92aWRlckV2ZW50IH0gZnJvbSAnLi9ldmVudHMnO1xuaW1wb3J0IHR5cGUge1xuICBFMkVFT3B0aW9ucyxcbiAgRTJFRVdvcmtlck1lc3NhZ2UsXG4gIEVuYWJsZU1lc3NhZ2UsXG4gIEVuY29kZU1lc3NhZ2UsXG4gIEluaXRNZXNzYWdlLFxuICBLZXlJbmZvLFxuICBSVFBWaWRlb01hcE1lc3NhZ2UsXG4gIFJhdGNoZXRSZXF1ZXN0TWVzc2FnZSxcbiAgUmVtb3ZlVHJhbnNmb3JtTWVzc2FnZSxcbiAgU2V0S2V5TWVzc2FnZSxcbiAgU2lmVHJhaWxlck1lc3NhZ2UsXG4gIFVwZGF0ZUNvZGVjTWVzc2FnZSxcbn0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBpc0UyRUVTdXBwb3J0ZWQsIGlzU2NyaXB0VHJhbnNmb3JtU3VwcG9ydGVkIH0gZnJvbSAnLi91dGlscyc7XG5cbi8qKlxuICogQGV4cGVyaW1lbnRhbFxuICovXG5leHBvcnQgY2xhc3MgRTJFRU1hbmFnZXIgZXh0ZW5kcyAoRXZlbnRFbWl0dGVyIGFzIG5ldyAoKSA9PiBUeXBlZEV2ZW50RW1pdHRlcjxFMkVFTWFuYWdlckNhbGxiYWNrcz4pIHtcbiAgcHJvdGVjdGVkIHdvcmtlcjogV29ya2VyO1xuXG4gIHByb3RlY3RlZCByb29tPzogUm9vbTtcblxuICBwcml2YXRlIGVuY3J5cHRpb25FbmFibGVkOiBib29sZWFuO1xuXG4gIHByaXZhdGUga2V5UHJvdmlkZXI6IEJhc2VLZXlQcm92aWRlcjtcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBFMkVFT3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5rZXlQcm92aWRlciA9IG9wdGlvbnMua2V5UHJvdmlkZXI7XG4gICAgdGhpcy53b3JrZXIgPSBvcHRpb25zLndvcmtlcjtcbiAgICB0aGlzLmVuY3J5cHRpb25FbmFibGVkID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzZXR1cChyb29tOiBSb29tKSB7XG4gICAgaWYgKCFpc0UyRUVTdXBwb3J0ZWQoKSkge1xuICAgICAgdGhyb3cgbmV3IERldmljZVVuc3VwcG9ydGVkRXJyb3IoXG4gICAgICAgICd0cmllZCB0byBzZXR1cCBlbmQtdG8tZW5kIGVuY3J5cHRpb24gb24gYW4gdW5zdXBwb3J0ZWQgYnJvd3NlcicsXG4gICAgICApO1xuICAgIH1cbiAgICBsb2cuaW5mbygnc2V0dGluZyB1cCBlMmVlJyk7XG4gICAgaWYgKHJvb20gIT09IHRoaXMucm9vbSkge1xuICAgICAgdGhpcy5yb29tID0gcm9vbTtcbiAgICAgIHRoaXMuc2V0dXBFdmVudExpc3RlbmVycyhyb29tLCB0aGlzLmtleVByb3ZpZGVyKTtcbiAgICAgIC8vIHRoaXMud29ya2VyID0gbmV3IFdvcmtlcignJyk7XG4gICAgICBjb25zdCBtc2c6IEluaXRNZXNzYWdlID0ge1xuICAgICAgICBraW5kOiAnaW5pdCcsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBrZXlQcm92aWRlck9wdGlvbnM6IHRoaXMua2V5UHJvdmlkZXIuZ2V0T3B0aW9ucygpLFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLndvcmtlcikge1xuICAgICAgICBsb2cuaW5mbyhgaW5pdGlhbGl6aW5nIHdvcmtlcmAsIHsgd29ya2VyOiB0aGlzLndvcmtlciB9KTtcbiAgICAgICAgdGhpcy53b3JrZXIub25tZXNzYWdlID0gdGhpcy5vbldvcmtlck1lc3NhZ2U7XG4gICAgICAgIHRoaXMud29ya2VyLm9uZXJyb3IgPSB0aGlzLm9uV29ya2VyRXJyb3I7XG4gICAgICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKG1zZyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc2V0UGFydGljaXBhbnRDcnlwdG9yRW5hYmxlZChlbmFibGVkOiBib29sZWFuLCBwYXJ0aWNpcGFudElkZW50aXR5OiBzdHJpbmcpIHtcbiAgICBsb2cuZGVidWcoYHNldCBlMmVlIHRvICR7ZW5hYmxlZH0gZm9yIHBhcnRpY2lwYW50ICR7cGFydGljaXBhbnRJZGVudGl0eX1gKTtcbiAgICB0aGlzLnBvc3RFbmFibGUoZW5hYmxlZCwgcGFydGljaXBhbnRJZGVudGl0eSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzZXRTaWZUcmFpbGVyKHRyYWlsZXI6IFVpbnQ4QXJyYXkpIHtcbiAgICBpZiAoIXRyYWlsZXIgfHwgdHJhaWxlci5sZW5ndGggPT09IDApIHtcbiAgICAgIGxvZy53YXJuKFwiaWdub3Jpbmcgc2VydmVyIHNlbnQgdHJhaWxlciBhcyBpdCdzIGVtcHR5XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBvc3RTaWZUcmFpbGVyKHRyYWlsZXIpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgb25Xb3JrZXJNZXNzYWdlID0gKGV2OiBNZXNzYWdlRXZlbnQ8RTJFRVdvcmtlck1lc3NhZ2U+KSA9PiB7XG4gICAgY29uc3QgeyBraW5kLCBkYXRhIH0gPSBldi5kYXRhO1xuICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICBsb2cuZXJyb3IoZGF0YS5lcnJvci5tZXNzYWdlKTtcbiAgICAgICAgdGhpcy5lbWl0KEVuY3J5cHRpb25FdmVudC5FbmNyeXB0aW9uRXJyb3IsIGRhdGEuZXJyb3IpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2luaXRBY2snOlxuICAgICAgICBpZiAoZGF0YS5lbmFibGVkKSB7XG4gICAgICAgICAgdGhpcy5rZXlQcm92aWRlci5nZXRLZXlzKCkuZm9yRWFjaCgoa2V5SW5mbykgPT4ge1xuICAgICAgICAgICAgdGhpcy5wb3N0S2V5KGtleUluZm8pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdlbmFibGUnOlxuICAgICAgICBpZiAoXG4gICAgICAgICAgdGhpcy5lbmNyeXB0aW9uRW5hYmxlZCAhPT0gZGF0YS5lbmFibGVkICYmXG4gICAgICAgICAgZGF0YS5wYXJ0aWNpcGFudElkZW50aXR5ID09PSB0aGlzLnJvb20/LmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHlcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KFxuICAgICAgICAgICAgRW5jcnlwdGlvbkV2ZW50LlBhcnRpY2lwYW50RW5jcnlwdGlvblN0YXR1c0NoYW5nZWQsXG4gICAgICAgICAgICBkYXRhLmVuYWJsZWQsXG4gICAgICAgICAgICB0aGlzLnJvb20hLmxvY2FsUGFydGljaXBhbnQsXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aGlzLmVuY3J5cHRpb25FbmFibGVkID0gZGF0YS5lbmFibGVkO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGEucGFydGljaXBhbnRJZGVudGl0eSkge1xuICAgICAgICAgIGNvbnN0IHBhcnRpY2lwYW50ID0gdGhpcy5yb29tPy5nZXRQYXJ0aWNpcGFudEJ5SWRlbnRpdHkoZGF0YS5wYXJ0aWNpcGFudElkZW50aXR5KTtcbiAgICAgICAgICBpZiAoIXBhcnRpY2lwYW50KSB7XG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgIGBjb3VsZG4ndCBzZXQgZW5jcnlwdGlvbiBzdGF0dXMsIHBhcnRpY2lwYW50IG5vdCBmb3VuZCR7ZGF0YS5wYXJ0aWNpcGFudElkZW50aXR5fWAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmVtaXQoRW5jcnlwdGlvbkV2ZW50LlBhcnRpY2lwYW50RW5jcnlwdGlvblN0YXR1c0NoYW5nZWQsIGRhdGEuZW5hYmxlZCwgcGFydGljaXBhbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmVuY3J5cHRpb25FbmFibGVkKSB7XG4gICAgICAgICAgdGhpcy5rZXlQcm92aWRlci5nZXRLZXlzKCkuZm9yRWFjaCgoa2V5SW5mbykgPT4ge1xuICAgICAgICAgICAgdGhpcy5wb3N0S2V5KGtleUluZm8pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmF0Y2hldEtleSc6XG4gICAgICAgIHRoaXMua2V5UHJvdmlkZXIuZW1pdChLZXlQcm92aWRlckV2ZW50LktleVJhdGNoZXRlZCwgZGF0YS5tYXRlcmlhbCwgZGF0YS5rZXlJbmRleCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9O1xuXG4gIHByaXZhdGUgb25Xb3JrZXJFcnJvciA9IChldjogRXJyb3JFdmVudCkgPT4ge1xuICAgIGxvZy5lcnJvcignZTJlZSB3b3JrZXIgZW5jb3VudGVyZWQgYW4gZXJyb3I6JywgeyBlcnJvcjogZXYuZXJyb3IgfSk7XG4gICAgdGhpcy5lbWl0KEVuY3J5cHRpb25FdmVudC5FbmNyeXB0aW9uRXJyb3IsIGV2LmVycm9yKTtcbiAgfTtcblxuICBwdWJsaWMgc2V0dXBFbmdpbmUoZW5naW5lOiBSVENFbmdpbmUpIHtcbiAgICBlbmdpbmUub24oRW5naW5lRXZlbnQuUlRQVmlkZW9NYXBVcGRhdGUsIChydHBNYXApID0+IHtcbiAgICAgIHRoaXMucG9zdFJUUE1hcChydHBNYXApO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBzZXR1cEV2ZW50TGlzdGVuZXJzKHJvb206IFJvb20sIGtleVByb3ZpZGVyOiBCYXNlS2V5UHJvdmlkZXIpIHtcbiAgICByb29tLm9uKFJvb21FdmVudC5UcmFja1B1Ymxpc2hlZCwgKHB1YiwgcGFydGljaXBhbnQpID0+XG4gICAgICB0aGlzLnNldFBhcnRpY2lwYW50Q3J5cHRvckVuYWJsZWQoXG4gICAgICAgIHB1Yi50cmFja0luZm8hLmVuY3J5cHRpb24gIT09IEVuY3J5cHRpb25fVHlwZS5OT05FLFxuICAgICAgICBwYXJ0aWNpcGFudC5pZGVudGl0eSxcbiAgICAgICksXG4gICAgKTtcbiAgICByb29tXG4gICAgICAub24oUm9vbUV2ZW50LkNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQsIChzdGF0ZSkgPT4ge1xuICAgICAgICBpZiAoc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0ZWQpIHtcbiAgICAgICAgICByb29tLnBhcnRpY2lwYW50cy5mb3JFYWNoKChwYXJ0aWNpcGFudCkgPT4ge1xuICAgICAgICAgICAgcGFydGljaXBhbnQudHJhY2tzLmZvckVhY2goKHB1YikgPT4ge1xuICAgICAgICAgICAgICB0aGlzLnNldFBhcnRpY2lwYW50Q3J5cHRvckVuYWJsZWQoXG4gICAgICAgICAgICAgICAgcHViLnRyYWNrSW5mbyEuZW5jcnlwdGlvbiAhPT0gRW5jcnlwdGlvbl9UeXBlLk5PTkUsXG4gICAgICAgICAgICAgICAgcGFydGljaXBhbnQuaWRlbnRpdHksXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5vbihSb29tRXZlbnQuVHJhY2tVbnN1YnNjcmliZWQsICh0cmFjaywgXywgcGFydGljaXBhbnQpID0+IHtcbiAgICAgICAgY29uc3QgbXNnOiBSZW1vdmVUcmFuc2Zvcm1NZXNzYWdlID0ge1xuICAgICAgICAgIGtpbmQ6ICdyZW1vdmVUcmFuc2Zvcm0nLFxuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIHBhcnRpY2lwYW50SWRlbnRpdHk6IHBhcnRpY2lwYW50LmlkZW50aXR5LFxuICAgICAgICAgICAgdHJhY2tJZDogdHJhY2subWVkaWFTdHJlYW1JRCxcbiAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLndvcmtlcj8ucG9zdE1lc3NhZ2UobXNnKTtcbiAgICAgIH0pXG4gICAgICAub24oUm9vbUV2ZW50LlRyYWNrU3Vic2NyaWJlZCwgKHRyYWNrLCBwdWIsIHBhcnRpY2lwYW50KSA9PiB7XG4gICAgICAgIHRoaXMuc2V0dXBFMkVFUmVjZWl2ZXIodHJhY2ssIHBhcnRpY2lwYW50LmlkZW50aXR5LCBwdWIudHJhY2tJbmZvKTtcbiAgICAgIH0pXG4gICAgICAub24oUm9vbUV2ZW50LlNpZ25hbENvbm5lY3RlZCwgKCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMucm9vbSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGV4cGVjdGVkIHJvb20gdG8gYmUgcHJlc2VudCBvbiBzaWduYWwgY29ubmVjdGApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0UGFydGljaXBhbnRDcnlwdG9yRW5hYmxlZChcbiAgICAgICAgICB0aGlzLnJvb20ubG9jYWxQYXJ0aWNpcGFudC5pc0UyRUVFbmFibGVkLFxuICAgICAgICAgIHRoaXMucm9vbS5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5LFxuICAgICAgICApO1xuICAgICAgICBrZXlQcm92aWRlci5nZXRLZXlzKCkuZm9yRWFjaCgoa2V5SW5mbykgPT4ge1xuICAgICAgICAgIHRoaXMucG9zdEtleShrZXlJbmZvKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICByb29tLmxvY2FsUGFydGljaXBhbnQub24oUGFydGljaXBhbnRFdmVudC5Mb2NhbFRyYWNrUHVibGlzaGVkLCBhc3luYyAocHVibGljYXRpb24pID0+IHtcbiAgICAgIHRoaXMuc2V0dXBFMkVFU2VuZGVyKHB1YmxpY2F0aW9uLnRyYWNrISwgcHVibGljYXRpb24udHJhY2shLnNlbmRlciEpO1xuICAgIH0pO1xuXG4gICAga2V5UHJvdmlkZXJcbiAgICAgIC5vbihLZXlQcm92aWRlckV2ZW50LlNldEtleSwgKGtleUluZm8pID0+IHRoaXMucG9zdEtleShrZXlJbmZvKSlcbiAgICAgIC5vbihLZXlQcm92aWRlckV2ZW50LlJhdGNoZXRSZXF1ZXN0LCAocGFydGljaXBhbnRJZCwga2V5SW5kZXgpID0+XG4gICAgICAgIHRoaXMucG9zdFJhdGNoZXRSZXF1ZXN0KHBhcnRpY2lwYW50SWQsIGtleUluZGV4KSxcbiAgICAgICk7XG4gIH1cblxuICBwcml2YXRlIHBvc3RSYXRjaGV0UmVxdWVzdChwYXJ0aWNpcGFudElkZW50aXR5Pzogc3RyaW5nLCBrZXlJbmRleD86IG51bWJlcikge1xuICAgIGlmICghdGhpcy53b3JrZXIpIHtcbiAgICAgIHRocm93IEVycm9yKCdjb3VsZCBub3QgcmF0Y2hldCBrZXksIHdvcmtlciBpcyBtaXNzaW5nJyk7XG4gICAgfVxuICAgIGNvbnN0IG1zZzogUmF0Y2hldFJlcXVlc3RNZXNzYWdlID0ge1xuICAgICAga2luZDogJ3JhdGNoZXRSZXF1ZXN0JyxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgcGFydGljaXBhbnRJZGVudGl0eTogcGFydGljaXBhbnRJZGVudGl0eSxcbiAgICAgICAga2V5SW5kZXgsXG4gICAgICB9LFxuICAgIH07XG4gICAgdGhpcy53b3JrZXIucG9zdE1lc3NhZ2UobXNnKTtcbiAgfVxuXG4gIHByaXZhdGUgcG9zdEtleSh7IGtleSwgcGFydGljaXBhbnRJZGVudGl0eSwga2V5SW5kZXggfTogS2V5SW5mbykge1xuICAgIGlmICghdGhpcy53b3JrZXIpIHtcbiAgICAgIHRocm93IEVycm9yKCdjb3VsZCBub3Qgc2V0IGtleSwgd29ya2VyIGlzIG1pc3NpbmcnKTtcbiAgICB9XG4gICAgY29uc3QgbXNnOiBTZXRLZXlNZXNzYWdlID0ge1xuICAgICAga2luZDogJ3NldEtleScsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHBhcnRpY2lwYW50SWRlbnRpdHk6IHBhcnRpY2lwYW50SWRlbnRpdHksXG4gICAgICAgIGlzUHVibGlzaGVyOiBwYXJ0aWNpcGFudElkZW50aXR5ID09PSB0aGlzLnJvb20/LmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHksXG4gICAgICAgIGtleSxcbiAgICAgICAga2V5SW5kZXgsXG4gICAgICB9LFxuICAgIH07XG4gICAgdGhpcy53b3JrZXIucG9zdE1lc3NhZ2UobXNnKTtcbiAgfVxuXG4gIHByaXZhdGUgcG9zdEVuYWJsZShlbmFibGVkOiBib29sZWFuLCBwYXJ0aWNpcGFudElkZW50aXR5OiBzdHJpbmcpIHtcbiAgICBpZiAodGhpcy53b3JrZXIpIHtcbiAgICAgIGNvbnN0IGVuYWJsZU1zZzogRW5hYmxlTWVzc2FnZSA9IHtcbiAgICAgICAga2luZDogJ2VuYWJsZScsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBlbmFibGVkLFxuICAgICAgICAgIHBhcnRpY2lwYW50SWRlbnRpdHksXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgICAgdGhpcy53b3JrZXIucG9zdE1lc3NhZ2UoZW5hYmxlTXNnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKCdmYWlsZWQgdG8gZW5hYmxlIGUyZWUsIHdvcmtlciBpcyBub3QgcmVhZHknKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHBvc3RSVFBNYXAobWFwOiBNYXA8bnVtYmVyLCBWaWRlb0NvZGVjPikge1xuICAgIGlmICghdGhpcy53b3JrZXIpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignY291bGQgbm90IHBvc3QgcnRwIG1hcCwgd29ya2VyIGlzIG1pc3NpbmcnKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnJvb20/LmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHkpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignY291bGQgbm90IHBvc3QgcnRwIG1hcCwgbG9jYWwgcGFydGljaXBhbnQgaWRlbnRpdHkgaXMgbWlzc2luZycpO1xuICAgIH1cbiAgICBjb25zdCBtc2c6IFJUUFZpZGVvTWFwTWVzc2FnZSA9IHtcbiAgICAgIGtpbmQ6ICdzZXRSVFBNYXAnLFxuICAgICAgZGF0YToge1xuICAgICAgICBtYXAsXG4gICAgICAgIHBhcnRpY2lwYW50SWRlbnRpdHk6IHRoaXMucm9vbS5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5LFxuICAgICAgfSxcbiAgICB9O1xuICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKG1zZyk7XG4gIH1cblxuICBwcml2YXRlIHBvc3RTaWZUcmFpbGVyKHRyYWlsZXI6IFVpbnQ4QXJyYXkpIHtcbiAgICBpZiAoIXRoaXMud29ya2VyKSB7XG4gICAgICB0aHJvdyBFcnJvcignY291bGQgbm90IHBvc3QgU0lGIHRyYWlsZXIsIHdvcmtlciBpcyBtaXNzaW5nJyk7XG4gICAgfVxuICAgIGNvbnN0IG1zZzogU2lmVHJhaWxlck1lc3NhZ2UgPSB7XG4gICAgICBraW5kOiAnc2V0U2lmVHJhaWxlcicsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHRyYWlsZXIsXG4gICAgICB9LFxuICAgIH07XG4gICAgdGhpcy53b3JrZXIucG9zdE1lc3NhZ2UobXNnKTtcbiAgfVxuXG4gIHByaXZhdGUgc2V0dXBFMkVFUmVjZWl2ZXIodHJhY2s6IFJlbW90ZVRyYWNrLCByZW1vdGVJZDogc3RyaW5nLCB0cmFja0luZm8/OiBUcmFja0luZm8pIHtcbiAgICBpZiAoIXRyYWNrLnJlY2VpdmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdHJhY2tJbmZvPy5taW1lVHlwZSB8fCB0cmFja0luZm8ubWltZVR5cGUgPT09ICcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdNaW1lVHlwZSBtaXNzaW5nIGZyb20gdHJhY2tJbmZvLCBjYW5ub3Qgc2V0IHVwIEUyRUUgY3J5cHRvcicpO1xuICAgIH1cbiAgICB0aGlzLmhhbmRsZVJlY2VpdmVyKFxuICAgICAgdHJhY2sucmVjZWl2ZXIsXG4gICAgICB0cmFjay5tZWRpYVN0cmVhbUlELFxuICAgICAgcmVtb3RlSWQsXG4gICAgICB0cmFjay5raW5kID09PSAndmlkZW8nID8gbWltZVR5cGVUb1ZpZGVvQ29kZWNTdHJpbmcodHJhY2tJbmZvLm1pbWVUeXBlKSA6IHVuZGVmaW5lZCxcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBzZXR1cEUyRUVTZW5kZXIodHJhY2s6IFRyYWNrLCBzZW5kZXI6IFJUQ1J0cFNlbmRlcikge1xuICAgIGlmICghKHRyYWNrIGluc3RhbmNlb2YgTG9jYWxUcmFjaykgfHwgIXNlbmRlcikge1xuICAgICAgaWYgKCFzZW5kZXIpIGxvZy53YXJuKCdlYXJseSByZXR1cm4gYmVjYXVzZSBzZW5kZXIgaXMgbm90IHJlYWR5Jyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuaGFuZGxlU2VuZGVyKHNlbmRlciwgdHJhY2subWVkaWFTdHJlYW1JRCwgdW5kZWZpbmVkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSBnaXZlbiB7QGNvZGUgUlRDUnRwUmVjZWl2ZXJ9IGJ5IGNyZWF0aW5nIGEge0Bjb2RlIFRyYW5zZm9ybVN0cmVhbX0gd2hpY2ggd2lsbCBpbmplY3RcbiAgICogYSBmcmFtZSBkZWNvZGVyLlxuICAgKlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBoYW5kbGVSZWNlaXZlcihcbiAgICByZWNlaXZlcjogUlRDUnRwUmVjZWl2ZXIsXG4gICAgdHJhY2tJZDogc3RyaW5nLFxuICAgIHBhcnRpY2lwYW50SWRlbnRpdHk6IHN0cmluZyxcbiAgICBjb2RlYz86IFZpZGVvQ29kZWMsXG4gICkge1xuICAgIGlmICghdGhpcy53b3JrZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaXNTY3JpcHRUcmFuc2Zvcm1TdXBwb3J0ZWQoKSkge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAga2luZDogJ2RlY29kZScsXG4gICAgICAgIHBhcnRpY2lwYW50SWRlbnRpdHksXG4gICAgICAgIHRyYWNrSWQsXG4gICAgICAgIGNvZGVjLFxuICAgICAgfTtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHJlY2VpdmVyLnRyYW5zZm9ybSA9IG5ldyBSVENSdHBTY3JpcHRUcmFuc2Zvcm0odGhpcy53b3JrZXIsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoRTJFRV9GTEFHIGluIHJlY2VpdmVyICYmIGNvZGVjKSB7XG4gICAgICAgIC8vIG9ubHkgdXBkYXRlIGNvZGVjXG4gICAgICAgIGNvbnN0IG1zZzogVXBkYXRlQ29kZWNNZXNzYWdlID0ge1xuICAgICAgICAgIGtpbmQ6ICd1cGRhdGVDb2RlYycsXG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgdHJhY2tJZCxcbiAgICAgICAgICAgIGNvZGVjLFxuICAgICAgICAgICAgcGFydGljaXBhbnRJZGVudGl0eTogcGFydGljaXBhbnRJZGVudGl0eSxcbiAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZShtc2cpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBsZXQgd3JpdGFibGU6IFdyaXRhYmxlU3RyZWFtID0gcmVjZWl2ZXIud3JpdGFibGVTdHJlYW07XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBsZXQgcmVhZGFibGU6IFJlYWRhYmxlU3RyZWFtID0gcmVjZWl2ZXIucmVhZGFibGVTdHJlYW07XG4gICAgICBpZiAoIXdyaXRhYmxlIHx8ICFyZWFkYWJsZSkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGNvbnN0IHJlY2VpdmVyU3RyZWFtcyA9IHJlY2VpdmVyLmNyZWF0ZUVuY29kZWRTdHJlYW1zKCk7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmVjZWl2ZXIud3JpdGFibGVTdHJlYW0gPSByZWNlaXZlclN0cmVhbXMud3JpdGFibGU7XG4gICAgICAgIHdyaXRhYmxlID0gcmVjZWl2ZXJTdHJlYW1zLndyaXRhYmxlO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJlY2VpdmVyLnJlYWRhYmxlU3RyZWFtID0gcmVjZWl2ZXJTdHJlYW1zLnJlYWRhYmxlO1xuICAgICAgICByZWFkYWJsZSA9IHJlY2VpdmVyU3RyZWFtcy5yZWFkYWJsZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbXNnOiBFbmNvZGVNZXNzYWdlID0ge1xuICAgICAgICBraW5kOiAnZGVjb2RlJyxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHJlYWRhYmxlU3RyZWFtOiByZWFkYWJsZSxcbiAgICAgICAgICB3cml0YWJsZVN0cmVhbTogd3JpdGFibGUsXG4gICAgICAgICAgdHJhY2tJZDogdHJhY2tJZCxcbiAgICAgICAgICBjb2RlYyxcbiAgICAgICAgICBwYXJ0aWNpcGFudElkZW50aXR5OiBwYXJ0aWNpcGFudElkZW50aXR5LFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKG1zZywgW3JlYWRhYmxlLCB3cml0YWJsZV0pO1xuICAgIH1cblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZWNlaXZlcltFMkVFX0ZMQUddID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSBnaXZlbiB7QGNvZGUgUlRDUnRwU2VuZGVyfSBieSBjcmVhdGluZyBhIHtAY29kZSBUcmFuc2Zvcm1TdHJlYW19IHdoaWNoIHdpbGwgaW5qZWN0XG4gICAqIGEgZnJhbWUgZW5jb2Rlci5cbiAgICpcbiAgICovXG4gIHByaXZhdGUgaGFuZGxlU2VuZGVyKHNlbmRlcjogUlRDUnRwU2VuZGVyLCB0cmFja0lkOiBzdHJpbmcsIGNvZGVjPzogVmlkZW9Db2RlYykge1xuICAgIGlmIChFMkVFX0ZMQUcgaW4gc2VuZGVyIHx8ICF0aGlzLndvcmtlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5yb29tPy5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5IHx8IHRoaXMucm9vbS5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5ID09PSAnJykge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdsb2NhbCBpZGVudGl0eSBuZWVkcyB0byBiZSBrbm93biBpbiBvcmRlciB0byBzZXQgdXAgZW5jcnlwdGVkIHNlbmRlcicpO1xuICAgIH1cblxuICAgIGlmIChpc1NjcmlwdFRyYW5zZm9ybVN1cHBvcnRlZCgpKSB7XG4gICAgICBsb2cuaW5mbygnaW5pdGlhbGl6ZSBzY3JpcHQgdHJhbnNmb3JtJyk7XG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBraW5kOiAnZW5jb2RlJyxcbiAgICAgICAgcGFydGljaXBhbnRJZGVudGl0eTogdGhpcy5yb29tLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHksXG4gICAgICAgIHRyYWNrSWQsXG4gICAgICAgIGNvZGVjLFxuICAgICAgfTtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHNlbmRlci50cmFuc2Zvcm0gPSBuZXcgUlRDUnRwU2NyaXB0VHJhbnNmb3JtKHRoaXMud29ya2VyLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nLmluZm8oJ2luaXRpYWxpemUgZW5jb2RlZCBzdHJlYW1zJyk7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBjb25zdCBzZW5kZXJTdHJlYW1zID0gc2VuZGVyLmNyZWF0ZUVuY29kZWRTdHJlYW1zKCk7XG4gICAgICBjb25zdCBtc2c6IEVuY29kZU1lc3NhZ2UgPSB7XG4gICAgICAgIGtpbmQ6ICdlbmNvZGUnLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgcmVhZGFibGVTdHJlYW06IHNlbmRlclN0cmVhbXMucmVhZGFibGUsXG4gICAgICAgICAgd3JpdGFibGVTdHJlYW06IHNlbmRlclN0cmVhbXMud3JpdGFibGUsXG4gICAgICAgICAgY29kZWMsXG4gICAgICAgICAgdHJhY2tJZCxcbiAgICAgICAgICBwYXJ0aWNpcGFudElkZW50aXR5OiB0aGlzLnJvb20ubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eSxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZShtc2csIFtzZW5kZXJTdHJlYW1zLnJlYWRhYmxlLCBzZW5kZXJTdHJlYW1zLndyaXRhYmxlXSk7XG4gICAgfVxuXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHNlbmRlcltFMkVFX0ZMQUddID0gdHJ1ZTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgTXV0ZXggfSBmcm9tICcuLi9yb29tL3V0aWxzJztcblxudHlwZSBRdWV1ZVRhc2s8VD4gPSAoKSA9PiBQcm9taXNlTGlrZTxUPjtcblxuZW51bSBRdWV1ZVRhc2tTdGF0dXMge1xuICAnV0FJVElORycsXG4gICdSVU5OSU5HJyxcbiAgJ0NPTVBMRVRFRCcsXG59XG5cbnR5cGUgUXVldWVUYXNrSW5mbyA9IHtcbiAgaWQ6IG51bWJlcjtcbiAgZW5xdWV1ZWRBdDogbnVtYmVyO1xuICBleGVjdXRlZEF0PzogbnVtYmVyO1xuICBzdGF0dXM6IFF1ZXVlVGFza1N0YXR1cztcbn07XG5cbmV4cG9ydCBjbGFzcyBBc3luY1F1ZXVlIHtcbiAgcHJpdmF0ZSBwZW5kaW5nVGFza3M6IE1hcDxudW1iZXIsIFF1ZXVlVGFza0luZm8+O1xuXG4gIHByaXZhdGUgdGFza011dGV4OiBNdXRleDtcblxuICBwcml2YXRlIG5leHRUYXNrSW5kZXg6IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnBlbmRpbmdUYXNrcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnRhc2tNdXRleCA9IG5ldyBNdXRleCgpO1xuICAgIHRoaXMubmV4dFRhc2tJbmRleCA9IDA7XG4gIH1cblxuICBhc3luYyBydW48VD4odGFzazogUXVldWVUYXNrPFQ+KSB7XG4gICAgY29uc3QgdGFza0luZm86IFF1ZXVlVGFza0luZm8gPSB7XG4gICAgICBpZDogdGhpcy5uZXh0VGFza0luZGV4KyssXG4gICAgICBlbnF1ZXVlZEF0OiBEYXRlLm5vdygpLFxuICAgICAgc3RhdHVzOiBRdWV1ZVRhc2tTdGF0dXMuV0FJVElORyxcbiAgICB9O1xuICAgIHRoaXMucGVuZGluZ1Rhc2tzLnNldCh0YXNrSW5mby5pZCwgdGFza0luZm8pO1xuICAgIGNvbnN0IHVubG9jayA9IGF3YWl0IHRoaXMudGFza011dGV4LmxvY2soKTtcbiAgICB0cnkge1xuICAgICAgdGFza0luZm8uZXhlY3V0ZWRBdCA9IERhdGUubm93KCk7XG4gICAgICB0YXNrSW5mby5zdGF0dXMgPSBRdWV1ZVRhc2tTdGF0dXMuUlVOTklORztcbiAgICAgIHJldHVybiBhd2FpdCB0YXNrKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRhc2tJbmZvLnN0YXR1cyA9IFF1ZXVlVGFza1N0YXR1cy5DT01QTEVURUQ7XG4gICAgICB0aGlzLnBlbmRpbmdUYXNrcy5kZWxldGUodGFza0luZm8uaWQpO1xuICAgICAgdW5sb2NrKCk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZmx1c2goKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuKGFzeW5jICgpID0+IHt9KTtcbiAgfVxuXG4gIHNuYXBzaG90KCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMucGVuZGluZ1Rhc2tzLnZhbHVlcygpKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgcHJvdG9JbnQ2NCB9IGZyb20gJ0BidWZidWlsZC9wcm90b2J1Zic7XG5pbXBvcnQgbG9nLCB7IExvZ2dlck5hbWVzLCBnZXRMb2dnZXIgfSBmcm9tICcuLi9sb2dnZXInO1xuaW1wb3J0IHtcbiAgQ2xpZW50SW5mbyxcbiAgRGlzY29ubmVjdFJlYXNvbixcbiAgUGFydGljaXBhbnRJbmZvLFxuICBSZWNvbm5lY3RSZWFzb24sXG4gIFJvb20sXG4gIFNwZWFrZXJJbmZvLFxuICBWaWRlb0xheWVyLFxufSBmcm9tICcuLi9wcm90by9saXZla2l0X21vZGVsc19wYic7XG5pbXBvcnQge1xuICBBZGRUcmFja1JlcXVlc3QsXG4gIENvbm5lY3Rpb25RdWFsaXR5VXBkYXRlLFxuICBKb2luUmVzcG9uc2UsXG4gIExlYXZlUmVxdWVzdCxcbiAgTXV0ZVRyYWNrUmVxdWVzdCxcbiAgUGluZyxcbiAgUmVjb25uZWN0UmVzcG9uc2UsXG4gIFNlc3Npb25EZXNjcmlwdGlvbixcbiAgU2lnbmFsUmVxdWVzdCxcbiAgU2lnbmFsUmVzcG9uc2UsXG4gIFNpZ25hbFRhcmdldCxcbiAgU2ltdWxhdGVTY2VuYXJpbyxcbiAgU3RyZWFtU3RhdGVVcGRhdGUsXG4gIFN1YnNjcmliZWRRdWFsaXR5VXBkYXRlLFxuICBTdWJzY3JpcHRpb25QZXJtaXNzaW9uLFxuICBTdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlLFxuICBTdWJzY3JpcHRpb25SZXNwb25zZSxcbiAgU3luY1N0YXRlLFxuICBUcmFja1Blcm1pc3Npb24sXG4gIFRyYWNrUHVibGlzaGVkUmVzcG9uc2UsXG4gIFRyYWNrVW5wdWJsaXNoZWRSZXNwb25zZSxcbiAgVHJpY2tsZVJlcXVlc3QsXG4gIFVwZGF0ZVBhcnRpY2lwYW50TWV0YWRhdGEsXG4gIFVwZGF0ZVN1YnNjcmlwdGlvbixcbiAgVXBkYXRlVHJhY2tTZXR0aW5ncyxcbiAgVXBkYXRlVmlkZW9MYXllcnMsXG59IGZyb20gJy4uL3Byb3RvL2xpdmVraXRfcnRjX3BiJztcbmltcG9ydCB7IENvbm5lY3Rpb25FcnJvciwgQ29ubmVjdGlvbkVycm9yUmVhc29uIH0gZnJvbSAnLi4vcm9vbS9lcnJvcnMnO1xuaW1wb3J0IENyaXRpY2FsVGltZXJzIGZyb20gJy4uL3Jvb20vdGltZXJzJztcbmltcG9ydCB0eXBlIHsgTG9nZ2VyT3B0aW9ucyB9IGZyb20gJy4uL3Jvb20vdHlwZXMnO1xuaW1wb3J0IHsgTXV0ZXgsIGdldENsaWVudEluZm8sIGlzUmVhY3ROYXRpdmUsIHNsZWVwLCB0b1dlYnNvY2tldFVybCB9IGZyb20gJy4uL3Jvb20vdXRpbHMnO1xuaW1wb3J0IHsgQXN5bmNRdWV1ZSB9IGZyb20gJy4uL3V0aWxzL0FzeW5jUXVldWUnO1xuXG4vLyBpbnRlcm5hbCBvcHRpb25zXG5pbnRlcmZhY2UgQ29ubmVjdE9wdHMgZXh0ZW5kcyBTaWduYWxPcHRpb25zIHtcbiAgLyoqIGludGVybmFsICovXG4gIHJlY29ubmVjdD86IGJvb2xlYW47XG4gIC8qKiBpbnRlcm5hbCAqL1xuICByZWNvbm5lY3RSZWFzb24/OiBudW1iZXI7XG4gIC8qKiBpbnRlcm5hbCAqL1xuICBzaWQ/OiBzdHJpbmc7XG59XG5cbi8vIHB1YmxpYyBvcHRpb25zXG5leHBvcnQgaW50ZXJmYWNlIFNpZ25hbE9wdGlvbnMge1xuICBhdXRvU3Vic2NyaWJlOiBib29sZWFuO1xuICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgcHVibGlzaE9ubHk/OiBzdHJpbmc7XG4gIGFkYXB0aXZlU3RyZWFtPzogYm9vbGVhbjtcbiAgbWF4UmV0cmllczogbnVtYmVyO1xuICBlMmVlRW5hYmxlZDogYm9vbGVhbjtcbiAgd2Vic29ja2V0VGltZW91dDogbnVtYmVyO1xufVxuXG50eXBlIFNpZ25hbE1lc3NhZ2UgPSBTaWduYWxSZXF1ZXN0WydtZXNzYWdlJ107XG5cbnR5cGUgU2lnbmFsS2luZCA9IE5vbk51bGxhYmxlPFNpZ25hbE1lc3NhZ2U+WydjYXNlJ107XG5cbmNvbnN0IHBhc3NUaHJvdWdoUXVldWVTaWduYWxzOiBBcnJheTxTaWduYWxLaW5kPiA9IFtcbiAgJ3N5bmNTdGF0ZScsXG4gICd0cmlja2xlJyxcbiAgJ29mZmVyJyxcbiAgJ2Fuc3dlcicsXG4gICdzaW11bGF0ZScsXG4gICdsZWF2ZScsXG5dO1xuXG5mdW5jdGlvbiBjYW5QYXNzVGhyb3VnaFF1ZXVlKHJlcTogU2lnbmFsTWVzc2FnZSk6IGJvb2xlYW4ge1xuICBjb25zdCBjYW5QYXNzID0gcGFzc1Rocm91Z2hRdWV1ZVNpZ25hbHMuaW5kZXhPZihyZXEhLmNhc2UpID49IDA7XG4gIGxvZy50cmFjZSgncmVxdWVzdCBhbGxvd2VkIHRvIGJ5cGFzcyBxdWV1ZTonLCB7IGNhblBhc3MsIHJlcSB9KTtcbiAgcmV0dXJuIGNhblBhc3M7XG59XG5cbmV4cG9ydCBlbnVtIFNpZ25hbENvbm5lY3Rpb25TdGF0ZSB7XG4gIENPTk5FQ1RJTkcsXG4gIENPTk5FQ1RFRCxcbiAgUkVDT05ORUNUSU5HLFxuICBESVNDT05ORUNUSU5HLFxuICBESVNDT05ORUNURUQsXG59XG5cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjbGFzcyBTaWduYWxDbGllbnQge1xuICByZXF1ZXN0UXVldWU6IEFzeW5jUXVldWU7XG5cbiAgcXVldWVkUmVxdWVzdHM6IEFycmF5PCgpID0+IFByb21pc2U8dm9pZD4+O1xuXG4gIHVzZUpTT046IGJvb2xlYW47XG5cbiAgLyoqIHNpZ25hbCBydHQgaW4gbWlsbGlzZWNvbmRzICovXG4gIHJ0dDogbnVtYmVyID0gMDtcblxuICAvKiogc2ltdWxhdGUgc2lnbmFsaW5nIGxhdGVuY3kgYnkgZGVsYXlpbmcgbWVzc2FnZXMgKi9cbiAgc2lnbmFsTGF0ZW5jeT86IG51bWJlcjtcblxuICBvbkNsb3NlPzogKHJlYXNvbjogc3RyaW5nKSA9PiB2b2lkO1xuXG4gIG9uQW5zd2VyPzogKHNkOiBSVENTZXNzaW9uRGVzY3JpcHRpb25Jbml0KSA9PiB2b2lkO1xuXG4gIG9uT2ZmZXI/OiAoc2Q6IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbkluaXQpID0+IHZvaWQ7XG5cbiAgLy8gd2hlbiBhIG5ldyBJQ0UgY2FuZGlkYXRlIGlzIG1hZGUgYXZhaWxhYmxlXG4gIG9uVHJpY2tsZT86IChzZDogUlRDSWNlQ2FuZGlkYXRlSW5pdCwgdGFyZ2V0OiBTaWduYWxUYXJnZXQpID0+IHZvaWQ7XG5cbiAgb25QYXJ0aWNpcGFudFVwZGF0ZT86ICh1cGRhdGVzOiBQYXJ0aWNpcGFudEluZm9bXSkgPT4gdm9pZDtcblxuICBvbkxvY2FsVHJhY2tQdWJsaXNoZWQ/OiAocmVzOiBUcmFja1B1Ymxpc2hlZFJlc3BvbnNlKSA9PiB2b2lkO1xuXG4gIG9uTmVnb3RpYXRlUmVxdWVzdGVkPzogKCkgPT4gdm9pZDtcblxuICBvblNwZWFrZXJzQ2hhbmdlZD86IChyZXM6IFNwZWFrZXJJbmZvW10pID0+IHZvaWQ7XG5cbiAgb25SZW1vdGVNdXRlQ2hhbmdlZD86ICh0cmFja1NpZDogc3RyaW5nLCBtdXRlZDogYm9vbGVhbikgPT4gdm9pZDtcblxuICBvblJvb21VcGRhdGU/OiAocm9vbTogUm9vbSkgPT4gdm9pZDtcblxuICBvbkNvbm5lY3Rpb25RdWFsaXR5PzogKHVwZGF0ZTogQ29ubmVjdGlvblF1YWxpdHlVcGRhdGUpID0+IHZvaWQ7XG5cbiAgb25TdHJlYW1TdGF0ZVVwZGF0ZT86ICh1cGRhdGU6IFN0cmVhbVN0YXRlVXBkYXRlKSA9PiB2b2lkO1xuXG4gIG9uU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGU/OiAodXBkYXRlOiBTdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSkgPT4gdm9pZDtcblxuICBvblN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGU/OiAodXBkYXRlOiBTdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlKSA9PiB2b2lkO1xuXG4gIG9uU3Vic2NyaXB0aW9uRXJyb3I/OiAodXBkYXRlOiBTdWJzY3JpcHRpb25SZXNwb25zZSkgPT4gdm9pZDtcblxuICBvbkxvY2FsVHJhY2tVbnB1Ymxpc2hlZD86IChyZXM6IFRyYWNrVW5wdWJsaXNoZWRSZXNwb25zZSkgPT4gdm9pZDtcblxuICBvblRva2VuUmVmcmVzaD86ICh0b2tlbjogc3RyaW5nKSA9PiB2b2lkO1xuXG4gIG9uTGVhdmU/OiAobGVhdmU6IExlYXZlUmVxdWVzdCkgPT4gdm9pZDtcblxuICBjb25uZWN0T3B0aW9ucz86IENvbm5lY3RPcHRzO1xuXG4gIHdzPzogV2ViU29ja2V0O1xuXG4gIGdldCBjdXJyZW50U3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGU7XG4gIH1cblxuICBnZXQgaXNEaXNjb25uZWN0ZWQoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMuc3RhdGUgPT09IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5ESVNDT05ORUNUSU5HIHx8XG4gICAgICB0aGlzLnN0YXRlID09PSBTaWduYWxDb25uZWN0aW9uU3RhdGUuRElTQ09OTkVDVEVEXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0IGlzRXN0YWJsaXNoaW5nQ29ubmVjdGlvbigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5zdGF0ZSA9PT0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkNPTk5FQ1RJTkcgfHxcbiAgICAgIHRoaXMuc3RhdGUgPT09IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5SRUNPTk5FQ1RJTkdcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBvcHRpb25zPzogU2lnbmFsT3B0aW9ucztcblxuICBwcml2YXRlIHBpbmdUaW1lb3V0OiBSZXR1cm5UeXBlPHR5cGVvZiBzZXRUaW1lb3V0PiB8IHVuZGVmaW5lZDtcblxuICBwcml2YXRlIHBpbmdUaW1lb3V0RHVyYXRpb246IG51bWJlciB8IHVuZGVmaW5lZDtcblxuICBwcml2YXRlIHBpbmdJbnRlcnZhbER1cmF0aW9uOiBudW1iZXIgfCB1bmRlZmluZWQ7XG5cbiAgcHJpdmF0ZSBwaW5nSW50ZXJ2YWw6IFJldHVyblR5cGU8dHlwZW9mIHNldEludGVydmFsPiB8IHVuZGVmaW5lZDtcblxuICBwcml2YXRlIGNsb3NpbmdMb2NrOiBNdXRleDtcblxuICBwcml2YXRlIHN0YXRlOiBTaWduYWxDb25uZWN0aW9uU3RhdGUgPSBTaWduYWxDb25uZWN0aW9uU3RhdGUuRElTQ09OTkVDVEVEO1xuXG4gIHByaXZhdGUgY29ubmVjdGlvbkxvY2s6IE11dGV4O1xuXG4gIHByaXZhdGUgbG9nID0gbG9nO1xuXG4gIHByaXZhdGUgbG9nZ2VyQ29udGV4dENiPzogTG9nZ2VyT3B0aW9uc1snbG9nZ2VyQ29udGV4dENiJ107XG5cbiAgY29uc3RydWN0b3IodXNlSlNPTjogYm9vbGVhbiA9IGZhbHNlLCBsb2dnZXJPcHRpb25zOiBMb2dnZXJPcHRpb25zID0ge30pIHtcbiAgICB0aGlzLmxvZyA9IGdldExvZ2dlcihsb2dnZXJPcHRpb25zLmxvZ2dlck5hbWUgPz8gTG9nZ2VyTmFtZXMuU2lnbmFsKTtcbiAgICB0aGlzLmxvZ2dlckNvbnRleHRDYiA9IGxvZ2dlck9wdGlvbnMubG9nZ2VyQ29udGV4dENiO1xuICAgIHRoaXMudXNlSlNPTiA9IHVzZUpTT047XG4gICAgdGhpcy5yZXF1ZXN0UXVldWUgPSBuZXcgQXN5bmNRdWV1ZSgpO1xuICAgIHRoaXMucXVldWVkUmVxdWVzdHMgPSBbXTtcbiAgICB0aGlzLmNsb3NpbmdMb2NrID0gbmV3IE11dGV4KCk7XG4gICAgdGhpcy5jb25uZWN0aW9uTG9jayA9IG5ldyBNdXRleCgpO1xuICAgIHRoaXMuc3RhdGUgPSBTaWduYWxDb25uZWN0aW9uU3RhdGUuRElTQ09OTkVDVEVEO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXQgbG9nQ29udGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5sb2dnZXJDb250ZXh0Q2I/LigpID8/IHt9O1xuICB9XG5cbiAgYXN5bmMgam9pbihcbiAgICB1cmw6IHN0cmluZyxcbiAgICB0b2tlbjogc3RyaW5nLFxuICAgIG9wdHM6IFNpZ25hbE9wdGlvbnMsXG4gICAgYWJvcnRTaWduYWw/OiBBYm9ydFNpZ25hbCxcbiAgKTogUHJvbWlzZTxKb2luUmVzcG9uc2U+IHtcbiAgICAvLyBkdXJpbmcgYSBmdWxsIHJlY29ubmVjdCwgd2UnZCB3YW50IHRvIHN0YXJ0IHRoZSBzZXF1ZW5jZSBldmVuIGlmIGN1cnJlbnRseVxuICAgIC8vIGNvbm5lY3RlZFxuICAgIHRoaXMuc3RhdGUgPSBTaWduYWxDb25uZWN0aW9uU3RhdGUuQ09OTkVDVElORztcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRzO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuY29ubmVjdCh1cmwsIHRva2VuLCBvcHRzLCBhYm9ydFNpZ25hbCk7XG4gICAgcmV0dXJuIHJlcyBhcyBKb2luUmVzcG9uc2U7XG4gIH1cblxuICBhc3luYyByZWNvbm5lY3QoXG4gICAgdXJsOiBzdHJpbmcsXG4gICAgdG9rZW46IHN0cmluZyxcbiAgICBzaWQ/OiBzdHJpbmcsXG4gICAgcmVhc29uPzogUmVjb25uZWN0UmVhc29uLFxuICApOiBQcm9taXNlPFJlY29ubmVjdFJlc3BvbnNlIHwgdm9pZD4ge1xuICAgIGlmICghdGhpcy5vcHRpb25zKSB7XG4gICAgICB0aGlzLmxvZy53YXJuKFxuICAgICAgICAnYXR0ZW1wdGVkIHRvIHJlY29ubmVjdCB3aXRob3V0IHNpZ25hbCBvcHRpb25zIGJlaW5nIHNldCwgaWdub3JpbmcnLFxuICAgICAgICB0aGlzLmxvZ0NvbnRleHQsXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlID0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLlJFQ09OTkVDVElORztcbiAgICAvLyBjbGVhciBwaW5nIGludGVydmFsIGFuZCByZXN0YXJ0IGl0IG9uY2UgcmVjb25uZWN0ZWRcbiAgICB0aGlzLmNsZWFyUGluZ0ludGVydmFsKCk7XG5cbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmNvbm5lY3QodXJsLCB0b2tlbiwge1xuICAgICAgLi4udGhpcy5vcHRpb25zLFxuICAgICAgcmVjb25uZWN0OiB0cnVlLFxuICAgICAgc2lkLFxuICAgICAgcmVjb25uZWN0UmVhc29uOiByZWFzb24sXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIHByaXZhdGUgY29ubmVjdChcbiAgICB1cmw6IHN0cmluZyxcbiAgICB0b2tlbjogc3RyaW5nLFxuICAgIG9wdHM6IENvbm5lY3RPcHRzLFxuICAgIGFib3J0U2lnbmFsPzogQWJvcnRTaWduYWwsXG4gICk6IFByb21pc2U8Sm9pblJlc3BvbnNlIHwgUmVjb25uZWN0UmVzcG9uc2UgfCB2b2lkPiB7XG4gICAgdGhpcy5jb25uZWN0T3B0aW9ucyA9IG9wdHM7XG4gICAgdXJsID0gdG9XZWJzb2NrZXRVcmwodXJsKTtcbiAgICAvLyBzdHJpcCB0cmFpbGluZyBzbGFzaFxuICAgIHVybCA9IHVybC5yZXBsYWNlKC9cXC8kLywgJycpO1xuICAgIHVybCArPSAnL3J0Yyc7XG5cbiAgICBjb25zdCBjbGllbnRJbmZvID0gZ2V0Q2xpZW50SW5mbygpO1xuICAgIGNvbnN0IHBhcmFtcyA9IGNyZWF0ZUNvbm5lY3Rpb25QYXJhbXModG9rZW4sIGNsaWVudEluZm8sIG9wdHMpO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPEpvaW5SZXNwb25zZSB8IFJlY29ubmVjdFJlc3BvbnNlIHwgdm9pZD4oYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgdW5sb2NrID0gYXdhaXQgdGhpcy5jb25uZWN0aW9uTG9jay5sb2NrKCk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBhYm9ydEhhbmRsZXIgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgIGNsZWFyVGltZW91dCh3c1RpbWVvdXQpO1xuICAgICAgICAgIHJlamVjdChuZXcgQ29ubmVjdGlvbkVycm9yKCdyb29tIGNvbm5lY3Rpb24gaGFzIGJlZW4gY2FuY2VsbGVkIChzaWduYWwpJykpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHdzVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICByZWplY3QobmV3IENvbm5lY3Rpb25FcnJvcigncm9vbSBjb25uZWN0aW9uIGhhcyB0aW1lZCBvdXQgKHNpZ25hbCknKSk7XG4gICAgICAgIH0sIG9wdHMud2Vic29ja2V0VGltZW91dCk7XG5cbiAgICAgICAgaWYgKGFib3J0U2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICAgICAgYWJvcnRIYW5kbGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgYWJvcnRTaWduYWw/LmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRIYW5kbGVyKTtcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoYGNvbm5lY3RpbmcgdG8gJHt1cmwgKyBwYXJhbXN9YCwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgaWYgKHRoaXMud3MpIHtcbiAgICAgICAgICBhd2FpdCB0aGlzLmNsb3NlKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndzID0gbmV3IFdlYlNvY2tldCh1cmwgKyBwYXJhbXMpO1xuICAgICAgICB0aGlzLndzLmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInO1xuXG4gICAgICAgIHRoaXMud3Mub25vcGVuID0gKCkgPT4ge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh3c1RpbWVvdXQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMud3Mub25lcnJvciA9IGFzeW5jIChldjogRXZlbnQpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkNPTk5FQ1RFRCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHdzVGltZW91dCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCByZXNwID0gYXdhaXQgZmV0Y2goYGh0dHAke3VybC5zdWJzdHJpbmcoMil9L3ZhbGlkYXRlJHtwYXJhbXN9YCk7XG4gICAgICAgICAgICAgIGlmIChyZXNwLnN0YXR1cy50b0ZpeGVkKDApLnN0YXJ0c1dpdGgoJzQnKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1zZyA9IGF3YWl0IHJlc3AudGV4dCgpO1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgQ29ubmVjdGlvbkVycm9yKG1zZywgQ29ubmVjdGlvbkVycm9yUmVhc29uLk5vdEFsbG93ZWQsIHJlc3Auc3RhdHVzKSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgICAgICAgbmV3IENvbm5lY3Rpb25FcnJvcihcbiAgICAgICAgICAgICAgICAgICAgJ0ludGVybmFsIGVycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgQ29ubmVjdGlvbkVycm9yUmVhc29uLkludGVybmFsRXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIHJlc3Auc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgICAgICBuZXcgQ29ubmVjdGlvbkVycm9yKFxuICAgICAgICAgICAgICAgICAgJ3NlcnZlciB3YXMgbm90IHJlYWNoYWJsZScsXG4gICAgICAgICAgICAgICAgICBDb25uZWN0aW9uRXJyb3JSZWFzb24uU2VydmVyVW5yZWFjaGFibGUsXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gb3RoZXIgZXJyb3JzLCBoYW5kbGVcbiAgICAgICAgICB0aGlzLmhhbmRsZVdTRXJyb3IoZXYpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMud3Mub25tZXNzYWdlID0gYXN5bmMgKGV2OiBNZXNzYWdlRXZlbnQpID0+IHtcbiAgICAgICAgICAvLyBub3QgY29uc2lkZXJlZCBjb25uZWN0ZWQgdW50aWwgSm9pblJlc3BvbnNlIGlzIHJlY2VpdmVkXG4gICAgICAgICAgbGV0IHJlc3A6IFNpZ25hbFJlc3BvbnNlO1xuICAgICAgICAgIGlmICh0eXBlb2YgZXYuZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnN0IGpzb24gPSBKU09OLnBhcnNlKGV2LmRhdGEpO1xuICAgICAgICAgICAgcmVzcCA9IFNpZ25hbFJlc3BvbnNlLmZyb21Kc29uKGpzb24pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZXYuZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICByZXNwID0gU2lnbmFsUmVzcG9uc2UuZnJvbUJpbmFyeShuZXcgVWludDhBcnJheShldi5kYXRhKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG9nLmVycm9yKFxuICAgICAgICAgICAgICBgY291bGQgbm90IGRlY29kZSB3ZWJzb2NrZXQgbWVzc2FnZTogJHt0eXBlb2YgZXYuZGF0YX1gLFxuICAgICAgICAgICAgICB0aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBTaWduYWxDb25uZWN0aW9uU3RhdGUuQ09OTkVDVEVEKSB7XG4gICAgICAgICAgICBsZXQgc2hvdWxkUHJvY2Vzc01lc3NhZ2UgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIGhhbmRsZSBqb2luIG1lc3NhZ2Ugb25seVxuICAgICAgICAgICAgaWYgKHJlc3AubWVzc2FnZT8uY2FzZSA9PT0gJ2pvaW4nKSB7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTaWduYWxDb25uZWN0aW9uU3RhdGUuQ09OTkVDVEVEO1xuICAgICAgICAgICAgICBhYm9ydFNpZ25hbD8ucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEhhbmRsZXIpO1xuICAgICAgICAgICAgICB0aGlzLnBpbmdUaW1lb3V0RHVyYXRpb24gPSByZXNwLm1lc3NhZ2UudmFsdWUucGluZ1RpbWVvdXQ7XG4gICAgICAgICAgICAgIHRoaXMucGluZ0ludGVydmFsRHVyYXRpb24gPSByZXNwLm1lc3NhZ2UudmFsdWUucGluZ0ludGVydmFsO1xuXG4gICAgICAgICAgICAgIGlmICh0aGlzLnBpbmdUaW1lb3V0RHVyYXRpb24gJiYgdGhpcy5waW5nVGltZW91dER1cmF0aW9uID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCdwaW5nIGNvbmZpZycsIHtcbiAgICAgICAgICAgICAgICAgIC4uLnRoaXMubG9nQ29udGV4dCxcbiAgICAgICAgICAgICAgICAgIHRpbWVvdXQ6IHRoaXMucGluZ1RpbWVvdXREdXJhdGlvbixcbiAgICAgICAgICAgICAgICAgIGludGVydmFsOiB0aGlzLnBpbmdJbnRlcnZhbER1cmF0aW9uLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRQaW5nSW50ZXJ2YWwoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3AubWVzc2FnZS52YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICB0aGlzLnN0YXRlID09PSBTaWduYWxDb25uZWN0aW9uU3RhdGUuUkVDT05ORUNUSU5HICYmXG4gICAgICAgICAgICAgIHJlc3AubWVzc2FnZS5jYXNlICE9PSAnbGVhdmUnXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgLy8gaW4gcmVjb25uZWN0aW5nLCBhbnkgbWVzc2FnZSByZWNlaXZlZCBtZWFucyBzaWduYWwgcmVjb25uZWN0ZWRcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5DT05ORUNURUQ7XG4gICAgICAgICAgICAgIGFib3J0U2lnbmFsPy5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0SGFuZGxlcik7XG4gICAgICAgICAgICAgIHRoaXMuc3RhcnRQaW5nSW50ZXJ2YWwoKTtcbiAgICAgICAgICAgICAgaWYgKHJlc3AubWVzc2FnZT8uY2FzZSA9PT0gJ3JlY29ubmVjdCcpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3AubWVzc2FnZT8udmFsdWUpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICBzaG91bGRQcm9jZXNzTWVzc2FnZSA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0VzdGFibGlzaGluZ0Nvbm5lY3Rpb24gJiYgcmVzcC5tZXNzYWdlLmNhc2UgPT09ICdsZWF2ZScpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgICAgIG5ldyBDb25uZWN0aW9uRXJyb3IoXG4gICAgICAgICAgICAgICAgICAnUmVjZWl2ZWQgbGVhdmUgcmVxdWVzdCB3aGlsZSB0cnlpbmcgdG8gKHJlKWNvbm5lY3QnLFxuICAgICAgICAgICAgICAgICAgQ29ubmVjdGlvbkVycm9yUmVhc29uLkxlYXZlUmVxdWVzdCxcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghb3B0cy5yZWNvbm5lY3QpIHtcbiAgICAgICAgICAgICAgLy8gbm9uLXJlY29ubmVjdCBjYXNlLCBzaG91bGQgcmVjZWl2ZSBqb2luIHJlc3BvbnNlIGZpcnN0XG4gICAgICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgICAgICBuZXcgQ29ubmVjdGlvbkVycm9yKFxuICAgICAgICAgICAgICAgICAgYGRpZCBub3QgcmVjZWl2ZSBqb2luIHJlc3BvbnNlLCBnb3QgJHtyZXNwLm1lc3NhZ2U/LmNhc2V9IGluc3RlYWRgLFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNob3VsZFByb2Nlc3NNZXNzYWdlKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5zaWduYWxMYXRlbmN5KSB7XG4gICAgICAgICAgICBhd2FpdCBzbGVlcCh0aGlzLnNpZ25hbExhdGVuY3kpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmhhbmRsZVNpZ25hbFJlc3BvbnNlKHJlc3ApO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMud3Mub25jbG9zZSA9IChldjogQ2xvc2VFdmVudCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmlzRXN0YWJsaXNoaW5nQ29ubmVjdGlvbikge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBDb25uZWN0aW9uRXJyb3IoJ1dlYnNvY2tldCBnb3QgY2xvc2VkIGR1cmluZyBhIChyZSljb25uZWN0aW9uIGF0dGVtcHQnKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5sb2cud2Fybihgd2Vic29ja2V0IGNsb3NlZGAsIHtcbiAgICAgICAgICAgIC4uLnRoaXMubG9nQ29udGV4dCxcbiAgICAgICAgICAgIHJlYXNvbjogZXYucmVhc29uLFxuICAgICAgICAgICAgc3RhdGU6IHRoaXMuc3RhdGUsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5oYW5kbGVPbkNsb3NlKGV2LnJlYXNvbik7XG4gICAgICAgIH07XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB1bmxvY2soKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcmVzZXRDYWxsYmFja3MgPSAoKSA9PiB7XG4gICAgdGhpcy5vbkFuc3dlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm9uTGVhdmUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vbkxvY2FsVHJhY2tQdWJsaXNoZWQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vbkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm9uTmVnb3RpYXRlUmVxdWVzdGVkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub25PZmZlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm9uUmVtb3RlTXV0ZUNoYW5nZWQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vblN1YnNjcmliZWRRdWFsaXR5VXBkYXRlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub25Ub2tlblJlZnJlc2ggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vblRyaWNrbGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vbkNsb3NlID0gdW5kZWZpbmVkO1xuICB9O1xuXG4gIGFzeW5jIGNsb3NlKHVwZGF0ZVN0YXRlOiBib29sZWFuID0gdHJ1ZSkge1xuICAgIGNvbnN0IHVubG9jayA9IGF3YWl0IHRoaXMuY2xvc2luZ0xvY2subG9jaygpO1xuICAgIHRyeSB7XG4gICAgICBpZiAodXBkYXRlU3RhdGUpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5ESVNDT05ORUNUSU5HO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMud3MpIHtcbiAgICAgICAgdGhpcy53cy5vbm1lc3NhZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLndzLm9ub3BlbiA9IG51bGw7XG4gICAgICAgIHRoaXMud3Mub25jbG9zZSA9IG51bGw7XG5cbiAgICAgICAgLy8gY2FsbGluZyBgd3MuY2xvc2UoKWAgb25seSBzdGFydHMgdGhlIGNsb3NpbmcgaGFuZHNoYWtlIChDTE9TSU5HIHN0YXRlKSwgcHJlZmVyIHRvIHdhaXQgdW50aWwgc3RhdGUgaXMgYWN0dWFsbHkgQ0xPU0VEXG4gICAgICAgIGNvbnN0IGNsb3NlUHJvbWlzZSA9IG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMud3MpIHtcbiAgICAgICAgICAgIHRoaXMud3Mub25jbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHRoaXMud3MucmVhZHlTdGF0ZSA8IHRoaXMud3MuQ0xPU0lORykge1xuICAgICAgICAgIHRoaXMud3MuY2xvc2UoKTtcbiAgICAgICAgICAvLyAyNTBtcyBncmFjZSBwZXJpb2QgZm9yIHdzIHRvIGNsb3NlIGdyYWNlZnVsbHlcbiAgICAgICAgICBhd2FpdCBQcm9taXNlLnJhY2UoW2Nsb3NlUHJvbWlzZSwgc2xlZXAoMjUwKV0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud3MgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmICh1cGRhdGVTdGF0ZSkge1xuICAgICAgICB0aGlzLnN0YXRlID0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkRJU0NPTk5FQ1RFRDtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2xlYXJQaW5nSW50ZXJ2YWwoKTtcbiAgICAgIHVubG9jaygpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGluaXRpYWwgb2ZmZXIgYWZ0ZXIgam9pbmluZ1xuICBzZW5kT2ZmZXIob2ZmZXI6IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbkluaXQpIHtcbiAgICB0aGlzLmxvZy5kZWJ1Zygnc2VuZGluZyBvZmZlcicsIHsgLi4udGhpcy5sb2dDb250ZXh0LCBvZmZlclNkcDogb2ZmZXIuc2RwIH0pO1xuICAgIHRoaXMuc2VuZFJlcXVlc3Qoe1xuICAgICAgY2FzZTogJ29mZmVyJyxcbiAgICAgIHZhbHVlOiB0b1Byb3RvU2Vzc2lvbkRlc2NyaXB0aW9uKG9mZmVyKSxcbiAgICB9KTtcbiAgfVxuXG4gIC8vIGFuc3dlciBhIHNlcnZlci1pbml0aWF0ZWQgb2ZmZXJcbiAgc2VuZEFuc3dlcihhbnN3ZXI6IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbkluaXQpIHtcbiAgICB0aGlzLmxvZy5kZWJ1Zygnc2VuZGluZyBhbnN3ZXInLCB7IC4uLnRoaXMubG9nQ29udGV4dCwgYW5zd2VyU2RwOiBhbnN3ZXIuc2RwIH0pO1xuICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KHtcbiAgICAgIGNhc2U6ICdhbnN3ZXInLFxuICAgICAgdmFsdWU6IHRvUHJvdG9TZXNzaW9uRGVzY3JpcHRpb24oYW5zd2VyKSxcbiAgICB9KTtcbiAgfVxuXG4gIHNlbmRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlOiBSVENJY2VDYW5kaWRhdGVJbml0LCB0YXJnZXQ6IFNpZ25hbFRhcmdldCkge1xuICAgIHRoaXMubG9nLnRyYWNlKCdzZW5kaW5nIGljZSBjYW5kaWRhdGUnLCB7IC4uLnRoaXMubG9nQ29udGV4dCwgY2FuZGlkYXRlIH0pO1xuICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KHtcbiAgICAgIGNhc2U6ICd0cmlja2xlJyxcbiAgICAgIHZhbHVlOiBuZXcgVHJpY2tsZVJlcXVlc3Qoe1xuICAgICAgICBjYW5kaWRhdGVJbml0OiBKU09OLnN0cmluZ2lmeShjYW5kaWRhdGUpLFxuICAgICAgICB0YXJnZXQsXG4gICAgICB9KSxcbiAgICB9KTtcbiAgfVxuXG4gIHNlbmRNdXRlVHJhY2sodHJhY2tTaWQ6IHN0cmluZywgbXV0ZWQ6IGJvb2xlYW4pIHtcbiAgICByZXR1cm4gdGhpcy5zZW5kUmVxdWVzdCh7XG4gICAgICBjYXNlOiAnbXV0ZScsXG4gICAgICB2YWx1ZTogbmV3IE11dGVUcmFja1JlcXVlc3Qoe1xuICAgICAgICBzaWQ6IHRyYWNrU2lkLFxuICAgICAgICBtdXRlZCxcbiAgICAgIH0pLFxuICAgIH0pO1xuICB9XG5cbiAgc2VuZEFkZFRyYWNrKHJlcTogQWRkVHJhY2tSZXF1ZXN0KSB7XG4gICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3Qoe1xuICAgICAgY2FzZTogJ2FkZFRyYWNrJyxcbiAgICAgIHZhbHVlOiByZXEsXG4gICAgfSk7XG4gIH1cblxuICBzZW5kVXBkYXRlTG9jYWxNZXRhZGF0YShtZXRhZGF0YTogc3RyaW5nLCBuYW1lOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5zZW5kUmVxdWVzdCh7XG4gICAgICBjYXNlOiAndXBkYXRlTWV0YWRhdGEnLFxuICAgICAgdmFsdWU6IG5ldyBVcGRhdGVQYXJ0aWNpcGFudE1ldGFkYXRhKHtcbiAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgIG5hbWUsXG4gICAgICB9KSxcbiAgICB9KTtcbiAgfVxuXG4gIHNlbmRVcGRhdGVUcmFja1NldHRpbmdzKHNldHRpbmdzOiBVcGRhdGVUcmFja1NldHRpbmdzKSB7XG4gICAgdGhpcy5zZW5kUmVxdWVzdCh7XG4gICAgICBjYXNlOiAndHJhY2tTZXR0aW5nJyxcbiAgICAgIHZhbHVlOiBzZXR0aW5ncyxcbiAgICB9KTtcbiAgfVxuXG4gIHNlbmRVcGRhdGVTdWJzY3JpcHRpb24oc3ViOiBVcGRhdGVTdWJzY3JpcHRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5zZW5kUmVxdWVzdCh7XG4gICAgICBjYXNlOiAnc3Vic2NyaXB0aW9uJyxcbiAgICAgIHZhbHVlOiBzdWIsXG4gICAgfSk7XG4gIH1cblxuICBzZW5kU3luY1N0YXRlKHN5bmM6IFN5bmNTdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KHtcbiAgICAgIGNhc2U6ICdzeW5jU3RhdGUnLFxuICAgICAgdmFsdWU6IHN5bmMsXG4gICAgfSk7XG4gIH1cblxuICBzZW5kVXBkYXRlVmlkZW9MYXllcnModHJhY2tTaWQ6IHN0cmluZywgbGF5ZXJzOiBWaWRlb0xheWVyW10pIHtcbiAgICByZXR1cm4gdGhpcy5zZW5kUmVxdWVzdCh7XG4gICAgICBjYXNlOiAndXBkYXRlTGF5ZXJzJyxcbiAgICAgIHZhbHVlOiBuZXcgVXBkYXRlVmlkZW9MYXllcnMoe1xuICAgICAgICB0cmFja1NpZCxcbiAgICAgICAgbGF5ZXJzLFxuICAgICAgfSksXG4gICAgfSk7XG4gIH1cblxuICBzZW5kVXBkYXRlU3Vic2NyaXB0aW9uUGVybWlzc2lvbnMoYWxsUGFydGljaXBhbnRzOiBib29sZWFuLCB0cmFja1Blcm1pc3Npb25zOiBUcmFja1Blcm1pc3Npb25bXSkge1xuICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KHtcbiAgICAgIGNhc2U6ICdzdWJzY3JpcHRpb25QZXJtaXNzaW9uJyxcbiAgICAgIHZhbHVlOiBuZXcgU3Vic2NyaXB0aW9uUGVybWlzc2lvbih7XG4gICAgICAgIGFsbFBhcnRpY2lwYW50cyxcbiAgICAgICAgdHJhY2tQZXJtaXNzaW9ucyxcbiAgICAgIH0pLFxuICAgIH0pO1xuICB9XG5cbiAgc2VuZFNpbXVsYXRlU2NlbmFyaW8oc2NlbmFyaW86IFNpbXVsYXRlU2NlbmFyaW8pIHtcbiAgICByZXR1cm4gdGhpcy5zZW5kUmVxdWVzdCh7XG4gICAgICBjYXNlOiAnc2ltdWxhdGUnLFxuICAgICAgdmFsdWU6IHNjZW5hcmlvLFxuICAgIH0pO1xuICB9XG5cbiAgc2VuZFBpbmcoKSB7XG4gICAgLyoqIHNlbmQgYm90aCBvZiBwaW5nIGFuZCBwaW5nUmVxIGZvciBjb21wYXRpYmlsaXR5IHRvIG9sZCBhbmQgbmV3IHNlcnZlciAqL1xuICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICB0aGlzLnNlbmRSZXF1ZXN0KHtcbiAgICAgICAgY2FzZTogJ3BpbmcnLFxuICAgICAgICB2YWx1ZTogcHJvdG9JbnQ2NC5wYXJzZShEYXRlLm5vdygpKSxcbiAgICAgIH0pLFxuICAgICAgdGhpcy5zZW5kUmVxdWVzdCh7XG4gICAgICAgIGNhc2U6ICdwaW5nUmVxJyxcbiAgICAgICAgdmFsdWU6IG5ldyBQaW5nKHtcbiAgICAgICAgICB0aW1lc3RhbXA6IHByb3RvSW50NjQucGFyc2UoRGF0ZS5ub3coKSksXG4gICAgICAgICAgcnR0OiBwcm90b0ludDY0LnBhcnNlKHRoaXMucnR0KSxcbiAgICAgICAgfSksXG4gICAgICB9KSxcbiAgICBdKTtcbiAgfVxuXG4gIHNlbmRMZWF2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zZW5kUmVxdWVzdCh7XG4gICAgICBjYXNlOiAnbGVhdmUnLFxuICAgICAgdmFsdWU6IG5ldyBMZWF2ZVJlcXVlc3Qoe1xuICAgICAgICBjYW5SZWNvbm5lY3Q6IGZhbHNlLFxuICAgICAgICByZWFzb246IERpc2Nvbm5lY3RSZWFzb24uQ0xJRU5UX0lOSVRJQVRFRCxcbiAgICAgIH0pLFxuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgc2VuZFJlcXVlc3QobWVzc2FnZTogU2lnbmFsTWVzc2FnZSwgZnJvbVF1ZXVlOiBib29sZWFuID0gZmFsc2UpIHtcbiAgICAvLyBjYXB0dXJlIGFsbCByZXF1ZXN0cyB3aGlsZSByZWNvbm5lY3RpbmcgYW5kIHB1dCB0aGVtIGluIGEgcXVldWVcbiAgICAvLyB1bmxlc3MgdGhlIHJlcXVlc3Qgb3JpZ2luYXRlcyBmcm9tIHRoZSBxdWV1ZSwgdGhlbiBkb24ndCBlbnF1ZXVlIGFnYWluXG4gICAgY29uc3QgY2FuUXVldWUgPSAhZnJvbVF1ZXVlICYmICFjYW5QYXNzVGhyb3VnaFF1ZXVlKG1lc3NhZ2UpO1xuICAgIGlmIChjYW5RdWV1ZSAmJiB0aGlzLnN0YXRlID09PSBTaWduYWxDb25uZWN0aW9uU3RhdGUuUkVDT05ORUNUSU5HKSB7XG4gICAgICB0aGlzLnF1ZXVlZFJlcXVlc3RzLnB1c2goYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCB0aGlzLnNlbmRSZXF1ZXN0KG1lc3NhZ2UsIHRydWUpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIG1ha2Ugc3VyZSBwcmV2aW91c2x5IHF1ZXVlZCByZXF1ZXN0cyBhcmUgYmVpbmcgc2VudCBmaXJzdFxuICAgIGlmICghZnJvbVF1ZXVlKSB7XG4gICAgICBhd2FpdCB0aGlzLnJlcXVlc3RRdWV1ZS5mbHVzaCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5zaWduYWxMYXRlbmN5KSB7XG4gICAgICBhd2FpdCBzbGVlcCh0aGlzLnNpZ25hbExhdGVuY3kpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMud3MgfHwgdGhpcy53cy5yZWFkeVN0YXRlICE9PSB0aGlzLndzLk9QRU4pIHtcbiAgICAgIHRoaXMubG9nLmVycm9yKFxuICAgICAgICBgY2Fubm90IHNlbmQgc2lnbmFsIHJlcXVlc3QgYmVmb3JlIGNvbm5lY3RlZCwgdHlwZTogJHttZXNzYWdlPy5jYXNlfWAsXG4gICAgICAgIHRoaXMubG9nQ29udGV4dCxcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlcSA9IG5ldyBTaWduYWxSZXF1ZXN0KHsgbWVzc2FnZSB9KTtcblxuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy51c2VKU09OKSB7XG4gICAgICAgIHRoaXMud3Muc2VuZChyZXEudG9Kc29uU3RyaW5nKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy53cy5zZW5kKHJlcS50b0JpbmFyeSgpKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aGlzLmxvZy5lcnJvcignZXJyb3Igc2VuZGluZyBzaWduYWwgbWVzc2FnZScsIHsgLi4udGhpcy5sb2dDb250ZXh0LCBlcnJvcjogZSB9KTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZVNpZ25hbFJlc3BvbnNlKHJlczogU2lnbmFsUmVzcG9uc2UpIHtcbiAgICBjb25zdCBtc2cgPSByZXMubWVzc2FnZTtcbiAgICBpZiAobXNnID09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5sb2cuZGVidWcoJ3JlY2VpdmVkIHVuc3VwcG9ydGVkIG1lc3NhZ2UnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBwaW5nSGFuZGxlZCA9IGZhbHNlO1xuICAgIGlmIChtc2cuY2FzZSA9PT0gJ2Fuc3dlcicpIHtcbiAgICAgIGNvbnN0IHNkID0gZnJvbVByb3RvU2Vzc2lvbkRlc2NyaXB0aW9uKG1zZy52YWx1ZSk7XG4gICAgICBpZiAodGhpcy5vbkFuc3dlcikge1xuICAgICAgICB0aGlzLm9uQW5zd2VyKHNkKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAnb2ZmZXInKSB7XG4gICAgICBjb25zdCBzZCA9IGZyb21Qcm90b1Nlc3Npb25EZXNjcmlwdGlvbihtc2cudmFsdWUpO1xuICAgICAgaWYgKHRoaXMub25PZmZlcikge1xuICAgICAgICB0aGlzLm9uT2ZmZXIoc2QpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICd0cmlja2xlJykge1xuICAgICAgY29uc3QgY2FuZGlkYXRlOiBSVENJY2VDYW5kaWRhdGVJbml0ID0gSlNPTi5wYXJzZShtc2cudmFsdWUuY2FuZGlkYXRlSW5pdCEpO1xuICAgICAgaWYgKHRoaXMub25Ucmlja2xlKSB7XG4gICAgICAgIHRoaXMub25Ucmlja2xlKGNhbmRpZGF0ZSwgbXNnLnZhbHVlLnRhcmdldCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3VwZGF0ZScpIHtcbiAgICAgIGlmICh0aGlzLm9uUGFydGljaXBhbnRVcGRhdGUpIHtcbiAgICAgICAgdGhpcy5vblBhcnRpY2lwYW50VXBkYXRlKG1zZy52YWx1ZS5wYXJ0aWNpcGFudHMgPz8gW10pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICd0cmFja1B1Ymxpc2hlZCcpIHtcbiAgICAgIGlmICh0aGlzLm9uTG9jYWxUcmFja1B1Ymxpc2hlZCkge1xuICAgICAgICB0aGlzLm9uTG9jYWxUcmFja1B1Ymxpc2hlZChtc2cudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICdzcGVha2Vyc0NoYW5nZWQnKSB7XG4gICAgICBpZiAodGhpcy5vblNwZWFrZXJzQ2hhbmdlZCkge1xuICAgICAgICB0aGlzLm9uU3BlYWtlcnNDaGFuZ2VkKG1zZy52YWx1ZS5zcGVha2VycyA/PyBbXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ2xlYXZlJykge1xuICAgICAgaWYgKHRoaXMub25MZWF2ZSkge1xuICAgICAgICB0aGlzLm9uTGVhdmUobXNnLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAnbXV0ZScpIHtcbiAgICAgIGlmICh0aGlzLm9uUmVtb3RlTXV0ZUNoYW5nZWQpIHtcbiAgICAgICAgdGhpcy5vblJlbW90ZU11dGVDaGFuZ2VkKG1zZy52YWx1ZS5zaWQsIG1zZy52YWx1ZS5tdXRlZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3Jvb21VcGRhdGUnKSB7XG4gICAgICBpZiAodGhpcy5vblJvb21VcGRhdGUgJiYgbXNnLnZhbHVlLnJvb20pIHtcbiAgICAgICAgdGhpcy5vblJvb21VcGRhdGUobXNnLnZhbHVlLnJvb20pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICdjb25uZWN0aW9uUXVhbGl0eScpIHtcbiAgICAgIGlmICh0aGlzLm9uQ29ubmVjdGlvblF1YWxpdHkpIHtcbiAgICAgICAgdGhpcy5vbkNvbm5lY3Rpb25RdWFsaXR5KG1zZy52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3N0cmVhbVN0YXRlVXBkYXRlJykge1xuICAgICAgaWYgKHRoaXMub25TdHJlYW1TdGF0ZVVwZGF0ZSkge1xuICAgICAgICB0aGlzLm9uU3RyZWFtU3RhdGVVcGRhdGUobXNnLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAnc3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUnKSB7XG4gICAgICBpZiAodGhpcy5vblN1YnNjcmliZWRRdWFsaXR5VXBkYXRlKSB7XG4gICAgICAgIHRoaXMub25TdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZShtc2cudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICdzdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlJykge1xuICAgICAgaWYgKHRoaXMub25TdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlKSB7XG4gICAgICAgIHRoaXMub25TdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlKG1zZy52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3JlZnJlc2hUb2tlbicpIHtcbiAgICAgIGlmICh0aGlzLm9uVG9rZW5SZWZyZXNoKSB7XG4gICAgICAgIHRoaXMub25Ub2tlblJlZnJlc2gobXNnLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAndHJhY2tVbnB1Ymxpc2hlZCcpIHtcbiAgICAgIGlmICh0aGlzLm9uTG9jYWxUcmFja1VucHVibGlzaGVkKSB7XG4gICAgICAgIHRoaXMub25Mb2NhbFRyYWNrVW5wdWJsaXNoZWQobXNnLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAnc3Vic2NyaXB0aW9uUmVzcG9uc2UnKSB7XG4gICAgICBpZiAodGhpcy5vblN1YnNjcmlwdGlvbkVycm9yKSB7XG4gICAgICAgIHRoaXMub25TdWJzY3JpcHRpb25FcnJvcihtc2cudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICdwb25nJykge1xuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICdwb25nUmVzcCcpIHtcbiAgICAgIHRoaXMucnR0ID0gRGF0ZS5ub3coKSAtIE51bWJlci5wYXJzZUludChtc2cudmFsdWUubGFzdFBpbmdUaW1lc3RhbXAudG9TdHJpbmcoKSk7XG4gICAgICB0aGlzLnJlc2V0UGluZ1RpbWVvdXQoKTtcbiAgICAgIHBpbmdIYW5kbGVkID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sb2cuZGVidWcoJ3Vuc3VwcG9ydGVkIG1lc3NhZ2UnLCB7IC4uLnRoaXMubG9nQ29udGV4dCwgbXNnQ2FzZTogbXNnLmNhc2UgfSk7XG4gICAgfVxuXG4gICAgaWYgKCFwaW5nSGFuZGxlZCkge1xuICAgICAgdGhpcy5yZXNldFBpbmdUaW1lb3V0KCk7XG4gICAgfVxuICB9XG5cbiAgc2V0UmVjb25uZWN0ZWQoKSB7XG4gICAgd2hpbGUgKHRoaXMucXVldWVkUmVxdWVzdHMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgcmVxID0gdGhpcy5xdWV1ZWRSZXF1ZXN0cy5zaGlmdCgpO1xuICAgICAgaWYgKHJlcSkge1xuICAgICAgICB0aGlzLnJlcXVlc3RRdWV1ZS5ydW4ocmVxKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGhhbmRsZU9uQ2xvc2UocmVhc29uOiBzdHJpbmcpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkRJU0NPTk5FQ1RFRCkgcmV0dXJuO1xuICAgIGNvbnN0IG9uQ2xvc2VDYWxsYmFjayA9IHRoaXMub25DbG9zZTtcbiAgICBhd2FpdCB0aGlzLmNsb3NlKCk7XG4gICAgdGhpcy5sb2cuZGVidWcoYHdlYnNvY2tldCBjb25uZWN0aW9uIGNsb3NlZDogJHtyZWFzb259YCwgeyAuLi50aGlzLmxvZ0NvbnRleHQsIHJlYXNvbiB9KTtcbiAgICBpZiAob25DbG9zZUNhbGxiYWNrKSB7XG4gICAgICBvbkNsb3NlQ2FsbGJhY2socmVhc29uKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZVdTRXJyb3IoZXY6IEV2ZW50KSB7XG4gICAgdGhpcy5sb2cuZXJyb3IoJ3dlYnNvY2tldCBlcnJvcicsIHsgLi4udGhpcy5sb2dDb250ZXh0LCBlcnJvcjogZXYgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVzZXRzIHRoZSBwaW5nIHRpbWVvdXQgYW5kIHN0YXJ0cyBhIG5ldyB0aW1lb3V0LlxuICAgKiBDYWxsIHRoaXMgYWZ0ZXIgcmVjZWl2aW5nIGEgcG9uZyBtZXNzYWdlXG4gICAqL1xuICBwcml2YXRlIHJlc2V0UGluZ1RpbWVvdXQoKSB7XG4gICAgdGhpcy5jbGVhclBpbmdUaW1lb3V0KCk7XG4gICAgaWYgKCF0aGlzLnBpbmdUaW1lb3V0RHVyYXRpb24pIHtcbiAgICAgIHRoaXMubG9nLndhcm4oJ3BpbmcgdGltZW91dCBkdXJhdGlvbiBub3Qgc2V0JywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5waW5nVGltZW91dCA9IENyaXRpY2FsVGltZXJzLnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5sb2cud2FybihcbiAgICAgICAgYHBpbmcgdGltZW91dCB0cmlnZ2VyZWQuIGxhc3QgcG9uZyByZWNlaXZlZCBhdDogJHtuZXcgRGF0ZShcbiAgICAgICAgICBEYXRlLm5vdygpIC0gdGhpcy5waW5nVGltZW91dER1cmF0aW9uISAqIDEwMDAsXG4gICAgICAgICkudG9VVENTdHJpbmcoKX1gLFxuICAgICAgICB0aGlzLmxvZ0NvbnRleHQsXG4gICAgICApO1xuICAgICAgdGhpcy5oYW5kbGVPbkNsb3NlKCdwaW5nIHRpbWVvdXQnKTtcbiAgICB9LCB0aGlzLnBpbmdUaW1lb3V0RHVyYXRpb24gKiAxMDAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhcnMgcGluZyB0aW1lb3V0IChkb2VzIG5vdCBzdGFydCBhIG5ldyB0aW1lb3V0KVxuICAgKi9cbiAgcHJpdmF0ZSBjbGVhclBpbmdUaW1lb3V0KCkge1xuICAgIGlmICh0aGlzLnBpbmdUaW1lb3V0KSB7XG4gICAgICBDcml0aWNhbFRpbWVycy5jbGVhclRpbWVvdXQodGhpcy5waW5nVGltZW91dCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzdGFydFBpbmdJbnRlcnZhbCgpIHtcbiAgICB0aGlzLmNsZWFyUGluZ0ludGVydmFsKCk7XG4gICAgdGhpcy5yZXNldFBpbmdUaW1lb3V0KCk7XG4gICAgaWYgKCF0aGlzLnBpbmdJbnRlcnZhbER1cmF0aW9uKSB7XG4gICAgICB0aGlzLmxvZy53YXJuKCdwaW5nIGludGVydmFsIGR1cmF0aW9uIG5vdCBzZXQnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmxvZy5kZWJ1Zygnc3RhcnQgcGluZyBpbnRlcnZhbCcsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgdGhpcy5waW5nSW50ZXJ2YWwgPSBDcml0aWNhbFRpbWVycy5zZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICB0aGlzLnNlbmRQaW5nKCk7XG4gICAgfSwgdGhpcy5waW5nSW50ZXJ2YWxEdXJhdGlvbiAqIDEwMDApO1xuICB9XG5cbiAgcHJpdmF0ZSBjbGVhclBpbmdJbnRlcnZhbCgpIHtcbiAgICB0aGlzLmxvZy5kZWJ1ZygnY2xlYXJpbmcgcGluZyBpbnRlcnZhbCcsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgdGhpcy5jbGVhclBpbmdUaW1lb3V0KCk7XG4gICAgaWYgKHRoaXMucGluZ0ludGVydmFsKSB7XG4gICAgICBDcml0aWNhbFRpbWVycy5jbGVhckludGVydmFsKHRoaXMucGluZ0ludGVydmFsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZnJvbVByb3RvU2Vzc2lvbkRlc2NyaXB0aW9uKHNkOiBTZXNzaW9uRGVzY3JpcHRpb24pOiBSVENTZXNzaW9uRGVzY3JpcHRpb25Jbml0IHtcbiAgY29uc3QgcnNkOiBSVENTZXNzaW9uRGVzY3JpcHRpb25Jbml0ID0ge1xuICAgIHR5cGU6ICdvZmZlcicsXG4gICAgc2RwOiBzZC5zZHAsXG4gIH07XG4gIHN3aXRjaCAoc2QudHlwZSkge1xuICAgIGNhc2UgJ2Fuc3dlcic6XG4gICAgY2FzZSAnb2ZmZXInOlxuICAgIGNhc2UgJ3ByYW5zd2VyJzpcbiAgICBjYXNlICdyb2xsYmFjayc6XG4gICAgICByc2QudHlwZSA9IHNkLnR5cGU7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHJzZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvUHJvdG9TZXNzaW9uRGVzY3JpcHRpb24oXG4gIHJzZDogUlRDU2Vzc2lvbkRlc2NyaXB0aW9uIHwgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uSW5pdCxcbik6IFNlc3Npb25EZXNjcmlwdGlvbiB7XG4gIGNvbnN0IHNkID0gbmV3IFNlc3Npb25EZXNjcmlwdGlvbih7XG4gICAgc2RwOiByc2Quc2RwISxcbiAgICB0eXBlOiByc2QudHlwZSEsXG4gIH0pO1xuICByZXR1cm4gc2Q7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbm5lY3Rpb25QYXJhbXModG9rZW46IHN0cmluZywgaW5mbzogQ2xpZW50SW5mbywgb3B0czogQ29ubmVjdE9wdHMpOiBzdHJpbmcge1xuICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gIHBhcmFtcy5zZXQoJ2FjY2Vzc190b2tlbicsIHRva2VuKTtcblxuICAvLyBvcHRzXG4gIGlmIChvcHRzLnJlY29ubmVjdCkge1xuICAgIHBhcmFtcy5zZXQoJ3JlY29ubmVjdCcsICcxJyk7XG4gICAgaWYgKG9wdHMuc2lkKSB7XG4gICAgICBwYXJhbXMuc2V0KCdzaWQnLCBvcHRzLnNpZCk7XG4gICAgfVxuICB9XG5cbiAgcGFyYW1zLnNldCgnYXV0b19zdWJzY3JpYmUnLCBvcHRzLmF1dG9TdWJzY3JpYmUgPyAnMScgOiAnMCcpO1xuXG4gIC8vIENsaWVudEluZm9cbiAgcGFyYW1zLnNldCgnc2RrJywgaXNSZWFjdE5hdGl2ZSgpID8gJ3JlYWN0bmF0aXZlJyA6ICdqcycpO1xuICBwYXJhbXMuc2V0KCd2ZXJzaW9uJywgaW5mby52ZXJzaW9uISk7XG4gIHBhcmFtcy5zZXQoJ3Byb3RvY29sJywgaW5mby5wcm90b2NvbCEudG9TdHJpbmcoKSk7XG4gIGlmIChpbmZvLmRldmljZU1vZGVsKSB7XG4gICAgcGFyYW1zLnNldCgnZGV2aWNlX21vZGVsJywgaW5mby5kZXZpY2VNb2RlbCk7XG4gIH1cbiAgaWYgKGluZm8ub3MpIHtcbiAgICBwYXJhbXMuc2V0KCdvcycsIGluZm8ub3MpO1xuICB9XG4gIGlmIChpbmZvLm9zVmVyc2lvbikge1xuICAgIHBhcmFtcy5zZXQoJ29zX3ZlcnNpb24nLCBpbmZvLm9zVmVyc2lvbik7XG4gIH1cbiAgaWYgKGluZm8uYnJvd3Nlcikge1xuICAgIHBhcmFtcy5zZXQoJ2Jyb3dzZXInLCBpbmZvLmJyb3dzZXIpO1xuICB9XG4gIGlmIChpbmZvLmJyb3dzZXJWZXJzaW9uKSB7XG4gICAgcGFyYW1zLnNldCgnYnJvd3Nlcl92ZXJzaW9uJywgaW5mby5icm93c2VyVmVyc2lvbik7XG4gIH1cblxuICBpZiAob3B0cy5wdWJsaXNoT25seSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcGFyYW1zLnNldCgncHVibGlzaCcsIG9wdHMucHVibGlzaE9ubHkpO1xuICB9XG5cbiAgaWYgKG9wdHMuYWRhcHRpdmVTdHJlYW0pIHtcbiAgICBwYXJhbXMuc2V0KCdhZGFwdGl2ZV9zdHJlYW0nLCAnMScpO1xuICB9XG5cbiAgaWYgKG9wdHMucmVjb25uZWN0UmVhc29uKSB7XG4gICAgcGFyYW1zLnNldCgncmVjb25uZWN0X3JlYXNvbicsIG9wdHMucmVjb25uZWN0UmVhc29uLnRvU3RyaW5nKCkpO1xuICB9XG5cbiAgLy8gQHRzLWlnbm9yZVxuICBpZiAobmF2aWdhdG9yLmNvbm5lY3Rpb24/LnR5cGUpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcGFyYW1zLnNldCgnbmV0d29yaycsIG5hdmlnYXRvci5jb25uZWN0aW9uLnR5cGUpO1xuICB9XG5cbiAgcmV0dXJuIGA/JHtwYXJhbXMudG9TdHJpbmcoKX1gO1xufVxuIiwidmFyIGdyYW1tYXIgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgdjogW3tcbiAgICBuYW1lOiAndmVyc2lvbicsXG4gICAgcmVnOiAvXihcXGQqKSQvXG4gIH1dLFxuICBvOiBbe1xuICAgIC8vIG89LSAyMDUxOCAwIElOIElQNCAyMDMuMC4xMTMuMVxuICAgIC8vIE5COiBzZXNzaW9uSWQgd2lsbCBiZSBhIFN0cmluZyBpbiBtb3N0IGNhc2VzIGJlY2F1c2UgaXQgaXMgaHVnZVxuICAgIG5hbWU6ICdvcmlnaW4nLFxuICAgIHJlZzogL14oXFxTKikgKFxcZCopIChcXGQqKSAoXFxTKikgSVAoXFxkKSAoXFxTKikvLFxuICAgIG5hbWVzOiBbJ3VzZXJuYW1lJywgJ3Nlc3Npb25JZCcsICdzZXNzaW9uVmVyc2lvbicsICduZXRUeXBlJywgJ2lwVmVyJywgJ2FkZHJlc3MnXSxcbiAgICBmb3JtYXQ6ICclcyAlcyAlZCAlcyBJUCVkICVzJ1xuICB9XSxcbiAgLy8gZGVmYXVsdCBwYXJzaW5nIG9mIHRoZXNlIG9ubHkgKHRob3VnaCBzb21lIG9mIHRoZXNlIGZlZWwgb3V0ZGF0ZWQpXG4gIHM6IFt7IG5hbWU6ICduYW1lJyB9XSxcbiAgaTogW3sgbmFtZTogJ2Rlc2NyaXB0aW9uJyB9XSxcbiAgdTogW3sgbmFtZTogJ3VyaScgfV0sXG4gIGU6IFt7IG5hbWU6ICdlbWFpbCcgfV0sXG4gIHA6IFt7IG5hbWU6ICdwaG9uZScgfV0sXG4gIHo6IFt7IG5hbWU6ICd0aW1lem9uZXMnIH1dLCAvLyBUT0RPOiB0aGlzIG9uZSBjYW4gYWN0dWFsbHkgYmUgcGFyc2VkIHByb3Blcmx5Li4uXG4gIHI6IFt7IG5hbWU6ICdyZXBlYXRzJyB9XSwgICAvLyBUT0RPOiB0aGlzIG9uZSBjYW4gYWxzbyBiZSBwYXJzZWQgcHJvcGVybHlcbiAgLy8gazogW3t9XSwgLy8gb3V0ZGF0ZWQgdGhpbmcgaWdub3JlZFxuICB0OiBbe1xuICAgIC8vIHQ9MCAwXG4gICAgbmFtZTogJ3RpbWluZycsXG4gICAgcmVnOiAvXihcXGQqKSAoXFxkKikvLFxuICAgIG5hbWVzOiBbJ3N0YXJ0JywgJ3N0b3AnXSxcbiAgICBmb3JtYXQ6ICclZCAlZCdcbiAgfV0sXG4gIGM6IFt7XG4gICAgLy8gYz1JTiBJUDQgMTAuNDcuMTk3LjI2XG4gICAgbmFtZTogJ2Nvbm5lY3Rpb24nLFxuICAgIHJlZzogL15JTiBJUChcXGQpIChcXFMqKS8sXG4gICAgbmFtZXM6IFsndmVyc2lvbicsICdpcCddLFxuICAgIGZvcm1hdDogJ0lOIElQJWQgJXMnXG4gIH1dLFxuICBiOiBbe1xuICAgIC8vIGI9QVM6NDAwMFxuICAgIHB1c2g6ICdiYW5kd2lkdGgnLFxuICAgIHJlZzogL14oVElBU3xBU3xDVHxSUnxSUyk6KFxcZCopLyxcbiAgICBuYW1lczogWyd0eXBlJywgJ2xpbWl0J10sXG4gICAgZm9ybWF0OiAnJXM6JXMnXG4gIH1dLFxuICBtOiBbe1xuICAgIC8vIG09dmlkZW8gNTE3NDQgUlRQL0FWUCAxMjYgOTcgOTggMzQgMzFcbiAgICAvLyBOQjogc3BlY2lhbCAtIHB1c2hlcyB0byBzZXNzaW9uXG4gICAgLy8gVE9ETzogcnRwL2ZtdHAgc2hvdWxkIGJlIGZpbHRlcmVkIGJ5IHRoZSBwYXlsb2FkcyBmb3VuZCBoZXJlP1xuICAgIHJlZzogL14oXFx3KikgKFxcZCopIChbXFx3L10qKSg/OiAoLiopKT8vLFxuICAgIG5hbWVzOiBbJ3R5cGUnLCAncG9ydCcsICdwcm90b2NvbCcsICdwYXlsb2FkcyddLFxuICAgIGZvcm1hdDogJyVzICVkICVzICVzJ1xuICB9XSxcbiAgYTogW1xuICAgIHtcbiAgICAgIC8vIGE9cnRwbWFwOjExMCBvcHVzLzQ4MDAwLzJcbiAgICAgIHB1c2g6ICdydHAnLFxuICAgICAgcmVnOiAvXnJ0cG1hcDooXFxkKikgKFtcXHdcXC0uXSopKD86XFxzKlxcLyhcXGQqKSg/OlxccypcXC8oXFxTKikpPyk/LyxcbiAgICAgIG5hbWVzOiBbJ3BheWxvYWQnLCAnY29kZWMnLCAncmF0ZScsICdlbmNvZGluZyddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gKG8uZW5jb2RpbmcpXG4gICAgICAgICAgPyAncnRwbWFwOiVkICVzLyVzLyVzJ1xuICAgICAgICAgIDogby5yYXRlXG4gICAgICAgICAgICA/ICdydHBtYXA6JWQgJXMvJXMnXG4gICAgICAgICAgICA6ICdydHBtYXA6JWQgJXMnO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1mbXRwOjEwOCBwcm9maWxlLWxldmVsLWlkPTI0O29iamVjdD0yMztiaXRyYXRlPTY0MDAwXG4gICAgICAvLyBhPWZtdHA6MTExIG1pbnB0aW1lPTEwOyB1c2VpbmJhbmRmZWM9MVxuICAgICAgcHVzaDogJ2ZtdHAnLFxuICAgICAgcmVnOiAvXmZtdHA6KFxcZCopIChbXFxTfCBdKikvLFxuICAgICAgbmFtZXM6IFsncGF5bG9hZCcsICdjb25maWcnXSxcbiAgICAgIGZvcm1hdDogJ2ZtdHA6JWQgJXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWNvbnRyb2w6c3RyZWFtaWQ9MFxuICAgICAgbmFtZTogJ2NvbnRyb2wnLFxuICAgICAgcmVnOiAvXmNvbnRyb2w6KC4qKS8sXG4gICAgICBmb3JtYXQ6ICdjb250cm9sOiVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1ydGNwOjY1MTc5IElOIElQNCAxOTMuODQuNzcuMTk0XG4gICAgICBuYW1lOiAncnRjcCcsXG4gICAgICByZWc6IC9ecnRjcDooXFxkKikoPzogKFxcUyopIElQKFxcZCkgKFxcUyopKT8vLFxuICAgICAgbmFtZXM6IFsncG9ydCcsICduZXRUeXBlJywgJ2lwVmVyJywgJ2FkZHJlc3MnXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuIChvLmFkZHJlc3MgIT0gbnVsbClcbiAgICAgICAgICA/ICdydGNwOiVkICVzIElQJWQgJXMnXG4gICAgICAgICAgOiAncnRjcDolZCc7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPXJ0Y3AtZmI6OTggdHJyLWludCAxMDBcbiAgICAgIHB1c2g6ICdydGNwRmJUcnJJbnQnLFxuICAgICAgcmVnOiAvXnJ0Y3AtZmI6KFxcKnxcXGQqKSB0cnItaW50IChcXGQqKS8sXG4gICAgICBuYW1lczogWydwYXlsb2FkJywgJ3ZhbHVlJ10sXG4gICAgICBmb3JtYXQ6ICdydGNwLWZiOiVzIHRyci1pbnQgJWQnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPXJ0Y3AtZmI6OTggbmFjayBycHNpXG4gICAgICBwdXNoOiAncnRjcEZiJyxcbiAgICAgIHJlZzogL15ydGNwLWZiOihcXCp8XFxkKikgKFtcXHctX10qKSg/OiAoW1xcdy1fXSopKT8vLFxuICAgICAgbmFtZXM6IFsncGF5bG9hZCcsICd0eXBlJywgJ3N1YnR5cGUnXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuIChvLnN1YnR5cGUgIT0gbnVsbClcbiAgICAgICAgICA/ICdydGNwLWZiOiVzICVzICVzJ1xuICAgICAgICAgIDogJ3J0Y3AtZmI6JXMgJXMnO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1leHRtYXA6MiB1cm46aWV0ZjpwYXJhbXM6cnRwLWhkcmV4dDp0b2Zmc2V0XG4gICAgICAvLyBhPWV4dG1hcDoxL3JlY3Zvbmx5IFVSSS1ncHMtc3RyaW5nXG4gICAgICAvLyBhPWV4dG1hcDozIHVybjppZXRmOnBhcmFtczpydHAtaGRyZXh0OmVuY3J5cHQgdXJuOmlldGY6cGFyYW1zOnJ0cC1oZHJleHQ6c21wdGUtdGMgMjVANjAwLzI0XG4gICAgICBwdXNoOiAnZXh0JyxcbiAgICAgIHJlZzogL15leHRtYXA6KFxcZCspKD86XFwvKFxcdyspKT8oPzogKHVybjppZXRmOnBhcmFtczpydHAtaGRyZXh0OmVuY3J5cHQpKT8gKFxcUyopKD86IChcXFMqKSk/LyxcbiAgICAgIG5hbWVzOiBbJ3ZhbHVlJywgJ2RpcmVjdGlvbicsICdlbmNyeXB0LXVyaScsICd1cmknLCAnY29uZmlnJ10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgJ2V4dG1hcDolZCcgK1xuICAgICAgICAgIChvLmRpcmVjdGlvbiA/ICcvJXMnIDogJyV2JykgK1xuICAgICAgICAgIChvWydlbmNyeXB0LXVyaSddID8gJyAlcycgOiAnJXYnKSArXG4gICAgICAgICAgJyAlcycgK1xuICAgICAgICAgIChvLmNvbmZpZyA/ICcgJXMnIDogJycpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWV4dG1hcC1hbGxvdy1taXhlZFxuICAgICAgbmFtZTogJ2V4dG1hcEFsbG93TWl4ZWQnLFxuICAgICAgcmVnOiAvXihleHRtYXAtYWxsb3ctbWl4ZWQpL1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1jcnlwdG86MSBBRVNfQ01fMTI4X0hNQUNfU0hBMV84MCBpbmxpbmU6UFMxdVFDVmVlQ0ZDYW5WbWNqa3BQeXdqTldoY1lEMG1YWHR4YVZCUnwyXjIwfDE6MzJcbiAgICAgIHB1c2g6ICdjcnlwdG8nLFxuICAgICAgcmVnOiAvXmNyeXB0bzooXFxkKikgKFtcXHdfXSopIChcXFMqKSg/OiAoXFxTKikpPy8sXG4gICAgICBuYW1lczogWydpZCcsICdzdWl0ZScsICdjb25maWcnLCAnc2Vzc2lvbkNvbmZpZyddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gKG8uc2Vzc2lvbkNvbmZpZyAhPSBudWxsKVxuICAgICAgICAgID8gJ2NyeXB0bzolZCAlcyAlcyAlcydcbiAgICAgICAgICA6ICdjcnlwdG86JWQgJXMgJXMnO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1zZXR1cDphY3RwYXNzXG4gICAgICBuYW1lOiAnc2V0dXAnLFxuICAgICAgcmVnOiAvXnNldHVwOihcXHcqKS8sXG4gICAgICBmb3JtYXQ6ICdzZXR1cDolcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9Y29ubmVjdGlvbjpuZXdcbiAgICAgIG5hbWU6ICdjb25uZWN0aW9uVHlwZScsXG4gICAgICByZWc6IC9eY29ubmVjdGlvbjoobmV3fGV4aXN0aW5nKS8sXG4gICAgICBmb3JtYXQ6ICdjb25uZWN0aW9uOiVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1taWQ6MVxuICAgICAgbmFtZTogJ21pZCcsXG4gICAgICByZWc6IC9ebWlkOihbXlxcc10qKS8sXG4gICAgICBmb3JtYXQ6ICdtaWQ6JXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPW1zaWQ6MGM4YjA2NGQtZDgwNy00M2I0LWI0MzQtZjkyYTg4OWQ4NTg3IDk4MTc4Njg1LWQ0MDktNDZlMC04ZTE2LTdlZjBkYjBkYjY0YVxuICAgICAgbmFtZTogJ21zaWQnLFxuICAgICAgcmVnOiAvXm1zaWQ6KC4qKS8sXG4gICAgICBmb3JtYXQ6ICdtc2lkOiVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1wdGltZToyMFxuICAgICAgbmFtZTogJ3B0aW1lJyxcbiAgICAgIHJlZzogL15wdGltZTooXFxkKig/OlxcLlxcZCopKikvLFxuICAgICAgZm9ybWF0OiAncHRpbWU6JWQnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPW1heHB0aW1lOjYwXG4gICAgICBuYW1lOiAnbWF4cHRpbWUnLFxuICAgICAgcmVnOiAvXm1heHB0aW1lOihcXGQqKD86XFwuXFxkKikqKS8sXG4gICAgICBmb3JtYXQ6ICdtYXhwdGltZTolZCdcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9c2VuZHJlY3ZcbiAgICAgIG5hbWU6ICdkaXJlY3Rpb24nLFxuICAgICAgcmVnOiAvXihzZW5kcmVjdnxyZWN2b25seXxzZW5kb25seXxpbmFjdGl2ZSkvXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWljZS1saXRlXG4gICAgICBuYW1lOiAnaWNlbGl0ZScsXG4gICAgICByZWc6IC9eKGljZS1saXRlKS9cbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9aWNlLXVmcmFnOkY3Z0lcbiAgICAgIG5hbWU6ICdpY2VVZnJhZycsXG4gICAgICByZWc6IC9eaWNlLXVmcmFnOihcXFMqKS8sXG4gICAgICBmb3JtYXQ6ICdpY2UtdWZyYWc6JXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWljZS1wd2Q6eDljbWwvWXppY2hWMitYbGhpTXU4Z1xuICAgICAgbmFtZTogJ2ljZVB3ZCcsXG4gICAgICByZWc6IC9eaWNlLXB3ZDooXFxTKikvLFxuICAgICAgZm9ybWF0OiAnaWNlLXB3ZDolcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9ZmluZ2VycHJpbnQ6U0hBLTEgMDA6MTE6MjI6MzM6NDQ6NTU6NjY6Nzc6ODg6OTk6QUE6QkI6Q0M6REQ6RUU6RkY6MDA6MTE6MjI6MzNcbiAgICAgIG5hbWU6ICdmaW5nZXJwcmludCcsXG4gICAgICByZWc6IC9eZmluZ2VycHJpbnQ6KFxcUyopIChcXFMqKS8sXG4gICAgICBuYW1lczogWyd0eXBlJywgJ2hhc2gnXSxcbiAgICAgIGZvcm1hdDogJ2ZpbmdlcnByaW50OiVzICVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1jYW5kaWRhdGU6MCAxIFVEUCAyMTEzNjY3MzI3IDIwMy4wLjExMy4xIDU0NDAwIHR5cCBob3N0XG4gICAgICAvLyBhPWNhbmRpZGF0ZToxMTYyODc1MDgxIDEgdWRwIDIxMTM5MzcxNTEgMTkyLjE2OC4zNC43NSA2MDAxNyB0eXAgaG9zdCBnZW5lcmF0aW9uIDAgbmV0d29yay1pZCAzIG5ldHdvcmstY29zdCAxMFxuICAgICAgLy8gYT1jYW5kaWRhdGU6MzI4OTkxMjk1NyAyIHVkcCAxODQ1NTAxNjk1IDE5My44NC43Ny4xOTQgNjAwMTcgdHlwIHNyZmx4IHJhZGRyIDE5Mi4xNjguMzQuNzUgcnBvcnQgNjAwMTcgZ2VuZXJhdGlvbiAwIG5ldHdvcmstaWQgMyBuZXR3b3JrLWNvc3QgMTBcbiAgICAgIC8vIGE9Y2FuZGlkYXRlOjIyOTgxNTYyMCAxIHRjcCAxNTE4MjgwNDQ3IDE5Mi4xNjguMTUwLjE5IDYwMDE3IHR5cCBob3N0IHRjcHR5cGUgYWN0aXZlIGdlbmVyYXRpb24gMCBuZXR3b3JrLWlkIDMgbmV0d29yay1jb3N0IDEwXG4gICAgICAvLyBhPWNhbmRpZGF0ZTozMjg5OTEyOTU3IDIgdGNwIDE4NDU1MDE2OTUgMTkzLjg0Ljc3LjE5NCA2MDAxNyB0eXAgc3JmbHggcmFkZHIgMTkyLjE2OC4zNC43NSBycG9ydCA2MDAxNyB0Y3B0eXBlIHBhc3NpdmUgZ2VuZXJhdGlvbiAwIG5ldHdvcmstaWQgMyBuZXR3b3JrLWNvc3QgMTBcbiAgICAgIHB1c2g6J2NhbmRpZGF0ZXMnLFxuICAgICAgcmVnOiAvXmNhbmRpZGF0ZTooXFxTKikgKFxcZCopIChcXFMqKSAoXFxkKikgKFxcUyopIChcXGQqKSB0eXAgKFxcUyopKD86IHJhZGRyIChcXFMqKSBycG9ydCAoXFxkKikpPyg/OiB0Y3B0eXBlIChcXFMqKSk/KD86IGdlbmVyYXRpb24gKFxcZCopKT8oPzogbmV0d29yay1pZCAoXFxkKikpPyg/OiBuZXR3b3JrLWNvc3QgKFxcZCopKT8vLFxuICAgICAgbmFtZXM6IFsnZm91bmRhdGlvbicsICdjb21wb25lbnQnLCAndHJhbnNwb3J0JywgJ3ByaW9yaXR5JywgJ2lwJywgJ3BvcnQnLCAndHlwZScsICdyYWRkcicsICdycG9ydCcsICd0Y3B0eXBlJywgJ2dlbmVyYXRpb24nLCAnbmV0d29yay1pZCcsICduZXR3b3JrLWNvc3QnXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgdmFyIHN0ciA9ICdjYW5kaWRhdGU6JXMgJWQgJXMgJWQgJXMgJWQgdHlwICVzJztcblxuICAgICAgICBzdHIgKz0gKG8ucmFkZHIgIT0gbnVsbCkgPyAnIHJhZGRyICVzIHJwb3J0ICVkJyA6ICcldiV2JztcblxuICAgICAgICAvLyBOQjogY2FuZGlkYXRlIGhhcyB0aHJlZSBvcHRpb25hbCBjaHVua3MsIHNvICV2b2lkIG1pZGRsZXMgb25lIGlmIGl0J3MgbWlzc2luZ1xuICAgICAgICBzdHIgKz0gKG8udGNwdHlwZSAhPSBudWxsKSA/ICcgdGNwdHlwZSAlcycgOiAnJXYnO1xuXG4gICAgICAgIGlmIChvLmdlbmVyYXRpb24gIT0gbnVsbCkge1xuICAgICAgICAgIHN0ciArPSAnIGdlbmVyYXRpb24gJWQnO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RyICs9IChvWyduZXR3b3JrLWlkJ10gIT0gbnVsbCkgPyAnIG5ldHdvcmstaWQgJWQnIDogJyV2JztcbiAgICAgICAgc3RyICs9IChvWyduZXR3b3JrLWNvc3QnXSAhPSBudWxsKSA/ICcgbmV0d29yay1jb3N0ICVkJyA6ICcldic7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWVuZC1vZi1jYW5kaWRhdGVzIChrZWVwIGFmdGVyIHRoZSBjYW5kaWRhdGVzIGxpbmUgZm9yIHJlYWRhYmlsaXR5KVxuICAgICAgbmFtZTogJ2VuZE9mQ2FuZGlkYXRlcycsXG4gICAgICByZWc6IC9eKGVuZC1vZi1jYW5kaWRhdGVzKS9cbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9cmVtb3RlLWNhbmRpZGF0ZXM6MSAyMDMuMC4xMTMuMSA1NDQwMCAyIDIwMy4wLjExMy4xIDU0NDAxIC4uLlxuICAgICAgbmFtZTogJ3JlbW90ZUNhbmRpZGF0ZXMnLFxuICAgICAgcmVnOiAvXnJlbW90ZS1jYW5kaWRhdGVzOiguKikvLFxuICAgICAgZm9ybWF0OiAncmVtb3RlLWNhbmRpZGF0ZXM6JXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWljZS1vcHRpb25zOmdvb2dsZS1pY2VcbiAgICAgIG5hbWU6ICdpY2VPcHRpb25zJyxcbiAgICAgIHJlZzogL15pY2Utb3B0aW9uczooXFxTKikvLFxuICAgICAgZm9ybWF0OiAnaWNlLW9wdGlvbnM6JXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPXNzcmM6MjU2NjEwNzU2OSBjbmFtZTp0OVlVOE0xVXhURjhZMUExXG4gICAgICBwdXNoOiAnc3NyY3MnLFxuICAgICAgcmVnOiAvXnNzcmM6KFxcZCopIChbXFx3Xy1dKikoPzo6KC4qKSk/LyxcbiAgICAgIG5hbWVzOiBbJ2lkJywgJ2F0dHJpYnV0ZScsICd2YWx1ZSddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICB2YXIgc3RyID0gJ3NzcmM6JWQnO1xuICAgICAgICBpZiAoby5hdHRyaWJ1dGUgIT0gbnVsbCkge1xuICAgICAgICAgIHN0ciArPSAnICVzJztcbiAgICAgICAgICBpZiAoby52YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzdHIgKz0gJzolcyc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPXNzcmMtZ3JvdXA6RkVDIDEgMlxuICAgICAgLy8gYT1zc3JjLWdyb3VwOkZFQy1GUiAzMDA0MzY0MTk1IDEwODA3NzIyNDFcbiAgICAgIHB1c2g6ICdzc3JjR3JvdXBzJyxcbiAgICAgIC8vIHRva2VuLWNoYXIgPSAleDIxIC8gJXgyMy0yNyAvICV4MkEtMkIgLyAleDJELTJFIC8gJXgzMC0zOSAvICV4NDEtNUEgLyAleDVFLTdFXG4gICAgICByZWc6IC9ec3NyYy1ncm91cDooW1xceDIxXFx4MjNcXHgyNFxceDI1XFx4MjZcXHgyN1xceDJBXFx4MkJcXHgyRFxceDJFXFx3XSopICguKikvLFxuICAgICAgbmFtZXM6IFsnc2VtYW50aWNzJywgJ3NzcmNzJ10sXG4gICAgICBmb3JtYXQ6ICdzc3JjLWdyb3VwOiVzICVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1tc2lkLXNlbWFudGljOiBXTVMgSnZsYW01WDNTWDFPUDZwbjIweldvZ3ZhS0p6NUhqZjlPbmxWXG4gICAgICBuYW1lOiAnbXNpZFNlbWFudGljJyxcbiAgICAgIHJlZzogL15tc2lkLXNlbWFudGljOlxccz8oXFx3KikgKFxcUyopLyxcbiAgICAgIG5hbWVzOiBbJ3NlbWFudGljJywgJ3Rva2VuJ10sXG4gICAgICBmb3JtYXQ6ICdtc2lkLXNlbWFudGljOiAlcyAlcycgLy8gc3BhY2UgYWZ0ZXIgJzonIGlzIG5vdCBhY2NpZGVudGFsXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWdyb3VwOkJVTkRMRSBhdWRpbyB2aWRlb1xuICAgICAgcHVzaDogJ2dyb3VwcycsXG4gICAgICByZWc6IC9eZ3JvdXA6KFxcdyopICguKikvLFxuICAgICAgbmFtZXM6IFsndHlwZScsICdtaWRzJ10sXG4gICAgICBmb3JtYXQ6ICdncm91cDolcyAlcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9cnRjcC1tdXhcbiAgICAgIG5hbWU6ICdydGNwTXV4JyxcbiAgICAgIHJlZzogL14ocnRjcC1tdXgpL1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1ydGNwLXJzaXplXG4gICAgICBuYW1lOiAncnRjcFJzaXplJyxcbiAgICAgIHJlZzogL14ocnRjcC1yc2l6ZSkvXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPXNjdHBtYXA6NTAwMCB3ZWJydGMtZGF0YWNoYW5uZWwgMTAyNFxuICAgICAgbmFtZTogJ3NjdHBtYXAnLFxuICAgICAgcmVnOiAvXnNjdHBtYXA6KFtcXHdfL10qKSAoXFxTKikoPzogKFxcUyopKT8vLFxuICAgICAgbmFtZXM6IFsnc2N0cG1hcE51bWJlcicsICdhcHAnLCAnbWF4TWVzc2FnZVNpemUnXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuIChvLm1heE1lc3NhZ2VTaXplICE9IG51bGwpXG4gICAgICAgICAgPyAnc2N0cG1hcDolcyAlcyAlcydcbiAgICAgICAgICA6ICdzY3RwbWFwOiVzICVzJztcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9eC1nb29nbGUtZmxhZzpjb25mZXJlbmNlXG4gICAgICBuYW1lOiAneEdvb2dsZUZsYWcnLFxuICAgICAgcmVnOiAvXngtZ29vZ2xlLWZsYWc6KFteXFxzXSopLyxcbiAgICAgIGZvcm1hdDogJ3gtZ29vZ2xlLWZsYWc6JXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPXJpZDoxIHNlbmQgbWF4LXdpZHRoPTEyODA7bWF4LWhlaWdodD03MjA7bWF4LWZwcz0zMDtkZXBlbmQ9MFxuICAgICAgcHVzaDogJ3JpZHMnLFxuICAgICAgcmVnOiAvXnJpZDooW1xcZFxcd10rKSAoXFx3KykoPzogKFtcXFN8IF0qKSk/LyxcbiAgICAgIG5hbWVzOiBbJ2lkJywgJ2RpcmVjdGlvbicsICdwYXJhbXMnXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuIChvLnBhcmFtcykgPyAncmlkOiVzICVzICVzJyA6ICdyaWQ6JXMgJXMnO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1pbWFnZWF0dHI6OTcgc2VuZCBbeD04MDAseT02NDAsc2FyPTEuMSxxPTAuNl0gW3g9NDgwLHk9MzIwXSByZWN2IFt4PTMzMCx5PTI1MF1cbiAgICAgIC8vIGE9aW1hZ2VhdHRyOiogc2VuZCBbeD04MDAseT02NDBdIHJlY3YgKlxuICAgICAgLy8gYT1pbWFnZWF0dHI6MTAwIHJlY3YgW3g9MzIwLHk9MjQwXVxuICAgICAgcHVzaDogJ2ltYWdlYXR0cnMnLFxuICAgICAgcmVnOiBuZXcgUmVnRXhwKFxuICAgICAgICAvLyBhPWltYWdlYXR0cjo5N1xuICAgICAgICAnXmltYWdlYXR0cjooXFxcXGQrfFxcXFwqKScgK1xuICAgICAgICAvLyBzZW5kIFt4PTgwMCx5PTY0MCxzYXI9MS4xLHE9MC42XSBbeD00ODAseT0zMjBdXG4gICAgICAgICdbXFxcXHNcXFxcdF0rKHNlbmR8cmVjdilbXFxcXHNcXFxcdF0rKFxcXFwqfFxcXFxbXFxcXFMrXFxcXF0oPzpbXFxcXHNcXFxcdF0rXFxcXFtcXFxcUytcXFxcXSkqKScgK1xuICAgICAgICAvLyByZWN2IFt4PTMzMCx5PTI1MF1cbiAgICAgICAgJyg/OltcXFxcc1xcXFx0XSsocmVjdnxzZW5kKVtcXFxcc1xcXFx0XSsoXFxcXCp8XFxcXFtcXFxcUytcXFxcXSg/OltcXFxcc1xcXFx0XStcXFxcW1xcXFxTK1xcXFxdKSopKT8nXG4gICAgICApLFxuICAgICAgbmFtZXM6IFsncHQnLCAnZGlyMScsICdhdHRyczEnLCAnZGlyMicsICdhdHRyczInXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuICdpbWFnZWF0dHI6JXMgJXMgJXMnICsgKG8uZGlyMiA/ICcgJXMgJXMnIDogJycpO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1zaW11bGNhc3Q6c2VuZCAxLDIsMzt+NCx+NSByZWN2IDY7fjcsfjhcbiAgICAgIC8vIGE9c2ltdWxjYXN0OnJlY3YgMTs0LDUgc2VuZCA2OzdcbiAgICAgIG5hbWU6ICdzaW11bGNhc3QnLFxuICAgICAgcmVnOiBuZXcgUmVnRXhwKFxuICAgICAgICAvLyBhPXNpbXVsY2FzdDpcbiAgICAgICAgJ15zaW11bGNhc3Q6JyArXG4gICAgICAgIC8vIHNlbmQgMSwyLDM7fjQsfjVcbiAgICAgICAgJyhzZW5kfHJlY3YpIChbYS16QS1aMC05XFxcXC1ffjssXSspJyArXG4gICAgICAgIC8vIHNwYWNlICsgcmVjdiA2O343LH44XG4gICAgICAgICcoPzpcXFxccz8oc2VuZHxyZWN2KSAoW2EtekEtWjAtOVxcXFwtX347LF0rKSk/JyArXG4gICAgICAgIC8vIGVuZFxuICAgICAgICAnJCdcbiAgICAgICksXG4gICAgICBuYW1lczogWydkaXIxJywgJ2xpc3QxJywgJ2RpcjInLCAnbGlzdDInXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuICdzaW11bGNhc3Q6JXMgJXMnICsgKG8uZGlyMiA/ICcgJXMgJXMnIDogJycpO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgLy8gb2xkIHNpbXVsY2FzdCBkcmFmdCAwMyAoaW1wbGVtZW50ZWQgYnkgRmlyZWZveClcbiAgICAgIC8vICAgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LWlldGYtbW11c2ljLXNkcC1zaW11bGNhc3QtMDNcbiAgICAgIC8vIGE9c2ltdWxjYXN0OiByZWN2IHB0PTk3Ozk4IHNlbmQgcHQ9OTdcbiAgICAgIC8vIGE9c2ltdWxjYXN0OiBzZW5kIHJpZD01OzY7NyBwYXVzZWQ9Niw3XG4gICAgICBuYW1lOiAnc2ltdWxjYXN0XzAzJyxcbiAgICAgIHJlZzogL15zaW11bGNhc3Q6W1xcc1xcdF0rKFtcXFMrXFxzXFx0XSspJC8sXG4gICAgICBuYW1lczogWyd2YWx1ZSddLFxuICAgICAgZm9ybWF0OiAnc2ltdWxjYXN0OiAlcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9ZnJhbWVyYXRlOjI1XG4gICAgICAvLyBhPWZyYW1lcmF0ZToyOS45N1xuICAgICAgbmFtZTogJ2ZyYW1lcmF0ZScsXG4gICAgICByZWc6IC9eZnJhbWVyYXRlOihcXGQrKD86JHxcXC5cXGQrKSkvLFxuICAgICAgZm9ybWF0OiAnZnJhbWVyYXRlOiVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gUkZDNDU3MFxuICAgICAgLy8gYT1zb3VyY2UtZmlsdGVyOiBpbmNsIElOIElQNCAyMzkuNS4yLjMxIDEwLjEuMTUuNVxuICAgICAgbmFtZTogJ3NvdXJjZUZpbHRlcicsXG4gICAgICByZWc6IC9ec291cmNlLWZpbHRlcjogKihleGNsfGluY2wpIChcXFMqKSAoSVA0fElQNnxcXCopIChcXFMqKSAoLiopLyxcbiAgICAgIG5hbWVzOiBbJ2ZpbHRlck1vZGUnLCAnbmV0VHlwZScsICdhZGRyZXNzVHlwZXMnLCAnZGVzdEFkZHJlc3MnLCAnc3JjTGlzdCddLFxuICAgICAgZm9ybWF0OiAnc291cmNlLWZpbHRlcjogJXMgJXMgJXMgJXMgJXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWJ1bmRsZS1vbmx5XG4gICAgICBuYW1lOiAnYnVuZGxlT25seScsXG4gICAgICByZWc6IC9eKGJ1bmRsZS1vbmx5KS9cbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9bGFiZWw6MVxuICAgICAgbmFtZTogJ2xhYmVsJyxcbiAgICAgIHJlZzogL15sYWJlbDooLispLyxcbiAgICAgIGZvcm1hdDogJ2xhYmVsOiVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gUkZDIHZlcnNpb24gMjYgZm9yIFNDVFAgb3ZlciBEVExTXG4gICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtaWV0Zi1tbXVzaWMtc2N0cC1zZHAtMjYjc2VjdGlvbi01XG4gICAgICBuYW1lOiAnc2N0cFBvcnQnLFxuICAgICAgcmVnOiAvXnNjdHAtcG9ydDooXFxkKykkLyxcbiAgICAgIGZvcm1hdDogJ3NjdHAtcG9ydDolcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIFJGQyB2ZXJzaW9uIDI2IGZvciBTQ1RQIG92ZXIgRFRMU1xuICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LWlldGYtbW11c2ljLXNjdHAtc2RwLTI2I3NlY3Rpb24tNlxuICAgICAgbmFtZTogJ21heE1lc3NhZ2VTaXplJyxcbiAgICAgIHJlZzogL15tYXgtbWVzc2FnZS1zaXplOihcXGQrKSQvLFxuICAgICAgZm9ybWF0OiAnbWF4LW1lc3NhZ2Utc2l6ZTolcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIFJGQzcyNzNcbiAgICAgIC8vIGE9dHMtcmVmY2xrOnB0cD1JRUVFMTU4OC0yMDA4OjM5LUE3LTk0LUZGLUZFLTA3LUNCLUQwOjM3XG4gICAgICBwdXNoOid0c1JlZkNsb2NrcycsXG4gICAgICByZWc6IC9edHMtcmVmY2xrOihbXlxccz1dKikoPzo9KFxcUyopKT8vLFxuICAgICAgbmFtZXM6IFsnY2xrc3JjJywgJ2Nsa3NyY0V4dCddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gJ3RzLXJlZmNsazolcycgKyAoby5jbGtzcmNFeHQgIT0gbnVsbCA/ICc9JXMnIDogJycpO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgLy8gUkZDNzI3M1xuICAgICAgLy8gYT1tZWRpYWNsazpkaXJlY3Q9OTYzMjE0NDI0XG4gICAgICBuYW1lOidtZWRpYUNsaycsXG4gICAgICByZWc6IC9ebWVkaWFjbGs6KD86aWQ9KFxcUyopKT8gKihbXlxccz1dKikoPzo9KFxcUyopKT8oPzogKnJhdGU9KFxcZCspXFwvKFxcZCspKT8vLFxuICAgICAgbmFtZXM6IFsnaWQnLCAnbWVkaWFDbG9ja05hbWUnLCAnbWVkaWFDbG9ja1ZhbHVlJywgJ3JhdGVOdW1lcmF0b3InLCAncmF0ZURlbm9taW5hdG9yJ10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHZhciBzdHIgPSAnbWVkaWFjbGs6JztcbiAgICAgICAgc3RyICs9IChvLmlkICE9IG51bGwgPyAnaWQ9JXMgJXMnIDogJyV2JXMnKTtcbiAgICAgICAgc3RyICs9IChvLm1lZGlhQ2xvY2tWYWx1ZSAhPSBudWxsID8gJz0lcycgOiAnJyk7XG4gICAgICAgIHN0ciArPSAoby5yYXRlTnVtZXJhdG9yICE9IG51bGwgPyAnIHJhdGU9JXMnIDogJycpO1xuICAgICAgICBzdHIgKz0gKG8ucmF0ZURlbm9taW5hdG9yICE9IG51bGwgPyAnLyVzJyA6ICcnKTtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9a2V5d2RzOmtleXdvcmRzXG4gICAgICBuYW1lOiAna2V5d29yZHMnLFxuICAgICAgcmVnOiAvXmtleXdkczooLispJC8sXG4gICAgICBmb3JtYXQ6ICdrZXl3ZHM6JXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWNvbnRlbnQ6bWFpblxuICAgICAgbmFtZTogJ2NvbnRlbnQnLFxuICAgICAgcmVnOiAvXmNvbnRlbnQ6KC4rKS8sXG4gICAgICBmb3JtYXQ6ICdjb250ZW50OiVzJ1xuICAgIH0sXG4gICAgLy8gQkZDUCBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNDU4M1xuICAgIHtcbiAgICAgIC8vIGE9Zmxvb3JjdHJsOmMtc1xuICAgICAgbmFtZTogJ2JmY3BGbG9vckN0cmwnLFxuICAgICAgcmVnOiAvXmZsb29yY3RybDooYy1vbmx5fHMtb25seXxjLXMpLyxcbiAgICAgIGZvcm1hdDogJ2Zsb29yY3RybDolcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9Y29uZmlkOjFcbiAgICAgIG5hbWU6ICdiZmNwQ29uZklkJyxcbiAgICAgIHJlZzogL15jb25maWQ6KFxcZCspLyxcbiAgICAgIGZvcm1hdDogJ2NvbmZpZDolcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9dXNlcmlkOjFcbiAgICAgIG5hbWU6ICdiZmNwVXNlcklkJyxcbiAgICAgIHJlZzogL151c2VyaWQ6KFxcZCspLyxcbiAgICAgIGZvcm1hdDogJ3VzZXJpZDolcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9Zmxvb3JpZDoxXG4gICAgICBuYW1lOiAnYmZjcEZsb29ySWQnLFxuICAgICAgcmVnOiAvXmZsb29yaWQ6KC4rKSAoPzptLXN0cmVhbXxtc3RybSk6KC4rKS8sXG4gICAgICBuYW1lczogWydpZCcsICdtU3RyZWFtJ10sXG4gICAgICBmb3JtYXQ6ICdmbG9vcmlkOiVzIG1zdHJtOiVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYW55IGE9IHRoYXQgd2UgZG9uJ3QgdW5kZXJzdGFuZCBpcyBrZXB0IHZlcmJhdGltIG9uIG1lZGlhLmludmFsaWRcbiAgICAgIHB1c2g6ICdpbnZhbGlkJyxcbiAgICAgIG5hbWVzOiBbJ3ZhbHVlJ11cbiAgICB9XG4gIF1cbn07XG5cbi8vIHNldCBzZW5zaWJsZSBkZWZhdWx0cyB0byBhdm9pZCBwb2xsdXRpbmcgdGhlIGdyYW1tYXIgd2l0aCBib3JpbmcgZGV0YWlsc1xuT2JqZWN0LmtleXMoZ3JhbW1hcikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIHZhciBvYmpzID0gZ3JhbW1hcltrZXldO1xuICBvYmpzLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgIGlmICghb2JqLnJlZykge1xuICAgICAgb2JqLnJlZyA9IC8oLiopLztcbiAgICB9XG4gICAgaWYgKCFvYmouZm9ybWF0KSB7XG4gICAgICBvYmouZm9ybWF0ID0gJyVzJztcbiAgICB9XG4gIH0pO1xufSk7XG4iLCJ2YXIgdG9JbnRJZkludCA9IGZ1bmN0aW9uICh2KSB7XG4gIHJldHVybiBTdHJpbmcoTnVtYmVyKHYpKSA9PT0gdiA/IE51bWJlcih2KSA6IHY7XG59O1xuXG52YXIgYXR0YWNoUHJvcGVydGllcyA9IGZ1bmN0aW9uIChtYXRjaCwgbG9jYXRpb24sIG5hbWVzLCByYXdOYW1lKSB7XG4gIGlmIChyYXdOYW1lICYmICFuYW1lcykge1xuICAgIGxvY2F0aW9uW3Jhd05hbWVdID0gdG9JbnRJZkludChtYXRjaFsxXSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgaWYgKG1hdGNoW2krMV0gIT0gbnVsbCkge1xuICAgICAgICBsb2NhdGlvbltuYW1lc1tpXV0gPSB0b0ludElmSW50KG1hdGNoW2krMV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIHBhcnNlUmVnID0gZnVuY3Rpb24gKG9iaiwgbG9jYXRpb24sIGNvbnRlbnQpIHtcbiAgdmFyIG5lZWRzQmxhbmsgPSBvYmoubmFtZSAmJiBvYmoubmFtZXM7XG4gIGlmIChvYmoucHVzaCAmJiAhbG9jYXRpb25bb2JqLnB1c2hdKSB7XG4gICAgbG9jYXRpb25bb2JqLnB1c2hdID0gW107XG4gIH1cbiAgZWxzZSBpZiAobmVlZHNCbGFuayAmJiAhbG9jYXRpb25bb2JqLm5hbWVdKSB7XG4gICAgbG9jYXRpb25bb2JqLm5hbWVdID0ge307XG4gIH1cbiAgdmFyIGtleUxvY2F0aW9uID0gb2JqLnB1c2ggP1xuICAgIHt9IDogIC8vIGJsYW5rIG9iamVjdCB0aGF0IHdpbGwgYmUgcHVzaGVkXG4gICAgbmVlZHNCbGFuayA/IGxvY2F0aW9uW29iai5uYW1lXSA6IGxvY2F0aW9uOyAvLyBvdGhlcndpc2UsIG5hbWVkIGxvY2F0aW9uIG9yIHJvb3RcblxuICBhdHRhY2hQcm9wZXJ0aWVzKGNvbnRlbnQubWF0Y2gob2JqLnJlZyksIGtleUxvY2F0aW9uLCBvYmoubmFtZXMsIG9iai5uYW1lKTtcblxuICBpZiAob2JqLnB1c2gpIHtcbiAgICBsb2NhdGlvbltvYmoucHVzaF0ucHVzaChrZXlMb2NhdGlvbik7XG4gIH1cbn07XG5cbnZhciBncmFtbWFyID0gcmVxdWlyZSgnLi9ncmFtbWFyJyk7XG52YXIgdmFsaWRMaW5lID0gUmVnRXhwLnByb3RvdHlwZS50ZXN0LmJpbmQoL14oW2Etel0pPSguKikvKTtcblxuZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uIChzZHApIHtcbiAgdmFyIHNlc3Npb24gPSB7fVxuICAgICwgbWVkaWEgPSBbXVxuICAgICwgbG9jYXRpb24gPSBzZXNzaW9uOyAvLyBwb2ludHMgYXQgd2hlcmUgcHJvcGVydGllcyBnbyB1bmRlciAob25lIG9mIHRoZSBhYm92ZSlcblxuICAvLyBwYXJzZSBsaW5lcyB3ZSB1bmRlcnN0YW5kXG4gIHNkcC5zcGxpdCgvKFxcclxcbnxcXHJ8XFxuKS8pLmZpbHRlcih2YWxpZExpbmUpLmZvckVhY2goZnVuY3Rpb24gKGwpIHtcbiAgICB2YXIgdHlwZSA9IGxbMF07XG4gICAgdmFyIGNvbnRlbnQgPSBsLnNsaWNlKDIpO1xuICAgIGlmICh0eXBlID09PSAnbScpIHtcbiAgICAgIG1lZGlhLnB1c2goe3J0cDogW10sIGZtdHA6IFtdfSk7XG4gICAgICBsb2NhdGlvbiA9IG1lZGlhW21lZGlhLmxlbmd0aC0xXTsgLy8gcG9pbnQgYXQgbGF0ZXN0IG1lZGlhIGxpbmVcbiAgICB9XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IChncmFtbWFyW3R5cGVdIHx8IFtdKS5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgdmFyIG9iaiA9IGdyYW1tYXJbdHlwZV1bal07XG4gICAgICBpZiAob2JqLnJlZy50ZXN0KGNvbnRlbnQpKSB7XG4gICAgICAgIHJldHVybiBwYXJzZVJlZyhvYmosIGxvY2F0aW9uLCBjb250ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHNlc3Npb24ubWVkaWEgPSBtZWRpYTsgLy8gbGluayBpdCB1cFxuICByZXR1cm4gc2Vzc2lvbjtcbn07XG5cbnZhciBwYXJhbVJlZHVjZXIgPSBmdW5jdGlvbiAoYWNjLCBleHByKSB7XG4gIHZhciBzID0gZXhwci5zcGxpdCgvPSguKykvLCAyKTtcbiAgaWYgKHMubGVuZ3RoID09PSAyKSB7XG4gICAgYWNjW3NbMF1dID0gdG9JbnRJZkludChzWzFdKTtcbiAgfSBlbHNlIGlmIChzLmxlbmd0aCA9PT0gMSAmJiBleHByLmxlbmd0aCA+IDEpIHtcbiAgICBhY2Nbc1swXV0gPSB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIGFjYztcbn07XG5cbmV4cG9ydHMucGFyc2VQYXJhbXMgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIuc3BsaXQoLztcXHM/LykucmVkdWNlKHBhcmFtUmVkdWNlciwge30pO1xufTtcblxuLy8gRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgLSBhbGlhcyB3aWxsIGJlIHJlbW92ZWQgaW4gMy4wLjBcbmV4cG9ydHMucGFyc2VGbXRwQ29uZmlnID0gZXhwb3J0cy5wYXJzZVBhcmFtcztcblxuZXhwb3J0cy5wYXJzZVBheWxvYWRzID0gZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnRvU3RyaW5nKCkuc3BsaXQoJyAnKS5tYXAoTnVtYmVyKTtcbn07XG5cbmV4cG9ydHMucGFyc2VSZW1vdGVDYW5kaWRhdGVzID0gZnVuY3Rpb24gKHN0cikge1xuICB2YXIgY2FuZGlkYXRlcyA9IFtdO1xuICB2YXIgcGFydHMgPSBzdHIuc3BsaXQoJyAnKS5tYXAodG9JbnRJZkludCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICBjYW5kaWRhdGVzLnB1c2goe1xuICAgICAgY29tcG9uZW50OiBwYXJ0c1tpXSxcbiAgICAgIGlwOiBwYXJ0c1tpICsgMV0sXG4gICAgICBwb3J0OiBwYXJ0c1tpICsgMl1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gY2FuZGlkYXRlcztcbn07XG5cbmV4cG9ydHMucGFyc2VJbWFnZUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIuc3BsaXQoJyAnKS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbS5zdWJzdHJpbmcoMSwgaXRlbS5sZW5ndGgtMSkuc3BsaXQoJywnKS5yZWR1Y2UocGFyYW1SZWR1Y2VyLCB7fSk7XG4gIH0pO1xufTtcblxuZXhwb3J0cy5wYXJzZVNpbXVsY2FzdFN0cmVhbUxpc3QgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIuc3BsaXQoJzsnKS5tYXAoZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgIHJldHVybiBzdHJlYW0uc3BsaXQoJywnKS5tYXAoZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgdmFyIHNjaWQsIHBhdXNlZCA9IGZhbHNlO1xuXG4gICAgICBpZiAoZm9ybWF0WzBdICE9PSAnficpIHtcbiAgICAgICAgc2NpZCA9IHRvSW50SWZJbnQoZm9ybWF0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjaWQgPSB0b0ludElmSW50KGZvcm1hdC5zdWJzdHJpbmcoMSwgZm9ybWF0Lmxlbmd0aCkpO1xuICAgICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzY2lkOiBzY2lkLFxuICAgICAgICBwYXVzZWQ6IHBhdXNlZFxuICAgICAgfTtcbiAgICB9KTtcbiAgfSk7XG59O1xuIiwidmFyIGdyYW1tYXIgPSByZXF1aXJlKCcuL2dyYW1tYXInKTtcblxuLy8gY3VzdG9taXplZCB1dGlsLmZvcm1hdCAtIGRpc2NhcmRzIGV4Y2VzcyBhcmd1bWVudHMgYW5kIGNhbiB2b2lkIG1pZGRsZSBvbmVzXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2R2JV0vZztcbnZhciBmb3JtYXQgPSBmdW5jdGlvbiAoZm9ybWF0U3RyKSB7XG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgcmV0dXJuIGZvcm1hdFN0ci5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24gKHgpIHtcbiAgICBpZiAoaSA+PSBsZW4pIHtcbiAgICAgIHJldHVybiB4OyAvLyBtaXNzaW5nIGFyZ3VtZW50XG4gICAgfVxuICAgIHZhciBhcmcgPSBhcmdzW2ldO1xuICAgIGkgKz0gMTtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICBjYXNlICclJSc6XG4gICAgICByZXR1cm4gJyUnO1xuICAgIGNhc2UgJyVzJzpcbiAgICAgIHJldHVybiBTdHJpbmcoYXJnKTtcbiAgICBjYXNlICclZCc6XG4gICAgICByZXR1cm4gTnVtYmVyKGFyZyk7XG4gICAgY2FzZSAnJXYnOlxuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgfSk7XG4gIC8vIE5COiB3ZSBkaXNjYXJkIGV4Y2VzcyBhcmd1bWVudHMgLSB0aGV5IGFyZSB0eXBpY2FsbHkgdW5kZWZpbmVkIGZyb20gbWFrZUxpbmVcbn07XG5cbnZhciBtYWtlTGluZSA9IGZ1bmN0aW9uICh0eXBlLCBvYmosIGxvY2F0aW9uKSB7XG4gIHZhciBzdHIgPSBvYmouZm9ybWF0IGluc3RhbmNlb2YgRnVuY3Rpb24gP1xuICAgIChvYmouZm9ybWF0KG9iai5wdXNoID8gbG9jYXRpb24gOiBsb2NhdGlvbltvYmoubmFtZV0pKSA6XG4gICAgb2JqLmZvcm1hdDtcblxuICB2YXIgYXJncyA9IFt0eXBlICsgJz0nICsgc3RyXTtcbiAgaWYgKG9iai5uYW1lcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLm5hbWVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICB2YXIgbiA9IG9iai5uYW1lc1tpXTtcbiAgICAgIGlmIChvYmoubmFtZSkge1xuICAgICAgICBhcmdzLnB1c2gobG9jYXRpb25bb2JqLm5hbWVdW25dKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgeyAvLyBmb3IgbUxpbmUgYW5kIHB1c2ggYXR0cmlidXRlc1xuICAgICAgICBhcmdzLnB1c2gobG9jYXRpb25bb2JqLm5hbWVzW2ldXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIGFyZ3MucHVzaChsb2NhdGlvbltvYmoubmFtZV0pO1xuICB9XG4gIHJldHVybiBmb3JtYXQuYXBwbHkobnVsbCwgYXJncyk7XG59O1xuXG4vLyBSRkMgc3BlY2lmaWVkIG9yZGVyXG4vLyBUT0RPOiBleHRlbmQgdGhpcyB3aXRoIGFsbCB0aGUgcmVzdFxudmFyIGRlZmF1bHRPdXRlck9yZGVyID0gW1xuICAndicsICdvJywgJ3MnLCAnaScsXG4gICd1JywgJ2UnLCAncCcsICdjJyxcbiAgJ2InLCAndCcsICdyJywgJ3onLCAnYSdcbl07XG52YXIgZGVmYXVsdElubmVyT3JkZXIgPSBbJ2knLCAnYycsICdiJywgJ2EnXTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzZXNzaW9uLCBvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAvLyBlbnN1cmUgY2VydGFpbiBwcm9wZXJ0aWVzIGV4aXN0XG4gIGlmIChzZXNzaW9uLnZlcnNpb24gPT0gbnVsbCkge1xuICAgIHNlc3Npb24udmVyc2lvbiA9IDA7IC8vICd2PTAnIG11c3QgYmUgdGhlcmUgKG9ubHkgZGVmaW5lZCB2ZXJzaW9uIGF0bSlcbiAgfVxuICBpZiAoc2Vzc2lvbi5uYW1lID09IG51bGwpIHtcbiAgICBzZXNzaW9uLm5hbWUgPSAnICc7IC8vICdzPSAnIG11c3QgYmUgdGhlcmUgaWYgbm8gbWVhbmluZ2Z1bCBuYW1lIHNldFxuICB9XG4gIHNlc3Npb24ubWVkaWEuZm9yRWFjaChmdW5jdGlvbiAobUxpbmUpIHtcbiAgICBpZiAobUxpbmUucGF5bG9hZHMgPT0gbnVsbCkge1xuICAgICAgbUxpbmUucGF5bG9hZHMgPSAnJztcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBvdXRlck9yZGVyID0gb3B0cy5vdXRlck9yZGVyIHx8IGRlZmF1bHRPdXRlck9yZGVyO1xuICB2YXIgaW5uZXJPcmRlciA9IG9wdHMuaW5uZXJPcmRlciB8fCBkZWZhdWx0SW5uZXJPcmRlcjtcbiAgdmFyIHNkcCA9IFtdO1xuXG4gIC8vIGxvb3AgdGhyb3VnaCBvdXRlck9yZGVyIGZvciBtYXRjaGluZyBwcm9wZXJ0aWVzIG9uIHNlc3Npb25cbiAgb3V0ZXJPcmRlci5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgZ3JhbW1hclt0eXBlXS5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIGlmIChvYmoubmFtZSBpbiBzZXNzaW9uICYmIHNlc3Npb25bb2JqLm5hbWVdICE9IG51bGwpIHtcbiAgICAgICAgc2RwLnB1c2gobWFrZUxpbmUodHlwZSwgb2JqLCBzZXNzaW9uKSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvYmoucHVzaCBpbiBzZXNzaW9uICYmIHNlc3Npb25bb2JqLnB1c2hdICE9IG51bGwpIHtcbiAgICAgICAgc2Vzc2lvbltvYmoucHVzaF0uZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICBzZHAucHVzaChtYWtlTGluZSh0eXBlLCBvYmosIGVsKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICAvLyB0aGVuIGZvciBlYWNoIG1lZGlhIGxpbmUsIGZvbGxvdyB0aGUgaW5uZXJPcmRlclxuICBzZXNzaW9uLm1lZGlhLmZvckVhY2goZnVuY3Rpb24gKG1MaW5lKSB7XG4gICAgc2RwLnB1c2gobWFrZUxpbmUoJ20nLCBncmFtbWFyLm1bMF0sIG1MaW5lKSk7XG5cbiAgICBpbm5lck9yZGVyLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIGdyYW1tYXJbdHlwZV0uZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIGlmIChvYmoubmFtZSBpbiBtTGluZSAmJiBtTGluZVtvYmoubmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgIHNkcC5wdXNoKG1ha2VMaW5lKHR5cGUsIG9iaiwgbUxpbmUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmoucHVzaCBpbiBtTGluZSAmJiBtTGluZVtvYmoucHVzaF0gIT0gbnVsbCkge1xuICAgICAgICAgIG1MaW5lW29iai5wdXNoXS5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgc2RwLnB1c2gobWFrZUxpbmUodHlwZSwgb2JqLCBlbCkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHNkcC5qb2luKCdcXHJcXG4nKSArICdcXHJcXG4nO1xufTtcbiIsInZhciBwYXJzZXIgPSByZXF1aXJlKCcuL3BhcnNlcicpO1xudmFyIHdyaXRlciA9IHJlcXVpcmUoJy4vd3JpdGVyJyk7XG5cbmV4cG9ydHMud3JpdGUgPSB3cml0ZXI7XG5leHBvcnRzLnBhcnNlID0gcGFyc2VyLnBhcnNlO1xuZXhwb3J0cy5wYXJzZVBhcmFtcyA9IHBhcnNlci5wYXJzZVBhcmFtcztcbmV4cG9ydHMucGFyc2VGbXRwQ29uZmlnID0gcGFyc2VyLnBhcnNlRm10cENvbmZpZzsgLy8gQWxpYXMgb2YgcGFyc2VQYXJhbXMoKS5cbmV4cG9ydHMucGFyc2VQYXlsb2FkcyA9IHBhcnNlci5wYXJzZVBheWxvYWRzO1xuZXhwb3J0cy5wYXJzZVJlbW90ZUNhbmRpZGF0ZXMgPSBwYXJzZXIucGFyc2VSZW1vdGVDYW5kaWRhdGVzO1xuZXhwb3J0cy5wYXJzZUltYWdlQXR0cmlidXRlcyA9IHBhcnNlci5wYXJzZUltYWdlQXR0cmlidXRlcztcbmV4cG9ydHMucGFyc2VTaW11bGNhc3RTdHJlYW1MaXN0ID0gcGFyc2VyLnBhcnNlU2ltdWxjYXN0U3RyZWFtTGlzdDtcbiIsImltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgdHlwZSB7IE1lZGlhRGVzY3JpcHRpb24gfSBmcm9tICdzZHAtdHJhbnNmb3JtJztcbmltcG9ydCB7IHBhcnNlLCB3cml0ZSB9IGZyb20gJ3NkcC10cmFuc2Zvcm0nO1xuaW1wb3J0IHsgZGVib3VuY2UgfSBmcm9tICd0cy1kZWJvdW5jZSc7XG5pbXBvcnQgbG9nLCB7IExvZ2dlck5hbWVzLCBnZXRMb2dnZXIgfSBmcm9tICcuLi9sb2dnZXInO1xuaW1wb3J0IHsgTmVnb3RpYXRpb25FcnJvciwgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSB9IGZyb20gJy4vZXJyb3JzJztcbmltcG9ydCB0eXBlIHsgTG9nZ2VyT3B0aW9ucyB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgZGRFeHRlbnNpb25VUkksIGlzQ2hyb21pdW1CYXNlZCwgaXNTVkNDb2RlYyB9IGZyb20gJy4vdXRpbHMnO1xuXG4vKiogQGludGVybmFsICovXG5pbnRlcmZhY2UgVHJhY2tCaXRyYXRlSW5mbyB7XG4gIGNpZD86IHN0cmluZztcbiAgdHJhbnNjZWl2ZXI/OiBSVENSdHBUcmFuc2NlaXZlcjtcbiAgY29kZWM6IHN0cmluZztcbiAgbWF4YnI6IG51bWJlcjtcbn1cblxuLyogVGhlIHN2YyBjb2RlYyAoYXYxL3ZwOSkgd291bGQgdXNlIGEgdmVyeSBsb3cgYml0cmF0ZSBhdCB0aGUgYmVnaW5pbmcgYW5kXG5pbmNyZWFzZSBzbG93bHkgYnkgdGhlIGJhbmR3aWR0aCBlc3RpbWF0b3IgdW50aWwgaXQgcmVhY2ggdGhlIHRhcmdldCBiaXRyYXRlLiBUaGVcbnByb2Nlc3MgY29tbW9ubHkgY29zdCBtb3JlIHRoYW4gMTAgc2Vjb25kcyBjYXVzZSBzdWJzY3JpYmVyIHdpbGwgZ2V0IGJsdXIgdmlkZW8gYXRcbnRoZSBmaXJzdCBmZXcgc2Vjb25kcy4gU28gd2UgdXNlIGEgNzAlIG9mIHRhcmdldCBiaXRyYXRlIGhlcmUgYXMgdGhlIHN0YXJ0IGJpdHJhdGUgdG9cbmVsaW1pbmF0ZSB0aGlzIGlzc3VlLlxuKi9cbmNvbnN0IHN0YXJ0Qml0cmF0ZUZvclNWQyA9IDAuNztcblxuZXhwb3J0IGNvbnN0IFBDRXZlbnRzID0ge1xuICBOZWdvdGlhdGlvblN0YXJ0ZWQ6ICduZWdvdGlhdGlvblN0YXJ0ZWQnLFxuICBOZWdvdGlhdGlvbkNvbXBsZXRlOiAnbmVnb3RpYXRpb25Db21wbGV0ZScsXG4gIFJUUFZpZGVvUGF5bG9hZFR5cGVzOiAncnRwVmlkZW9QYXlsb2FkVHlwZXMnLFxufSBhcyBjb25zdDtcblxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUENUcmFuc3BvcnQgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBwcml2YXRlIF9wYzogUlRDUGVlckNvbm5lY3Rpb24gfCBudWxsO1xuXG4gIHByaXZhdGUgZ2V0IHBjKCkge1xuICAgIGlmICghdGhpcy5fcGMpIHtcbiAgICAgIHRoaXMuX3BjID0gdGhpcy5jcmVhdGVQQygpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcGM7XG4gIH1cblxuICBwcml2YXRlIGNvbmZpZz86IFJUQ0NvbmZpZ3VyYXRpb247XG5cbiAgcHJpdmF0ZSBtZWRpYUNvbnN0cmFpbnRzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcblxuICBwcml2YXRlIGxvZyA9IGxvZztcblxuICBwcml2YXRlIGxvZ2dlck9wdGlvbnM6IExvZ2dlck9wdGlvbnM7XG5cbiAgcGVuZGluZ0NhbmRpZGF0ZXM6IFJUQ0ljZUNhbmRpZGF0ZUluaXRbXSA9IFtdO1xuXG4gIHJlc3RhcnRpbmdJY2U6IGJvb2xlYW4gPSBmYWxzZTtcblxuICByZW5lZ290aWF0ZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIHRyYWNrQml0cmF0ZXM6IFRyYWNrQml0cmF0ZUluZm9bXSA9IFtdO1xuXG4gIHJlbW90ZVN0ZXJlb01pZHM6IHN0cmluZ1tdID0gW107XG5cbiAgcmVtb3RlTmFja01pZHM6IHN0cmluZ1tdID0gW107XG5cbiAgb25PZmZlcj86IChvZmZlcjogUlRDU2Vzc2lvbkRlc2NyaXB0aW9uSW5pdCkgPT4gdm9pZDtcblxuICBvbkljZUNhbmRpZGF0ZT86IChjYW5kaWRhdGU6IFJUQ0ljZUNhbmRpZGF0ZSkgPT4gdm9pZDtcblxuICBvbkljZUNhbmRpZGF0ZUVycm9yPzogKGV2OiBFdmVudCkgPT4gdm9pZDtcblxuICBvbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZT86IChzdGF0ZTogUlRDUGVlckNvbm5lY3Rpb25TdGF0ZSkgPT4gdm9pZDtcblxuICBvbkljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZT86IChzdGF0ZTogUlRDSWNlQ29ubmVjdGlvblN0YXRlKSA9PiB2b2lkO1xuXG4gIG9uU2lnbmFsaW5nU3RhdGVjaGFuZ2U/OiAoc3RhdGU6IFJUQ1NpZ25hbGluZ1N0YXRlKSA9PiB2b2lkO1xuXG4gIG9uRGF0YUNoYW5uZWw/OiAoZXY6IFJUQ0RhdGFDaGFubmVsRXZlbnQpID0+IHZvaWQ7XG5cbiAgb25UcmFjaz86IChldjogUlRDVHJhY2tFdmVudCkgPT4gdm9pZDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBjb25maWc/OiBSVENDb25maWd1cmF0aW9uLFxuICAgIG1lZGlhQ29uc3RyYWludHM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+ID0ge30sXG4gICAgbG9nZ2VyT3B0aW9uczogTG9nZ2VyT3B0aW9ucyA9IHt9LFxuICApIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubG9nID0gZ2V0TG9nZ2VyKGxvZ2dlck9wdGlvbnMubG9nZ2VyTmFtZSA/PyBMb2dnZXJOYW1lcy5QQ1RyYW5zcG9ydCk7XG4gICAgdGhpcy5sb2dnZXJPcHRpb25zID0gbG9nZ2VyT3B0aW9ucztcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLm1lZGlhQ29uc3RyYWludHMgPSBtZWRpYUNvbnN0cmFpbnRzO1xuICAgIHRoaXMuX3BjID0gdGhpcy5jcmVhdGVQQygpO1xuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGVQQygpIHtcbiAgICBjb25zdCBwYyA9IGlzQ2hyb21pdW1CYXNlZCgpXG4gICAgICA/IC8vIEB0cy1leHBlY3QtZXJyb3IgY2hyb21lIGFsbG93cyBhZGRpdGlvbmFsIG1lZGlhIGNvbnN0cmFpbnRzIHRvIGJlIHBhc3NlZCBpbnRvIHRoZSBSVENQZWVyQ29ubmVjdGlvbiBjb25zdHJ1Y3RvclxuICAgICAgICBuZXcgUlRDUGVlckNvbm5lY3Rpb24odGhpcy5jb25maWcsIHRoaXMubWVkaWFDb25zdHJhaW50cylcbiAgICAgIDogbmV3IFJUQ1BlZXJDb25uZWN0aW9uKHRoaXMuY29uZmlnKTtcblxuICAgIHBjLm9uaWNlY2FuZGlkYXRlID0gKGV2KSA9PiB7XG4gICAgICBpZiAoIWV2LmNhbmRpZGF0ZSkgcmV0dXJuO1xuICAgICAgdGhpcy5vbkljZUNhbmRpZGF0ZT8uKGV2LmNhbmRpZGF0ZSk7XG4gICAgfTtcbiAgICBwYy5vbmljZWNhbmRpZGF0ZWVycm9yID0gKGV2KSA9PiB7XG4gICAgICB0aGlzLm9uSWNlQ2FuZGlkYXRlRXJyb3I/Lihldik7XG4gICAgfTtcblxuICAgIHBjLm9uaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgICAgdGhpcy5vbkljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZT8uKHBjLmljZUNvbm5lY3Rpb25TdGF0ZSk7XG4gICAgfTtcblxuICAgIHBjLm9uc2lnbmFsaW5nc3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICB0aGlzLm9uU2lnbmFsaW5nU3RhdGVjaGFuZ2U/LihwYy5zaWduYWxpbmdTdGF0ZSk7XG4gICAgfTtcblxuICAgIHBjLm9uY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgICAgdGhpcy5vbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZT8uKHBjLmNvbm5lY3Rpb25TdGF0ZSk7XG4gICAgfTtcbiAgICBwYy5vbmRhdGFjaGFubmVsID0gKGV2KSA9PiB7XG4gICAgICB0aGlzLm9uRGF0YUNoYW5uZWw/Lihldik7XG4gICAgfTtcbiAgICBwYy5vbnRyYWNrID0gKGV2KSA9PiB7XG4gICAgICB0aGlzLm9uVHJhY2s/Lihldik7XG4gICAgfTtcbiAgICByZXR1cm4gcGM7XG4gIH1cblxuICBwcml2YXRlIGdldCBsb2dDb250ZXh0KCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi50aGlzLmxvZ2dlck9wdGlvbnMubG9nZ2VyQ29udGV4dENiPy4oKSxcbiAgICB9O1xuICB9XG5cbiAgZ2V0IGlzSUNFQ29ubmVjdGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLl9wYyAhPT0gbnVsbCAmJlxuICAgICAgKHRoaXMucGMuaWNlQ29ubmVjdGlvblN0YXRlID09PSAnY29ubmVjdGVkJyB8fCB0aGlzLnBjLmljZUNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2NvbXBsZXRlZCcpXG4gICAgKTtcbiAgfVxuXG4gIGFzeW5jIGFkZEljZUNhbmRpZGF0ZShjYW5kaWRhdGU6IFJUQ0ljZUNhbmRpZGF0ZUluaXQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAodGhpcy5wYy5yZW1vdGVEZXNjcmlwdGlvbiAmJiAhdGhpcy5yZXN0YXJ0aW5nSWNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYy5hZGRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKTtcbiAgICB9XG4gICAgdGhpcy5wZW5kaW5nQ2FuZGlkYXRlcy5wdXNoKGNhbmRpZGF0ZSk7XG4gIH1cblxuICBhc3luYyBzZXRSZW1vdGVEZXNjcmlwdGlvbihzZDogUlRDU2Vzc2lvbkRlc2NyaXB0aW9uSW5pdCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGxldCBtdW5nZWRTRFA6IHN0cmluZyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICBpZiAoc2QudHlwZSA9PT0gJ29mZmVyJykge1xuICAgICAgbGV0IHsgc3RlcmVvTWlkcywgbmFja01pZHMgfSA9IGV4dHJhY3RTdGVyZW9BbmROYWNrQXVkaW9Gcm9tT2ZmZXIoc2QpO1xuICAgICAgdGhpcy5yZW1vdGVTdGVyZW9NaWRzID0gc3RlcmVvTWlkcztcbiAgICAgIHRoaXMucmVtb3RlTmFja01pZHMgPSBuYWNrTWlkcztcbiAgICB9IGVsc2UgaWYgKHNkLnR5cGUgPT09ICdhbnN3ZXInKSB7XG4gICAgICBjb25zdCBzZHBQYXJzZWQgPSBwYXJzZShzZC5zZHAgPz8gJycpO1xuICAgICAgc2RwUGFyc2VkLm1lZGlhLmZvckVhY2goKG1lZGlhKSA9PiB7XG4gICAgICAgIGlmIChtZWRpYS50eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICAgICAgLy8gbXVuZyBzZHAgZm9yIG9wdXMgYml0cmF0ZSBzZXR0aW5nc1xuICAgICAgICAgIHRoaXMudHJhY2tCaXRyYXRlcy5zb21lKCh0cmFja2JyKTogYm9vbGVhbiA9PiB7XG4gICAgICAgICAgICBpZiAoIXRyYWNrYnIudHJhbnNjZWl2ZXIgfHwgbWVkaWEubWlkICE9IHRyYWNrYnIudHJhbnNjZWl2ZXIubWlkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGNvZGVjUGF5bG9hZCA9IDA7XG4gICAgICAgICAgICBtZWRpYS5ydHAuc29tZSgocnRwKTogYm9vbGVhbiA9PiB7XG4gICAgICAgICAgICAgIGlmIChydHAuY29kZWMudG9VcHBlckNhc2UoKSA9PT0gdHJhY2tici5jb2RlYy50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgY29kZWNQYXlsb2FkID0gcnRwLnBheWxvYWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChjb2RlY1BheWxvYWQgPT09IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBmbXRwRm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZm10cCBvZiBtZWRpYS5mbXRwKSB7XG4gICAgICAgICAgICAgIGlmIChmbXRwLnBheWxvYWQgPT09IGNvZGVjUGF5bG9hZCkge1xuICAgICAgICAgICAgICAgIGZtdHAuY29uZmlnID0gZm10cC5jb25maWdcbiAgICAgICAgICAgICAgICAgIC5zcGxpdCgnOycpXG4gICAgICAgICAgICAgICAgICAuZmlsdGVyKChhdHRyKSA9PiAhYXR0ci5pbmNsdWRlcygnbWF4YXZlcmFnZWJpdHJhdGUnKSlcbiAgICAgICAgICAgICAgICAgIC5qb2luKCc7Jyk7XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNrYnIubWF4YnIgPiAwKSB7XG4gICAgICAgICAgICAgICAgICBmbXRwLmNvbmZpZyArPSBgO21heGF2ZXJhZ2ViaXRyYXRlPSR7dHJhY2tici5tYXhiciAqIDEwMDB9YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm10cEZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWZtdHBGb3VuZCkge1xuICAgICAgICAgICAgICBpZiAodHJhY2tici5tYXhiciA+IDApIHtcbiAgICAgICAgICAgICAgICBtZWRpYS5mbXRwLnB1c2goe1xuICAgICAgICAgICAgICAgICAgcGF5bG9hZDogY29kZWNQYXlsb2FkLFxuICAgICAgICAgICAgICAgICAgY29uZmlnOiBgbWF4YXZlcmFnZWJpdHJhdGU9JHt0cmFja2JyLm1heGJyICogMTAwMH1gLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIG11bmdlZFNEUCA9IHdyaXRlKHNkcFBhcnNlZCk7XG4gICAgfVxuICAgIGF3YWl0IHRoaXMuc2V0TXVuZ2VkU0RQKHNkLCBtdW5nZWRTRFAsIHRydWUpO1xuXG4gICAgdGhpcy5wZW5kaW5nQ2FuZGlkYXRlcy5mb3JFYWNoKChjYW5kaWRhdGUpID0+IHtcbiAgICAgIHRoaXMucGMuYWRkSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSk7XG4gICAgfSk7XG4gICAgdGhpcy5wZW5kaW5nQ2FuZGlkYXRlcyA9IFtdO1xuICAgIHRoaXMucmVzdGFydGluZ0ljZSA9IGZhbHNlO1xuXG4gICAgaWYgKHRoaXMucmVuZWdvdGlhdGUpIHtcbiAgICAgIHRoaXMucmVuZWdvdGlhdGUgPSBmYWxzZTtcbiAgICAgIGF3YWl0IHRoaXMuY3JlYXRlQW5kU2VuZE9mZmVyKCk7XG4gICAgfSBlbHNlIGlmIChzZC50eXBlID09PSAnYW5zd2VyJykge1xuICAgICAgdGhpcy5lbWl0KFBDRXZlbnRzLk5lZ290aWF0aW9uQ29tcGxldGUpO1xuICAgICAgaWYgKHNkLnNkcCkge1xuICAgICAgICBjb25zdCBzZHBQYXJzZWQgPSBwYXJzZShzZC5zZHApO1xuICAgICAgICBzZHBQYXJzZWQubWVkaWEuZm9yRWFjaCgobWVkaWEpID0+IHtcbiAgICAgICAgICBpZiAobWVkaWEudHlwZSA9PT0gJ3ZpZGVvJykge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFBDRXZlbnRzLlJUUFZpZGVvUGF5bG9hZFR5cGVzLCBtZWRpYS5ydHApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gZGVib3VuY2VkIG5lZ290aWF0ZSBpbnRlcmZhY2VcbiAgbmVnb3RpYXRlID0gZGVib3VuY2UoYXN5bmMgKG9uRXJyb3I/OiAoZTogRXJyb3IpID0+IHZvaWQpID0+IHtcbiAgICB0aGlzLmVtaXQoUENFdmVudHMuTmVnb3RpYXRpb25TdGFydGVkKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5jcmVhdGVBbmRTZW5kT2ZmZXIoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAob25FcnJvcikge1xuICAgICAgICBvbkVycm9yKGUgYXMgRXJyb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIDEwMCk7XG5cbiAgYXN5bmMgY3JlYXRlQW5kU2VuZE9mZmVyKG9wdGlvbnM/OiBSVENPZmZlck9wdGlvbnMpIHtcbiAgICBpZiAodGhpcy5vbk9mZmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucz8uaWNlUmVzdGFydCkge1xuICAgICAgdGhpcy5sb2cuZGVidWcoJ3Jlc3RhcnRpbmcgSUNFJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHRoaXMucmVzdGFydGluZ0ljZSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3BjICYmIHRoaXMuX3BjLnNpZ25hbGluZ1N0YXRlID09PSAnaGF2ZS1sb2NhbC1vZmZlcicpIHtcbiAgICAgIC8vIHdlJ3JlIHdhaXRpbmcgZm9yIHRoZSBwZWVyIHRvIGFjY2VwdCBvdXIgb2ZmZXIsIHNvIHdlJ2xsIGp1c3Qgd2FpdFxuICAgICAgLy8gdGhlIG9ubHkgZXhjZXB0aW9uIHRvIHRoaXMgaXMgd2hlbiBJQ0UgcmVzdGFydCBpcyBuZWVkZWRcbiAgICAgIGNvbnN0IGN1cnJlbnRTRCA9IHRoaXMuX3BjLnJlbW90ZURlc2NyaXB0aW9uO1xuICAgICAgaWYgKG9wdGlvbnM/LmljZVJlc3RhcnQgJiYgY3VycmVudFNEKSB7XG4gICAgICAgIC8vIFRPRE86IGhhbmRsZSB3aGVuIElDRSByZXN0YXJ0IGlzIG5lZWRlZCBidXQgd2UgZG9uJ3QgaGF2ZSBhIHJlbW90ZSBkZXNjcmlwdGlvblxuICAgICAgICAvLyB0aGUgYmVzdCB0aGluZyB0byBkbyBpcyB0byByZWNyZWF0ZSB0aGUgcGVlcmNvbm5lY3Rpb25cbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oY3VycmVudFNEKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVuZWdvdGlhdGUgPSB0cnVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghdGhpcy5fcGMgfHwgdGhpcy5fcGMuc2lnbmFsaW5nU3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICB0aGlzLmxvZy53YXJuKCdjb3VsZCBub3QgY3JlYXRlT2ZmZXIgd2l0aCBjbG9zZWQgcGVlciBjb25uZWN0aW9uJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBhY3R1YWxseSBuZWdvdGlhdGVcbiAgICB0aGlzLmxvZy5kZWJ1Zygnc3RhcnRpbmcgdG8gbmVnb3RpYXRlJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMucGMuY3JlYXRlT2ZmZXIob3B0aW9ucyk7XG5cbiAgICBjb25zdCBzZHBQYXJzZWQgPSBwYXJzZShvZmZlci5zZHAgPz8gJycpO1xuICAgIHNkcFBhcnNlZC5tZWRpYS5mb3JFYWNoKChtZWRpYSkgPT4ge1xuICAgICAgaWYgKG1lZGlhLnR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgICAgZW5zdXJlQXVkaW9OYWNrQW5kU3RlcmVvKG1lZGlhLCBbXSwgW10pO1xuICAgICAgfSBlbHNlIGlmIChtZWRpYS50eXBlID09PSAndmlkZW8nKSB7XG4gICAgICAgIGVuc3VyZVZpZGVvRERFeHRlbnNpb25Gb3JTVkMobWVkaWEpO1xuICAgICAgICAvLyBtdW5nIHNkcCBmb3IgY29kZWMgYml0cmF0ZSBzZXR0aW5nIHRoYXQgY2FuJ3QgYXBwbHkgYnkgc2VuZEVuY29kaW5nXG4gICAgICAgIHRoaXMudHJhY2tCaXRyYXRlcy5zb21lKCh0cmFja2JyKTogYm9vbGVhbiA9PiB7XG4gICAgICAgICAgaWYgKCFtZWRpYS5tc2lkIHx8ICF0cmFja2JyLmNpZCB8fCAhbWVkaWEubXNpZC5pbmNsdWRlcyh0cmFja2JyLmNpZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgY29kZWNQYXlsb2FkID0gMDtcbiAgICAgICAgICBtZWRpYS5ydHAuc29tZSgocnRwKTogYm9vbGVhbiA9PiB7XG4gICAgICAgICAgICBpZiAocnRwLmNvZGVjLnRvVXBwZXJDYXNlKCkgPT09IHRyYWNrYnIuY29kZWMudG9VcHBlckNhc2UoKSkge1xuICAgICAgICAgICAgICBjb2RlY1BheWxvYWQgPSBydHAucGF5bG9hZDtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoY29kZWNQYXlsb2FkID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgZm10cEZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgZm9yIChjb25zdCBmbXRwIG9mIG1lZGlhLmZtdHApIHtcbiAgICAgICAgICAgIGlmIChmbXRwLnBheWxvYWQgPT09IGNvZGVjUGF5bG9hZCkge1xuICAgICAgICAgICAgICBpZiAoIWZtdHAuY29uZmlnLmluY2x1ZGVzKCd4LWdvb2dsZS1zdGFydC1iaXRyYXRlJykpIHtcbiAgICAgICAgICAgICAgICBmbXRwLmNvbmZpZyArPSBgO3gtZ29vZ2xlLXN0YXJ0LWJpdHJhdGU9JHtNYXRoLnJvdW5kKFxuICAgICAgICAgICAgICAgICAgdHJhY2tici5tYXhiciAqIHN0YXJ0Qml0cmF0ZUZvclNWQyxcbiAgICAgICAgICAgICAgICApfWA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFmbXRwLmNvbmZpZy5pbmNsdWRlcygneC1nb29nbGUtbWF4LWJpdHJhdGUnKSkge1xuICAgICAgICAgICAgICAgIGZtdHAuY29uZmlnICs9IGA7eC1nb29nbGUtbWF4LWJpdHJhdGU9JHt0cmFja2JyLm1heGJyfWA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZm10cEZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFmbXRwRm91bmQpIHtcbiAgICAgICAgICAgIG1lZGlhLmZtdHAucHVzaCh7XG4gICAgICAgICAgICAgIHBheWxvYWQ6IGNvZGVjUGF5bG9hZCxcbiAgICAgICAgICAgICAgY29uZmlnOiBgeC1nb29nbGUtc3RhcnQtYml0cmF0ZT0ke01hdGgucm91bmQoXG4gICAgICAgICAgICAgICAgdHJhY2tici5tYXhiciAqIHN0YXJ0Qml0cmF0ZUZvclNWQyxcbiAgICAgICAgICAgICAgKX07eC1nb29nbGUtbWF4LWJpdHJhdGU9JHt0cmFja2JyLm1heGJyfWAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhd2FpdCB0aGlzLnNldE11bmdlZFNEUChvZmZlciwgd3JpdGUoc2RwUGFyc2VkKSk7XG4gICAgdGhpcy5vbk9mZmVyKG9mZmVyKTtcbiAgfVxuXG4gIGFzeW5jIGNyZWF0ZUFuZFNldEFuc3dlcigpOiBQcm9taXNlPFJUQ1Nlc3Npb25EZXNjcmlwdGlvbkluaXQ+IHtcbiAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCB0aGlzLnBjLmNyZWF0ZUFuc3dlcigpO1xuICAgIGNvbnN0IHNkcFBhcnNlZCA9IHBhcnNlKGFuc3dlci5zZHAgPz8gJycpO1xuICAgIHNkcFBhcnNlZC5tZWRpYS5mb3JFYWNoKChtZWRpYSkgPT4ge1xuICAgICAgaWYgKG1lZGlhLnR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgICAgZW5zdXJlQXVkaW9OYWNrQW5kU3RlcmVvKG1lZGlhLCB0aGlzLnJlbW90ZVN0ZXJlb01pZHMsIHRoaXMucmVtb3RlTmFja01pZHMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGF3YWl0IHRoaXMuc2V0TXVuZ2VkU0RQKGFuc3dlciwgd3JpdGUoc2RwUGFyc2VkKSk7XG4gICAgcmV0dXJuIGFuc3dlcjtcbiAgfVxuXG4gIGNyZWF0ZURhdGFDaGFubmVsKGxhYmVsOiBzdHJpbmcsIGRhdGFDaGFubmVsRGljdDogUlRDRGF0YUNoYW5uZWxJbml0KSB7XG4gICAgcmV0dXJuIHRoaXMucGMuY3JlYXRlRGF0YUNoYW5uZWwobGFiZWwsIGRhdGFDaGFubmVsRGljdCk7XG4gIH1cblxuICBhZGRUcmFuc2NlaXZlcihtZWRpYVN0cmVhbVRyYWNrOiBNZWRpYVN0cmVhbVRyYWNrLCB0cmFuc2NlaXZlckluaXQ6IFJUQ1J0cFRyYW5zY2VpdmVySW5pdCkge1xuICAgIHJldHVybiB0aGlzLnBjLmFkZFRyYW5zY2VpdmVyKG1lZGlhU3RyZWFtVHJhY2ssIHRyYW5zY2VpdmVySW5pdCk7XG4gIH1cblxuICBhZGRUcmFjayh0cmFjazogTWVkaWFTdHJlYW1UcmFjaykge1xuICAgIGlmICghdGhpcy5fcGMpIHtcbiAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdQQyBjbG9zZWQsIGNhbm5vdCBhZGQgdHJhY2snKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3BjLmFkZFRyYWNrKHRyYWNrKTtcbiAgfVxuXG4gIHNldFRyYWNrQ29kZWNCaXRyYXRlKGluZm86IFRyYWNrQml0cmF0ZUluZm8pIHtcbiAgICB0aGlzLnRyYWNrQml0cmF0ZXMucHVzaChpbmZvKTtcbiAgfVxuXG4gIHNldENvbmZpZ3VyYXRpb24ocnRjQ29uZmlnOiBSVENDb25maWd1cmF0aW9uKSB7XG4gICAgaWYgKCF0aGlzLl9wYykge1xuICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ1BDIGNsb3NlZCwgY2Fubm90IGNvbmZpZ3VyZScpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcGM/LnNldENvbmZpZ3VyYXRpb24ocnRjQ29uZmlnKTtcbiAgfVxuXG4gIGNhblJlbW92ZVRyYWNrKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhIXRoaXMuX3BjPy5yZW1vdmVUcmFjaztcbiAgfVxuXG4gIHJlbW92ZVRyYWNrKHNlbmRlcjogUlRDUnRwU2VuZGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BjPy5yZW1vdmVUcmFjayhzZW5kZXIpO1xuICB9XG5cbiAgZ2V0Q29ubmVjdGlvblN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9wYz8uY29ubmVjdGlvblN0YXRlID8/ICdjbG9zZWQnO1xuICB9XG5cbiAgZ2V0SUNFQ29ubmVjdGlvblN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9wYz8uaWNlQ29ubmVjdGlvblN0YXRlID8/ICdjbG9zZWQnO1xuICB9XG5cbiAgZ2V0U2lnbmFsbGluZ1N0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9wYz8uc2lnbmFsaW5nU3RhdGUgPz8gJ2Nsb3NlZCc7XG4gIH1cblxuICBnZXRUcmFuc2NlaXZlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BjPy5nZXRUcmFuc2NlaXZlcnMoKSA/PyBbXTtcbiAgfVxuXG4gIGdldFNlbmRlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BjPy5nZXRTZW5kZXJzKCkgPz8gW107XG4gIH1cblxuICBnZXRMb2NhbERlc2NyaXB0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9wYz8ubG9jYWxEZXNjcmlwdGlvbjtcbiAgfVxuXG4gIGdldFJlbW90ZURlc2NyaXB0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnBjPy5yZW1vdGVEZXNjcmlwdGlvbjtcbiAgfVxuXG4gIGdldFN0YXRzKCkge1xuICAgIHJldHVybiB0aGlzLnBjLmdldFN0YXRzKCk7XG4gIH1cblxuICBhc3luYyBnZXRDb25uZWN0ZWRBZGRyZXNzKCk6IFByb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPiB7XG4gICAgaWYgKCF0aGlzLl9wYykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgc2VsZWN0ZWRDYW5kaWRhdGVQYWlySWQgPSAnJztcbiAgICBjb25zdCBjYW5kaWRhdGVQYWlycyA9IG5ldyBNYXA8c3RyaW5nLCBSVENJY2VDYW5kaWRhdGVQYWlyU3RhdHM+KCk7XG4gICAgLy8gaWQgLT4gY2FuZGlkYXRlIGlwXG4gICAgY29uc3QgY2FuZGlkYXRlcyA9IG5ldyBNYXA8c3RyaW5nLCBzdHJpbmc+KCk7XG4gICAgY29uc3Qgc3RhdHM6IFJUQ1N0YXRzUmVwb3J0ID0gYXdhaXQgdGhpcy5fcGMuZ2V0U3RhdHMoKTtcbiAgICBzdGF0cy5mb3JFYWNoKCh2KSA9PiB7XG4gICAgICBzd2l0Y2ggKHYudHlwZSkge1xuICAgICAgICBjYXNlICd0cmFuc3BvcnQnOlxuICAgICAgICAgIHNlbGVjdGVkQ2FuZGlkYXRlUGFpcklkID0gdi5zZWxlY3RlZENhbmRpZGF0ZVBhaXJJZDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnY2FuZGlkYXRlLXBhaXInOlxuICAgICAgICAgIGlmIChzZWxlY3RlZENhbmRpZGF0ZVBhaXJJZCA9PT0gJycgJiYgdi5zZWxlY3RlZCkge1xuICAgICAgICAgICAgc2VsZWN0ZWRDYW5kaWRhdGVQYWlySWQgPSB2LmlkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYW5kaWRhdGVQYWlycy5zZXQodi5pZCwgdik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JlbW90ZS1jYW5kaWRhdGUnOlxuICAgICAgICAgIGNhbmRpZGF0ZXMuc2V0KHYuaWQsIGAke3YuYWRkcmVzc306JHt2LnBvcnR9YCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoc2VsZWN0ZWRDYW5kaWRhdGVQYWlySWQgPT09ICcnKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3RlZElEID0gY2FuZGlkYXRlUGFpcnMuZ2V0KHNlbGVjdGVkQ2FuZGlkYXRlUGFpcklkKT8ucmVtb3RlQ2FuZGlkYXRlSWQ7XG4gICAgaWYgKHNlbGVjdGVkSUQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGNhbmRpZGF0ZXMuZ2V0KHNlbGVjdGVkSUQpO1xuICB9XG5cbiAgY2xvc2UgPSAoKSA9PiB7XG4gICAgaWYgKCF0aGlzLl9wYykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9wYy5jbG9zZSgpO1xuICAgIHRoaXMuX3BjLm9uY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICB0aGlzLl9wYy5vbmljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgdGhpcy5fcGMub25pY2VnYXRoZXJpbmdzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgdGhpcy5fcGMub25kYXRhY2hhbm5lbCA9IG51bGw7XG4gICAgdGhpcy5fcGMub25uZWdvdGlhdGlvbm5lZWRlZCA9IG51bGw7XG4gICAgdGhpcy5fcGMub25zaWduYWxpbmdzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgdGhpcy5fcGMub25pY2VjYW5kaWRhdGUgPSBudWxsO1xuICAgIHRoaXMuX3BjLm9uZGF0YWNoYW5uZWwgPSBudWxsO1xuICAgIHRoaXMuX3BjLm9udHJhY2sgPSBudWxsO1xuICAgIHRoaXMuX3BjLm9uY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICB0aGlzLl9wYy5vbmljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgdGhpcy5fcGMgPSBudWxsO1xuICB9O1xuXG4gIHByaXZhdGUgYXN5bmMgc2V0TXVuZ2VkU0RQKHNkOiBSVENTZXNzaW9uRGVzY3JpcHRpb25Jbml0LCBtdW5nZWQ/OiBzdHJpbmcsIHJlbW90ZT86IGJvb2xlYW4pIHtcbiAgICBpZiAobXVuZ2VkKSB7XG4gICAgICBjb25zdCBvcmlnaW5hbFNkcCA9IHNkLnNkcDtcbiAgICAgIHNkLnNkcCA9IG11bmdlZDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKFxuICAgICAgICAgIGBzZXR0aW5nIG11bmdlZCAke3JlbW90ZSA/ICdyZW1vdGUnIDogJ2xvY2FsJ30gZGVzY3JpcHRpb25gLFxuICAgICAgICAgIHRoaXMubG9nQ29udGV4dCxcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHJlbW90ZSkge1xuICAgICAgICAgIGF3YWl0IHRoaXMucGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oc2QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGF3YWl0IHRoaXMucGMuc2V0TG9jYWxEZXNjcmlwdGlvbihzZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmxvZy53YXJuKGBub3QgYWJsZSB0byBzZXQgJHtzZC50eXBlfSwgZmFsbGluZyBiYWNrIHRvIHVubW9kaWZpZWQgc2RwYCwge1xuICAgICAgICAgIC4uLnRoaXMubG9nQ29udGV4dCxcbiAgICAgICAgICBlcnJvcjogZSxcbiAgICAgICAgICBzZHA6IG11bmdlZCxcbiAgICAgICAgfSk7XG4gICAgICAgIHNkLnNkcCA9IG9yaWdpbmFsU2RwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBpZiAocmVtb3RlKSB7XG4gICAgICAgIGF3YWl0IHRoaXMucGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oc2QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXdhaXQgdGhpcy5wYy5zZXRMb2NhbERlc2NyaXB0aW9uKHNkKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyB0aGlzIGVycm9yIGNhbm5vdCBhbHdheXMgYmUgY2F1Z2h0LlxuICAgICAgLy8gSWYgdGhlIGxvY2FsIGRlc2NyaXB0aW9uIGhhcyBhIHNldENvZGVjUHJlZmVyZW5jZXMgZXJyb3IsIHRoaXMgZXJyb3Igd2lsbCBiZSB1bmNhdWdodFxuICAgICAgbGV0IG1zZyA9ICd1bmtub3duIGVycm9yJztcbiAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgbXNnID0gZS5tZXNzYWdlO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbXNnID0gZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZmllbGRzOiBhbnkgPSB7XG4gICAgICAgIGVycm9yOiBtc2csXG4gICAgICAgIHNkcDogc2Quc2RwLFxuICAgICAgfTtcbiAgICAgIGlmICghcmVtb3RlICYmIHRoaXMucGMucmVtb3RlRGVzY3JpcHRpb24pIHtcbiAgICAgICAgZmllbGRzLnJlbW90ZVNkcCA9IHRoaXMucGMucmVtb3RlRGVzY3JpcHRpb247XG4gICAgICB9XG4gICAgICB0aGlzLmxvZy5lcnJvcihgdW5hYmxlIHRvIHNldCAke3NkLnR5cGV9YCwgeyAuLi50aGlzLmxvZ0NvbnRleHQsIGZpZWxkcyB9KTtcbiAgICAgIHRocm93IG5ldyBOZWdvdGlhdGlvbkVycm9yKG1zZyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGVuc3VyZUF1ZGlvTmFja0FuZFN0ZXJlbyhcbiAgbWVkaWE6IHtcbiAgICB0eXBlOiBzdHJpbmc7XG4gICAgcG9ydDogbnVtYmVyO1xuICAgIHByb3RvY29sOiBzdHJpbmc7XG4gICAgcGF5bG9hZHM/OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIH0gJiBNZWRpYURlc2NyaXB0aW9uLFxuICBzdGVyZW9NaWRzOiBzdHJpbmdbXSxcbiAgbmFja01pZHM6IHN0cmluZ1tdLFxuKSB7XG4gIC8vIGZvdW5kIG9wdXMgY29kZWMgdG8gYWRkIG5hY2sgZmJcbiAgbGV0IG9wdXNQYXlsb2FkID0gMDtcbiAgbWVkaWEucnRwLnNvbWUoKHJ0cCk6IGJvb2xlYW4gPT4ge1xuICAgIGlmIChydHAuY29kZWMgPT09ICdvcHVzJykge1xuICAgICAgb3B1c1BheWxvYWQgPSBydHAucGF5bG9hZDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0pO1xuXG4gIC8vIGFkZCBuYWNrIHJ0Y3BmYiBpZiBub3QgZXhpc3RcbiAgaWYgKG9wdXNQYXlsb2FkID4gMCkge1xuICAgIGlmICghbWVkaWEucnRjcEZiKSB7XG4gICAgICBtZWRpYS5ydGNwRmIgPSBbXTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBuYWNrTWlkcy5pbmNsdWRlcyhtZWRpYS5taWQhKSAmJlxuICAgICAgIW1lZGlhLnJ0Y3BGYi5zb21lKChmYikgPT4gZmIucGF5bG9hZCA9PT0gb3B1c1BheWxvYWQgJiYgZmIudHlwZSA9PT0gJ25hY2snKVxuICAgICkge1xuICAgICAgbWVkaWEucnRjcEZiLnB1c2goe1xuICAgICAgICBwYXlsb2FkOiBvcHVzUGF5bG9hZCxcbiAgICAgICAgdHlwZTogJ25hY2snLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHN0ZXJlb01pZHMuaW5jbHVkZXMobWVkaWEubWlkISkpIHtcbiAgICAgIG1lZGlhLmZtdHAuc29tZSgoZm10cCk6IGJvb2xlYW4gPT4ge1xuICAgICAgICBpZiAoZm10cC5wYXlsb2FkID09PSBvcHVzUGF5bG9hZCkge1xuICAgICAgICAgIGlmICghZm10cC5jb25maWcuaW5jbHVkZXMoJ3N0ZXJlbz0xJykpIHtcbiAgICAgICAgICAgIGZtdHAuY29uZmlnICs9ICc7c3RlcmVvPTEnO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5zdXJlVmlkZW9EREV4dGVuc2lvbkZvclNWQyhcbiAgbWVkaWE6IHtcbiAgICB0eXBlOiBzdHJpbmc7XG4gICAgcG9ydDogbnVtYmVyO1xuICAgIHByb3RvY29sOiBzdHJpbmc7XG4gICAgcGF5bG9hZHM/OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIH0gJiBNZWRpYURlc2NyaXB0aW9uLFxuKSB7XG4gIGNvbnN0IGNvZGVjID0gbWVkaWEucnRwWzBdPy5jb2RlYz8udG9Mb3dlckNhc2UoKTtcbiAgaWYgKCFpc1NWQ0NvZGVjKGNvZGVjKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxldCBtYXhJRCA9IDA7XG4gIGNvbnN0IGRkRm91bmQgPSBtZWRpYS5leHQ/LnNvbWUoKGV4dCk6IGJvb2xlYW4gPT4ge1xuICAgIGlmIChleHQudXJpID09PSBkZEV4dGVuc2lvblVSSSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChleHQudmFsdWUgPiBtYXhJRCkge1xuICAgICAgbWF4SUQgPSBleHQudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSk7XG5cbiAgaWYgKCFkZEZvdW5kKSB7XG4gICAgbWVkaWEuZXh0Py5wdXNoKHtcbiAgICAgIHZhbHVlOiBtYXhJRCArIDEsXG4gICAgICB1cmk6IGRkRXh0ZW5zaW9uVVJJLFxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RTdGVyZW9BbmROYWNrQXVkaW9Gcm9tT2ZmZXIob2ZmZXI6IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbkluaXQpOiB7XG4gIHN0ZXJlb01pZHM6IHN0cmluZ1tdO1xuICBuYWNrTWlkczogc3RyaW5nW107XG59IHtcbiAgY29uc3Qgc3RlcmVvTWlkczogc3RyaW5nW10gPSBbXTtcbiAgY29uc3QgbmFja01pZHM6IHN0cmluZ1tdID0gW107XG4gIGNvbnN0IHNkcFBhcnNlZCA9IHBhcnNlKG9mZmVyLnNkcCA/PyAnJyk7XG4gIGxldCBvcHVzUGF5bG9hZCA9IDA7XG4gIHNkcFBhcnNlZC5tZWRpYS5mb3JFYWNoKChtZWRpYSkgPT4ge1xuICAgIGlmIChtZWRpYS50eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICBtZWRpYS5ydHAuc29tZSgocnRwKTogYm9vbGVhbiA9PiB7XG4gICAgICAgIGlmIChydHAuY29kZWMgPT09ICdvcHVzJykge1xuICAgICAgICAgIG9wdXNQYXlsb2FkID0gcnRwLnBheWxvYWQ7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChtZWRpYS5ydGNwRmI/LnNvbWUoKGZiKSA9PiBmYi5wYXlsb2FkID09PSBvcHVzUGF5bG9hZCAmJiBmYi50eXBlID09PSAnbmFjaycpKSB7XG4gICAgICAgIG5hY2tNaWRzLnB1c2gobWVkaWEubWlkISk7XG4gICAgICB9XG5cbiAgICAgIG1lZGlhLmZtdHAuc29tZSgoZm10cCk6IGJvb2xlYW4gPT4ge1xuICAgICAgICBpZiAoZm10cC5wYXlsb2FkID09PSBvcHVzUGF5bG9hZCkge1xuICAgICAgICAgIGlmIChmbXRwLmNvbmZpZy5pbmNsdWRlcygnc3Byb3Atc3RlcmVvPTEnKSkge1xuICAgICAgICAgICAgc3RlcmVvTWlkcy5wdXNoKG1lZGlhLm1pZCEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4geyBzdGVyZW9NaWRzLCBuYWNrTWlkcyB9O1xufVxuIiwiaW1wb3J0IHR5cGUgeyBJbnRlcm5hbFJvb21Db25uZWN0T3B0aW9ucywgSW50ZXJuYWxSb29tT3B0aW9ucyB9IGZyb20gJy4uL29wdGlvbnMnO1xuaW1wb3J0IERlZmF1bHRSZWNvbm5lY3RQb2xpY3kgZnJvbSAnLi9EZWZhdWx0UmVjb25uZWN0UG9saWN5JztcbmltcG9ydCB0eXBlIHtcbiAgQXVkaW9DYXB0dXJlT3B0aW9ucyxcbiAgVHJhY2tQdWJsaXNoRGVmYXVsdHMsXG4gIFZpZGVvQ2FwdHVyZU9wdGlvbnMsXG59IGZyb20gJy4vdHJhY2svb3B0aW9ucyc7XG5pbXBvcnQgeyBBdWRpb1ByZXNldHMsIFNjcmVlblNoYXJlUHJlc2V0cywgVmlkZW9QcmVzZXRzIH0gZnJvbSAnLi90cmFjay9vcHRpb25zJztcblxuZXhwb3J0IGNvbnN0IGRlZmF1bHRWaWRlb0NvZGVjID0gJ3ZwOCc7XG5cbmV4cG9ydCBjb25zdCBwdWJsaXNoRGVmYXVsdHM6IFRyYWNrUHVibGlzaERlZmF1bHRzID0ge1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGF1ZGlvQml0cmF0ZTogQXVkaW9QcmVzZXRzLm11c2ljLm1heEJpdHJhdGUsXG4gIGF1ZGlvUHJlc2V0OiBBdWRpb1ByZXNldHMubXVzaWMsXG4gIGR0eDogdHJ1ZSxcbiAgcmVkOiB0cnVlLFxuICBmb3JjZVN0ZXJlbzogZmFsc2UsXG4gIHNpbXVsY2FzdDogdHJ1ZSxcbiAgc2NyZWVuU2hhcmVFbmNvZGluZzogU2NyZWVuU2hhcmVQcmVzZXRzLmgxMDgwZnBzMTUuZW5jb2RpbmcsXG4gIHN0b3BNaWNUcmFja09uTXV0ZTogZmFsc2UsXG4gIHZpZGVvQ29kZWM6IGRlZmF1bHRWaWRlb0NvZGVjLFxuICBiYWNrdXBDb2RlYzogdHJ1ZSxcbn0gYXMgY29uc3Q7XG5cbmV4cG9ydCBjb25zdCBhdWRpb0RlZmF1bHRzOiBBdWRpb0NhcHR1cmVPcHRpb25zID0ge1xuICBhdXRvR2FpbkNvbnRyb2w6IHRydWUsXG4gIGVjaG9DYW5jZWxsYXRpb246IHRydWUsXG4gIG5vaXNlU3VwcHJlc3Npb246IHRydWUsXG59O1xuXG5leHBvcnQgY29uc3QgdmlkZW9EZWZhdWx0czogVmlkZW9DYXB0dXJlT3B0aW9ucyA9IHtcbiAgcmVzb2x1dGlvbjogVmlkZW9QcmVzZXRzLmg3MjAucmVzb2x1dGlvbixcbn07XG5cbmV4cG9ydCBjb25zdCByb29tT3B0aW9uRGVmYXVsdHM6IEludGVybmFsUm9vbU9wdGlvbnMgPSB7XG4gIGFkYXB0aXZlU3RyZWFtOiBmYWxzZSxcbiAgZHluYWNhc3Q6IGZhbHNlLFxuICBzdG9wTG9jYWxUcmFja09uVW5wdWJsaXNoOiB0cnVlLFxuICByZWNvbm5lY3RQb2xpY3k6IG5ldyBEZWZhdWx0UmVjb25uZWN0UG9saWN5KCksXG4gIGRpc2Nvbm5lY3RPblBhZ2VMZWF2ZTogdHJ1ZSxcbiAgZXhwV2ViQXVkaW9NaXg6IGZhbHNlLFxufSBhcyBjb25zdDtcblxuZXhwb3J0IGNvbnN0IHJvb21Db25uZWN0T3B0aW9uRGVmYXVsdHM6IEludGVybmFsUm9vbUNvbm5lY3RPcHRpb25zID0ge1xuICBhdXRvU3Vic2NyaWJlOiB0cnVlLFxuICBtYXhSZXRyaWVzOiAxLFxuICBwZWVyQ29ubmVjdGlvblRpbWVvdXQ6IDE1XzAwMCxcbiAgd2Vic29ja2V0VGltZW91dDogMTVfMDAwLFxufSBhcyBjb25zdDtcbiIsImltcG9ydCBsb2csIHsgTG9nZ2VyTmFtZXMsIGdldExvZ2dlciB9IGZyb20gJy4uL2xvZ2dlcic7XG5pbXBvcnQgeyBTaWduYWxUYXJnZXQgfSBmcm9tICcuLi9wcm90by9saXZla2l0X3J0Y19wYic7XG5pbXBvcnQgUENUcmFuc3BvcnQsIHsgUENFdmVudHMgfSBmcm9tICcuL1BDVHJhbnNwb3J0JztcbmltcG9ydCB7IHJvb21Db25uZWN0T3B0aW9uRGVmYXVsdHMgfSBmcm9tICcuL2RlZmF1bHRzJztcbmltcG9ydCB7IENvbm5lY3Rpb25FcnJvciwgQ29ubmVjdGlvbkVycm9yUmVhc29uIH0gZnJvbSAnLi9lcnJvcnMnO1xuaW1wb3J0IENyaXRpY2FsVGltZXJzIGZyb20gJy4vdGltZXJzJztcbmltcG9ydCB0eXBlIHsgTG9nZ2VyT3B0aW9ucyB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgTXV0ZXgsIHNsZWVwIH0gZnJvbSAnLi91dGlscyc7XG5cbmV4cG9ydCBlbnVtIFBDVHJhbnNwb3J0U3RhdGUge1xuICBORVcsXG4gIENPTk5FQ1RJTkcsXG4gIENPTk5FQ1RFRCxcbiAgRkFJTEVELFxuICBDTE9TSU5HLFxuICBDTE9TRUQsXG59XG5cbmV4cG9ydCBjbGFzcyBQQ1RyYW5zcG9ydE1hbmFnZXIge1xuICBwdWJsaWMgcHVibGlzaGVyOiBQQ1RyYW5zcG9ydDtcblxuICBwdWJsaWMgc3Vic2NyaWJlcjogUENUcmFuc3BvcnQ7XG5cbiAgcHVibGljIHBlZXJDb25uZWN0aW9uVGltZW91dDogbnVtYmVyID0gcm9vbUNvbm5lY3RPcHRpb25EZWZhdWx0cy5wZWVyQ29ubmVjdGlvblRpbWVvdXQ7XG5cbiAgcHVibGljIGdldCBuZWVkc1B1Ymxpc2hlcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1B1Ymxpc2hlckNvbm5lY3Rpb25SZXF1aXJlZDtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgbmVlZHNTdWJzY3JpYmVyKCkge1xuICAgIHJldHVybiB0aGlzLmlzU3Vic2NyaWJlckNvbm5lY3Rpb25SZXF1aXJlZDtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgY3VycmVudFN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlO1xuICB9XG5cbiAgcHVibGljIG9uU3RhdGVDaGFuZ2U/OiAoXG4gICAgc3RhdGU6IFBDVHJhbnNwb3J0U3RhdGUsXG4gICAgcHViU3RhdGU6IFJUQ1BlZXJDb25uZWN0aW9uU3RhdGUsXG4gICAgc3ViU3RhdGU6IFJUQ1BlZXJDb25uZWN0aW9uU3RhdGUsXG4gICkgPT4gdm9pZDtcblxuICBwdWJsaWMgb25JY2VDYW5kaWRhdGU/OiAoZXY6IFJUQ0ljZUNhbmRpZGF0ZSwgdGFyZ2V0OiBTaWduYWxUYXJnZXQpID0+IHZvaWQ7XG5cbiAgcHVibGljIG9uRGF0YUNoYW5uZWw/OiAoZXY6IFJUQ0RhdGFDaGFubmVsRXZlbnQpID0+IHZvaWQ7XG5cbiAgcHVibGljIG9uVHJhY2s/OiAoZXY6IFJUQ1RyYWNrRXZlbnQpID0+IHZvaWQ7XG5cbiAgcHVibGljIG9uUHVibGlzaGVyT2ZmZXI/OiAob2ZmZXI6IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbkluaXQpID0+IHZvaWQ7XG5cbiAgcHJpdmF0ZSBpc1B1Ymxpc2hlckNvbm5lY3Rpb25SZXF1aXJlZDogYm9vbGVhbjtcblxuICBwcml2YXRlIGlzU3Vic2NyaWJlckNvbm5lY3Rpb25SZXF1aXJlZDogYm9vbGVhbjtcblxuICBwcml2YXRlIHN0YXRlOiBQQ1RyYW5zcG9ydFN0YXRlO1xuXG4gIHByaXZhdGUgY29ubmVjdGlvbkxvY2s6IE11dGV4O1xuXG4gIHByaXZhdGUgbG9nID0gbG9nO1xuXG4gIHByaXZhdGUgbG9nZ2VyT3B0aW9uczogTG9nZ2VyT3B0aW9ucztcblxuICBjb25zdHJ1Y3RvcihcbiAgICBydGNDb25maWc6IFJUQ0NvbmZpZ3VyYXRpb24sXG4gICAgc3Vic2NyaWJlclByaW1hcnk6IGJvb2xlYW4sXG4gICAgbG9nZ2VyT3B0aW9uczogTG9nZ2VyT3B0aW9ucyxcbiAgKSB7XG4gICAgdGhpcy5sb2cgPSBnZXRMb2dnZXIobG9nZ2VyT3B0aW9ucy5sb2dnZXJOYW1lID8/IExvZ2dlck5hbWVzLlBDTWFuYWdlcik7XG4gICAgdGhpcy5sb2dnZXJPcHRpb25zID0gbG9nZ2VyT3B0aW9ucztcblxuICAgIHRoaXMuaXNQdWJsaXNoZXJDb25uZWN0aW9uUmVxdWlyZWQgPSAhc3Vic2NyaWJlclByaW1hcnk7XG4gICAgdGhpcy5pc1N1YnNjcmliZXJDb25uZWN0aW9uUmVxdWlyZWQgPSBzdWJzY3JpYmVyUHJpbWFyeTtcbiAgICBjb25zdCBnb29nQ29uc3RyYWludHMgPSB7IG9wdGlvbmFsOiBbeyBnb29nRHNjcDogdHJ1ZSB9XSB9O1xuICAgIHRoaXMucHVibGlzaGVyID0gbmV3IFBDVHJhbnNwb3J0KHJ0Y0NvbmZpZywgZ29vZ0NvbnN0cmFpbnRzLCBsb2dnZXJPcHRpb25zKTtcbiAgICB0aGlzLnN1YnNjcmliZXIgPSBuZXcgUENUcmFuc3BvcnQocnRjQ29uZmlnLCB1bmRlZmluZWQsIGxvZ2dlck9wdGlvbnMpO1xuXG4gICAgdGhpcy5wdWJsaXNoZXIub25Db25uZWN0aW9uU3RhdGVDaGFuZ2UgPSB0aGlzLnVwZGF0ZVN0YXRlO1xuICAgIHRoaXMuc3Vic2NyaWJlci5vbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZSA9IHRoaXMudXBkYXRlU3RhdGU7XG4gICAgdGhpcy5wdWJsaXNoZXIub25JY2VDb25uZWN0aW9uU3RhdGVDaGFuZ2UgPSB0aGlzLnVwZGF0ZVN0YXRlO1xuICAgIHRoaXMuc3Vic2NyaWJlci5vbkljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZSA9IHRoaXMudXBkYXRlU3RhdGU7XG4gICAgdGhpcy5wdWJsaXNoZXIub25TaWduYWxpbmdTdGF0ZWNoYW5nZSA9IHRoaXMudXBkYXRlU3RhdGU7XG4gICAgdGhpcy5zdWJzY3JpYmVyLm9uU2lnbmFsaW5nU3RhdGVjaGFuZ2UgPSB0aGlzLnVwZGF0ZVN0YXRlO1xuICAgIHRoaXMucHVibGlzaGVyLm9uSWNlQ2FuZGlkYXRlID0gKGNhbmRpZGF0ZSkgPT4ge1xuICAgICAgdGhpcy5vbkljZUNhbmRpZGF0ZT8uKGNhbmRpZGF0ZSwgU2lnbmFsVGFyZ2V0LlBVQkxJU0hFUik7XG4gICAgfTtcbiAgICB0aGlzLnN1YnNjcmliZXIub25JY2VDYW5kaWRhdGUgPSAoY2FuZGlkYXRlKSA9PiB7XG4gICAgICB0aGlzLm9uSWNlQ2FuZGlkYXRlPy4oY2FuZGlkYXRlLCBTaWduYWxUYXJnZXQuU1VCU0NSSUJFUik7XG4gICAgfTtcbiAgICAvLyBpbiBzdWJzY3JpYmVyIHByaW1hcnkgbW9kZSwgc2VydmVyIHNpZGUgb3BlbnMgc3ViIGRhdGEgY2hhbm5lbHMuXG4gICAgdGhpcy5zdWJzY3JpYmVyLm9uRGF0YUNoYW5uZWwgPSAoZXYpID0+IHtcbiAgICAgIHRoaXMub25EYXRhQ2hhbm5lbD8uKGV2KTtcbiAgICB9O1xuICAgIHRoaXMuc3Vic2NyaWJlci5vblRyYWNrID0gKGV2KSA9PiB7XG4gICAgICB0aGlzLm9uVHJhY2s/Lihldik7XG4gICAgfTtcbiAgICB0aGlzLnB1Ymxpc2hlci5vbk9mZmVyID0gKG9mZmVyKSA9PiB7XG4gICAgICB0aGlzLm9uUHVibGlzaGVyT2ZmZXI/LihvZmZlcik7XG4gICAgfTtcblxuICAgIHRoaXMuc3RhdGUgPSBQQ1RyYW5zcG9ydFN0YXRlLk5FVztcblxuICAgIHRoaXMuY29ubmVjdGlvbkxvY2sgPSBuZXcgTXV0ZXgoKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0IGxvZ0NvbnRleHQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnRoaXMubG9nZ2VyT3B0aW9ucy5sb2dnZXJDb250ZXh0Q2I/LigpLFxuICAgIH07XG4gIH1cblxuICByZXF1aXJlUHVibGlzaGVyKHJlcXVpcmUgPSB0cnVlKSB7XG4gICAgdGhpcy5pc1B1Ymxpc2hlckNvbm5lY3Rpb25SZXF1aXJlZCA9IHJlcXVpcmU7XG4gICAgdGhpcy51cGRhdGVTdGF0ZSgpO1xuICB9XG5cbiAgcmVxdWlyZVN1YnNjcmliZXIocmVxdWlyZSA9IHRydWUpIHtcbiAgICB0aGlzLmlzU3Vic2NyaWJlckNvbm5lY3Rpb25SZXF1aXJlZCA9IHJlcXVpcmU7XG4gICAgdGhpcy51cGRhdGVTdGF0ZSgpO1xuICB9XG5cbiAgY3JlYXRlQW5kU2VuZFB1Ymxpc2hlck9mZmVyKG9wdGlvbnM/OiBSVENPZmZlck9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5wdWJsaXNoZXIuY3JlYXRlQW5kU2VuZE9mZmVyKG9wdGlvbnMpO1xuICB9XG5cbiAgc2V0UHVibGlzaGVyQW5zd2VyKHNkOiBSVENTZXNzaW9uRGVzY3JpcHRpb25Jbml0KSB7XG4gICAgcmV0dXJuIHRoaXMucHVibGlzaGVyLnNldFJlbW90ZURlc2NyaXB0aW9uKHNkKTtcbiAgfVxuXG4gIHJlbW92ZVRyYWNrKHNlbmRlcjogUlRDUnRwU2VuZGVyKSB7XG4gICAgcmV0dXJuIHRoaXMucHVibGlzaGVyLnJlbW92ZVRyYWNrKHNlbmRlcik7XG4gIH1cblxuICBhc3luYyBjbG9zZSgpIHtcbiAgICBpZiAodGhpcy5wdWJsaXNoZXIgJiYgdGhpcy5wdWJsaXNoZXIuZ2V0U2lnbmFsbGluZ1N0YXRlKCkgIT09ICdjbG9zZWQnKSB7XG4gICAgICBjb25zdCBwdWJsaXNoZXIgPSB0aGlzLnB1Ymxpc2hlcjtcbiAgICAgIGZvciAoY29uc3Qgc2VuZGVyIG9mIHB1Ymxpc2hlci5nZXRTZW5kZXJzKCkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUT0RPOiByZWFjdC1uYXRpdmUtd2VicnRjIGRvZXNuJ3QgaGF2ZSByZW1vdmVUcmFjayB5ZXQuXG4gICAgICAgICAgaWYgKHB1Ymxpc2hlci5jYW5SZW1vdmVUcmFjaygpKSB7XG4gICAgICAgICAgICBwdWJsaXNoZXIucmVtb3ZlVHJhY2soc2VuZGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aGlzLmxvZy53YXJuKCdjb3VsZCBub3QgcmVtb3ZlVHJhY2snLCB7IC4uLnRoaXMubG9nQ29udGV4dCwgZXJyb3I6IGUgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoW3RoaXMucHVibGlzaGVyLmNsb3NlKCksIHRoaXMuc3Vic2NyaWJlci5jbG9zZSgpXSk7XG4gICAgdGhpcy51cGRhdGVTdGF0ZSgpO1xuICB9XG5cbiAgYXN5bmMgdHJpZ2dlckljZVJlc3RhcnQoKSB7XG4gICAgdGhpcy5zdWJzY3JpYmVyLnJlc3RhcnRpbmdJY2UgPSB0cnVlO1xuICAgIC8vIG9ubHkgcmVzdGFydCBwdWJsaXNoZXIgaWYgaXQncyBuZWVkZWRcbiAgICBpZiAodGhpcy5uZWVkc1B1Ymxpc2hlcikge1xuICAgICAgYXdhaXQgdGhpcy5jcmVhdGVBbmRTZW5kUHVibGlzaGVyT2ZmZXIoeyBpY2VSZXN0YXJ0OiB0cnVlIH0pO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGFkZEljZUNhbmRpZGF0ZShjYW5kaWRhdGU6IFJUQ0ljZUNhbmRpZGF0ZUluaXQsIHRhcmdldDogU2lnbmFsVGFyZ2V0KSB7XG4gICAgaWYgKHRhcmdldCA9PT0gU2lnbmFsVGFyZ2V0LlBVQkxJU0hFUikge1xuICAgICAgYXdhaXQgdGhpcy5wdWJsaXNoZXIuYWRkSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF3YWl0IHRoaXMuc3Vic2NyaWJlci5hZGRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBjcmVhdGVTdWJzY3JpYmVyQW5zd2VyRnJvbU9mZmVyKHNkOiBSVENTZXNzaW9uRGVzY3JpcHRpb25Jbml0KSB7XG4gICAgdGhpcy5sb2cuZGVidWcoJ3JlY2VpdmVkIHNlcnZlciBvZmZlcicsIHtcbiAgICAgIC4uLnRoaXMubG9nQ29udGV4dCxcbiAgICAgIFJUQ1NkcFR5cGU6IHNkLnR5cGUsXG4gICAgICBzZHA6IHNkLnNkcCxcbiAgICAgIHNpZ25hbGluZ1N0YXRlOiB0aGlzLnN1YnNjcmliZXIuZ2V0U2lnbmFsbGluZ1N0YXRlKCkudG9TdHJpbmcoKSxcbiAgICB9KTtcbiAgICBhd2FpdCB0aGlzLnN1YnNjcmliZXIuc2V0UmVtb3RlRGVzY3JpcHRpb24oc2QpO1xuXG4gICAgLy8gYW5zd2VyIHRoZSBvZmZlclxuICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHRoaXMuc3Vic2NyaWJlci5jcmVhdGVBbmRTZXRBbnN3ZXIoKTtcbiAgICByZXR1cm4gYW5zd2VyO1xuICB9XG5cbiAgdXBkYXRlQ29uZmlndXJhdGlvbihjb25maWc6IFJUQ0NvbmZpZ3VyYXRpb24sIGljZVJlc3RhcnQ/OiBib29sZWFuKSB7XG4gICAgdGhpcy5wdWJsaXNoZXIuc2V0Q29uZmlndXJhdGlvbihjb25maWcpO1xuICAgIHRoaXMuc3Vic2NyaWJlci5zZXRDb25maWd1cmF0aW9uKGNvbmZpZyk7XG4gICAgaWYgKGljZVJlc3RhcnQpIHtcbiAgICAgIHRoaXMudHJpZ2dlckljZVJlc3RhcnQoKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBlbnN1cmVQQ1RyYW5zcG9ydENvbm5lY3Rpb24oYWJvcnRDb250cm9sbGVyPzogQWJvcnRDb250cm9sbGVyLCB0aW1lb3V0PzogbnVtYmVyKSB7XG4gICAgY29uc3QgdW5sb2NrID0gYXdhaXQgdGhpcy5jb25uZWN0aW9uTG9jay5sb2NrKCk7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5pc1B1Ymxpc2hlckNvbm5lY3Rpb25SZXF1aXJlZCAmJlxuICAgICAgICB0aGlzLnB1Ymxpc2hlci5nZXRDb25uZWN0aW9uU3RhdGUoKSAhPT0gJ2Nvbm5lY3RlZCcgJiZcbiAgICAgICAgdGhpcy5wdWJsaXNoZXIuZ2V0Q29ubmVjdGlvblN0YXRlKCkgIT09ICdjb25uZWN0aW5nJ1xuICAgICAgKSB7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKCduZWdvdGlhdGlvbiByZXF1aXJlZCwgc3RhcnQgbmVnb3RpYXRpbmcnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICB0aGlzLnB1Ymxpc2hlci5uZWdvdGlhdGUoKTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICB0aGlzLnJlcXVpcmVkVHJhbnNwb3J0cz8ubWFwKCh0cmFuc3BvcnQpID0+XG4gICAgICAgICAgdGhpcy5lbnN1cmVUcmFuc3BvcnRDb25uZWN0ZWQodHJhbnNwb3J0LCBhYm9ydENvbnRyb2xsZXIsIHRpbWVvdXQpLFxuICAgICAgICApLFxuICAgICAgKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdW5sb2NrKCk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgbmVnb3RpYXRlKGFib3J0Q29udHJvbGxlcjogQWJvcnRDb250cm9sbGVyKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IG5lZ290aWF0aW9uVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICByZWplY3QoJ25lZ290aWF0aW9uIHRpbWVkIG91dCcpO1xuICAgICAgfSwgdGhpcy5wZWVyQ29ubmVjdGlvblRpbWVvdXQpO1xuXG4gICAgICBjb25zdCBhYm9ydEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dChuZWdvdGlhdGlvblRpbWVvdXQpO1xuICAgICAgICByZWplY3QoJ25lZ290aWF0aW9uIGFib3J0ZWQnKTtcbiAgICAgIH07XG5cbiAgICAgIGFib3J0Q29udHJvbGxlci5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEhhbmRsZXIpO1xuICAgICAgdGhpcy5wdWJsaXNoZXIub25jZShQQ0V2ZW50cy5OZWdvdGlhdGlvblN0YXJ0ZWQsICgpID0+IHtcbiAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnB1Ymxpc2hlci5vbmNlKFBDRXZlbnRzLk5lZ290aWF0aW9uQ29tcGxldGUsICgpID0+IHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQobmVnb3RpYXRpb25UaW1lb3V0KTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IHRoaXMucHVibGlzaGVyLm5lZ290aWF0ZSgoZSkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQobmVnb3RpYXRpb25UaW1lb3V0KTtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBhZGRQdWJsaXNoZXJUcmFuc2NlaXZlcih0cmFjazogTWVkaWFTdHJlYW1UcmFjaywgdHJhbnNjZWl2ZXJJbml0OiBSVENSdHBUcmFuc2NlaXZlckluaXQpIHtcbiAgICByZXR1cm4gdGhpcy5wdWJsaXNoZXIuYWRkVHJhbnNjZWl2ZXIodHJhY2ssIHRyYW5zY2VpdmVySW5pdCk7XG4gIH1cblxuICBhZGRQdWJsaXNoZXJUcmFjayh0cmFjazogTWVkaWFTdHJlYW1UcmFjaykge1xuICAgIHJldHVybiB0aGlzLnB1Ymxpc2hlci5hZGRUcmFjayh0cmFjayk7XG4gIH1cblxuICBjcmVhdGVQdWJsaXNoZXJEYXRhQ2hhbm5lbChsYWJlbDogc3RyaW5nLCBkYXRhQ2hhbm5lbERpY3Q6IFJUQ0RhdGFDaGFubmVsSW5pdCkge1xuICAgIHJldHVybiB0aGlzLnB1Ymxpc2hlci5jcmVhdGVEYXRhQ2hhbm5lbChsYWJlbCwgZGF0YUNoYW5uZWxEaWN0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaXJzdCByZXF1aXJlZCB0cmFuc3BvcnQncyBhZGRyZXNzIGlmIG5vIGV4cGxpY2l0IHRhcmdldCBpcyBzcGVjaWZpZWRcbiAgICovXG4gIGdldENvbm5lY3RlZEFkZHJlc3ModGFyZ2V0PzogU2lnbmFsVGFyZ2V0KSB7XG4gICAgaWYgKHRhcmdldCA9PT0gU2lnbmFsVGFyZ2V0LlBVQkxJU0hFUikge1xuICAgICAgcmV0dXJuIHRoaXMucHVibGlzaGVyLmdldENvbm5lY3RlZEFkZHJlc3MoKTtcbiAgICB9IGVsc2UgaWYgKHRhcmdldCA9PT0gU2lnbmFsVGFyZ2V0LlNVQlNDUklCRVIpIHtcbiAgICAgIHJldHVybiB0aGlzLnB1Ymxpc2hlci5nZXRDb25uZWN0ZWRBZGRyZXNzKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlcXVpcmVkVHJhbnNwb3J0c1swXS5nZXRDb25uZWN0ZWRBZGRyZXNzKCk7XG4gIH1cblxuICBwcml2YXRlIGdldCByZXF1aXJlZFRyYW5zcG9ydHMoKSB7XG4gICAgY29uc3QgdHJhbnNwb3J0czogUENUcmFuc3BvcnRbXSA9IFtdO1xuICAgIGlmICh0aGlzLmlzUHVibGlzaGVyQ29ubmVjdGlvblJlcXVpcmVkKSB7XG4gICAgICB0cmFuc3BvcnRzLnB1c2godGhpcy5wdWJsaXNoZXIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1N1YnNjcmliZXJDb25uZWN0aW9uUmVxdWlyZWQpIHtcbiAgICAgIHRyYW5zcG9ydHMucHVzaCh0aGlzLnN1YnNjcmliZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNwb3J0cztcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlU3RhdGUgPSAoKSA9PiB7XG4gICAgY29uc3QgcHJldmlvdXNTdGF0ZSA9IHRoaXMuc3RhdGU7XG5cbiAgICBjb25zdCBjb25uZWN0aW9uU3RhdGVzID0gdGhpcy5yZXF1aXJlZFRyYW5zcG9ydHMubWFwKCh0cikgPT4gdHIuZ2V0Q29ubmVjdGlvblN0YXRlKCkpO1xuICAgIGlmIChjb25uZWN0aW9uU3RhdGVzLmV2ZXJ5KChzdCkgPT4gc3QgPT09ICdjb25uZWN0ZWQnKSkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFBDVHJhbnNwb3J0U3RhdGUuQ09OTkVDVEVEO1xuICAgIH0gZWxzZSBpZiAoY29ubmVjdGlvblN0YXRlcy5zb21lKChzdCkgPT4gc3QgPT09ICdmYWlsZWQnKSkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFBDVHJhbnNwb3J0U3RhdGUuRkFJTEVEO1xuICAgIH0gZWxzZSBpZiAoY29ubmVjdGlvblN0YXRlcy5zb21lKChzdCkgPT4gc3QgPT09ICdjb25uZWN0aW5nJykpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBQQ1RyYW5zcG9ydFN0YXRlLkNPTk5FQ1RJTkc7XG4gICAgfSBlbHNlIGlmIChjb25uZWN0aW9uU3RhdGVzLmV2ZXJ5KChzdCkgPT4gc3QgPT09ICdjbG9zZWQnKSkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFBDVHJhbnNwb3J0U3RhdGUuQ0xPU0VEO1xuICAgIH0gZWxzZSBpZiAoY29ubmVjdGlvblN0YXRlcy5zb21lKChzdCkgPT4gc3QgPT09ICdjbG9zZWQnKSkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFBDVHJhbnNwb3J0U3RhdGUuQ0xPU0lORztcbiAgICB9IGVsc2UgaWYgKGNvbm5lY3Rpb25TdGF0ZXMuZXZlcnkoKHN0KSA9PiBzdCA9PT0gJ25ldycpKSB7XG4gICAgICB0aGlzLnN0YXRlID0gUENUcmFuc3BvcnRTdGF0ZS5ORVc7XG4gICAgfVxuXG4gICAgaWYgKHByZXZpb3VzU3RhdGUgIT09IHRoaXMuc3RhdGUpIHtcbiAgICAgIHRoaXMubG9nLmRlYnVnKFxuICAgICAgICBgcGMgc3RhdGUgY2hhbmdlOiBmcm9tICR7UENUcmFuc3BvcnRTdGF0ZVtwcmV2aW91c1N0YXRlXX0gdG8gJHtcbiAgICAgICAgICBQQ1RyYW5zcG9ydFN0YXRlW3RoaXMuc3RhdGVdXG4gICAgICAgIH1gLFxuICAgICAgICB0aGlzLmxvZ0NvbnRleHQsXG4gICAgICApO1xuICAgICAgdGhpcy5vblN0YXRlQ2hhbmdlPy4oXG4gICAgICAgIHRoaXMuc3RhdGUsXG4gICAgICAgIHRoaXMucHVibGlzaGVyLmdldENvbm5lY3Rpb25TdGF0ZSgpLFxuICAgICAgICB0aGlzLnN1YnNjcmliZXIuZ2V0Q29ubmVjdGlvblN0YXRlKCksXG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuICBwcml2YXRlIGFzeW5jIGVuc3VyZVRyYW5zcG9ydENvbm5lY3RlZChcbiAgICBwY1RyYW5zcG9ydDogUENUcmFuc3BvcnQsXG4gICAgYWJvcnRDb250cm9sbGVyPzogQWJvcnRDb250cm9sbGVyLFxuICAgIHRpbWVvdXQ6IG51bWJlciA9IHRoaXMucGVlckNvbm5lY3Rpb25UaW1lb3V0LFxuICApIHtcbiAgICBjb25zdCBjb25uZWN0aW9uU3RhdGUgPSBwY1RyYW5zcG9ydC5nZXRDb25uZWN0aW9uU3RhdGUoKTtcbiAgICBpZiAoY29ubmVjdGlvblN0YXRlID09PSAnY29ubmVjdGVkJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPihhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBhYm9ydEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMubG9nLndhcm4oJ2Fib3J0IHRyYW5zcG9ydCBjb25uZWN0aW9uJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgQ3JpdGljYWxUaW1lcnMuY2xlYXJUaW1lb3V0KGNvbm5lY3RUaW1lb3V0KTtcblxuICAgICAgICByZWplY3QoXG4gICAgICAgICAgbmV3IENvbm5lY3Rpb25FcnJvcihcbiAgICAgICAgICAgICdyb29tIGNvbm5lY3Rpb24gaGFzIGJlZW4gY2FuY2VsbGVkJyxcbiAgICAgICAgICAgIENvbm5lY3Rpb25FcnJvclJlYXNvbi5DYW5jZWxsZWQsXG4gICAgICAgICAgKSxcbiAgICAgICAgKTtcbiAgICAgIH07XG4gICAgICBpZiAoYWJvcnRDb250cm9sbGVyPy5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICBhYm9ydEhhbmRsZXIoKTtcbiAgICAgIH1cbiAgICAgIGFib3J0Q29udHJvbGxlcj8uc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRIYW5kbGVyKTtcblxuICAgICAgY29uc3QgY29ubmVjdFRpbWVvdXQgPSBDcml0aWNhbFRpbWVycy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgYWJvcnRDb250cm9sbGVyPy5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEhhbmRsZXIpO1xuICAgICAgICByZWplY3QobmV3IENvbm5lY3Rpb25FcnJvcignY291bGQgbm90IGVzdGFibGlzaCBwYyBjb25uZWN0aW9uJykpO1xuICAgICAgfSwgdGltZW91dCk7XG5cbiAgICAgIHdoaWxlICh0aGlzLnN0YXRlICE9PSBQQ1RyYW5zcG9ydFN0YXRlLkNPTk5FQ1RFRCkge1xuICAgICAgICBhd2FpdCBzbGVlcCg1MCk7IC8vIEZJWE1FIHdlIHNob3VsZG4ndCByZWx5IG9uIGBzbGVlcGAgaW4gdGhlIGNvbm5lY3Rpb24gcGF0aHMsIGFzIGl0IGludm9rZXMgYHNldFRpbWVvdXRgIHdoaWNoIGNhbiBiZSBkcmFzdGljYWxseSB0aHJvdHRsZWQgYnkgYnJvd3NlciBpbXBsZW1lbnRhdGlvbnNcbiAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlcj8uc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICBuZXcgQ29ubmVjdGlvbkVycm9yKFxuICAgICAgICAgICAgICAncm9vbSBjb25uZWN0aW9uIGhhcyBiZWVuIGNhbmNlbGxlZCcsXG4gICAgICAgICAgICAgIENvbm5lY3Rpb25FcnJvclJlYXNvbi5DYW5jZWxsZWQsXG4gICAgICAgICAgICApLFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBDcml0aWNhbFRpbWVycy5jbGVhclRpbWVvdXQoY29ubmVjdFRpbWVvdXQpO1xuICAgICAgYWJvcnRDb250cm9sbGVyPy5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEhhbmRsZXIpO1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0pO1xuICB9XG59XG4iLCJpbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnO1xuaW1wb3J0IHR5cGUgeyBNZWRpYUF0dHJpYnV0ZXMgfSBmcm9tICdzZHAtdHJhbnNmb3JtJztcbmltcG9ydCB0eXBlIFR5cGVkRXZlbnRFbWl0dGVyIGZyb20gJ3R5cGVkLWVtaXR0ZXInO1xuaW1wb3J0IHR5cGUgeyBTaWduYWxPcHRpb25zIH0gZnJvbSAnLi4vYXBpL1NpZ25hbENsaWVudCc7XG5pbXBvcnQge1xuICBTaWduYWxDbGllbnQsXG4gIFNpZ25hbENvbm5lY3Rpb25TdGF0ZSxcbiAgdG9Qcm90b1Nlc3Npb25EZXNjcmlwdGlvbixcbn0gZnJvbSAnLi4vYXBpL1NpZ25hbENsaWVudCc7XG5pbXBvcnQgbG9nLCB7IExvZ2dlck5hbWVzLCBnZXRMb2dnZXIgfSBmcm9tICcuLi9sb2dnZXInO1xuaW1wb3J0IHR5cGUgeyBJbnRlcm5hbFJvb21PcHRpb25zIH0gZnJvbSAnLi4vb3B0aW9ucyc7XG5pbXBvcnQge1xuICBDbGllbnRDb25maWdTZXR0aW5nLFxuICBDbGllbnRDb25maWd1cmF0aW9uLFxuICBEYXRhUGFja2V0LFxuICBEYXRhUGFja2V0X0tpbmQsXG4gIERpc2Nvbm5lY3RSZWFzb24sXG4gIFBhcnRpY2lwYW50SW5mbyxcbiAgUmVjb25uZWN0UmVhc29uLFxuICBSb29tIGFzIFJvb21Nb2RlbCxcbiAgU3BlYWtlckluZm8sXG4gIFRyYWNrSW5mbyxcbiAgVXNlclBhY2tldCxcbn0gZnJvbSAnLi4vcHJvdG8vbGl2ZWtpdF9tb2RlbHNfcGInO1xuaW1wb3J0IHtcbiAgdHlwZSBBZGRUcmFja1JlcXVlc3QsXG4gIHR5cGUgQ29ubmVjdGlvblF1YWxpdHlVcGRhdGUsXG4gIERhdGFDaGFubmVsSW5mbyxcbiAgdHlwZSBKb2luUmVzcG9uc2UsXG4gIHR5cGUgTGVhdmVSZXF1ZXN0LFxuICB0eXBlIFJlY29ubmVjdFJlc3BvbnNlLFxuICBTaWduYWxUYXJnZXQsXG4gIHR5cGUgU3RyZWFtU3RhdGVVcGRhdGUsXG4gIFN1YnNjcmliZWRRdWFsaXR5VXBkYXRlLFxuICB0eXBlIFN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUsXG4gIHR5cGUgU3Vic2NyaXB0aW9uUmVzcG9uc2UsXG4gIFN5bmNTdGF0ZSxcbiAgdHlwZSBUcmFja1B1Ymxpc2hlZFJlc3BvbnNlLFxuICBUcmFja1VucHVibGlzaGVkUmVzcG9uc2UsXG4gIFVwZGF0ZVN1YnNjcmlwdGlvbixcbn0gZnJvbSAnLi4vcHJvdG8vbGl2ZWtpdF9ydGNfcGInO1xuaW1wb3J0IFBDVHJhbnNwb3J0LCB7IFBDRXZlbnRzIH0gZnJvbSAnLi9QQ1RyYW5zcG9ydCc7XG5pbXBvcnQgeyBQQ1RyYW5zcG9ydE1hbmFnZXIsIFBDVHJhbnNwb3J0U3RhdGUgfSBmcm9tICcuL1BDVHJhbnNwb3J0TWFuYWdlcic7XG5pbXBvcnQgdHlwZSB7IFJlY29ubmVjdENvbnRleHQsIFJlY29ubmVjdFBvbGljeSB9IGZyb20gJy4vUmVjb25uZWN0UG9saWN5JztcbmltcG9ydCB0eXBlIHsgUmVnaW9uVXJsUHJvdmlkZXIgfSBmcm9tICcuL1JlZ2lvblVybFByb3ZpZGVyJztcbmltcG9ydCB7IHJvb21Db25uZWN0T3B0aW9uRGVmYXVsdHMgfSBmcm9tICcuL2RlZmF1bHRzJztcbmltcG9ydCB7XG4gIENvbm5lY3Rpb25FcnJvcixcbiAgQ29ubmVjdGlvbkVycm9yUmVhc29uLFxuICBOZWdvdGlhdGlvbkVycm9yLFxuICBUcmFja0ludmFsaWRFcnJvcixcbiAgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSxcbn0gZnJvbSAnLi9lcnJvcnMnO1xuaW1wb3J0IHsgRW5naW5lRXZlbnQgfSBmcm9tICcuL2V2ZW50cyc7XG5pbXBvcnQgQ3JpdGljYWxUaW1lcnMgZnJvbSAnLi90aW1lcnMnO1xuaW1wb3J0IHR5cGUgTG9jYWxUcmFjayBmcm9tICcuL3RyYWNrL0xvY2FsVHJhY2snO1xuaW1wb3J0IHR5cGUgTG9jYWxUcmFja1B1YmxpY2F0aW9uIGZyb20gJy4vdHJhY2svTG9jYWxUcmFja1B1YmxpY2F0aW9uJztcbmltcG9ydCB0eXBlIExvY2FsVmlkZW9UcmFjayBmcm9tICcuL3RyYWNrL0xvY2FsVmlkZW9UcmFjayc7XG5pbXBvcnQgdHlwZSB7IFNpbXVsY2FzdFRyYWNrSW5mbyB9IGZyb20gJy4vdHJhY2svTG9jYWxWaWRlb1RyYWNrJztcbmltcG9ydCB0eXBlIFJlbW90ZVRyYWNrUHVibGljYXRpb24gZnJvbSAnLi90cmFjay9SZW1vdGVUcmFja1B1YmxpY2F0aW9uJztcbmltcG9ydCB7IFRyYWNrIH0gZnJvbSAnLi90cmFjay9UcmFjayc7XG5pbXBvcnQgdHlwZSB7IFRyYWNrUHVibGlzaE9wdGlvbnMsIFZpZGVvQ29kZWMgfSBmcm9tICcuL3RyYWNrL29wdGlvbnMnO1xuaW1wb3J0IHsgZ2V0VHJhY2tQdWJsaWNhdGlvbkluZm8gfSBmcm9tICcuL3RyYWNrL3V0aWxzJztcbmltcG9ydCB0eXBlIHsgTG9nZ2VyT3B0aW9ucyB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHtcbiAgTXV0ZXgsXG4gIGlzVmlkZW9Db2RlYyxcbiAgaXNXZWIsXG4gIHNsZWVwLFxuICBzdXBwb3J0c0FkZFRyYWNrLFxuICBzdXBwb3J0c1NldENvZGVjUHJlZmVyZW5jZXMsXG4gIHN1cHBvcnRzVHJhbnNjZWl2ZXIsXG59IGZyb20gJy4vdXRpbHMnO1xuXG5jb25zdCBsb3NzeURhdGFDaGFubmVsID0gJ19sb3NzeSc7XG5jb25zdCByZWxpYWJsZURhdGFDaGFubmVsID0gJ19yZWxpYWJsZSc7XG5jb25zdCBtaW5SZWNvbm5lY3RXYWl0ID0gMiAqIDEwMDA7XG5jb25zdCBsZWF2ZVJlY29ubmVjdCA9ICdsZWF2ZS1yZWNvbm5lY3QnO1xuXG5lbnVtIFBDU3RhdGUge1xuICBOZXcsXG4gIENvbm5lY3RlZCxcbiAgRGlzY29ubmVjdGVkLFxuICBSZWNvbm5lY3RpbmcsXG4gIENsb3NlZCxcbn1cblxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUlRDRW5naW5lIGV4dGVuZHMgKEV2ZW50RW1pdHRlciBhcyBuZXcgKCkgPT4gVHlwZWRFdmVudEVtaXR0ZXI8RW5naW5lRXZlbnRDYWxsYmFja3M+KSB7XG4gIGNsaWVudDogU2lnbmFsQ2xpZW50O1xuXG4gIHJ0Y0NvbmZpZzogUlRDQ29uZmlndXJhdGlvbiA9IHt9O1xuXG4gIHBlZXJDb25uZWN0aW9uVGltZW91dDogbnVtYmVyID0gcm9vbUNvbm5lY3RPcHRpb25EZWZhdWx0cy5wZWVyQ29ubmVjdGlvblRpbWVvdXQ7XG5cbiAgZnVsbFJlY29ubmVjdE9uTmV4dDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIHBjTWFuYWdlcj86IFBDVHJhbnNwb3J0TWFuYWdlcjtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBsYXRlc3RKb2luUmVzcG9uc2U/OiBKb2luUmVzcG9uc2U7XG5cbiAgZ2V0IGlzQ2xvc2VkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc0Nsb3NlZDtcbiAgfVxuXG4gIHByaXZhdGUgbG9zc3lEQz86IFJUQ0RhdGFDaGFubmVsO1xuXG4gIC8vIEB0cy1pZ25vcmUgbm9VbnVzZWRMb2NhbHNcbiAgcHJpdmF0ZSBsb3NzeURDU3ViPzogUlRDRGF0YUNoYW5uZWw7XG5cbiAgcHJpdmF0ZSByZWxpYWJsZURDPzogUlRDRGF0YUNoYW5uZWw7XG5cbiAgcHJpdmF0ZSBkY0J1ZmZlclN0YXR1czogTWFwPERhdGFQYWNrZXRfS2luZCwgYm9vbGVhbj47XG5cbiAgLy8gQHRzLWlnbm9yZSBub1VudXNlZExvY2Fsc1xuICBwcml2YXRlIHJlbGlhYmxlRENTdWI/OiBSVENEYXRhQ2hhbm5lbDtcblxuICBwcml2YXRlIHN1YnNjcmliZXJQcmltYXJ5OiBib29sZWFuID0gZmFsc2U7XG5cbiAgcHJpdmF0ZSBwY1N0YXRlOiBQQ1N0YXRlID0gUENTdGF0ZS5OZXc7XG5cbiAgcHJpdmF0ZSBfaXNDbG9zZWQ6IGJvb2xlYW4gPSB0cnVlO1xuXG4gIHByaXZhdGUgcGVuZGluZ1RyYWNrUmVzb2x2ZXJzOiB7XG4gICAgW2tleTogc3RyaW5nXTogeyByZXNvbHZlOiAoaW5mbzogVHJhY2tJbmZvKSA9PiB2b2lkOyByZWplY3Q6ICgpID0+IHZvaWQgfTtcbiAgfSA9IHt9O1xuXG4gIC8vIGtlZXAgam9pbiBpbmZvIGFyb3VuZCBmb3IgcmVjb25uZWN0LCB0aGlzIGNvdWxkIGJlIGEgcmVnaW9uIHVybFxuICBwcml2YXRlIHVybD86IHN0cmluZztcblxuICBwcml2YXRlIHRva2VuPzogc3RyaW5nO1xuXG4gIHByaXZhdGUgc2lnbmFsT3B0cz86IFNpZ25hbE9wdGlvbnM7XG5cbiAgcHJpdmF0ZSByZWNvbm5lY3RBdHRlbXB0czogbnVtYmVyID0gMDtcblxuICBwcml2YXRlIHJlY29ubmVjdFN0YXJ0OiBudW1iZXIgPSAwO1xuXG4gIHByaXZhdGUgY2xpZW50Q29uZmlndXJhdGlvbj86IENsaWVudENvbmZpZ3VyYXRpb247XG5cbiAgcHJpdmF0ZSBhdHRlbXB0aW5nUmVjb25uZWN0OiBib29sZWFuID0gZmFsc2U7XG5cbiAgcHJpdmF0ZSByZWNvbm5lY3RQb2xpY3k6IFJlY29ubmVjdFBvbGljeTtcblxuICBwcml2YXRlIHJlY29ubmVjdFRpbWVvdXQ/OiBSZXR1cm5UeXBlPHR5cGVvZiBzZXRUaW1lb3V0PjtcblxuICBwcml2YXRlIHBhcnRpY2lwYW50U2lkPzogc3RyaW5nO1xuXG4gIC8qKiBrZWVwcyB0cmFjayBvZiBob3cgb2Z0ZW4gYW4gaW5pdGlhbCBqb2luIGNvbm5lY3Rpb24gaGFzIGJlZW4gdHJpZWQgKi9cbiAgcHJpdmF0ZSBqb2luQXR0ZW1wdHM6IG51bWJlciA9IDA7XG5cbiAgLyoqIHNwZWNpZmllcyBob3cgb2Z0ZW4gYW4gaW5pdGlhbCBqb2luIGNvbm5lY3Rpb24gaXMgYWxsb3dlZCB0byByZXRyeSAqL1xuICBwcml2YXRlIG1heEpvaW5BdHRlbXB0czogbnVtYmVyID0gMTtcblxuICBwcml2YXRlIGNsb3NpbmdMb2NrOiBNdXRleDtcblxuICBwcml2YXRlIGRhdGFQcm9jZXNzTG9jazogTXV0ZXg7XG5cbiAgcHJpdmF0ZSBzaG91bGRGYWlsTmV4dDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIHByaXZhdGUgcmVnaW9uVXJsUHJvdmlkZXI/OiBSZWdpb25VcmxQcm92aWRlcjtcblxuICBwcml2YXRlIGxvZyA9IGxvZztcblxuICBwcml2YXRlIGxvZ2dlck9wdGlvbnM6IExvZ2dlck9wdGlvbnM7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBvcHRpb25zOiBJbnRlcm5hbFJvb21PcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmxvZyA9IGdldExvZ2dlcihvcHRpb25zLmxvZ2dlck5hbWUgPz8gTG9nZ2VyTmFtZXMuRW5naW5lKTtcbiAgICB0aGlzLmxvZ2dlck9wdGlvbnMgPSB7XG4gICAgICBsb2dnZXJOYW1lOiBvcHRpb25zLmxvZ2dlck5hbWUsXG4gICAgICBsb2dnZXJDb250ZXh0Q2I6ICgpID0+IHRoaXMubG9nQ29udGV4dCxcbiAgICB9O1xuICAgIHRoaXMuY2xpZW50ID0gbmV3IFNpZ25hbENsaWVudCh1bmRlZmluZWQsIHRoaXMubG9nZ2VyT3B0aW9ucyk7XG4gICAgdGhpcy5jbGllbnQuc2lnbmFsTGF0ZW5jeSA9IHRoaXMub3B0aW9ucy5leHBTaWduYWxMYXRlbmN5O1xuICAgIHRoaXMucmVjb25uZWN0UG9saWN5ID0gdGhpcy5vcHRpb25zLnJlY29ubmVjdFBvbGljeTtcbiAgICB0aGlzLnJlZ2lzdGVyT25MaW5lTGlzdGVuZXIoKTtcbiAgICB0aGlzLmNsb3NpbmdMb2NrID0gbmV3IE11dGV4KCk7XG4gICAgdGhpcy5kYXRhUHJvY2Vzc0xvY2sgPSBuZXcgTXV0ZXgoKTtcbiAgICB0aGlzLmRjQnVmZmVyU3RhdHVzID0gbmV3IE1hcChbXG4gICAgICBbRGF0YVBhY2tldF9LaW5kLkxPU1NZLCB0cnVlXSxcbiAgICAgIFtEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUsIHRydWVdLFxuICAgIF0pO1xuXG4gICAgdGhpcy5jbGllbnQub25QYXJ0aWNpcGFudFVwZGF0ZSA9ICh1cGRhdGVzKSA9PlxuICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlBhcnRpY2lwYW50VXBkYXRlLCB1cGRhdGVzKTtcbiAgICB0aGlzLmNsaWVudC5vbkNvbm5lY3Rpb25RdWFsaXR5ID0gKHVwZGF0ZSkgPT5cbiAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5Db25uZWN0aW9uUXVhbGl0eVVwZGF0ZSwgdXBkYXRlKTtcbiAgICB0aGlzLmNsaWVudC5vblJvb21VcGRhdGUgPSAodXBkYXRlKSA9PiB0aGlzLmVtaXQoRW5naW5lRXZlbnQuUm9vbVVwZGF0ZSwgdXBkYXRlKTtcbiAgICB0aGlzLmNsaWVudC5vblN1YnNjcmlwdGlvbkVycm9yID0gKHJlc3ApID0+IHRoaXMuZW1pdChFbmdpbmVFdmVudC5TdWJzY3JpcHRpb25FcnJvciwgcmVzcCk7XG4gICAgdGhpcy5jbGllbnQub25TdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlID0gKHVwZGF0ZSkgPT5cbiAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5TdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlLCB1cGRhdGUpO1xuICAgIHRoaXMuY2xpZW50Lm9uU3BlYWtlcnNDaGFuZ2VkID0gKHVwZGF0ZSkgPT4gdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlNwZWFrZXJzQ2hhbmdlZCwgdXBkYXRlKTtcbiAgICB0aGlzLmNsaWVudC5vblN0cmVhbVN0YXRlVXBkYXRlID0gKHVwZGF0ZSkgPT4gdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlN0cmVhbVN0YXRlQ2hhbmdlZCwgdXBkYXRlKTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZ2V0IGxvZ0NvbnRleHQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvb206IHRoaXMubGF0ZXN0Sm9pblJlc3BvbnNlPy5yb29tPy5uYW1lLFxuICAgICAgcm9vbVNpZDogdGhpcy5sYXRlc3RKb2luUmVzcG9uc2U/LnJvb20/LnNpZCxcbiAgICAgIGlkZW50aXR5OiB0aGlzLmxhdGVzdEpvaW5SZXNwb25zZT8ucGFydGljaXBhbnQ/LmlkZW50aXR5LFxuICAgIH07XG4gIH1cblxuICBhc3luYyBqb2luKFxuICAgIHVybDogc3RyaW5nLFxuICAgIHRva2VuOiBzdHJpbmcsXG4gICAgb3B0czogU2lnbmFsT3B0aW9ucyxcbiAgICBhYm9ydFNpZ25hbD86IEFib3J0U2lnbmFsLFxuICApOiBQcm9taXNlPEpvaW5SZXNwb25zZT4ge1xuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICB0aGlzLnNpZ25hbE9wdHMgPSBvcHRzO1xuICAgIHRoaXMubWF4Sm9pbkF0dGVtcHRzID0gb3B0cy5tYXhSZXRyaWVzO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmpvaW5BdHRlbXB0cyArPSAxO1xuXG4gICAgICB0aGlzLnNldHVwU2lnbmFsQ2xpZW50Q2FsbGJhY2tzKCk7XG4gICAgICBjb25zdCBqb2luUmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNsaWVudC5qb2luKHVybCwgdG9rZW4sIG9wdHMsIGFib3J0U2lnbmFsKTtcbiAgICAgIHRoaXMuX2lzQ2xvc2VkID0gZmFsc2U7XG4gICAgICB0aGlzLmxhdGVzdEpvaW5SZXNwb25zZSA9IGpvaW5SZXNwb25zZTtcblxuICAgICAgdGhpcy5zdWJzY3JpYmVyUHJpbWFyeSA9IGpvaW5SZXNwb25zZS5zdWJzY3JpYmVyUHJpbWFyeTtcbiAgICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5jb25maWd1cmUoam9pblJlc3BvbnNlKTtcbiAgICAgIH1cblxuICAgICAgLy8gY3JlYXRlIG9mZmVyXG4gICAgICBpZiAoIXRoaXMuc3Vic2NyaWJlclByaW1hcnkpIHtcbiAgICAgICAgdGhpcy5uZWdvdGlhdGUoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jbGllbnRDb25maWd1cmF0aW9uID0gam9pblJlc3BvbnNlLmNsaWVudENvbmZpZ3VyYXRpb247XG4gICAgICByZXR1cm4gam9pblJlc3BvbnNlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlIGluc3RhbmNlb2YgQ29ubmVjdGlvbkVycm9yKSB7XG4gICAgICAgIGlmIChlLnJlYXNvbiA9PT0gQ29ubmVjdGlvbkVycm9yUmVhc29uLlNlcnZlclVucmVhY2hhYmxlKSB7XG4gICAgICAgICAgdGhpcy5sb2cud2FybihcbiAgICAgICAgICAgIGBDb3VsZG4ndCBjb25uZWN0IHRvIHNlcnZlciwgYXR0ZW1wdCAke3RoaXMuam9pbkF0dGVtcHRzfSBvZiAke3RoaXMubWF4Sm9pbkF0dGVtcHRzfWAsXG4gICAgICAgICAgICB0aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAodGhpcy5qb2luQXR0ZW1wdHMgPCB0aGlzLm1heEpvaW5BdHRlbXB0cykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuam9pbih1cmwsIHRva2VuLCBvcHRzLCBhYm9ydFNpZ25hbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGNsb3NlKCkge1xuICAgIGNvbnN0IHVubG9jayA9IGF3YWl0IHRoaXMuY2xvc2luZ0xvY2subG9jaygpO1xuICAgIGlmICh0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICB1bmxvY2soKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX2lzQ2xvc2VkID0gdHJ1ZTtcbiAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5DbG9zaW5nKTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICB0aGlzLmRlcmVnaXN0ZXJPbkxpbmVMaXN0ZW5lcigpO1xuICAgICAgdGhpcy5jbGVhclBlbmRpbmdSZWNvbm5lY3QoKTtcbiAgICAgIGF3YWl0IHRoaXMuY2xlYW51cFBlZXJDb25uZWN0aW9ucygpO1xuICAgICAgYXdhaXQgdGhpcy5jbGVhbnVwQ2xpZW50KCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHVubG9jaygpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGNsZWFudXBQZWVyQ29ubmVjdGlvbnMoKSB7XG4gICAgYXdhaXQgdGhpcy5wY01hbmFnZXI/LmNsb3NlKCk7XG4gICAgdGhpcy5wY01hbmFnZXIgPSB1bmRlZmluZWQ7XG5cbiAgICBjb25zdCBkY0NsZWFudXAgPSAoZGM6IFJUQ0RhdGFDaGFubmVsIHwgdW5kZWZpbmVkKSA9PiB7XG4gICAgICBpZiAoIWRjKSByZXR1cm47XG4gICAgICBkYy5jbG9zZSgpO1xuICAgICAgZGMub25idWZmZXJlZGFtb3VudGxvdyA9IG51bGw7XG4gICAgICBkYy5vbmNsb3NlID0gbnVsbDtcbiAgICAgIGRjLm9uY2xvc2luZyA9IG51bGw7XG4gICAgICBkYy5vbmVycm9yID0gbnVsbDtcbiAgICAgIGRjLm9ubWVzc2FnZSA9IG51bGw7XG4gICAgICBkYy5vbm9wZW4gPSBudWxsO1xuICAgIH07XG4gICAgZGNDbGVhbnVwKHRoaXMubG9zc3lEQyk7XG4gICAgZGNDbGVhbnVwKHRoaXMubG9zc3lEQ1N1Yik7XG4gICAgZGNDbGVhbnVwKHRoaXMucmVsaWFibGVEQyk7XG4gICAgZGNDbGVhbnVwKHRoaXMucmVsaWFibGVEQ1N1Yik7XG5cbiAgICB0aGlzLmxvc3N5REMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sb3NzeURDU3ViID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucmVsaWFibGVEQyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnJlbGlhYmxlRENTdWIgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBhc3luYyBjbGVhbnVwQ2xpZW50KCkge1xuICAgIGF3YWl0IHRoaXMuY2xpZW50LmNsb3NlKCk7XG4gICAgdGhpcy5jbGllbnQucmVzZXRDYWxsYmFja3MoKTtcbiAgfVxuXG4gIGFkZFRyYWNrKHJlcTogQWRkVHJhY2tSZXF1ZXN0KTogUHJvbWlzZTxUcmFja0luZm8+IHtcbiAgICBpZiAodGhpcy5wZW5kaW5nVHJhY2tSZXNvbHZlcnNbcmVxLmNpZF0pIHtcbiAgICAgIHRocm93IG5ldyBUcmFja0ludmFsaWRFcnJvcignYSB0cmFjayB3aXRoIHRoZSBzYW1lIElEIGhhcyBhbHJlYWR5IGJlZW4gcHVibGlzaGVkJyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZTxUcmFja0luZm8+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHB1YmxpY2F0aW9uVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBkZWxldGUgdGhpcy5wZW5kaW5nVHJhY2tSZXNvbHZlcnNbcmVxLmNpZF07XG4gICAgICAgIHJlamVjdChcbiAgICAgICAgICBuZXcgQ29ubmVjdGlvbkVycm9yKCdwdWJsaWNhdGlvbiBvZiBsb2NhbCB0cmFjayB0aW1lZCBvdXQsIG5vIHJlc3BvbnNlIGZyb20gc2VydmVyJyksXG4gICAgICAgICk7XG4gICAgICB9LCAxMF8wMDApO1xuICAgICAgdGhpcy5wZW5kaW5nVHJhY2tSZXNvbHZlcnNbcmVxLmNpZF0gPSB7XG4gICAgICAgIHJlc29sdmU6IChpbmZvOiBUcmFja0luZm8pID0+IHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQocHVibGljYXRpb25UaW1lb3V0KTtcbiAgICAgICAgICByZXNvbHZlKGluZm8pO1xuICAgICAgICB9LFxuICAgICAgICByZWplY3Q6ICgpID0+IHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQocHVibGljYXRpb25UaW1lb3V0KTtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdDYW5jZWxsZWQgcHVibGljYXRpb24gYnkgY2FsbGluZyB1bnB1Ymxpc2gnKSk7XG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgICAgdGhpcy5jbGllbnQuc2VuZEFkZFRyYWNrKHJlcSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBzZW5kZXIgZnJvbSBQZWVyQ29ubmVjdGlvbiwgcmV0dXJuaW5nIHRydWUgaWYgaXQgd2FzIHJlbW92ZWQgc3VjY2Vzc2Z1bGx5XG4gICAqIGFuZCBhIG5lZ290aWF0aW9uIGlzIG5lY2Vzc2FyeVxuICAgKiBAcGFyYW0gc2VuZGVyXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICByZW1vdmVUcmFjayhzZW5kZXI6IFJUQ1J0cFNlbmRlcik6IGJvb2xlYW4ge1xuICAgIGlmIChzZW5kZXIudHJhY2sgJiYgdGhpcy5wZW5kaW5nVHJhY2tSZXNvbHZlcnNbc2VuZGVyLnRyYWNrLmlkXSkge1xuICAgICAgY29uc3QgeyByZWplY3QgfSA9IHRoaXMucGVuZGluZ1RyYWNrUmVzb2x2ZXJzW3NlbmRlci50cmFjay5pZF07XG4gICAgICBpZiAocmVqZWN0KSB7XG4gICAgICAgIHJlamVjdCgpO1xuICAgICAgfVxuICAgICAgZGVsZXRlIHRoaXMucGVuZGluZ1RyYWNrUmVzb2x2ZXJzW3NlbmRlci50cmFjay5pZF07XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICB0aGlzLnBjTWFuYWdlciEucmVtb3ZlVHJhY2soc2VuZGVyKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGU6IHVua25vd24pIHtcbiAgICAgIHRoaXMubG9nLndhcm4oJ2ZhaWxlZCB0byByZW1vdmUgdHJhY2snLCB7IC4uLnRoaXMubG9nQ29udGV4dCwgZXJyb3I6IGUgfSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHVwZGF0ZU11dGVTdGF0dXModHJhY2tTaWQ6IHN0cmluZywgbXV0ZWQ6IGJvb2xlYW4pIHtcbiAgICB0aGlzLmNsaWVudC5zZW5kTXV0ZVRyYWNrKHRyYWNrU2lkLCBtdXRlZCk7XG4gIH1cblxuICBnZXQgZGF0YVN1YnNjcmliZXJSZWFkeVN0YXRlKCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMucmVsaWFibGVEQ1N1Yj8ucmVhZHlTdGF0ZTtcbiAgfVxuXG4gIGFzeW5jIGdldENvbm5lY3RlZFNlcnZlckFkZHJlc3MoKTogUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+IHtcbiAgICByZXR1cm4gdGhpcy5wY01hbmFnZXI/LmdldENvbm5lY3RlZEFkZHJlc3MoKTtcbiAgfVxuXG4gIC8qIEBpbnRlcm5hbCAqL1xuICBzZXRSZWdpb25VcmxQcm92aWRlcihwcm92aWRlcjogUmVnaW9uVXJsUHJvdmlkZXIpIHtcbiAgICB0aGlzLnJlZ2lvblVybFByb3ZpZGVyID0gcHJvdmlkZXI7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGNvbmZpZ3VyZShqb2luUmVzcG9uc2U6IEpvaW5SZXNwb25zZSkge1xuICAgIC8vIGFscmVhZHkgY29uZmlndXJlZFxuICAgIGlmICh0aGlzLnBjTWFuYWdlciAmJiB0aGlzLnBjTWFuYWdlci5jdXJyZW50U3RhdGUgIT09IFBDVHJhbnNwb3J0U3RhdGUuTkVXKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5wYXJ0aWNpcGFudFNpZCA9IGpvaW5SZXNwb25zZS5wYXJ0aWNpcGFudD8uc2lkO1xuXG4gICAgY29uc3QgcnRjQ29uZmlnID0gdGhpcy5tYWtlUlRDQ29uZmlndXJhdGlvbihqb2luUmVzcG9uc2UpO1xuXG4gICAgdGhpcy5wY01hbmFnZXIgPSBuZXcgUENUcmFuc3BvcnRNYW5hZ2VyKFxuICAgICAgcnRjQ29uZmlnLFxuICAgICAgam9pblJlc3BvbnNlLnN1YnNjcmliZXJQcmltYXJ5LFxuICAgICAgdGhpcy5sb2dnZXJPcHRpb25zLFxuICAgICk7XG5cbiAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuVHJhbnNwb3J0c0NyZWF0ZWQsIHRoaXMucGNNYW5hZ2VyLnB1Ymxpc2hlciwgdGhpcy5wY01hbmFnZXIuc3Vic2NyaWJlcik7XG5cbiAgICB0aGlzLnBjTWFuYWdlci5vbkljZUNhbmRpZGF0ZSA9IChjYW5kaWRhdGUsIHRhcmdldCkgPT4ge1xuICAgICAgdGhpcy5jbGllbnQuc2VuZEljZUNhbmRpZGF0ZShjYW5kaWRhdGUsIHRhcmdldCk7XG4gICAgfTtcblxuICAgIHRoaXMucGNNYW5hZ2VyLm9uUHVibGlzaGVyT2ZmZXIgPSAob2ZmZXIpID0+IHtcbiAgICAgIHRoaXMuY2xpZW50LnNlbmRPZmZlcihvZmZlcik7XG4gICAgfTtcblxuICAgIHRoaXMucGNNYW5hZ2VyLm9uRGF0YUNoYW5uZWwgPSB0aGlzLmhhbmRsZURhdGFDaGFubmVsO1xuICAgIHRoaXMucGNNYW5hZ2VyLm9uU3RhdGVDaGFuZ2UgPSBhc3luYyAoY29ubmVjdGlvblN0YXRlLCBwdWJsaXNoZXJTdGF0ZSwgc3Vic2NyaWJlclN0YXRlKSA9PiB7XG4gICAgICB0aGlzLmxvZy5kZWJ1ZyhgcHJpbWFyeSBQQyBzdGF0ZSBjaGFuZ2VkICR7Y29ubmVjdGlvblN0YXRlfWAsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICBpZiAoY29ubmVjdGlvblN0YXRlID09PSBQQ1RyYW5zcG9ydFN0YXRlLkNPTk5FQ1RFRCkge1xuICAgICAgICBjb25zdCBzaG91bGRFbWl0ID0gdGhpcy5wY1N0YXRlID09PSBQQ1N0YXRlLk5ldztcbiAgICAgICAgdGhpcy5wY1N0YXRlID0gUENTdGF0ZS5Db25uZWN0ZWQ7XG4gICAgICAgIGlmIChzaG91bGRFbWl0KSB7XG4gICAgICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LkNvbm5lY3RlZCwgam9pblJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjb25uZWN0aW9uU3RhdGUgPT09IFBDVHJhbnNwb3J0U3RhdGUuRkFJTEVEKSB7XG4gICAgICAgIC8vIG9uIFNhZmFyaSwgUGVlckNvbm5lY3Rpb24gd2lsbCBzd2l0Y2ggdG8gJ2Rpc2Nvbm5lY3RlZCcgZHVyaW5nIHJlbmVnb3RpYXRpb25cbiAgICAgICAgaWYgKHRoaXMucGNTdGF0ZSA9PT0gUENTdGF0ZS5Db25uZWN0ZWQpIHtcbiAgICAgICAgICB0aGlzLnBjU3RhdGUgPSBQQ1N0YXRlLkRpc2Nvbm5lY3RlZDtcblxuICAgICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdChcbiAgICAgICAgICAgICdwZWVyY29ubmVjdGlvbiBmYWlsZWQnLFxuICAgICAgICAgICAgc3Vic2NyaWJlclN0YXRlID09PSAnZmFpbGVkJ1xuICAgICAgICAgICAgICA/IFJlY29ubmVjdFJlYXNvbi5SUl9TVUJTQ1JJQkVSX0ZBSUxFRFxuICAgICAgICAgICAgICA6IFJlY29ubmVjdFJlYXNvbi5SUl9QVUJMSVNIRVJfRkFJTEVELFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMucGNNYW5hZ2VyLm9uVHJhY2sgPSAoZXY6IFJUQ1RyYWNrRXZlbnQpID0+IHtcbiAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5NZWRpYVRyYWNrQWRkZWQsIGV2LnRyYWNrLCBldi5zdHJlYW1zWzBdLCBldi5yZWNlaXZlcik7XG4gICAgfTtcblxuICAgIHRoaXMuY3JlYXRlRGF0YUNoYW5uZWxzKCk7XG4gIH1cblxuICBwcml2YXRlIHNldHVwU2lnbmFsQ2xpZW50Q2FsbGJhY2tzKCkge1xuICAgIC8vIGNvbmZpZ3VyZSBzaWduYWxpbmcgY2xpZW50XG4gICAgdGhpcy5jbGllbnQub25BbnN3ZXIgPSBhc3luYyAoc2QpID0+IHtcbiAgICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2cuZGVidWcoJ3JlY2VpdmVkIHNlcnZlciBhbnN3ZXInLCB7IC4uLnRoaXMubG9nQ29udGV4dCwgUlRDU2RwVHlwZTogc2QudHlwZSB9KTtcbiAgICAgIGF3YWl0IHRoaXMucGNNYW5hZ2VyLnNldFB1Ymxpc2hlckFuc3dlcihzZCk7XG4gICAgfTtcblxuICAgIC8vIGFkZCBjYW5kaWRhdGUgb24gdHJpY2tsZVxuICAgIHRoaXMuY2xpZW50Lm9uVHJpY2tsZSA9IChjYW5kaWRhdGUsIHRhcmdldCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmxvZy50cmFjZSgnZ290IElDRSBjYW5kaWRhdGUgZnJvbSBwZWVyJywgeyAuLi50aGlzLmxvZ0NvbnRleHQsIGNhbmRpZGF0ZSwgdGFyZ2V0IH0pO1xuICAgICAgdGhpcy5wY01hbmFnZXIuYWRkSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSwgdGFyZ2V0KTtcbiAgICB9O1xuXG4gICAgLy8gd2hlbiBzZXJ2ZXIgY3JlYXRlcyBhbiBvZmZlciBmb3IgdGhlIGNsaWVudFxuICAgIHRoaXMuY2xpZW50Lm9uT2ZmZXIgPSBhc3luYyAoc2QpID0+IHtcbiAgICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgYW5zd2VyID0gYXdhaXQgdGhpcy5wY01hbmFnZXIuY3JlYXRlU3Vic2NyaWJlckFuc3dlckZyb21PZmZlcihzZCk7XG4gICAgICB0aGlzLmNsaWVudC5zZW5kQW5zd2VyKGFuc3dlcik7XG4gICAgfTtcblxuICAgIHRoaXMuY2xpZW50Lm9uTG9jYWxUcmFja1B1Ymxpc2hlZCA9IChyZXM6IFRyYWNrUHVibGlzaGVkUmVzcG9uc2UpID0+IHtcbiAgICAgIHRoaXMubG9nLmRlYnVnKCdyZWNlaXZlZCB0cmFja1B1Ymxpc2hlZFJlc3BvbnNlJywge1xuICAgICAgICAuLi50aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgIGNpZDogcmVzLmNpZCxcbiAgICAgICAgdHJhY2s6IHJlcy50cmFjaz8uc2lkLFxuICAgICAgfSk7XG4gICAgICBpZiAoIXRoaXMucGVuZGluZ1RyYWNrUmVzb2x2ZXJzW3Jlcy5jaWRdKSB7XG4gICAgICAgIHRoaXMubG9nLmVycm9yKGBtaXNzaW5nIHRyYWNrIHJlc29sdmVyIGZvciAke3Jlcy5jaWR9YCwge1xuICAgICAgICAgIC4uLnRoaXMubG9nQ29udGV4dCxcbiAgICAgICAgICBjaWQ6IHJlcy5jaWQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB7IHJlc29sdmUgfSA9IHRoaXMucGVuZGluZ1RyYWNrUmVzb2x2ZXJzW3Jlcy5jaWRdO1xuICAgICAgZGVsZXRlIHRoaXMucGVuZGluZ1RyYWNrUmVzb2x2ZXJzW3Jlcy5jaWRdO1xuICAgICAgcmVzb2x2ZShyZXMudHJhY2shKTtcbiAgICB9O1xuXG4gICAgdGhpcy5jbGllbnQub25Mb2NhbFRyYWNrVW5wdWJsaXNoZWQgPSAocmVzcG9uc2U6IFRyYWNrVW5wdWJsaXNoZWRSZXNwb25zZSkgPT4ge1xuICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCwgcmVzcG9uc2UpO1xuICAgIH07XG5cbiAgICB0aGlzLmNsaWVudC5vblRva2VuUmVmcmVzaCA9ICh0b2tlbjogc3RyaW5nKSA9PiB7XG4gICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgfTtcblxuICAgIHRoaXMuY2xpZW50Lm9uUmVtb3RlTXV0ZUNoYW5nZWQgPSAodHJhY2tTaWQ6IHN0cmluZywgbXV0ZWQ6IGJvb2xlYW4pID0+IHtcbiAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5SZW1vdGVNdXRlLCB0cmFja1NpZCwgbXV0ZWQpO1xuICAgIH07XG5cbiAgICB0aGlzLmNsaWVudC5vblN1YnNjcmliZWRRdWFsaXR5VXBkYXRlID0gKHVwZGF0ZTogU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUpID0+IHtcbiAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5TdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSwgdXBkYXRlKTtcbiAgICB9O1xuXG4gICAgdGhpcy5jbGllbnQub25DbG9zZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCgnc2lnbmFsJywgUmVjb25uZWN0UmVhc29uLlJSX1NJR05BTF9ESVNDT05ORUNURUQpO1xuICAgIH07XG5cbiAgICB0aGlzLmNsaWVudC5vbkxlYXZlID0gKGxlYXZlPzogTGVhdmVSZXF1ZXN0KSA9PiB7XG4gICAgICBpZiAobGVhdmU/LmNhblJlY29ubmVjdCkge1xuICAgICAgICB0aGlzLmZ1bGxSZWNvbm5lY3RPbk5leHQgPSB0cnVlO1xuICAgICAgICAvLyByZWNvbm5lY3QgaW1tZWRpYXRlbHkgaW5zdGVhZCBvZiB3YWl0aW5nIGZvciBuZXh0IGF0dGVtcHRcbiAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KGxlYXZlUmVjb25uZWN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5EaXNjb25uZWN0ZWQsIGxlYXZlPy5yZWFzb24pO1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmxvZy5kZWJ1ZygnY2xpZW50IGxlYXZlIHJlcXVlc3QnLCB7IC4uLnRoaXMubG9nQ29udGV4dCwgcmVhc29uOiBsZWF2ZT8ucmVhc29uIH0pO1xuICAgIH07XG4gIH1cblxuICBwcml2YXRlIG1ha2VSVENDb25maWd1cmF0aW9uKHNlcnZlclJlc3BvbnNlOiBKb2luUmVzcG9uc2UgfCBSZWNvbm5lY3RSZXNwb25zZSk6IFJUQ0NvbmZpZ3VyYXRpb24ge1xuICAgIGNvbnN0IHJ0Y0NvbmZpZyA9IHsgLi4udGhpcy5ydGNDb25maWcgfTtcblxuICAgIGlmICh0aGlzLnNpZ25hbE9wdHM/LmUyZWVFbmFibGVkKSB7XG4gICAgICB0aGlzLmxvZy5kZWJ1ZygnRTJFRSAtIHNldHRpbmcgdXAgdHJhbnNwb3J0cyB3aXRoIGluc2VydGFibGUgc3RyZWFtcycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAvLyAgdGhpcyBtYWtlcyBzdXJlIHRoYXQgbm8gZGF0YSBpcyBzZW50IGJlZm9yZSB0aGUgdHJhbnNmb3JtcyBhcmUgcmVhZHlcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHJ0Y0NvbmZpZy5lbmNvZGVkSW5zZXJ0YWJsZVN0cmVhbXMgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBJQ0Ugc2VydmVycyBiZWZvcmUgY3JlYXRpbmcgUGVlckNvbm5lY3Rpb25cbiAgICBpZiAoc2VydmVyUmVzcG9uc2UuaWNlU2VydmVycyAmJiAhcnRjQ29uZmlnLmljZVNlcnZlcnMpIHtcbiAgICAgIGNvbnN0IHJ0Y0ljZVNlcnZlcnM6IFJUQ0ljZVNlcnZlcltdID0gW107XG4gICAgICBzZXJ2ZXJSZXNwb25zZS5pY2VTZXJ2ZXJzLmZvckVhY2goKGljZVNlcnZlcikgPT4ge1xuICAgICAgICBjb25zdCBydGNJY2VTZXJ2ZXI6IFJUQ0ljZVNlcnZlciA9IHtcbiAgICAgICAgICB1cmxzOiBpY2VTZXJ2ZXIudXJscyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGljZVNlcnZlci51c2VybmFtZSkgcnRjSWNlU2VydmVyLnVzZXJuYW1lID0gaWNlU2VydmVyLnVzZXJuYW1lO1xuICAgICAgICBpZiAoaWNlU2VydmVyLmNyZWRlbnRpYWwpIHtcbiAgICAgICAgICBydGNJY2VTZXJ2ZXIuY3JlZGVudGlhbCA9IGljZVNlcnZlci5jcmVkZW50aWFsO1xuICAgICAgICB9XG4gICAgICAgIHJ0Y0ljZVNlcnZlcnMucHVzaChydGNJY2VTZXJ2ZXIpO1xuICAgICAgfSk7XG4gICAgICBydGNDb25maWcuaWNlU2VydmVycyA9IHJ0Y0ljZVNlcnZlcnM7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgc2VydmVyUmVzcG9uc2UuY2xpZW50Q29uZmlndXJhdGlvbiAmJlxuICAgICAgc2VydmVyUmVzcG9uc2UuY2xpZW50Q29uZmlndXJhdGlvbi5mb3JjZVJlbGF5ID09PSBDbGllbnRDb25maWdTZXR0aW5nLkVOQUJMRURcbiAgICApIHtcbiAgICAgIHJ0Y0NvbmZpZy5pY2VUcmFuc3BvcnRQb2xpY3kgPSAncmVsYXknO1xuICAgIH1cblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBydGNDb25maWcuc2RwU2VtYW50aWNzID0gJ3VuaWZpZWQtcGxhbic7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJ0Y0NvbmZpZy5jb250aW51YWxHYXRoZXJpbmdQb2xpY3kgPSAnZ2F0aGVyX2NvbnRpbnVhbGx5JztcblxuICAgIHJldHVybiBydGNDb25maWc7XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZURhdGFDaGFubmVscygpIHtcbiAgICBpZiAoIXRoaXMucGNNYW5hZ2VyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gY2xlYXIgb2xkIGRhdGEgY2hhbm5lbCBjYWxsYmFja3MgaWYgcmVjcmVhdGVcbiAgICBpZiAodGhpcy5sb3NzeURDKSB7XG4gICAgICB0aGlzLmxvc3N5REMub25tZXNzYWdlID0gbnVsbDtcbiAgICAgIHRoaXMubG9zc3lEQy5vbmVycm9yID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMucmVsaWFibGVEQykge1xuICAgICAgdGhpcy5yZWxpYWJsZURDLm9ubWVzc2FnZSA9IG51bGw7XG4gICAgICB0aGlzLnJlbGlhYmxlREMub25lcnJvciA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIGRhdGEgY2hhbm5lbHNcbiAgICB0aGlzLmxvc3N5REMgPSB0aGlzLnBjTWFuYWdlci5jcmVhdGVQdWJsaXNoZXJEYXRhQ2hhbm5lbChsb3NzeURhdGFDaGFubmVsLCB7XG4gICAgICAvLyB3aWxsIGRyb3Agb2xkZXIgcGFja2V0cyB0aGF0IGFycml2ZVxuICAgICAgb3JkZXJlZDogdHJ1ZSxcbiAgICAgIG1heFJldHJhbnNtaXRzOiAwLFxuICAgIH0pO1xuICAgIHRoaXMucmVsaWFibGVEQyA9IHRoaXMucGNNYW5hZ2VyLmNyZWF0ZVB1Ymxpc2hlckRhdGFDaGFubmVsKHJlbGlhYmxlRGF0YUNoYW5uZWwsIHtcbiAgICAgIG9yZGVyZWQ6IHRydWUsXG4gICAgfSk7XG5cbiAgICAvLyBhbHNvIGhhbmRsZSBtZXNzYWdlcyBvdmVyIHRoZSBwdWIgY2hhbm5lbCwgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgdGhpcy5sb3NzeURDLm9ubWVzc2FnZSA9IHRoaXMuaGFuZGxlRGF0YU1lc3NhZ2U7XG4gICAgdGhpcy5yZWxpYWJsZURDLm9ubWVzc2FnZSA9IHRoaXMuaGFuZGxlRGF0YU1lc3NhZ2U7XG5cbiAgICAvLyBoYW5kbGUgZGF0YWNoYW5uZWwgZXJyb3JzXG4gICAgdGhpcy5sb3NzeURDLm9uZXJyb3IgPSB0aGlzLmhhbmRsZURhdGFFcnJvcjtcbiAgICB0aGlzLnJlbGlhYmxlREMub25lcnJvciA9IHRoaXMuaGFuZGxlRGF0YUVycm9yO1xuXG4gICAgLy8gc2V0IHVwIGRjIGJ1ZmZlciB0aHJlc2hvbGQsIHNldCB0byA2NGtCIChvdGhlcndpc2UgMCBieSBkZWZhdWx0KVxuICAgIHRoaXMubG9zc3lEQy5idWZmZXJlZEFtb3VudExvd1RocmVzaG9sZCA9IDY1NTM1O1xuICAgIHRoaXMucmVsaWFibGVEQy5idWZmZXJlZEFtb3VudExvd1RocmVzaG9sZCA9IDY1NTM1O1xuXG4gICAgLy8gaGFuZGxlIGJ1ZmZlciBhbW91bnQgbG93IGV2ZW50c1xuICAgIHRoaXMubG9zc3lEQy5vbmJ1ZmZlcmVkYW1vdW50bG93ID0gdGhpcy5oYW5kbGVCdWZmZXJlZEFtb3VudExvdztcbiAgICB0aGlzLnJlbGlhYmxlREMub25idWZmZXJlZGFtb3VudGxvdyA9IHRoaXMuaGFuZGxlQnVmZmVyZWRBbW91bnRMb3c7XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZURhdGFDaGFubmVsID0gYXN5bmMgKHsgY2hhbm5lbCB9OiBSVENEYXRhQ2hhbm5lbEV2ZW50KSA9PiB7XG4gICAgaWYgKCFjaGFubmVsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjaGFubmVsLmxhYmVsID09PSByZWxpYWJsZURhdGFDaGFubmVsKSB7XG4gICAgICB0aGlzLnJlbGlhYmxlRENTdWIgPSBjaGFubmVsO1xuICAgIH0gZWxzZSBpZiAoY2hhbm5lbC5sYWJlbCA9PT0gbG9zc3lEYXRhQ2hhbm5lbCkge1xuICAgICAgdGhpcy5sb3NzeURDU3ViID0gY2hhbm5lbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmxvZy5kZWJ1Zyhgb24gZGF0YSBjaGFubmVsICR7Y2hhbm5lbC5pZH0sICR7Y2hhbm5lbC5sYWJlbH1gLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgIGNoYW5uZWwub25tZXNzYWdlID0gdGhpcy5oYW5kbGVEYXRhTWVzc2FnZTtcbiAgfTtcblxuICBwcml2YXRlIGhhbmRsZURhdGFNZXNzYWdlID0gYXN5bmMgKG1lc3NhZ2U6IE1lc3NhZ2VFdmVudCkgPT4ge1xuICAgIC8vIG1ha2Ugc3VyZSB0byByZXNwZWN0IGluY29taW5nIGRhdGEgbWVzc2FnZSBvcmRlciBieSBwcm9jZXNzaW5nIG1lc3NhZ2UgZXZlbnRzIG9uZSBhZnRlciB0aGUgb3RoZXJcbiAgICBjb25zdCB1bmxvY2sgPSBhd2FpdCB0aGlzLmRhdGFQcm9jZXNzTG9jay5sb2NrKCk7XG4gICAgdHJ5IHtcbiAgICAgIC8vIGRlY29kZVxuICAgICAgbGV0IGJ1ZmZlcjogQXJyYXlCdWZmZXIgfCB1bmRlZmluZWQ7XG4gICAgICBpZiAobWVzc2FnZS5kYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgYnVmZmVyID0gbWVzc2FnZS5kYXRhO1xuICAgICAgfSBlbHNlIGlmIChtZXNzYWdlLmRhdGEgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgIGJ1ZmZlciA9IGF3YWl0IG1lc3NhZ2UuZGF0YS5hcnJheUJ1ZmZlcigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sb2cuZXJyb3IoJ3Vuc3VwcG9ydGVkIGRhdGEgdHlwZScsIHsgLi4udGhpcy5sb2dDb250ZXh0LCBkYXRhOiBtZXNzYWdlLmRhdGEgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRwID0gRGF0YVBhY2tldC5mcm9tQmluYXJ5KG5ldyBVaW50OEFycmF5KGJ1ZmZlcikpO1xuICAgICAgaWYgKGRwLnZhbHVlPy5jYXNlID09PSAnc3BlYWtlcicpIHtcbiAgICAgICAgLy8gZGlzcGF0Y2ggc3BlYWtlciB1cGRhdGVzXG4gICAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5BY3RpdmVTcGVha2Vyc1VwZGF0ZSwgZHAudmFsdWUudmFsdWUuc3BlYWtlcnMpO1xuICAgICAgfSBlbHNlIGlmIChkcC52YWx1ZT8uY2FzZSA9PT0gJ3VzZXInKSB7XG4gICAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5EYXRhUGFja2V0UmVjZWl2ZWQsIGRwLnZhbHVlLnZhbHVlLCBkcC5raW5kKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdW5sb2NrKCk7XG4gICAgfVxuICB9O1xuXG4gIHByaXZhdGUgaGFuZGxlRGF0YUVycm9yID0gKGV2ZW50OiBFdmVudCkgPT4ge1xuICAgIGNvbnN0IGNoYW5uZWwgPSBldmVudC5jdXJyZW50VGFyZ2V0IGFzIFJUQ0RhdGFDaGFubmVsO1xuICAgIGNvbnN0IGNoYW5uZWxLaW5kID0gY2hhbm5lbC5tYXhSZXRyYW5zbWl0cyA9PT0gMCA/ICdsb3NzeScgOiAncmVsaWFibGUnO1xuXG4gICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgRXJyb3JFdmVudCAmJiBldmVudC5lcnJvcikge1xuICAgICAgY29uc3QgeyBlcnJvciB9ID0gZXZlbnQuZXJyb3I7XG4gICAgICB0aGlzLmxvZy5lcnJvcihgRGF0YUNoYW5uZWwgZXJyb3Igb24gJHtjaGFubmVsS2luZH06ICR7ZXZlbnQubWVzc2FnZX1gLCB7XG4gICAgICAgIC4uLnRoaXMubG9nQ29udGV4dCxcbiAgICAgICAgZXJyb3IsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sb2cuZXJyb3IoYFVua25vd24gRGF0YUNoYW5uZWwgZXJyb3Igb24gJHtjaGFubmVsS2luZH1gLCB7IC4uLnRoaXMubG9nQ29udGV4dCwgZXZlbnQgfSk7XG4gICAgfVxuICB9O1xuXG4gIHByaXZhdGUgaGFuZGxlQnVmZmVyZWRBbW91bnRMb3cgPSAoZXZlbnQ6IEV2ZW50KSA9PiB7XG4gICAgY29uc3QgY2hhbm5lbCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQgYXMgUlRDRGF0YUNoYW5uZWw7XG4gICAgY29uc3QgY2hhbm5lbEtpbmQgPVxuICAgICAgY2hhbm5lbC5tYXhSZXRyYW5zbWl0cyA9PT0gMCA/IERhdGFQYWNrZXRfS2luZC5MT1NTWSA6IERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRTtcblxuICAgIHRoaXMudXBkYXRlQW5kRW1pdERDQnVmZmVyU3RhdHVzKGNoYW5uZWxLaW5kKTtcbiAgfTtcblxuICBwcml2YXRlIHNldFByZWZlcnJlZENvZGVjKFxuICAgIHRyYW5zY2VpdmVyOiBSVENSdHBUcmFuc2NlaXZlcixcbiAgICBraW5kOiBUcmFjay5LaW5kLFxuICAgIHZpZGVvQ29kZWM6IFZpZGVvQ29kZWMsXG4gICkge1xuICAgIGlmICghKCdnZXRDYXBhYmlsaXRpZXMnIGluIFJUQ1J0cFJlY2VpdmVyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyB3aGVuIHNldHRpbmcgY29kZWMgcHJlZmVyZW5jZXMsIHRoZSBjYXBhYmlsaXRlcyBuZWVkIHRvIGJlIHJlYWQgZnJvbSB0aGUgUlRDUnRwUmVjZWl2ZXJcbiAgICBjb25zdCBjYXAgPSBSVENSdHBSZWNlaXZlci5nZXRDYXBhYmlsaXRpZXMoa2luZCk7XG4gICAgaWYgKCFjYXApIHJldHVybjtcbiAgICB0aGlzLmxvZy5kZWJ1ZygnZ2V0IHJlY2VpdmVyIGNhcGFiaWxpdGllcycsIHsgLi4udGhpcy5sb2dDb250ZXh0LCBjYXAgfSk7XG4gICAgY29uc3QgbWF0Y2hlZDogUlRDUnRwQ29kZWNDYXBhYmlsaXR5W10gPSBbXTtcbiAgICBjb25zdCBwYXJ0aWFsTWF0Y2hlZDogUlRDUnRwQ29kZWNDYXBhYmlsaXR5W10gPSBbXTtcbiAgICBjb25zdCB1bm1hdGNoZWQ6IFJUQ1J0cENvZGVjQ2FwYWJpbGl0eVtdID0gW107XG4gICAgY2FwLmNvZGVjcy5mb3JFYWNoKChjKSA9PiB7XG4gICAgICBjb25zdCBjb2RlYyA9IGMubWltZVR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmIChjb2RlYyA9PT0gJ2F1ZGlvL29wdXMnKSB7XG4gICAgICAgIG1hdGNoZWQucHVzaChjKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbWF0Y2hlc1ZpZGVvQ29kZWMgPSBjb2RlYyA9PT0gYHZpZGVvLyR7dmlkZW9Db2RlY31gO1xuICAgICAgaWYgKCFtYXRjaGVzVmlkZW9Db2RlYykge1xuICAgICAgICB1bm1hdGNoZWQucHVzaChjKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gZm9yIGgyNjQgY29kZWNzIHRoYXQgaGF2ZSBzZHBGbXRwTGluZSBhdmFpbGFibGUsIHVzZSBvbmx5IGlmIHRoZVxuICAgICAgLy8gcHJvZmlsZS1sZXZlbC1pZCBpcyA0MmUwMWYgZm9yIGNyb3NzLWJyb3dzZXIgY29tcGF0aWJpbGl0eVxuICAgICAgaWYgKHZpZGVvQ29kZWMgPT09ICdoMjY0Jykge1xuICAgICAgICBpZiAoYy5zZHBGbXRwTGluZSAmJiBjLnNkcEZtdHBMaW5lLmluY2x1ZGVzKCdwcm9maWxlLWxldmVsLWlkPTQyZTAxZicpKSB7XG4gICAgICAgICAgbWF0Y2hlZC5wdXNoKGMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcnRpYWxNYXRjaGVkLnB1c2goYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBtYXRjaGVkLnB1c2goYyk7XG4gICAgfSk7XG5cbiAgICBpZiAoc3VwcG9ydHNTZXRDb2RlY1ByZWZlcmVuY2VzKHRyYW5zY2VpdmVyKSkge1xuICAgICAgdHJhbnNjZWl2ZXIuc2V0Q29kZWNQcmVmZXJlbmNlcyhtYXRjaGVkLmNvbmNhdChwYXJ0aWFsTWF0Y2hlZCwgdW5tYXRjaGVkKSk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgY3JlYXRlU2VuZGVyKFxuICAgIHRyYWNrOiBMb2NhbFRyYWNrLFxuICAgIG9wdHM6IFRyYWNrUHVibGlzaE9wdGlvbnMsXG4gICAgZW5jb2RpbmdzPzogUlRDUnRwRW5jb2RpbmdQYXJhbWV0ZXJzW10sXG4gICkge1xuICAgIGlmIChzdXBwb3J0c1RyYW5zY2VpdmVyKCkpIHtcbiAgICAgIGNvbnN0IHNlbmRlciA9IGF3YWl0IHRoaXMuY3JlYXRlVHJhbnNjZWl2ZXJSVENSdHBTZW5kZXIodHJhY2ssIG9wdHMsIGVuY29kaW5ncyk7XG4gICAgICByZXR1cm4gc2VuZGVyO1xuICAgIH1cbiAgICBpZiAoc3VwcG9ydHNBZGRUcmFjaygpKSB7XG4gICAgICB0aGlzLmxvZy53YXJuKCd1c2luZyBhZGQtdHJhY2sgZmFsbGJhY2snLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgY29uc3Qgc2VuZGVyID0gYXdhaXQgdGhpcy5jcmVhdGVSVENSdHBTZW5kZXIodHJhY2subWVkaWFTdHJlYW1UcmFjayk7XG4gICAgICByZXR1cm4gc2VuZGVyO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgnUmVxdWlyZWQgd2ViUlRDIEFQSXMgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGRldmljZScpO1xuICB9XG5cbiAgYXN5bmMgY3JlYXRlU2ltdWxjYXN0U2VuZGVyKFxuICAgIHRyYWNrOiBMb2NhbFZpZGVvVHJhY2ssXG4gICAgc2ltdWxjYXN0VHJhY2s6IFNpbXVsY2FzdFRyYWNrSW5mbyxcbiAgICBvcHRzOiBUcmFja1B1Ymxpc2hPcHRpb25zLFxuICAgIGVuY29kaW5ncz86IFJUQ1J0cEVuY29kaW5nUGFyYW1ldGVyc1tdLFxuICApIHtcbiAgICAvLyBzdG9yZSBSVENSdHBTZW5kZXJcbiAgICBpZiAoc3VwcG9ydHNUcmFuc2NlaXZlcigpKSB7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVTaW11bGNhc3RUcmFuc2NlaXZlclNlbmRlcih0cmFjaywgc2ltdWxjYXN0VHJhY2ssIG9wdHMsIGVuY29kaW5ncyk7XG4gICAgfVxuICAgIGlmIChzdXBwb3J0c0FkZFRyYWNrKCkpIHtcbiAgICAgIHRoaXMubG9nLmRlYnVnKCd1c2luZyBhZGQtdHJhY2sgZmFsbGJhY2snLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlUlRDUnRwU2VuZGVyKHRyYWNrLm1lZGlhU3RyZWFtVHJhY2spO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdDYW5ub3Qgc3RyZWFtIG9uIHRoaXMgZGV2aWNlJyk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGNyZWF0ZVRyYW5zY2VpdmVyUlRDUnRwU2VuZGVyKFxuICAgIHRyYWNrOiBMb2NhbFRyYWNrLFxuICAgIG9wdHM6IFRyYWNrUHVibGlzaE9wdGlvbnMsXG4gICAgZW5jb2RpbmdzPzogUlRDUnRwRW5jb2RpbmdQYXJhbWV0ZXJzW10sXG4gICkge1xuICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcbiAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdwdWJsaXNoZXIgaXMgY2xvc2VkJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RyZWFtczogTWVkaWFTdHJlYW1bXSA9IFtdO1xuXG4gICAgaWYgKHRyYWNrLm1lZGlhU3RyZWFtKSB7XG4gICAgICBzdHJlYW1zLnB1c2godHJhY2subWVkaWFTdHJlYW0pO1xuICAgIH1cblxuICAgIGNvbnN0IHRyYW5zY2VpdmVySW5pdDogUlRDUnRwVHJhbnNjZWl2ZXJJbml0ID0geyBkaXJlY3Rpb246ICdzZW5kb25seScsIHN0cmVhbXMgfTtcbiAgICBpZiAoZW5jb2RpbmdzKSB7XG4gICAgICB0cmFuc2NlaXZlckluaXQuc2VuZEVuY29kaW5ncyA9IGVuY29kaW5ncztcbiAgICB9XG4gICAgLy8gYWRkVHJhbnNjZWl2ZXIgZm9yIHJlYWN0LW5hdGl2ZSBpcyBhc3luYy4gd2ViIGlzIHN5bmNocm9ub3VzLCBidXQgYXdhaXQgd29uJ3QgZWZmZWN0IGl0LlxuICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gYXdhaXQgdGhpcy5wY01hbmFnZXIuYWRkUHVibGlzaGVyVHJhbnNjZWl2ZXIoXG4gICAgICB0cmFjay5tZWRpYVN0cmVhbVRyYWNrLFxuICAgICAgdHJhbnNjZWl2ZXJJbml0LFxuICAgICk7XG5cbiAgICBpZiAodHJhY2sua2luZCA9PT0gVHJhY2suS2luZC5WaWRlbyAmJiBvcHRzLnZpZGVvQ29kZWMpIHtcbiAgICAgIHRoaXMuc2V0UHJlZmVycmVkQ29kZWModHJhbnNjZWl2ZXIsIHRyYWNrLmtpbmQsIG9wdHMudmlkZW9Db2RlYyk7XG4gICAgICB0cmFjay5jb2RlYyA9IG9wdHMudmlkZW9Db2RlYztcbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zY2VpdmVyLnNlbmRlcjtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgY3JlYXRlU2ltdWxjYXN0VHJhbnNjZWl2ZXJTZW5kZXIoXG4gICAgdHJhY2s6IExvY2FsVmlkZW9UcmFjayxcbiAgICBzaW11bGNhc3RUcmFjazogU2ltdWxjYXN0VHJhY2tJbmZvLFxuICAgIG9wdHM6IFRyYWNrUHVibGlzaE9wdGlvbnMsXG4gICAgZW5jb2RpbmdzPzogUlRDUnRwRW5jb2RpbmdQYXJhbWV0ZXJzW10sXG4gICkge1xuICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcbiAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdwdWJsaXNoZXIgaXMgY2xvc2VkJyk7XG4gICAgfVxuICAgIGNvbnN0IHRyYW5zY2VpdmVySW5pdDogUlRDUnRwVHJhbnNjZWl2ZXJJbml0ID0geyBkaXJlY3Rpb246ICdzZW5kb25seScgfTtcbiAgICBpZiAoZW5jb2RpbmdzKSB7XG4gICAgICB0cmFuc2NlaXZlckluaXQuc2VuZEVuY29kaW5ncyA9IGVuY29kaW5ncztcbiAgICB9XG4gICAgLy8gYWRkVHJhbnNjZWl2ZXIgZm9yIHJlYWN0LW5hdGl2ZSBpcyBhc3luYy4gd2ViIGlzIHN5bmNocm9ub3VzLCBidXQgYXdhaXQgd29uJ3QgZWZmZWN0IGl0LlxuICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gYXdhaXQgdGhpcy5wY01hbmFnZXIuYWRkUHVibGlzaGVyVHJhbnNjZWl2ZXIoXG4gICAgICBzaW11bGNhc3RUcmFjay5tZWRpYVN0cmVhbVRyYWNrLFxuICAgICAgdHJhbnNjZWl2ZXJJbml0LFxuICAgICk7XG4gICAgaWYgKCFvcHRzLnZpZGVvQ29kZWMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zZXRQcmVmZXJyZWRDb2RlYyh0cmFuc2NlaXZlciwgdHJhY2sua2luZCwgb3B0cy52aWRlb0NvZGVjKTtcbiAgICB0cmFjay5zZXRTaW11bGNhc3RUcmFja1NlbmRlcihvcHRzLnZpZGVvQ29kZWMsIHRyYW5zY2VpdmVyLnNlbmRlcik7XG4gICAgcmV0dXJuIHRyYW5zY2VpdmVyLnNlbmRlcjtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgY3JlYXRlUlRDUnRwU2VuZGVyKHRyYWNrOiBNZWRpYVN0cmVhbVRyYWNrKSB7XG4gICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xuICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ3B1Ymxpc2hlciBpcyBjbG9zZWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGNNYW5hZ2VyLmFkZFB1Ymxpc2hlclRyYWNrKHRyYWNrKTtcbiAgfVxuXG4gIC8vIHdlYnNvY2tldCByZWNvbm5lY3QgYmVoYXZpb3IuIGlmIHdlYnNvY2tldCBpcyBpbnRlcnJ1cHRlZCwgYW5kIHRoZSBQZWVyQ29ubmVjdGlvblxuICAvLyBjb250aW51ZXMgdG8gd29yaywgd2UgY2FuIHJlY29ubmVjdCB0byB3ZWJzb2NrZXQgdG8gY29udGludWUgdGhlIHNlc3Npb25cbiAgLy8gYWZ0ZXIgYSBudW1iZXIgb2YgcmV0cmllcywgd2UnbGwgY2xvc2UgYW5kIGdpdmUgdXAgcGVybWFuZW50bHlcbiAgcHJpdmF0ZSBoYW5kbGVEaXNjb25uZWN0ID0gKGNvbm5lY3Rpb246IHN0cmluZywgZGlzY29ubmVjdFJlYXNvbj86IFJlY29ubmVjdFJlYXNvbikgPT4ge1xuICAgIGlmICh0aGlzLl9pc0Nsb3NlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMubG9nLndhcm4oYCR7Y29ubmVjdGlvbn0gZGlzY29ubmVjdGVkYCwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICBpZiAodGhpcy5yZWNvbm5lY3RBdHRlbXB0cyA9PT0gMCkge1xuICAgICAgLy8gb25seSByZXNldCBzdGFydCB0aW1lIG9uIHRoZSBmaXJzdCB0cnlcbiAgICAgIHRoaXMucmVjb25uZWN0U3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIH1cblxuICAgIGNvbnN0IGRpc2Nvbm5lY3QgPSAoZHVyYXRpb246IG51bWJlcikgPT4ge1xuICAgICAgdGhpcy5sb2cud2FybihcbiAgICAgICAgYGNvdWxkIG5vdCByZWNvdmVyIGNvbm5lY3Rpb24gYWZ0ZXIgJHt0aGlzLnJlY29ubmVjdEF0dGVtcHRzfSBhdHRlbXB0cywgJHtkdXJhdGlvbn1tcy4gZ2l2aW5nIHVwYCxcbiAgICAgICAgdGhpcy5sb2dDb250ZXh0LFxuICAgICAgKTtcbiAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5EaXNjb25uZWN0ZWQpO1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH07XG5cbiAgICBjb25zdCBkdXJhdGlvbiA9IERhdGUubm93KCkgLSB0aGlzLnJlY29ubmVjdFN0YXJ0O1xuICAgIGxldCBkZWxheSA9IHRoaXMuZ2V0TmV4dFJldHJ5RGVsYXkoe1xuICAgICAgZWxhcHNlZE1zOiBkdXJhdGlvbixcbiAgICAgIHJldHJ5Q291bnQ6IHRoaXMucmVjb25uZWN0QXR0ZW1wdHMsXG4gICAgfSk7XG5cbiAgICBpZiAoZGVsYXkgPT09IG51bGwpIHtcbiAgICAgIGRpc2Nvbm5lY3QoZHVyYXRpb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY29ubmVjdGlvbiA9PT0gbGVhdmVSZWNvbm5lY3QpIHtcbiAgICAgIGRlbGF5ID0gMDtcbiAgICB9XG5cbiAgICB0aGlzLmxvZy5kZWJ1ZyhgcmVjb25uZWN0aW5nIGluICR7ZGVsYXl9bXNgLCB0aGlzLmxvZ0NvbnRleHQpO1xuXG4gICAgdGhpcy5jbGVhclJlY29ubmVjdFRpbWVvdXQoKTtcbiAgICBpZiAodGhpcy50b2tlbiAmJiB0aGlzLnJlZ2lvblVybFByb3ZpZGVyKSB7XG4gICAgICAvLyB0b2tlbiBtYXkgaGF2ZSBiZWVuIHJlZnJlc2hlZCwgd2UgZG8gbm90IHdhbnQgdG8gcmVjcmVhdGUgdGhlIHJlZ2lvblVybFByb3ZpZGVyXG4gICAgICAvLyBzaW5jZSB0aGUgY3VycmVudCBlbmdpbmUgbWF5IGhhdmUgaW5oZXJpdGVkIGEgcmVnaW9uYWwgdXJsXG4gICAgICB0aGlzLnJlZ2lvblVybFByb3ZpZGVyLnVwZGF0ZVRva2VuKHRoaXMudG9rZW4pO1xuICAgIH1cbiAgICB0aGlzLnJlY29ubmVjdFRpbWVvdXQgPSBDcml0aWNhbFRpbWVycy5zZXRUaW1lb3V0KFxuICAgICAgKCkgPT4gdGhpcy5hdHRlbXB0UmVjb25uZWN0KGRpc2Nvbm5lY3RSZWFzb24pLFxuICAgICAgZGVsYXksXG4gICAgKTtcbiAgfTtcblxuICBwcml2YXRlIGFzeW5jIGF0dGVtcHRSZWNvbm5lY3QocmVhc29uPzogUmVjb25uZWN0UmVhc29uKSB7XG4gICAgaWYgKHRoaXMuX2lzQ2xvc2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGd1YXJkIGZvciBhdHRlbXB0aW5nIHJlY29ubmVjdGlvbiBtdWx0aXBsZSB0aW1lcyB3aGlsZSBvbmUgYXR0ZW1wdCBpcyBzdGlsbCBub3QgZmluaXNoZWRcbiAgICBpZiAodGhpcy5hdHRlbXB0aW5nUmVjb25uZWN0KSB7XG4gICAgICBsb2cud2FybignYWxyZWFkeSBhdHRlbXB0aW5nIHJlY29ubmVjdCwgcmV0dXJuaW5nIGVhcmx5JywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgdGhpcy5jbGllbnRDb25maWd1cmF0aW9uPy5yZXN1bWVDb25uZWN0aW9uID09PSBDbGllbnRDb25maWdTZXR0aW5nLkRJU0FCTEVEIHx8XG4gICAgICAvLyBzaWduYWxpbmcgc3RhdGUgY291bGQgY2hhbmdlIHRvIGNsb3NlZCBkdWUgdG8gaGFyZHdhcmUgc2xlZXBcbiAgICAgIC8vIHRob3NlIGNvbm5lY3Rpb25zIGNhbm5vdCBiZSByZXN1bWVkXG4gICAgICAodGhpcy5wY01hbmFnZXI/LmN1cnJlbnRTdGF0ZSA/PyBQQ1RyYW5zcG9ydFN0YXRlLk5FVykgPT09IFBDVHJhbnNwb3J0U3RhdGUuTkVXXG4gICAgKSB7XG4gICAgICB0aGlzLmZ1bGxSZWNvbm5lY3RPbk5leHQgPSB0cnVlO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICB0aGlzLmF0dGVtcHRpbmdSZWNvbm5lY3QgPSB0cnVlO1xuICAgICAgaWYgKHRoaXMuZnVsbFJlY29ubmVjdE9uTmV4dCkge1xuICAgICAgICBhd2FpdCB0aGlzLnJlc3RhcnRDb25uZWN0aW9uKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhd2FpdCB0aGlzLnJlc3VtZUNvbm5lY3Rpb24ocmVhc29uKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2xlYXJQZW5kaW5nUmVjb25uZWN0KCk7XG4gICAgICB0aGlzLmZ1bGxSZWNvbm5lY3RPbk5leHQgPSBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aGlzLnJlY29ubmVjdEF0dGVtcHRzICs9IDE7XG4gICAgICBsZXQgcmVjb3ZlcmFibGUgPSB0cnVlO1xuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKSB7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKCdyZWNlaXZlZCB1bnJlY292ZXJhYmxlIGVycm9yJywgeyAuLi50aGlzLmxvZ0NvbnRleHQsIGVycm9yOiBlIH0pO1xuICAgICAgICAvLyB1bnJlY292ZXJhYmxlXG4gICAgICAgIHJlY292ZXJhYmxlID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKCEoZSBpbnN0YW5jZW9mIFNpZ25hbFJlY29ubmVjdEVycm9yKSkge1xuICAgICAgICAvLyBjYW5ub3QgcmVzdW1lXG4gICAgICAgIHRoaXMuZnVsbFJlY29ubmVjdE9uTmV4dCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvdmVyYWJsZSkge1xuICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QoJ3JlY29ubmVjdCcsIFJlY29ubmVjdFJlYXNvbi5SUl9VTktOT1dOKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubG9nLmluZm8oXG4gICAgICAgICAgYGNvdWxkIG5vdCByZWNvdmVyIGNvbm5lY3Rpb24gYWZ0ZXIgJHt0aGlzLnJlY29ubmVjdEF0dGVtcHRzfSBhdHRlbXB0cywgJHtcbiAgICAgICAgICAgIERhdGUubm93KCkgLSB0aGlzLnJlY29ubmVjdFN0YXJ0XG4gICAgICAgICAgfW1zLiBnaXZpbmcgdXBgLFxuICAgICAgICAgIHRoaXMubG9nQ29udGV4dCxcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LkRpc2Nvbm5lY3RlZCk7XG4gICAgICAgIGF3YWl0IHRoaXMuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5hdHRlbXB0aW5nUmVjb25uZWN0ID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZXROZXh0UmV0cnlEZWxheShjb250ZXh0OiBSZWNvbm5lY3RDb250ZXh0KSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0aGlzLnJlY29ubmVjdFBvbGljeS5uZXh0UmV0cnlEZWxheUluTXMoY29udGV4dCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5sb2cud2FybignZW5jb3VudGVyZWQgZXJyb3IgaW4gcmVjb25uZWN0IHBvbGljeScsIHsgLi4udGhpcy5sb2dDb250ZXh0LCBlcnJvcjogZSB9KTtcbiAgICB9XG5cbiAgICAvLyBlcnJvciBpbiB1c2VyIGNvZGUgd2l0aCBwcm92aWRlZCByZWNvbm5lY3QgcG9saWN5LCBzdG9wIHJlY29ubmVjdGluZ1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyByZXN0YXJ0Q29ubmVjdGlvbihyZWdpb25Vcmw/OiBzdHJpbmcpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKCF0aGlzLnVybCB8fCAhdGhpcy50b2tlbikge1xuICAgICAgICAvLyBwZXJtYW5lbnQgZmFpbHVyZSwgZG9uJ3QgYXR0ZW1wdCByZWNvbm5lY3Rpb25cbiAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ2NvdWxkIG5vdCByZWNvbm5lY3QsIHVybCBvciB0b2tlbiBub3Qgc2F2ZWQnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5sb2cuaW5mbyhgcmVjb25uZWN0aW5nLCBhdHRlbXB0OiAke3RoaXMucmVjb25uZWN0QXR0ZW1wdHN9YCwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5SZXN0YXJ0aW5nKTtcblxuICAgICAgaWYgKCF0aGlzLmNsaWVudC5pc0Rpc2Nvbm5lY3RlZCkge1xuICAgICAgICBhd2FpdCB0aGlzLmNsaWVudC5zZW5kTGVhdmUoKTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHRoaXMuY2xlYW51cFBlZXJDb25uZWN0aW9ucygpO1xuICAgICAgYXdhaXQgdGhpcy5jbGVhbnVwQ2xpZW50KCk7XG5cbiAgICAgIGxldCBqb2luUmVzcG9uc2U6IEpvaW5SZXNwb25zZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghdGhpcy5zaWduYWxPcHRzKSB7XG4gICAgICAgICAgdGhpcy5sb2cud2FybihcbiAgICAgICAgICAgICdhdHRlbXB0ZWQgY29ubmVjdGlvbiByZXN0YXJ0LCB3aXRob3V0IHNpZ25hbCBvcHRpb25zIHByZXNlbnQnLFxuICAgICAgICAgICAgdGhpcy5sb2dDb250ZXh0LFxuICAgICAgICAgICk7XG4gICAgICAgICAgdGhyb3cgbmV3IFNpZ25hbFJlY29ubmVjdEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW4gY2FzZSBhIHJlZ2lvblVybCBpcyBwYXNzZWQsIHRoZSByZWdpb24gVVJMIHRha2VzIHByZWNlZGVuY2VcbiAgICAgICAgam9pblJlc3BvbnNlID0gYXdhaXQgdGhpcy5qb2luKHJlZ2lvblVybCA/PyB0aGlzLnVybCwgdGhpcy50b2tlbiwgdGhpcy5zaWduYWxPcHRzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBDb25uZWN0aW9uRXJyb3IgJiYgZS5yZWFzb24gPT09IENvbm5lY3Rpb25FcnJvclJlYXNvbi5Ob3RBbGxvd2VkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ2NvdWxkIG5vdCByZWNvbm5lY3QsIHRva2VuIG1pZ2h0IGJlIGV4cGlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgU2lnbmFsUmVjb25uZWN0RXJyb3IoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc2hvdWxkRmFpbE5leHQpIHtcbiAgICAgICAgdGhpcy5zaG91bGRGYWlsTmV4dCA9IGZhbHNlO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpbXVsYXRlZCBmYWlsdXJlJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2xpZW50LnNldFJlY29ubmVjdGVkKCk7XG4gICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuU2lnbmFsUmVzdGFydGVkLCBqb2luUmVzcG9uc2UpO1xuXG4gICAgICBhd2FpdCB0aGlzLndhaXRGb3JQQ1JlY29ubmVjdGVkKCk7XG5cbiAgICAgIC8vIHJlLWNoZWNrIHNpZ25hbCBjb25uZWN0aW9uIHN0YXRlIGJlZm9yZSBzZXR0aW5nIGVuZ2luZSBhcyByZXN1bWVkXG4gICAgICBpZiAodGhpcy5jbGllbnQuY3VycmVudFN0YXRlICE9PSBTaWduYWxDb25uZWN0aW9uU3RhdGUuQ09OTkVDVEVEKSB7XG4gICAgICAgIHRocm93IG5ldyBTaWduYWxSZWNvbm5lY3RFcnJvcignU2lnbmFsIGNvbm5lY3Rpb24gZ290IHNldmVyZWQgZHVyaW5nIHJlY29ubmVjdCcpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnJlZ2lvblVybFByb3ZpZGVyPy5yZXNldEF0dGVtcHRzKCk7XG4gICAgICAvLyByZWNvbm5lY3Qgc3VjY2Vzc1xuICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlJlc3RhcnRlZCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnN0IG5leHRSZWdpb25VcmwgPSBhd2FpdCB0aGlzLnJlZ2lvblVybFByb3ZpZGVyPy5nZXROZXh0QmVzdFJlZ2lvblVybCgpO1xuICAgICAgaWYgKG5leHRSZWdpb25VcmwpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5yZXN0YXJ0Q29ubmVjdGlvbihuZXh0UmVnaW9uVXJsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbm8gbW9yZSByZWdpb25zIHRvIHRyeSAob3Igd2UncmUgbm90IG9uIGNsb3VkKVxuICAgICAgICB0aGlzLnJlZ2lvblVybFByb3ZpZGVyPy5yZXNldEF0dGVtcHRzKCk7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgcmVzdW1lQ29ubmVjdGlvbihyZWFzb24/OiBSZWNvbm5lY3RSZWFzb24pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIXRoaXMudXJsIHx8ICF0aGlzLnRva2VuKSB7XG4gICAgICAvLyBwZXJtYW5lbnQgZmFpbHVyZSwgZG9uJ3QgYXR0ZW1wdCByZWNvbm5lY3Rpb25cbiAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdjb3VsZCBub3QgcmVjb25uZWN0LCB1cmwgb3IgdG9rZW4gbm90IHNhdmVkJyk7XG4gICAgfVxuICAgIC8vIHRyaWdnZXIgcHVibGlzaGVyIHJlY29ubmVjdFxuICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcbiAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdwdWJsaXNoZXIgYW5kIHN1YnNjcmliZXIgY29ubmVjdGlvbnMgdW5zZXQnKTtcbiAgICB9XG5cbiAgICB0aGlzLmxvZy5pbmZvKGByZXN1bWluZyBzaWduYWwgY29ubmVjdGlvbiwgYXR0ZW1wdCAke3RoaXMucmVjb25uZWN0QXR0ZW1wdHN9YCwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuUmVzdW1pbmcpO1xuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuc2V0dXBTaWduYWxDbGllbnRDYWxsYmFja3MoKTtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuY2xpZW50LnJlY29ubmVjdCh0aGlzLnVybCwgdGhpcy50b2tlbiwgdGhpcy5wYXJ0aWNpcGFudFNpZCwgcmVhc29uKTtcbiAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgY29uc3QgcnRjQ29uZmlnID0gdGhpcy5tYWtlUlRDQ29uZmlndXJhdGlvbihyZXMpO1xuICAgICAgICB0aGlzLnBjTWFuYWdlci51cGRhdGVDb25maWd1cmF0aW9uKHJ0Y0NvbmZpZyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxldCBtZXNzYWdlID0gJyc7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBtZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcbiAgICAgICAgdGhpcy5sb2cuZXJyb3IoZXJyb3IubWVzc2FnZSwgeyAuLi50aGlzLmxvZ0NvbnRleHQsIGVycm9yIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQ29ubmVjdGlvbkVycm9yICYmIGVycm9yLnJlYXNvbiA9PT0gQ29ubmVjdGlvbkVycm9yUmVhc29uLk5vdEFsbG93ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ2NvdWxkIG5vdCByZWNvbm5lY3QsIHRva2VuIG1pZ2h0IGJlIGV4cGlyZWQnKTtcbiAgICAgIH1cbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIENvbm5lY3Rpb25FcnJvciAmJiBlcnJvci5yZWFzb24gPT09IENvbm5lY3Rpb25FcnJvclJlYXNvbi5MZWF2ZVJlcXVlc3QpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgU2lnbmFsUmVjb25uZWN0RXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5TaWduYWxSZXN1bWVkKTtcblxuICAgIGlmICh0aGlzLnNob3VsZEZhaWxOZXh0KSB7XG4gICAgICB0aGlzLnNob3VsZEZhaWxOZXh0ID0gZmFsc2U7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpbXVsYXRlZCBmYWlsdXJlJyk7XG4gICAgfVxuXG4gICAgYXdhaXQgdGhpcy5wY01hbmFnZXIudHJpZ2dlckljZVJlc3RhcnQoKTtcblxuICAgIGF3YWl0IHRoaXMud2FpdEZvclBDUmVjb25uZWN0ZWQoKTtcblxuICAgIC8vIHJlLWNoZWNrIHNpZ25hbCBjb25uZWN0aW9uIHN0YXRlIGJlZm9yZSBzZXR0aW5nIGVuZ2luZSBhcyByZXN1bWVkXG4gICAgaWYgKHRoaXMuY2xpZW50LmN1cnJlbnRTdGF0ZSAhPT0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkNPTk5FQ1RFRCkge1xuICAgICAgdGhyb3cgbmV3IFNpZ25hbFJlY29ubmVjdEVycm9yKCdTaWduYWwgY29ubmVjdGlvbiBnb3Qgc2V2ZXJlZCBkdXJpbmcgcmVjb25uZWN0Jyk7XG4gICAgfVxuXG4gICAgdGhpcy5jbGllbnQuc2V0UmVjb25uZWN0ZWQoKTtcblxuICAgIC8vIHJlY3JlYXRlIHB1Ymxpc2ggZGF0YWNoYW5uZWwgaWYgaXQncyBpZCBpcyBudWxsXG4gICAgLy8gKGZvciBzYWZhcmkgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE4NDY4OClcbiAgICBpZiAodGhpcy5yZWxpYWJsZURDPy5yZWFkeVN0YXRlID09PSAnb3BlbicgJiYgdGhpcy5yZWxpYWJsZURDLmlkID09PSBudWxsKSB7XG4gICAgICB0aGlzLmNyZWF0ZURhdGFDaGFubmVscygpO1xuICAgIH1cblxuICAgIC8vIHJlc3VtZSBzdWNjZXNzXG4gICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlJlc3VtZWQpO1xuICB9XG5cbiAgYXN5bmMgd2FpdEZvclBDSW5pdGlhbENvbm5lY3Rpb24odGltZW91dD86IG51bWJlciwgYWJvcnRDb250cm9sbGVyPzogQWJvcnRDb250cm9sbGVyKSB7XG4gICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xuICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ1BDIG1hbmFnZXIgaXMgY2xvc2VkJyk7XG4gICAgfVxuICAgIGF3YWl0IHRoaXMucGNNYW5hZ2VyLmVuc3VyZVBDVHJhbnNwb3J0Q29ubmVjdGlvbihhYm9ydENvbnRyb2xsZXIsIHRpbWVvdXQpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyB3YWl0Rm9yUENSZWNvbm5lY3RlZCgpIHtcbiAgICB0aGlzLnBjU3RhdGUgPSBQQ1N0YXRlLlJlY29ubmVjdGluZztcblxuICAgIHRoaXMubG9nLmRlYnVnKCd3YWl0aW5nIGZvciBwZWVyIGNvbm5lY3Rpb24gdG8gcmVjb25uZWN0JywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgc2xlZXAobWluUmVjb25uZWN0V2FpdCk7IC8vIEZJWE1FIHNldFRpbWVvdXQgYWdhaW4gbm90IGlkZWFsIGZvciBhIGNvbm5lY3Rpb24gY3JpdGljYWwgcGF0aFxuICAgICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xuICAgICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgnUEMgbWFuYWdlciBpcyBjbG9zZWQnKTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHRoaXMucGNNYW5hZ2VyLmVuc3VyZVBDVHJhbnNwb3J0Q29ubmVjdGlvbih1bmRlZmluZWQsIHRoaXMucGVlckNvbm5lY3Rpb25UaW1lb3V0KTtcbiAgICAgIHRoaXMucGNTdGF0ZSA9IFBDU3RhdGUuQ29ubmVjdGVkO1xuICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgLy8gVE9ETyBkbyB3ZSBuZWVkIGEgYGZhaWxlZGAgc3RhdGUgaGVyZSBmb3IgdGhlIFBDP1xuICAgICAgdGhpcy5wY1N0YXRlID0gUENTdGF0ZS5EaXNjb25uZWN0ZWQ7XG4gICAgICB0aHJvdyBuZXcgQ29ubmVjdGlvbkVycm9yKGBjb3VsZCBub3QgZXN0YWJsaXNoIFBDIGNvbm5lY3Rpb24sICR7ZS5tZXNzYWdlfWApO1xuICAgIH1cbiAgfVxuXG4gIHdhaXRGb3JSZXN0YXJ0ZWQgPSAoKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICh0aGlzLnBjU3RhdGUgPT09IFBDU3RhdGUuQ29ubmVjdGVkKSB7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9uUmVzdGFydGVkID0gKCkgPT4ge1xuICAgICAgICB0aGlzLm9mZihFbmdpbmVFdmVudC5EaXNjb25uZWN0ZWQsIG9uRGlzY29ubmVjdGVkKTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IG9uRGlzY29ubmVjdGVkID0gKCkgPT4ge1xuICAgICAgICB0aGlzLm9mZihFbmdpbmVFdmVudC5SZXN0YXJ0ZWQsIG9uUmVzdGFydGVkKTtcbiAgICAgICAgcmVqZWN0KCk7XG4gICAgICB9O1xuICAgICAgdGhpcy5vbmNlKEVuZ2luZUV2ZW50LlJlc3RhcnRlZCwgb25SZXN0YXJ0ZWQpO1xuICAgICAgdGhpcy5vbmNlKEVuZ2luZUV2ZW50LkRpc2Nvbm5lY3RlZCwgb25EaXNjb25uZWN0ZWQpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qIEBpbnRlcm5hbCAqL1xuICBhc3luYyBzZW5kRGF0YVBhY2tldChwYWNrZXQ6IERhdGFQYWNrZXQsIGtpbmQ6IERhdGFQYWNrZXRfS2luZCkge1xuICAgIGNvbnN0IG1zZyA9IHBhY2tldC50b0JpbmFyeSgpO1xuXG4gICAgLy8gbWFrZSBzdXJlIHdlIGRvIGhhdmUgYSBkYXRhIGNvbm5lY3Rpb25cbiAgICBhd2FpdCB0aGlzLmVuc3VyZVB1Ymxpc2hlckNvbm5lY3RlZChraW5kKTtcblxuICAgIGNvbnN0IGRjID0gdGhpcy5kYXRhQ2hhbm5lbEZvcktpbmQoa2luZCk7XG4gICAgaWYgKGRjKSB7XG4gICAgICBkYy5zZW5kKG1zZyk7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVBbmRFbWl0RENCdWZmZXJTdGF0dXMoa2luZCk7XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZUFuZEVtaXREQ0J1ZmZlclN0YXR1cyA9IChraW5kOiBEYXRhUGFja2V0X0tpbmQpID0+IHtcbiAgICBjb25zdCBzdGF0dXMgPSB0aGlzLmlzQnVmZmVyU3RhdHVzTG93KGtpbmQpO1xuICAgIGlmICh0eXBlb2Ygc3RhdHVzICE9PSAndW5kZWZpbmVkJyAmJiBzdGF0dXMgIT09IHRoaXMuZGNCdWZmZXJTdGF0dXMuZ2V0KGtpbmQpKSB7XG4gICAgICB0aGlzLmRjQnVmZmVyU3RhdHVzLnNldChraW5kLCBzdGF0dXMpO1xuICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LkRDQnVmZmVyU3RhdHVzQ2hhbmdlZCwgc3RhdHVzLCBraW5kKTtcbiAgICB9XG4gIH07XG5cbiAgcHJpdmF0ZSBpc0J1ZmZlclN0YXR1c0xvdyA9IChraW5kOiBEYXRhUGFja2V0X0tpbmQpOiBib29sZWFuIHwgdW5kZWZpbmVkID0+IHtcbiAgICBjb25zdCBkYyA9IHRoaXMuZGF0YUNoYW5uZWxGb3JLaW5kKGtpbmQpO1xuICAgIGlmIChkYykge1xuICAgICAgcmV0dXJuIGRjLmJ1ZmZlcmVkQW1vdW50IDw9IGRjLmJ1ZmZlcmVkQW1vdW50TG93VGhyZXNob2xkO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBhc3luYyBlbnN1cmVEYXRhVHJhbnNwb3J0Q29ubmVjdGVkKFxuICAgIGtpbmQ6IERhdGFQYWNrZXRfS2luZCxcbiAgICBzdWJzY3JpYmVyOiBib29sZWFuID0gdGhpcy5zdWJzY3JpYmVyUHJpbWFyeSxcbiAgKSB7XG4gICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xuICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ1BDIG1hbmFnZXIgaXMgY2xvc2VkJyk7XG4gICAgfVxuICAgIGNvbnN0IHRyYW5zcG9ydCA9IHN1YnNjcmliZXIgPyB0aGlzLnBjTWFuYWdlci5zdWJzY3JpYmVyIDogdGhpcy5wY01hbmFnZXIucHVibGlzaGVyO1xuICAgIGNvbnN0IHRyYW5zcG9ydE5hbWUgPSBzdWJzY3JpYmVyID8gJ1N1YnNjcmliZXInIDogJ1B1Ymxpc2hlcic7XG4gICAgaWYgKCF0cmFuc3BvcnQpIHtcbiAgICAgIHRocm93IG5ldyBDb25uZWN0aW9uRXJyb3IoYCR7dHJhbnNwb3J0TmFtZX0gY29ubmVjdGlvbiBub3Qgc2V0YCk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgIXN1YnNjcmliZXIgJiZcbiAgICAgICF0aGlzLnBjTWFuYWdlci5wdWJsaXNoZXIuaXNJQ0VDb25uZWN0ZWQgJiZcbiAgICAgIHRoaXMucGNNYW5hZ2VyLnB1Ymxpc2hlci5nZXRJQ0VDb25uZWN0aW9uU3RhdGUoKSAhPT0gJ2NoZWNraW5nJ1xuICAgICkge1xuICAgICAgLy8gc3RhcnQgbmVnb3RpYXRpb25cbiAgICAgIHRoaXMubmVnb3RpYXRlKCk7XG4gICAgfVxuXG4gICAgY29uc3QgdGFyZ2V0Q2hhbm5lbCA9IHRoaXMuZGF0YUNoYW5uZWxGb3JLaW5kKGtpbmQsIHN1YnNjcmliZXIpO1xuICAgIGlmICh0YXJnZXRDaGFubmVsPy5yZWFkeVN0YXRlID09PSAnb3BlbicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyB3YWl0IHVudGlsIElDRSBjb25uZWN0ZWRcbiAgICBjb25zdCBlbmRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgKyB0aGlzLnBlZXJDb25uZWN0aW9uVGltZW91dDtcbiAgICB3aGlsZSAobmV3IERhdGUoKS5nZXRUaW1lKCkgPCBlbmRUaW1lKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHRyYW5zcG9ydC5pc0lDRUNvbm5lY3RlZCAmJlxuICAgICAgICB0aGlzLmRhdGFDaGFubmVsRm9yS2luZChraW5kLCBzdWJzY3JpYmVyKT8ucmVhZHlTdGF0ZSA9PT0gJ29wZW4nXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYXdhaXQgc2xlZXAoNTApO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBDb25uZWN0aW9uRXJyb3IoXG4gICAgICBgY291bGQgbm90IGVzdGFibGlzaCAke3RyYW5zcG9ydE5hbWV9IGNvbm5lY3Rpb24sIHN0YXRlOiAke3RyYW5zcG9ydC5nZXRJQ0VDb25uZWN0aW9uU3RhdGUoKX1gLFxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGVuc3VyZVB1Ymxpc2hlckNvbm5lY3RlZChraW5kOiBEYXRhUGFja2V0X0tpbmQpIHtcbiAgICBhd2FpdCB0aGlzLmVuc3VyZURhdGFUcmFuc3BvcnRDb25uZWN0ZWQoa2luZCwgZmFsc2UpO1xuICB9XG5cbiAgLyogQGludGVybmFsICovXG4gIHZlcmlmeVRyYW5zcG9ydCgpOiBib29sZWFuIHtcbiAgICBpZiAoIXRoaXMucGNNYW5hZ2VyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIHByaW1hcnkgY29ubmVjdGlvblxuICAgIGlmICh0aGlzLnBjTWFuYWdlci5jdXJyZW50U3RhdGUgIT09IFBDVHJhbnNwb3J0U3RhdGUuQ09OTkVDVEVEKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gZW5zdXJlIHNpZ25hbCBpcyBjb25uZWN0ZWRcbiAgICBpZiAoIXRoaXMuY2xpZW50LndzIHx8IHRoaXMuY2xpZW50LndzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DTE9TRUQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIGFzeW5jIG5lZ290aWF0ZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyBvYnNlcnZlIHNpZ25hbCBzdGF0ZVxuICAgIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPihhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAoIXRoaXMucGNNYW5hZ2VyKSB7XG4gICAgICAgIHJlamVjdChuZXcgTmVnb3RpYXRpb25FcnJvcignUEMgbWFuYWdlciBpcyBjbG9zZWQnKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wY01hbmFnZXIucmVxdWlyZVB1Ymxpc2hlcigpO1xuXG4gICAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG5cbiAgICAgIGNvbnN0IGhhbmRsZUNsb3NlZCA9ICgpID0+IHtcbiAgICAgICAgYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKCdlbmdpbmUgZGlzY29ubmVjdGVkIHdoaWxlIG5lZ290aWF0aW9uIHdhcyBvbmdvaW5nJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xuICAgICAgICByZWplY3QoJ2Nhbm5vdCBuZWdvdGlhdGUgb24gY2xvc2VkIGVuZ2luZScpO1xuICAgICAgfVxuICAgICAgdGhpcy5vbihFbmdpbmVFdmVudC5DbG9zaW5nLCBoYW5kbGVDbG9zZWQpO1xuXG4gICAgICB0aGlzLnBjTWFuYWdlci5wdWJsaXNoZXIub25jZShcbiAgICAgICAgUENFdmVudHMuUlRQVmlkZW9QYXlsb2FkVHlwZXMsXG4gICAgICAgIChydHBUeXBlczogTWVkaWFBdHRyaWJ1dGVzWydydHAnXSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJ0cE1hcCA9IG5ldyBNYXA8bnVtYmVyLCBWaWRlb0NvZGVjPigpO1xuICAgICAgICAgIHJ0cFR5cGVzLmZvckVhY2goKHJ0cCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29kZWMgPSBydHAuY29kZWMudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChpc1ZpZGVvQ29kZWMoY29kZWMpKSB7XG4gICAgICAgICAgICAgIHJ0cE1hcC5zZXQocnRwLnBheWxvYWQsIGNvZGVjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuUlRQVmlkZW9NYXBVcGRhdGUsIHJ0cE1hcCk7XG4gICAgICAgIH0sXG4gICAgICApO1xuXG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLnBjTWFuYWdlci5uZWdvdGlhdGUoYWJvcnRDb250cm9sbGVyKTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgTmVnb3RpYXRpb25FcnJvcikge1xuICAgICAgICAgIHRoaXMuZnVsbFJlY29ubmVjdE9uTmV4dCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KCduZWdvdGlhdGlvbicsIFJlY29ubmVjdFJlYXNvbi5SUl9VTktOT1dOKTtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5vZmYoRW5naW5lRXZlbnQuQ2xvc2luZywgaGFuZGxlQ2xvc2VkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGRhdGFDaGFubmVsRm9yS2luZChraW5kOiBEYXRhUGFja2V0X0tpbmQsIHN1Yj86IGJvb2xlYW4pOiBSVENEYXRhQ2hhbm5lbCB8IHVuZGVmaW5lZCB7XG4gICAgaWYgKCFzdWIpIHtcbiAgICAgIGlmIChraW5kID09PSBEYXRhUGFja2V0X0tpbmQuTE9TU1kpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9zc3lEQztcbiAgICAgIH1cbiAgICAgIGlmIChraW5kID09PSBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVsaWFibGVEQztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGtpbmQgPT09IERhdGFQYWNrZXRfS2luZC5MT1NTWSkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb3NzeURDU3ViO1xuICAgICAgfVxuICAgICAgaWYgKGtpbmQgPT09IERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWxpYWJsZURDU3ViO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc2VuZFN5bmNTdGF0ZShyZW1vdGVUcmFja3M6IFJlbW90ZVRyYWNrUHVibGljYXRpb25bXSwgbG9jYWxUcmFja3M6IExvY2FsVHJhY2tQdWJsaWNhdGlvbltdKSB7XG4gICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xuICAgICAgdGhpcy5sb2cud2Fybignc3luYyBzdGF0ZSBjYW5ub3QgYmUgc2VudCB3aXRob3V0IHBlZXIgY29ubmVjdGlvbiBzZXR1cCcsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHByZXZpb3VzQW5zd2VyID0gdGhpcy5wY01hbmFnZXIuc3Vic2NyaWJlci5nZXRMb2NhbERlc2NyaXB0aW9uKCk7XG4gICAgY29uc3QgcHJldmlvdXNPZmZlciA9IHRoaXMucGNNYW5hZ2VyLnN1YnNjcmliZXIuZ2V0UmVtb3RlRGVzY3JpcHRpb24oKTtcblxuICAgIC8qIDEuIGF1dG9zdWJzY3JpYmUgb24sIHNvIHN1YnNjcmliZWQgdHJhY2tzID0gYWxsIHRyYWNrcyAtIHVuc3ViIHRyYWNrcyxcbiAgICAgICAgICBpbiB0aGlzIGNhc2UsIHdlIHNlbmQgdW5zdWIgdHJhY2tzLCBzbyBzZXJ2ZXIgYWRkIGFsbCB0cmFja3MgdG8gdGhpc1xuICAgICAgICAgIHN1YnNjcmliZSBwYyBhbmQgdW5zdWIgc3BlY2lhbCB0cmFja3MgZnJvbSBpdC5cbiAgICAgICAyLiBhdXRvc3Vic2NyaWJlIG9mZiwgd2Ugc2VuZCBzdWJzY3JpYmVkIHRyYWNrcy5cbiAgICAqL1xuICAgIGNvbnN0IGF1dG9TdWJzY3JpYmUgPSB0aGlzLnNpZ25hbE9wdHM/LmF1dG9TdWJzY3JpYmUgPz8gdHJ1ZTtcbiAgICBjb25zdCB0cmFja1NpZHMgPSBuZXcgQXJyYXk8c3RyaW5nPigpO1xuXG4gICAgcmVtb3RlVHJhY2tzLmZvckVhY2goKHRyYWNrKSA9PiB7XG4gICAgICBpZiAodHJhY2suaXNEZXNpcmVkICE9PSBhdXRvU3Vic2NyaWJlKSB7XG4gICAgICAgIHRyYWNrU2lkcy5wdXNoKHRyYWNrLnRyYWNrU2lkKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuY2xpZW50LnNlbmRTeW5jU3RhdGUoXG4gICAgICBuZXcgU3luY1N0YXRlKHtcbiAgICAgICAgYW5zd2VyOiBwcmV2aW91c0Fuc3dlclxuICAgICAgICAgID8gdG9Qcm90b1Nlc3Npb25EZXNjcmlwdGlvbih7XG4gICAgICAgICAgICAgIHNkcDogcHJldmlvdXNBbnN3ZXIuc2RwLFxuICAgICAgICAgICAgICB0eXBlOiBwcmV2aW91c0Fuc3dlci50eXBlLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgb2ZmZXI6IHByZXZpb3VzT2ZmZXJcbiAgICAgICAgICA/IHRvUHJvdG9TZXNzaW9uRGVzY3JpcHRpb24oe1xuICAgICAgICAgICAgICBzZHA6IHByZXZpb3VzT2ZmZXIuc2RwLFxuICAgICAgICAgICAgICB0eXBlOiBwcmV2aW91c09mZmVyLnR5cGUsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICBzdWJzY3JpcHRpb246IG5ldyBVcGRhdGVTdWJzY3JpcHRpb24oe1xuICAgICAgICAgIHRyYWNrU2lkcyxcbiAgICAgICAgICBzdWJzY3JpYmU6ICFhdXRvU3Vic2NyaWJlLFxuICAgICAgICAgIHBhcnRpY2lwYW50VHJhY2tzOiBbXSxcbiAgICAgICAgfSksXG4gICAgICAgIHB1Ymxpc2hUcmFja3M6IGdldFRyYWNrUHVibGljYXRpb25JbmZvKGxvY2FsVHJhY2tzKSxcbiAgICAgICAgZGF0YUNoYW5uZWxzOiB0aGlzLmRhdGFDaGFubmVsc0luZm8oKSxcbiAgICAgIH0pLFxuICAgICk7XG4gIH1cblxuICAvKiBAaW50ZXJuYWwgKi9cbiAgZmFpbE5leHQoKSB7XG4gICAgLy8gZGVidWdnaW5nIG1ldGhvZCB0byBmYWlsIHRoZSBuZXh0IHJlY29ubmVjdC9yZXN1bWUgYXR0ZW1wdFxuICAgIHRoaXMuc2hvdWxkRmFpbE5leHQgPSB0cnVlO1xuICB9XG5cbiAgcHJpdmF0ZSBkYXRhQ2hhbm5lbHNJbmZvKCk6IERhdGFDaGFubmVsSW5mb1tdIHtcbiAgICBjb25zdCBpbmZvczogRGF0YUNoYW5uZWxJbmZvW10gPSBbXTtcbiAgICBjb25zdCBnZXRJbmZvID0gKGRjOiBSVENEYXRhQ2hhbm5lbCB8IHVuZGVmaW5lZCwgdGFyZ2V0OiBTaWduYWxUYXJnZXQpID0+IHtcbiAgICAgIGlmIChkYz8uaWQgIT09IHVuZGVmaW5lZCAmJiBkYy5pZCAhPT0gbnVsbCkge1xuICAgICAgICBpbmZvcy5wdXNoKFxuICAgICAgICAgIG5ldyBEYXRhQ2hhbm5lbEluZm8oe1xuICAgICAgICAgICAgbGFiZWw6IGRjLmxhYmVsLFxuICAgICAgICAgICAgaWQ6IGRjLmlkLFxuICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgIH0pLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH07XG4gICAgZ2V0SW5mbyh0aGlzLmRhdGFDaGFubmVsRm9yS2luZChEYXRhUGFja2V0X0tpbmQuTE9TU1kpLCBTaWduYWxUYXJnZXQuUFVCTElTSEVSKTtcbiAgICBnZXRJbmZvKHRoaXMuZGF0YUNoYW5uZWxGb3JLaW5kKERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSksIFNpZ25hbFRhcmdldC5QVUJMSVNIRVIpO1xuICAgIGdldEluZm8odGhpcy5kYXRhQ2hhbm5lbEZvcktpbmQoRGF0YVBhY2tldF9LaW5kLkxPU1NZLCB0cnVlKSwgU2lnbmFsVGFyZ2V0LlNVQlNDUklCRVIpO1xuICAgIGdldEluZm8odGhpcy5kYXRhQ2hhbm5lbEZvcktpbmQoRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFLCB0cnVlKSwgU2lnbmFsVGFyZ2V0LlNVQlNDUklCRVIpO1xuICAgIHJldHVybiBpbmZvcztcbiAgfVxuXG4gIHByaXZhdGUgY2xlYXJSZWNvbm5lY3RUaW1lb3V0KCkge1xuICAgIGlmICh0aGlzLnJlY29ubmVjdFRpbWVvdXQpIHtcbiAgICAgIENyaXRpY2FsVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnJlY29ubmVjdFRpbWVvdXQpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY2xlYXJQZW5kaW5nUmVjb25uZWN0KCkge1xuICAgIHRoaXMuY2xlYXJSZWNvbm5lY3RUaW1lb3V0KCk7XG4gICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cyA9IDA7XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZUJyb3dzZXJPbkxpbmUgPSAoKSA9PiB7XG4gICAgLy8gaW4gY2FzZSB0aGUgZW5naW5lIGlzIGN1cnJlbnRseSByZWNvbm5lY3RpbmcsIGF0dGVtcHQgYSByZWNvbm5lY3QgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGJyb3dzZXIgc3RhdGUgaGFzIGNoYW5nZWQgdG8gJ29uTGluZSdcbiAgICBpZiAodGhpcy5jbGllbnQuY3VycmVudFN0YXRlID09PSBTaWduYWxDb25uZWN0aW9uU3RhdGUuUkVDT05ORUNUSU5HKSB7XG4gICAgICB0aGlzLmNsZWFyUmVjb25uZWN0VGltZW91dCgpO1xuICAgICAgdGhpcy5hdHRlbXB0UmVjb25uZWN0KFJlY29ubmVjdFJlYXNvbi5SUl9TSUdOQUxfRElTQ09OTkVDVEVEKTtcbiAgICB9XG4gIH07XG5cbiAgcHJpdmF0ZSByZWdpc3Rlck9uTGluZUxpc3RlbmVyKCkge1xuICAgIGlmIChpc1dlYigpKSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb25saW5lJywgdGhpcy5oYW5kbGVCcm93c2VyT25MaW5lKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGRlcmVnaXN0ZXJPbkxpbmVMaXN0ZW5lcigpIHtcbiAgICBpZiAoaXNXZWIoKSkge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ29ubGluZScsIHRoaXMuaGFuZGxlQnJvd3Nlck9uTGluZSk7XG4gICAgfVxuICB9XG59XG5cbmNsYXNzIFNpZ25hbFJlY29ubmVjdEVycm9yIGV4dGVuZHMgRXJyb3Ige31cblxuZXhwb3J0IHR5cGUgRW5naW5lRXZlbnRDYWxsYmFja3MgPSB7XG4gIGNvbm5lY3RlZDogKGpvaW5SZXNwOiBKb2luUmVzcG9uc2UpID0+IHZvaWQ7XG4gIGRpc2Nvbm5lY3RlZDogKHJlYXNvbj86IERpc2Nvbm5lY3RSZWFzb24pID0+IHZvaWQ7XG4gIHJlc3VtaW5nOiAoKSA9PiB2b2lkO1xuICByZXN1bWVkOiAoKSA9PiB2b2lkO1xuICByZXN0YXJ0aW5nOiAoKSA9PiB2b2lkO1xuICByZXN0YXJ0ZWQ6ICgpID0+IHZvaWQ7XG4gIHNpZ25hbFJlc3VtZWQ6ICgpID0+IHZvaWQ7XG4gIHNpZ25hbFJlc3RhcnRlZDogKGpvaW5SZXNwOiBKb2luUmVzcG9uc2UpID0+IHZvaWQ7XG4gIGNsb3Npbmc6ICgpID0+IHZvaWQ7XG4gIG1lZGlhVHJhY2tBZGRlZDogKFxuICAgIHRyYWNrOiBNZWRpYVN0cmVhbVRyYWNrLFxuICAgIHN0cmVhbXM6IE1lZGlhU3RyZWFtLFxuICAgIHJlY2VpdmVyPzogUlRDUnRwUmVjZWl2ZXIsXG4gICkgPT4gdm9pZDtcbiAgYWN0aXZlU3BlYWtlcnNVcGRhdGU6IChzcGVha2VyczogQXJyYXk8U3BlYWtlckluZm8+KSA9PiB2b2lkO1xuICBkYXRhUGFja2V0UmVjZWl2ZWQ6ICh1c2VyUGFja2V0OiBVc2VyUGFja2V0LCBraW5kOiBEYXRhUGFja2V0X0tpbmQpID0+IHZvaWQ7XG4gIHRyYW5zcG9ydHNDcmVhdGVkOiAocHVibGlzaGVyOiBQQ1RyYW5zcG9ydCwgc3Vic2NyaWJlcjogUENUcmFuc3BvcnQpID0+IHZvaWQ7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgdHJhY2tTZW5kZXJBZGRlZDogKHRyYWNrOiBUcmFjaywgc2VuZGVyOiBSVENSdHBTZW5kZXIpID0+IHZvaWQ7XG4gIHJ0cFZpZGVvTWFwVXBkYXRlOiAocnRwTWFwOiBNYXA8bnVtYmVyLCBWaWRlb0NvZGVjPikgPT4gdm9pZDtcbiAgZGNCdWZmZXJTdGF0dXNDaGFuZ2VkOiAoaXNMb3c6IGJvb2xlYW4sIGtpbmQ6IERhdGFQYWNrZXRfS2luZCkgPT4gdm9pZDtcbiAgcGFydGljaXBhbnRVcGRhdGU6IChpbmZvczogUGFydGljaXBhbnRJbmZvW10pID0+IHZvaWQ7XG4gIHJvb21VcGRhdGU6IChyb29tOiBSb29tTW9kZWwpID0+IHZvaWQ7XG4gIGNvbm5lY3Rpb25RdWFsaXR5VXBkYXRlOiAodXBkYXRlOiBDb25uZWN0aW9uUXVhbGl0eVVwZGF0ZSkgPT4gdm9pZDtcbiAgc3BlYWtlcnNDaGFuZ2VkOiAoc3BlYWtlclVwZGF0ZXM6IFNwZWFrZXJJbmZvW10pID0+IHZvaWQ7XG4gIHN0cmVhbVN0YXRlQ2hhbmdlZDogKHVwZGF0ZTogU3RyZWFtU3RhdGVVcGRhdGUpID0+IHZvaWQ7XG4gIHN1YnNjcmlwdGlvbkVycm9yOiAocmVzcDogU3Vic2NyaXB0aW9uUmVzcG9uc2UpID0+IHZvaWQ7XG4gIHN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGU6ICh1cGRhdGU6IFN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUpID0+IHZvaWQ7XG4gIHN1YnNjcmliZWRRdWFsaXR5VXBkYXRlOiAodXBkYXRlOiBTdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSkgPT4gdm9pZDtcbiAgbG9jYWxUcmFja1VucHVibGlzaGVkOiAodW5wdWJsaXNoZWRSZXNwb25zZTogVHJhY2tVbnB1Ymxpc2hlZFJlc3BvbnNlKSA9PiB2b2lkO1xuICByZW1vdGVNdXRlOiAodHJhY2tTaWQ6IHN0cmluZywgbXV0ZWQ6IGJvb2xlYW4pID0+IHZvaWQ7XG59O1xuIiwiaW1wb3J0IGxvZyBmcm9tICcuLi9sb2dnZXInO1xuaW1wb3J0IHR5cGUgeyBSZWdpb25JbmZvLCBSZWdpb25TZXR0aW5ncyB9IGZyb20gJy4uL3Byb3RvL2xpdmVraXRfcnRjX3BiJztcbmltcG9ydCB7IENvbm5lY3Rpb25FcnJvciwgQ29ubmVjdGlvbkVycm9yUmVhc29uIH0gZnJvbSAnLi9lcnJvcnMnO1xuaW1wb3J0IHsgaXNDbG91ZCB9IGZyb20gJy4vdXRpbHMnO1xuXG5leHBvcnQgY2xhc3MgUmVnaW9uVXJsUHJvdmlkZXIge1xuICBwcml2YXRlIHNlcnZlclVybDogVVJMO1xuXG4gIHByaXZhdGUgdG9rZW46IHN0cmluZztcblxuICBwcml2YXRlIHJlZ2lvblNldHRpbmdzOiBSZWdpb25TZXR0aW5ncyB8IHVuZGVmaW5lZDtcblxuICBwcml2YXRlIGxhc3RVcGRhdGVBdDogbnVtYmVyID0gMDtcblxuICBwcml2YXRlIHNldHRpbmdzQ2FjaGVUaW1lID0gM18wMDA7XG5cbiAgcHJpdmF0ZSBhdHRlbXB0ZWRSZWdpb25zOiBSZWdpb25JbmZvW10gPSBbXTtcblxuICBjb25zdHJ1Y3Rvcih1cmw6IHN0cmluZywgdG9rZW46IHN0cmluZykge1xuICAgIHRoaXMuc2VydmVyVXJsID0gbmV3IFVSTCh1cmwpO1xuICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgfVxuXG4gIHVwZGF0ZVRva2VuKHRva2VuOiBzdHJpbmcpIHtcbiAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gIH1cblxuICBpc0Nsb3VkKCkge1xuICAgIHJldHVybiBpc0Nsb3VkKHRoaXMuc2VydmVyVXJsKTtcbiAgfVxuXG4gIGdldFNlcnZlclVybCgpIHtcbiAgICByZXR1cm4gdGhpcy5zZXJ2ZXJVcmw7XG4gIH1cblxuICBhc3luYyBnZXROZXh0QmVzdFJlZ2lvblVybChhYm9ydFNpZ25hbD86IEFib3J0U2lnbmFsKSB7XG4gICAgaWYgKCF0aGlzLmlzQ2xvdWQoKSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ3JlZ2lvbiBhdmFpbGFiaWxpdHkgaXMgb25seSBzdXBwb3J0ZWQgZm9yIExpdmVLaXQgQ2xvdWQgZG9tYWlucycpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMucmVnaW9uU2V0dGluZ3MgfHwgRGF0ZS5ub3coKSAtIHRoaXMubGFzdFVwZGF0ZUF0ID4gdGhpcy5zZXR0aW5nc0NhY2hlVGltZSkge1xuICAgICAgdGhpcy5yZWdpb25TZXR0aW5ncyA9IGF3YWl0IHRoaXMuZmV0Y2hSZWdpb25TZXR0aW5ncyhhYm9ydFNpZ25hbCk7XG4gICAgfVxuICAgIGNvbnN0IHJlZ2lvbnNMZWZ0ID0gdGhpcy5yZWdpb25TZXR0aW5ncy5yZWdpb25zLmZpbHRlcihcbiAgICAgIChyZWdpb24pID0+ICF0aGlzLmF0dGVtcHRlZFJlZ2lvbnMuZmluZCgoYXR0ZW1wdGVkKSA9PiBhdHRlbXB0ZWQudXJsID09PSByZWdpb24udXJsKSxcbiAgICApO1xuICAgIGlmIChyZWdpb25zTGVmdC5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBuZXh0UmVnaW9uID0gcmVnaW9uc0xlZnRbMF07XG4gICAgICB0aGlzLmF0dGVtcHRlZFJlZ2lvbnMucHVzaChuZXh0UmVnaW9uKTtcbiAgICAgIGxvZy5kZWJ1ZyhgbmV4dCByZWdpb246ICR7bmV4dFJlZ2lvbi5yZWdpb259YCk7XG4gICAgICByZXR1cm4gbmV4dFJlZ2lvbi51cmw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHJlc2V0QXR0ZW1wdHMoKSB7XG4gICAgdGhpcy5hdHRlbXB0ZWRSZWdpb25zID0gW107XG4gIH1cblxuICAvKiBAaW50ZXJuYWwgKi9cbiAgYXN5bmMgZmV0Y2hSZWdpb25TZXR0aW5ncyhzaWduYWw/OiBBYm9ydFNpZ25hbCkge1xuICAgIGNvbnN0IHJlZ2lvblNldHRpbmdzUmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtnZXRDbG91ZENvbmZpZ1VybCh0aGlzLnNlcnZlclVybCl9L3JlZ2lvbnNgLCB7XG4gICAgICBoZWFkZXJzOiB7IGF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0aGlzLnRva2VufWAgfSxcbiAgICAgIHNpZ25hbCxcbiAgICB9KTtcbiAgICBpZiAocmVnaW9uU2V0dGluZ3NSZXNwb25zZS5vaykge1xuICAgICAgY29uc3QgcmVnaW9uU2V0dGluZ3MgPSAoYXdhaXQgcmVnaW9uU2V0dGluZ3NSZXNwb25zZS5qc29uKCkpIGFzIFJlZ2lvblNldHRpbmdzO1xuICAgICAgdGhpcy5sYXN0VXBkYXRlQXQgPSBEYXRlLm5vdygpO1xuICAgICAgcmV0dXJuIHJlZ2lvblNldHRpbmdzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgQ29ubmVjdGlvbkVycm9yKFxuICAgICAgICBgQ291bGQgbm90IGZldGNoIHJlZ2lvbiBzZXR0aW5nczogJHtyZWdpb25TZXR0aW5nc1Jlc3BvbnNlLnN0YXR1c1RleHR9YCxcbiAgICAgICAgcmVnaW9uU2V0dGluZ3NSZXNwb25zZS5zdGF0dXMgPT09IDQwMSA/IENvbm5lY3Rpb25FcnJvclJlYXNvbi5Ob3RBbGxvd2VkIDogdW5kZWZpbmVkLFxuICAgICAgICByZWdpb25TZXR0aW5nc1Jlc3BvbnNlLnN0YXR1cyxcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldENsb3VkQ29uZmlnVXJsKHNlcnZlclVybDogVVJMKSB7XG4gIHJldHVybiBgJHtzZXJ2ZXJVcmwucHJvdG9jb2wucmVwbGFjZSgnd3MnLCAnaHR0cCcpfS8vJHtzZXJ2ZXJVcmwuaG9zdH0vc2V0dGluZ3NgO1xufVxuIiwiZXhwb3J0IGNvbnN0IG1vbml0b3JGcmVxdWVuY3kgPSAyMDAwO1xuXG4vLyBrZXkgc3RhdHMgZm9yIHNlbmRlcnMgYW5kIHJlY2VpdmVyc1xuaW50ZXJmYWNlIFNlbmRlclN0YXRzIHtcbiAgLyoqIG51bWJlciBvZiBwYWNrZXRzIHNlbnQgKi9cbiAgcGFja2V0c1NlbnQ/OiBudW1iZXI7XG5cbiAgLyoqIG51bWJlciBvZiBieXRlcyBzZW50ICovXG4gIGJ5dGVzU2VudD86IG51bWJlcjtcblxuICAvKiogaml0dGVyIGFzIHBlcmNlaXZlZCBieSByZW1vdGUgKi9cbiAgaml0dGVyPzogbnVtYmVyO1xuXG4gIC8qKiBwYWNrZXRzIHJlcG9ydGVkIGxvc3QgYnkgcmVtb3RlICovXG4gIHBhY2tldHNMb3N0PzogbnVtYmVyO1xuXG4gIC8qKiBSVFQgcmVwb3J0ZWQgYnkgcmVtb3RlICovXG4gIHJvdW5kVHJpcFRpbWU/OiBudW1iZXI7XG5cbiAgLyoqIElEIG9mIHRoZSBvdXRib3VuZCBzdHJlYW0gKi9cbiAgc3RyZWFtSWQ/OiBzdHJpbmc7XG5cbiAgdGltZXN0YW1wOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXVkaW9TZW5kZXJTdGF0cyBleHRlbmRzIFNlbmRlclN0YXRzIHtcbiAgdHlwZTogJ2F1ZGlvJztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBWaWRlb1NlbmRlclN0YXRzIGV4dGVuZHMgU2VuZGVyU3RhdHMge1xuICB0eXBlOiAndmlkZW8nO1xuXG4gIGZpckNvdW50OiBudW1iZXI7XG5cbiAgcGxpQ291bnQ6IG51bWJlcjtcblxuICBuYWNrQ291bnQ6IG51bWJlcjtcblxuICByaWQ6IHN0cmluZztcblxuICBmcmFtZVdpZHRoOiBudW1iZXI7XG5cbiAgZnJhbWVIZWlnaHQ6IG51bWJlcjtcblxuICBmcmFtZXNTZW50OiBudW1iZXI7XG5cbiAgLy8gYmFuZHdpZHRoLCBjcHUsIG90aGVyLCBub25lXG4gIHF1YWxpdHlMaW1pdGF0aW9uUmVhc29uOiBzdHJpbmc7XG5cbiAgcXVhbGl0eUxpbWl0YXRpb25SZXNvbHV0aW9uQ2hhbmdlczogbnVtYmVyO1xuXG4gIHJldHJhbnNtaXR0ZWRQYWNrZXRzU2VudDogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgUmVjZWl2ZXJTdGF0cyB7XG4gIGppdHRlckJ1ZmZlckRlbGF5PzogbnVtYmVyO1xuXG4gIC8qKiBwYWNrZXRzIHJlcG9ydGVkIGxvc3QgYnkgcmVtb3RlICovXG4gIHBhY2tldHNMb3N0PzogbnVtYmVyO1xuXG4gIC8qKiBudW1iZXIgb2YgcGFja2V0cyBzZW50ICovXG4gIHBhY2tldHNSZWNlaXZlZD86IG51bWJlcjtcblxuICBieXRlc1JlY2VpdmVkPzogbnVtYmVyO1xuXG4gIHN0cmVhbUlkPzogc3RyaW5nO1xuXG4gIGppdHRlcj86IG51bWJlcjtcblxuICB0aW1lc3RhbXA6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBdWRpb1JlY2VpdmVyU3RhdHMgZXh0ZW5kcyBSZWNlaXZlclN0YXRzIHtcbiAgdHlwZTogJ2F1ZGlvJztcblxuICBjb25jZWFsZWRTYW1wbGVzPzogbnVtYmVyO1xuXG4gIGNvbmNlYWxtZW50RXZlbnRzPzogbnVtYmVyO1xuXG4gIHNpbGVudENvbmNlYWxlZFNhbXBsZXM/OiBudW1iZXI7XG5cbiAgc2lsZW50Q29uY2VhbG1lbnRFdmVudHM/OiBudW1iZXI7XG5cbiAgdG90YWxBdWRpb0VuZXJneT86IG51bWJlcjtcblxuICB0b3RhbFNhbXBsZXNEdXJhdGlvbj86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBWaWRlb1JlY2VpdmVyU3RhdHMgZXh0ZW5kcyBSZWNlaXZlclN0YXRzIHtcbiAgdHlwZTogJ3ZpZGVvJztcblxuICBmcmFtZXNEZWNvZGVkOiBudW1iZXI7XG5cbiAgZnJhbWVzRHJvcHBlZDogbnVtYmVyO1xuXG4gIGZyYW1lc1JlY2VpdmVkOiBudW1iZXI7XG5cbiAgZnJhbWVXaWR0aD86IG51bWJlcjtcblxuICBmcmFtZUhlaWdodD86IG51bWJlcjtcblxuICBmaXJDb3VudD86IG51bWJlcjtcblxuICBwbGlDb3VudD86IG51bWJlcjtcblxuICBuYWNrQ291bnQ/OiBudW1iZXI7XG5cbiAgZGVjb2RlckltcGxlbWVudGF0aW9uPzogc3RyaW5nO1xuXG4gIG1pbWVUeXBlPzogc3RyaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUJpdHJhdGU8VCBleHRlbmRzIFJlY2VpdmVyU3RhdHMgfCBTZW5kZXJTdGF0cz4oXG4gIGN1cnJlbnRTdGF0czogVCxcbiAgcHJldlN0YXRzPzogVCxcbik6IG51bWJlciB7XG4gIGlmICghcHJldlN0YXRzKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgbGV0IGJ5dGVzTm93OiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gIGxldCBieXRlc1ByZXY6IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgaWYgKCdieXRlc1JlY2VpdmVkJyBpbiBjdXJyZW50U3RhdHMpIHtcbiAgICBieXRlc05vdyA9IChjdXJyZW50U3RhdHMgYXMgUmVjZWl2ZXJTdGF0cykuYnl0ZXNSZWNlaXZlZDtcbiAgICBieXRlc1ByZXYgPSAocHJldlN0YXRzIGFzIFJlY2VpdmVyU3RhdHMpLmJ5dGVzUmVjZWl2ZWQ7XG4gIH0gZWxzZSBpZiAoJ2J5dGVzU2VudCcgaW4gY3VycmVudFN0YXRzKSB7XG4gICAgYnl0ZXNOb3cgPSAoY3VycmVudFN0YXRzIGFzIFNlbmRlclN0YXRzKS5ieXRlc1NlbnQ7XG4gICAgYnl0ZXNQcmV2ID0gKHByZXZTdGF0cyBhcyBTZW5kZXJTdGF0cykuYnl0ZXNTZW50O1xuICB9XG4gIGlmIChcbiAgICBieXRlc05vdyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgYnl0ZXNQcmV2ID09PSB1bmRlZmluZWQgfHxcbiAgICBjdXJyZW50U3RhdHMudGltZXN0YW1wID09PSB1bmRlZmluZWQgfHxcbiAgICBwcmV2U3RhdHMudGltZXN0YW1wID09PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuICgoYnl0ZXNOb3cgLSBieXRlc1ByZXYpICogOCAqIDEwMDApIC8gKGN1cnJlbnRTdGF0cy50aW1lc3RhbXAgLSBwcmV2U3RhdHMudGltZXN0YW1wKTtcbn1cbiIsImltcG9ydCB7IFRyYWNrRXZlbnQgfSBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IHsgY29tcHV0ZUJpdHJhdGUsIG1vbml0b3JGcmVxdWVuY3kgfSBmcm9tICcuLi9zdGF0cyc7XG5pbXBvcnQgdHlwZSB7IEF1ZGlvU2VuZGVyU3RhdHMgfSBmcm9tICcuLi9zdGF0cyc7XG5pbXBvcnQgdHlwZSB7IExvZ2dlck9wdGlvbnMgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBpc1dlYiwgdW53cmFwQ29uc3RyYWludCB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCBMb2NhbFRyYWNrIGZyb20gJy4vTG9jYWxUcmFjayc7XG5pbXBvcnQgeyBUcmFjayB9IGZyb20gJy4vVHJhY2snO1xuaW1wb3J0IHR5cGUgeyBBdWRpb0NhcHR1cmVPcHRpb25zIH0gZnJvbSAnLi9vcHRpb25zJztcbmltcG9ydCB0eXBlIHsgVHJhY2tQcm9jZXNzb3IgfSBmcm9tICcuL3Byb2Nlc3Nvci90eXBlcyc7XG5pbXBvcnQgeyBjb25zdHJhaW50c0Zvck9wdGlvbnMsIGRldGVjdFNpbGVuY2UgfSBmcm9tICcuL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTG9jYWxBdWRpb1RyYWNrIGV4dGVuZHMgTG9jYWxUcmFjayB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RvcE9uTXV0ZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIHByaXZhdGUgYXVkaW9Db250ZXh0PzogQXVkaW9Db250ZXh0O1xuXG4gIHByaXZhdGUgcHJldlN0YXRzPzogQXVkaW9TZW5kZXJTdGF0cztcblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIG1lZGlhVHJhY2tcbiAgICogQHBhcmFtIGNvbnN0cmFpbnRzIE1lZGlhVHJhY2tDb25zdHJhaW50cyB0aGF0IGFyZSBiZWluZyB1c2VkIHdoZW4gcmVzdGFydGluZyBvciByZWFjcXVpcmluZyB0cmFja3NcbiAgICogQHBhcmFtIHVzZXJQcm92aWRlZFRyYWNrIFNpZ25hbHMgdG8gdGhlIFNESyB3aGV0aGVyIG9yIG5vdCB0aGUgbWVkaWFUcmFjayBzaG91bGQgYmUgbWFuYWdlZCAoaS5lLiByZWxlYXNlZCBhbmQgcmVhY3F1aXJlZCkgaW50ZXJuYWxseSBieSB0aGUgU0RLXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBtZWRpYVRyYWNrOiBNZWRpYVN0cmVhbVRyYWNrLFxuICAgIGNvbnN0cmFpbnRzPzogTWVkaWFUcmFja0NvbnN0cmFpbnRzLFxuICAgIHVzZXJQcm92aWRlZFRyYWNrID0gdHJ1ZSxcbiAgICBhdWRpb0NvbnRleHQ/OiBBdWRpb0NvbnRleHQsXG4gICAgbG9nZ2VyT3B0aW9ucz86IExvZ2dlck9wdGlvbnMsXG4gICkge1xuICAgIHN1cGVyKG1lZGlhVHJhY2ssIFRyYWNrLktpbmQuQXVkaW8sIGNvbnN0cmFpbnRzLCB1c2VyUHJvdmlkZWRUcmFjaywgbG9nZ2VyT3B0aW9ucyk7XG4gICAgdGhpcy5hdWRpb0NvbnRleHQgPSBhdWRpb0NvbnRleHQ7XG4gICAgdGhpcy5jaGVja0ZvclNpbGVuY2UoKTtcbiAgfVxuXG4gIGFzeW5jIHNldERldmljZUlkKGRldmljZUlkOiBDb25zdHJhaW5ET01TdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBpZiAodGhpcy5fY29uc3RyYWludHMuZGV2aWNlSWQgPT09IGRldmljZUlkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5fY29uc3RyYWludHMuZGV2aWNlSWQgPSBkZXZpY2VJZDtcbiAgICBpZiAoIXRoaXMuaXNNdXRlZCkge1xuICAgICAgYXdhaXQgdGhpcy5yZXN0YXJ0VHJhY2soKTtcbiAgICB9XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMuaXNNdXRlZCB8fCB1bndyYXBDb25zdHJhaW50KGRldmljZUlkKSA9PT0gdGhpcy5tZWRpYVN0cmVhbVRyYWNrLmdldFNldHRpbmdzKCkuZGV2aWNlSWRcbiAgICApO1xuICB9XG5cbiAgYXN5bmMgbXV0ZSgpOiBQcm9taXNlPExvY2FsQXVkaW9UcmFjaz4ge1xuICAgIGNvbnN0IHVubG9jayA9IGF3YWl0IHRoaXMubXV0ZUxvY2subG9jaygpO1xuICAgIHRyeSB7XG4gICAgICAvLyBkaXNhYmxlZCBzcGVjaWFsIGhhbmRsaW5nIGFzIGl0IHdpbGwgY2F1c2UgQlQgaGVhZHNldHMgdG8gc3dpdGNoIGNvbW11bmljYXRpb24gbW9kZXNcbiAgICAgIGlmICh0aGlzLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLk1pY3JvcGhvbmUgJiYgdGhpcy5zdG9wT25NdXRlICYmICF0aGlzLmlzVXNlclByb3ZpZGVkKSB7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKCdzdG9wcGluZyBtaWMgdHJhY2snLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAvLyBhbHNvIHN0b3AgdGhlIHRyYWNrLCBzbyB0aGF0IG1pY3JvcGhvbmUgaW5kaWNhdG9yIGlzIHR1cm5lZCBvZmZcbiAgICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5zdG9wKCk7XG4gICAgICB9XG4gICAgICBhd2FpdCBzdXBlci5tdXRlKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdW5sb2NrKCk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgdW5tdXRlKCk6IFByb21pc2U8TG9jYWxBdWRpb1RyYWNrPiB7XG4gICAgY29uc3QgdW5sb2NrID0gYXdhaXQgdGhpcy5tdXRlTG9jay5sb2NrKCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRldmljZUhhc0NoYW5nZWQgPVxuICAgICAgICB0aGlzLl9jb25zdHJhaW50cy5kZXZpY2VJZCAmJlxuICAgICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLmdldFNldHRpbmdzKCkuZGV2aWNlSWQgIT09XG4gICAgICAgICAgdW53cmFwQ29uc3RyYWludCh0aGlzLl9jb25zdHJhaW50cy5kZXZpY2VJZCk7XG5cbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lICYmXG4gICAgICAgICh0aGlzLnN0b3BPbk11dGUgfHwgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5yZWFkeVN0YXRlID09PSAnZW5kZWQnIHx8IGRldmljZUhhc0NoYW5nZWQpICYmXG4gICAgICAgICF0aGlzLmlzVXNlclByb3ZpZGVkXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3JlYWNxdWlyaW5nIG1pYyB0cmFjaycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIGF3YWl0IHRoaXMucmVzdGFydFRyYWNrKCk7XG4gICAgICB9XG4gICAgICBhd2FpdCBzdXBlci51bm11dGUoKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHVubG9jaygpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHJlc3RhcnRUcmFjayhvcHRpb25zPzogQXVkaW9DYXB0dXJlT3B0aW9ucykge1xuICAgIGxldCBjb25zdHJhaW50czogTWVkaWFUcmFja0NvbnN0cmFpbnRzIHwgdW5kZWZpbmVkO1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICBjb25zdCBzdHJlYW1Db25zdHJhaW50cyA9IGNvbnN0cmFpbnRzRm9yT3B0aW9ucyh7IGF1ZGlvOiBvcHRpb25zIH0pO1xuICAgICAgaWYgKHR5cGVvZiBzdHJlYW1Db25zdHJhaW50cy5hdWRpbyAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIGNvbnN0cmFpbnRzID0gc3RyZWFtQ29uc3RyYWludHMuYXVkaW87XG4gICAgICB9XG4gICAgfVxuICAgIGF3YWl0IHRoaXMucmVzdGFydChjb25zdHJhaW50cyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgcmVzdGFydChjb25zdHJhaW50cz86IE1lZGlhVHJhY2tDb25zdHJhaW50cyk6IFByb21pc2U8TG9jYWxUcmFjaz4ge1xuICAgIGNvbnN0IHRyYWNrID0gYXdhaXQgc3VwZXIucmVzdGFydChjb25zdHJhaW50cyk7XG4gICAgdGhpcy5jaGVja0ZvclNpbGVuY2UoKTtcbiAgICByZXR1cm4gdHJhY2s7XG4gIH1cblxuICAvKiBAaW50ZXJuYWwgKi9cbiAgc3RhcnRNb25pdG9yKCkge1xuICAgIGlmICghaXNXZWIoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5tb25pdG9ySW50ZXJ2YWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5tb25pdG9ySW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICB0aGlzLm1vbml0b3JTZW5kZXIoKTtcbiAgICB9LCBtb25pdG9yRnJlcXVlbmN5KTtcbiAgfVxuXG4gIHByb3RlY3RlZCBtb25pdG9yU2VuZGVyID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmICghdGhpcy5zZW5kZXIpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRCaXRyYXRlID0gMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgc3RhdHM6IEF1ZGlvU2VuZGVyU3RhdHMgfCB1bmRlZmluZWQ7XG4gICAgdHJ5IHtcbiAgICAgIHN0YXRzID0gYXdhaXQgdGhpcy5nZXRTZW5kZXJTdGF0cygpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMubG9nLmVycm9yKCdjb3VsZCBub3QgZ2V0IGF1ZGlvIHNlbmRlciBzdGF0cycsIHsgLi4udGhpcy5sb2dDb250ZXh0LCBlcnJvcjogZSB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoc3RhdHMgJiYgdGhpcy5wcmV2U3RhdHMpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRCaXRyYXRlID0gY29tcHV0ZUJpdHJhdGUoc3RhdHMsIHRoaXMucHJldlN0YXRzKTtcbiAgICB9XG5cbiAgICB0aGlzLnByZXZTdGF0cyA9IHN0YXRzO1xuICB9O1xuXG4gIGFzeW5jIHNldFByb2Nlc3Nvcihwcm9jZXNzb3I6IFRyYWNrUHJvY2Vzc29yPHRoaXNbJ2tpbmQnXT4pIHtcbiAgICBjb25zdCB1bmxvY2sgPSBhd2FpdCB0aGlzLnByb2Nlc3NvckxvY2subG9jaygpO1xuICAgIHRyeSB7XG4gICAgICBpZiAoIXRoaXMuYXVkaW9Db250ZXh0KSB7XG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICdBdWRpbyBjb250ZXh0IG5lZWRzIHRvIGJlIHNldCBvbiBMb2NhbEF1ZGlvVHJhY2sgaW4gb3JkZXIgdG8gZW5hYmxlIHByb2Nlc3NvcnMnLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucHJvY2Vzc29yKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc3RvcFByb2Nlc3NvcigpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMua2luZCA9PT0gJ3Vua25vd24nKSB7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcignY2Fubm90IHNldCBwcm9jZXNzb3Igb24gdHJhY2sgb2YgdW5rbm93biBraW5kJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHByb2Nlc3Nvck9wdGlvbnMgPSB7XG4gICAgICAgIGtpbmQ6IHRoaXMua2luZCxcbiAgICAgICAgdHJhY2s6IHRoaXMuX21lZGlhU3RyZWFtVHJhY2ssXG4gICAgICAgIGF1ZGlvQ29udGV4dDogdGhpcy5hdWRpb0NvbnRleHQsXG4gICAgICB9O1xuICAgICAgdGhpcy5sb2cuZGVidWcoYHNldHRpbmcgdXAgYXVkaW8gcHJvY2Vzc29yICR7cHJvY2Vzc29yLm5hbWV9YCwgdGhpcy5sb2dDb250ZXh0KTtcblxuICAgICAgYXdhaXQgcHJvY2Vzc29yLmluaXQocHJvY2Vzc29yT3B0aW9ucyk7XG4gICAgICB0aGlzLnByb2Nlc3NvciA9IHByb2Nlc3NvcjtcbiAgICAgIGlmICh0aGlzLnByb2Nlc3Nvci5wcm9jZXNzZWRUcmFjaykge1xuICAgICAgICBhd2FpdCB0aGlzLnNlbmRlcj8ucmVwbGFjZVRyYWNrKHRoaXMucHJvY2Vzc29yLnByb2Nlc3NlZFRyYWNrKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdW5sb2NrKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAZXhwZXJpbWVudGFsXG4gICAqL1xuICBzZXRBdWRpb0NvbnRleHQoYXVkaW9Db250ZXh0OiBBdWRpb0NvbnRleHQgfCB1bmRlZmluZWQpIHtcbiAgICB0aGlzLmF1ZGlvQ29udGV4dCA9IGF1ZGlvQ29udGV4dDtcbiAgfVxuXG4gIGFzeW5jIGdldFNlbmRlclN0YXRzKCk6IFByb21pc2U8QXVkaW9TZW5kZXJTdGF0cyB8IHVuZGVmaW5lZD4ge1xuICAgIGlmICghdGhpcy5zZW5kZXI/LmdldFN0YXRzKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXRzID0gYXdhaXQgdGhpcy5zZW5kZXIuZ2V0U3RhdHMoKTtcbiAgICBsZXQgYXVkaW9TdGF0czogQXVkaW9TZW5kZXJTdGF0cyB8IHVuZGVmaW5lZDtcbiAgICBzdGF0cy5mb3JFYWNoKCh2KSA9PiB7XG4gICAgICBpZiAodi50eXBlID09PSAnb3V0Ym91bmQtcnRwJykge1xuICAgICAgICBhdWRpb1N0YXRzID0ge1xuICAgICAgICAgIHR5cGU6ICdhdWRpbycsXG4gICAgICAgICAgc3RyZWFtSWQ6IHYuaWQsXG4gICAgICAgICAgcGFja2V0c1NlbnQ6IHYucGFja2V0c1NlbnQsXG4gICAgICAgICAgcGFja2V0c0xvc3Q6IHYucGFja2V0c0xvc3QsXG4gICAgICAgICAgYnl0ZXNTZW50OiB2LmJ5dGVzU2VudCxcbiAgICAgICAgICB0aW1lc3RhbXA6IHYudGltZXN0YW1wLFxuICAgICAgICAgIHJvdW5kVHJpcFRpbWU6IHYucm91bmRUcmlwVGltZSxcbiAgICAgICAgICBqaXR0ZXI6IHYuaml0dGVyLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGF1ZGlvU3RhdHM7XG4gIH1cblxuICBhc3luYyBjaGVja0ZvclNpbGVuY2UoKSB7XG4gICAgY29uc3QgdHJhY2tJc1NpbGVudCA9IGF3YWl0IGRldGVjdFNpbGVuY2UodGhpcyk7XG4gICAgaWYgKHRyYWNrSXNTaWxlbnQpIHtcbiAgICAgIGlmICghdGhpcy5pc011dGVkKSB7XG4gICAgICAgIHRoaXMubG9nLndhcm4oJ3NpbGVuY2UgZGV0ZWN0ZWQgb24gbG9jYWwgYXVkaW8gdHJhY2snLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuQXVkaW9TaWxlbmNlRGV0ZWN0ZWQpO1xuICAgIH1cbiAgICByZXR1cm4gdHJhY2tJc1NpbGVudDtcbiAgfVxufVxuIiwiaW1wb3J0IGxvZyBmcm9tICcuLi8uLi9sb2dnZXInO1xuaW1wb3J0IHsgVHJhY2tJbnZhbGlkRXJyb3IgfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IExvY2FsQXVkaW9UcmFjayBmcm9tICcuLi90cmFjay9Mb2NhbEF1ZGlvVHJhY2snO1xuaW1wb3J0IExvY2FsVmlkZW9UcmFjayBmcm9tICcuLi90cmFjay9Mb2NhbFZpZGVvVHJhY2snO1xuaW1wb3J0IHsgVHJhY2sgfSBmcm9tICcuLi90cmFjay9UcmFjayc7XG5pbXBvcnQgdHlwZSB7XG4gIEJhY2t1cFZpZGVvQ29kZWMsXG4gIFRyYWNrUHVibGlzaE9wdGlvbnMsXG4gIFZpZGVvQ29kZWMsXG4gIFZpZGVvRW5jb2RpbmcsXG59IGZyb20gJy4uL3RyYWNrL29wdGlvbnMnO1xuaW1wb3J0IHsgU2NyZWVuU2hhcmVQcmVzZXRzLCBWaWRlb1ByZXNldCwgVmlkZW9QcmVzZXRzLCBWaWRlb1ByZXNldHM0MyB9IGZyb20gJy4uL3RyYWNrL29wdGlvbnMnO1xuaW1wb3J0IHR5cGUgeyBMb2dnZXJPcHRpb25zIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgZ2V0UmVhY3ROYXRpdmVPcywgaXNGaXJlRm94LCBpc1JlYWN0TmF0aXZlLCBpc1NWQ0NvZGVjIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gbWVkaWFUcmFja1RvTG9jYWxUcmFjayhcbiAgbWVkaWFTdHJlYW1UcmFjazogTWVkaWFTdHJlYW1UcmFjayxcbiAgY29uc3RyYWludHM/OiBNZWRpYVRyYWNrQ29uc3RyYWludHMsXG4gIGxvZ2dlck9wdGlvbnM/OiBMb2dnZXJPcHRpb25zLFxuKTogTG9jYWxWaWRlb1RyYWNrIHwgTG9jYWxBdWRpb1RyYWNrIHtcbiAgc3dpdGNoIChtZWRpYVN0cmVhbVRyYWNrLmtpbmQpIHtcbiAgICBjYXNlICdhdWRpbyc6XG4gICAgICByZXR1cm4gbmV3IExvY2FsQXVkaW9UcmFjayhtZWRpYVN0cmVhbVRyYWNrLCBjb25zdHJhaW50cywgZmFsc2UsIHVuZGVmaW5lZCwgbG9nZ2VyT3B0aW9ucyk7XG4gICAgY2FzZSAndmlkZW8nOlxuICAgICAgcmV0dXJuIG5ldyBMb2NhbFZpZGVvVHJhY2sobWVkaWFTdHJlYW1UcmFjaywgY29uc3RyYWludHMsIGZhbHNlLCBsb2dnZXJPcHRpb25zKTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFRyYWNrSW52YWxpZEVycm9yKGB1bnN1cHBvcnRlZCB0cmFjayB0eXBlOiAke21lZGlhU3RyZWFtVHJhY2sua2luZH1gKTtcbiAgfVxufVxuXG4vKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBwcmVzZXRzMTY5ID0gT2JqZWN0LnZhbHVlcyhWaWRlb1ByZXNldHMpO1xuXG4vKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBwcmVzZXRzNDMgPSBPYmplY3QudmFsdWVzKFZpZGVvUHJlc2V0czQzKTtcblxuLyogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgcHJlc2V0c1NjcmVlblNoYXJlID0gT2JqZWN0LnZhbHVlcyhTY3JlZW5TaGFyZVByZXNldHMpO1xuXG4vKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBkZWZhdWx0U2ltdWxjYXN0UHJlc2V0czE2OSA9IFtWaWRlb1ByZXNldHMuaDE4MCwgVmlkZW9QcmVzZXRzLmgzNjBdO1xuXG4vKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBkZWZhdWx0U2ltdWxjYXN0UHJlc2V0czQzID0gW1ZpZGVvUHJlc2V0czQzLmgxODAsIFZpZGVvUHJlc2V0czQzLmgzNjBdO1xuXG4vKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBjb21wdXRlRGVmYXVsdFNjcmVlblNoYXJlU2ltdWxjYXN0UHJlc2V0cyA9IChmcm9tUHJlc2V0OiBWaWRlb1ByZXNldCkgPT4ge1xuICBjb25zdCBsYXllcnMgPSBbeyBzY2FsZVJlc29sdXRpb25Eb3duQnk6IDIsIGZwczogZnJvbVByZXNldC5lbmNvZGluZy5tYXhGcmFtZXJhdGUgfV07XG4gIHJldHVybiBsYXllcnMubWFwKFxuICAgICh0KSA9PlxuICAgICAgbmV3IFZpZGVvUHJlc2V0KFxuICAgICAgICBNYXRoLmZsb29yKGZyb21QcmVzZXQud2lkdGggLyB0LnNjYWxlUmVzb2x1dGlvbkRvd25CeSksXG4gICAgICAgIE1hdGguZmxvb3IoZnJvbVByZXNldC5oZWlnaHQgLyB0LnNjYWxlUmVzb2x1dGlvbkRvd25CeSksXG4gICAgICAgIE1hdGgubWF4KFxuICAgICAgICAgIDE1MF8wMDAsXG4gICAgICAgICAgTWF0aC5mbG9vcihcbiAgICAgICAgICAgIGZyb21QcmVzZXQuZW5jb2RpbmcubWF4Qml0cmF0ZSAvXG4gICAgICAgICAgICAgICh0LnNjYWxlUmVzb2x1dGlvbkRvd25CeSAqKiAyICpcbiAgICAgICAgICAgICAgICAoKGZyb21QcmVzZXQuZW5jb2RpbmcubWF4RnJhbWVyYXRlID8/IDMwKSAvICh0LmZwcyA/PyAzMCkpKSxcbiAgICAgICAgICApLFxuICAgICAgICApLFxuICAgICAgICB0LmZwcyxcbiAgICAgICAgZnJvbVByZXNldC5lbmNvZGluZy5wcmlvcml0eSxcbiAgICAgICksXG4gICk7XG59O1xuXG4vLyAvKipcbi8vICAqXG4vLyAgKiBAaW50ZXJuYWxcbi8vICAqIEBleHBlcmltZW50YWxcbi8vICAqL1xuLy8gY29uc3QgY29tcHV0ZURlZmF1bHRNdWx0aUNvZGVjU2ltdWxjYXN0RW5jb2RpbmdzID0gKHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKSA9PiB7XG4vLyAgIC8vIHVzZSB2cDggYXMgYSBkZWZhdWx0XG4vLyAgIGNvbnN0IHZwOCA9IGRldGVybWluZUFwcHJvcHJpYXRlRW5jb2RpbmcoZmFsc2UsIHdpZHRoLCBoZWlnaHQpO1xuLy8gICBjb25zdCB2cDkgPSB7IC4uLnZwOCwgbWF4Qml0cmF0ZTogdnA4Lm1heEJpdHJhdGUgKiAwLjkgfTtcbi8vICAgY29uc3QgaDI2NCA9IHsgLi4udnA4LCBtYXhCaXRyYXRlOiB2cDgubWF4Qml0cmF0ZSAqIDEuMSB9O1xuLy8gICBjb25zdCBhdjEgPSB7IC4uLnZwOCwgbWF4Qml0cmF0ZTogdnA4Lm1heEJpdHJhdGUgKiAwLjcgfTtcbi8vICAgcmV0dXJuIHtcbi8vICAgICB2cDgsXG4vLyAgICAgdnA5LFxuLy8gICAgIGgyNjQsXG4vLyAgICAgYXYxLFxuLy8gICB9O1xuLy8gfTtcblxuY29uc3QgdmlkZW9SaWRzID0gWydxJywgJ2gnLCAnZiddO1xuXG4vKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlVmlkZW9FbmNvZGluZ3MoXG4gIGlzU2NyZWVuU2hhcmU6IGJvb2xlYW4sXG4gIHdpZHRoPzogbnVtYmVyLFxuICBoZWlnaHQ/OiBudW1iZXIsXG4gIG9wdGlvbnM/OiBUcmFja1B1Ymxpc2hPcHRpb25zLFxuKTogUlRDUnRwRW5jb2RpbmdQYXJhbWV0ZXJzW10ge1xuICBsZXQgdmlkZW9FbmNvZGluZzogVmlkZW9FbmNvZGluZyB8IHVuZGVmaW5lZCA9IG9wdGlvbnM/LnZpZGVvRW5jb2Rpbmc7XG5cbiAgaWYgKGlzU2NyZWVuU2hhcmUpIHtcbiAgICB2aWRlb0VuY29kaW5nID0gb3B0aW9ucz8uc2NyZWVuU2hhcmVFbmNvZGluZztcbiAgfVxuXG4gIGNvbnN0IHVzZVNpbXVsY2FzdCA9IG9wdGlvbnM/LnNpbXVsY2FzdDtcbiAgY29uc3Qgc2NhbGFiaWxpdHlNb2RlID0gb3B0aW9ucz8uc2NhbGFiaWxpdHlNb2RlO1xuICBjb25zdCB2aWRlb0NvZGVjID0gb3B0aW9ucz8udmlkZW9Db2RlYztcblxuICBpZiAoKCF2aWRlb0VuY29kaW5nICYmICF1c2VTaW11bGNhc3QgJiYgIXNjYWxhYmlsaXR5TW9kZSkgfHwgIXdpZHRoIHx8ICFoZWlnaHQpIHtcbiAgICAvLyB3aGVuIHdlIGFyZW4ndCBzaW11bGNhc3Rpbmcgb3Igc3ZjLCB3aWxsIG5lZWQgdG8gcmV0dXJuIGEgc2luZ2xlIGVuY29kaW5nIHdpdGhvdXRcbiAgICAvLyBjYXBwaW5nIGJhbmR3aWR0aC4gd2UgYWx3YXlzIHJlcXVpcmUgYSBlbmNvZGluZyBmb3IgZHluYWNhc3RcbiAgICByZXR1cm4gW3t9XTtcbiAgfVxuXG4gIGlmICghdmlkZW9FbmNvZGluZykge1xuICAgIC8vIGZpbmQgdGhlIHJpZ2h0IGVuY29kaW5nIGJhc2VkIG9uIHdpZHRoL2hlaWdodFxuICAgIHZpZGVvRW5jb2RpbmcgPSBkZXRlcm1pbmVBcHByb3ByaWF0ZUVuY29kaW5nKGlzU2NyZWVuU2hhcmUsIHdpZHRoLCBoZWlnaHQsIHZpZGVvQ29kZWMpO1xuICAgIGxvZy5kZWJ1ZygndXNpbmcgdmlkZW8gZW5jb2RpbmcnLCB2aWRlb0VuY29kaW5nKTtcbiAgfVxuXG4gIGNvbnN0IG9yaWdpbmFsID0gbmV3IFZpZGVvUHJlc2V0KFxuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICB2aWRlb0VuY29kaW5nLm1heEJpdHJhdGUsXG4gICAgdmlkZW9FbmNvZGluZy5tYXhGcmFtZXJhdGUsXG4gICAgdmlkZW9FbmNvZGluZy5wcmlvcml0eSxcbiAgKTtcblxuICBpZiAoc2NhbGFiaWxpdHlNb2RlICYmIGlzU1ZDQ29kZWModmlkZW9Db2RlYykpIHtcbiAgICBsb2cuZGVidWcoYHVzaW5nIHN2YyB3aXRoIHNjYWxhYmlsaXR5TW9kZSAke3NjYWxhYmlsaXR5TW9kZX1gKTtcblxuICAgIGNvbnN0IHNtID0gbmV3IFNjYWxhYmlsaXR5TW9kZShzY2FsYWJpbGl0eU1vZGUpO1xuXG4gICAgY29uc3QgZW5jb2RpbmdzOiBSVENSdHBFbmNvZGluZ1BhcmFtZXRlcnNbXSA9IFtdO1xuXG4gICAgaWYgKHNtLnNwYXRpYWwgPiAzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIHNjYWxhYmlsaXR5TW9kZTogJHtzY2FsYWJpbGl0eU1vZGV9YCk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc20uc3BhdGlhbDsgaSArPSAxKSB7XG4gICAgICBlbmNvZGluZ3MucHVzaCh7XG4gICAgICAgIHJpZDogdmlkZW9SaWRzWzIgLSBpXSxcbiAgICAgICAgbWF4Qml0cmF0ZTogdmlkZW9FbmNvZGluZy5tYXhCaXRyYXRlIC8gMyAqKiBpLFxuICAgICAgICAvKiBAdHMtaWdub3JlICovXG4gICAgICAgIG1heEZyYW1lcmF0ZTogb3JpZ2luYWwuZW5jb2RpbmcubWF4RnJhbWVyYXRlLFxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qIEB0cy1pZ25vcmUgKi9cbiAgICBlbmNvZGluZ3NbMF0uc2NhbGFiaWxpdHlNb2RlID0gc2NhbGFiaWxpdHlNb2RlO1xuICAgIGxvZy5kZWJ1ZygnZW5jb2RpbmdzJywgZW5jb2RpbmdzKTtcbiAgICByZXR1cm4gZW5jb2RpbmdzO1xuICB9XG5cbiAgaWYgKCF1c2VTaW11bGNhc3QpIHtcbiAgICByZXR1cm4gW3ZpZGVvRW5jb2RpbmddO1xuICB9XG5cbiAgbGV0IHByZXNldHM6IEFycmF5PFZpZGVvUHJlc2V0PiA9IFtdO1xuICBpZiAoaXNTY3JlZW5TaGFyZSkge1xuICAgIHByZXNldHMgPVxuICAgICAgc29ydFByZXNldHMob3B0aW9ucz8uc2NyZWVuU2hhcmVTaW11bGNhc3RMYXllcnMpID8/XG4gICAgICBkZWZhdWx0U2ltdWxjYXN0TGF5ZXJzKGlzU2NyZWVuU2hhcmUsIG9yaWdpbmFsKTtcbiAgfSBlbHNlIHtcbiAgICBwcmVzZXRzID1cbiAgICAgIHNvcnRQcmVzZXRzKG9wdGlvbnM/LnZpZGVvU2ltdWxjYXN0TGF5ZXJzKSA/PyBkZWZhdWx0U2ltdWxjYXN0TGF5ZXJzKGlzU2NyZWVuU2hhcmUsIG9yaWdpbmFsKTtcbiAgfVxuICBsZXQgbWlkUHJlc2V0OiBWaWRlb1ByZXNldCB8IHVuZGVmaW5lZDtcbiAgaWYgKHByZXNldHMubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGxvd1ByZXNldCA9IHByZXNldHNbMF07XG4gICAgaWYgKHByZXNldHMubGVuZ3RoID4gMSkge1xuICAgICAgWywgbWlkUHJlc2V0XSA9IHByZXNldHM7XG4gICAgfVxuXG4gICAgLy8gTk9URTpcbiAgICAvLyAgIDEuIE9yZGVyaW5nIG9mIHRoZXNlIGVuY29kaW5ncyBpcyBpbXBvcnRhbnQuIENocm9tZSBzZWVtc1xuICAgIC8vICAgICAgdG8gdXNlIHRoZSBpbmRleCBpbnRvIGVuY29kaW5ncyB0byBkZWNpZGUgd2hpY2ggbGF5ZXJcbiAgICAvLyAgICAgIHRvIGRpc2FibGUgd2hlbiBDUFUgY29uc3RyYWluZWQuXG4gICAgLy8gICAgICBTbyBlbmNvZGluZ3Mgc2hvdWxkIGJlIG9yZGVyZWQgaW4gaW5jcmVhc2luZyBzcGF0aWFsXG4gICAgLy8gICAgICByZXNvbHV0aW9uIG9yZGVyLlxuICAgIC8vICAgMi4gaW9uLXNmdSB0cmFuc2xhdGVzIHJpZHMgaW50byBsYXllcnMuIFNvLCBhbGwgZW5jb2RpbmdzXG4gICAgLy8gICAgICBzaG91bGQgaGF2ZSB0aGUgYmFzZSBsYXllciBgcWAgYW5kIHRoZW4gbW9yZSBhZGRlZFxuICAgIC8vICAgICAgYmFzZWQgb24gb3RoZXIgY29uZGl0aW9ucy5cbiAgICBjb25zdCBzaXplID0gTWF0aC5tYXgod2lkdGgsIGhlaWdodCk7XG4gICAgaWYgKHNpemUgPj0gOTYwICYmIG1pZFByZXNldCkge1xuICAgICAgcmV0dXJuIGVuY29kaW5nc0Zyb21QcmVzZXRzKHdpZHRoLCBoZWlnaHQsIFtsb3dQcmVzZXQsIG1pZFByZXNldCwgb3JpZ2luYWxdKTtcbiAgICB9XG4gICAgaWYgKHNpemUgPj0gNDgwKSB7XG4gICAgICByZXR1cm4gZW5jb2RpbmdzRnJvbVByZXNldHMod2lkdGgsIGhlaWdodCwgW2xvd1ByZXNldCwgb3JpZ2luYWxdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVuY29kaW5nc0Zyb21QcmVzZXRzKHdpZHRoLCBoZWlnaHQsIFtvcmlnaW5hbF0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZVRyYWNrQmFja3VwRW5jb2RpbmdzKFxuICB0cmFjazogTG9jYWxWaWRlb1RyYWNrLFxuICB2aWRlb0NvZGVjOiBCYWNrdXBWaWRlb0NvZGVjLFxuICBvcHRzOiBUcmFja1B1Ymxpc2hPcHRpb25zLFxuKSB7XG4gIC8vIGJhY2t1cENvZGVjIHNob3VsZCBub3QgYmUgdHJ1ZSBhbnltb3JlLCBkZWZhdWx0IGNvZGVjIGlzIHNldCBpbiBMb2NhbFBhcnRpY2lwYW50LnB1Ymxpc2hcbiAgaWYgKFxuICAgICFvcHRzLmJhY2t1cENvZGVjIHx8XG4gICAgb3B0cy5iYWNrdXBDb2RlYyA9PT0gdHJ1ZSB8fFxuICAgIG9wdHMuYmFja3VwQ29kZWMuY29kZWMgPT09IG9wdHMudmlkZW9Db2RlY1xuICApIHtcbiAgICAvLyBiYWNrdXAgY29kZWMgcHVibGlzaGluZyBpcyBkaXNhYmxlZFxuICAgIHJldHVybjtcbiAgfVxuICBpZiAodmlkZW9Db2RlYyAhPT0gb3B0cy5iYWNrdXBDb2RlYy5jb2RlYykge1xuICAgIGxvZy53YXJuKCdyZXF1ZXN0ZWQgYSBkaWZmZXJlbnQgY29kZWMgdGhhbiBzcGVjaWZpZWQgYXMgYmFja3VwJywge1xuICAgICAgc2VydmVyUmVxdWVzdGVkOiB2aWRlb0NvZGVjLFxuICAgICAgYmFja3VwOiBvcHRzLmJhY2t1cENvZGVjLmNvZGVjLFxuICAgIH0pO1xuICB9XG5cbiAgb3B0cy52aWRlb0NvZGVjID0gdmlkZW9Db2RlYztcbiAgLy8gdXNlIGJhY2t1cCBlbmNvZGluZyBzZXR0aW5nIGFzIHZpZGVvRW5jb2RpbmcgZm9yIGJhY2t1cCBjb2RlYyBwdWJsaXNoaW5nXG4gIG9wdHMudmlkZW9FbmNvZGluZyA9IG9wdHMuYmFja3VwQ29kZWMuZW5jb2Rpbmc7XG5cbiAgY29uc3Qgc2V0dGluZ3MgPSB0cmFjay5tZWRpYVN0cmVhbVRyYWNrLmdldFNldHRpbmdzKCk7XG4gIGNvbnN0IHdpZHRoID0gc2V0dGluZ3Mud2lkdGggPz8gdHJhY2suZGltZW5zaW9ucz8ud2lkdGg7XG4gIGNvbnN0IGhlaWdodCA9IHNldHRpbmdzLmhlaWdodCA/PyB0cmFjay5kaW1lbnNpb25zPy5oZWlnaHQ7XG5cbiAgY29uc3QgZW5jb2RpbmdzID0gY29tcHV0ZVZpZGVvRW5jb2RpbmdzKFxuICAgIHRyYWNrLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlLFxuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBvcHRzLFxuICApO1xuICByZXR1cm4gZW5jb2RpbmdzO1xufVxuXG4vKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXRlcm1pbmVBcHByb3ByaWF0ZUVuY29kaW5nKFxuICBpc1NjcmVlblNoYXJlOiBib29sZWFuLFxuICB3aWR0aDogbnVtYmVyLFxuICBoZWlnaHQ6IG51bWJlcixcbiAgY29kZWM/OiBWaWRlb0NvZGVjLFxuKTogVmlkZW9FbmNvZGluZyB7XG4gIGNvbnN0IHByZXNldHMgPSBwcmVzZXRzRm9yUmVzb2x1dGlvbihpc1NjcmVlblNoYXJlLCB3aWR0aCwgaGVpZ2h0KTtcbiAgbGV0IHsgZW5jb2RpbmcgfSA9IHByZXNldHNbMF07XG5cbiAgLy8gaGFuZGxlIHBvcnRyYWl0IGJ5IHN3YXBwaW5nIGRpbWVuc2lvbnNcbiAgY29uc3Qgc2l6ZSA9IE1hdGgubWF4KHdpZHRoLCBoZWlnaHQpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlc2V0cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IHByZXNldCA9IHByZXNldHNbaV07XG4gICAgZW5jb2RpbmcgPSBwcmVzZXQuZW5jb2Rpbmc7XG4gICAgaWYgKHByZXNldC53aWR0aCA+PSBzaXplKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgLy8gcHJlc2V0cyBhcmUgYmFzZWQgb24gdGhlIGFzc3VtcHRpb24gb2YgdnA4IGFzIGEgY29kZWNcbiAgLy8gZm9yIG90aGVyIGNvZGVjcyB3ZSBhZGp1c3QgdGhlIG1heEJpdHJhdGUgaWYgbm8gc3BlY2lmaWMgdmlkZW9FbmNvZGluZyBoYXMgYmVlbiBwcm92aWRlZFxuICAvLyB1c2VycyBzaG91bGQgb3ZlcnJpZGUgdGhlc2Ugd2l0aCBvbmVzIHRoYXQgYXJlIG9wdGltaXplZCBmb3IgdGhlaXIgdXNlIGNhc2VcbiAgLy8gTk9URTogU1ZDIGNvZGVjIGJpdHJhdGVzIGFyZSBpbmNsdXNpdmUgb2YgYWxsIHNjYWxhYmlsaXR5IGxheWVycy4gd2hpbGVcbiAgLy8gYml0cmF0ZSBmb3Igbm9uLVNWQyBjb2RlY3MgZG9lcyBub3QgaW5jbHVkZSBvdGhlciBzaW11bGNhc3QgbGF5ZXJzLlxuICBpZiAoY29kZWMpIHtcbiAgICBzd2l0Y2ggKGNvZGVjKSB7XG4gICAgICBjYXNlICdhdjEnOlxuICAgICAgICBlbmNvZGluZyA9IHsgLi4uZW5jb2RpbmcgfTtcbiAgICAgICAgZW5jb2RpbmcubWF4Qml0cmF0ZSA9IGVuY29kaW5nLm1heEJpdHJhdGUgKiAwLjc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndnA5JzpcbiAgICAgICAgZW5jb2RpbmcgPSB7IC4uLmVuY29kaW5nIH07XG4gICAgICAgIGVuY29kaW5nLm1heEJpdHJhdGUgPSBlbmNvZGluZy5tYXhCaXRyYXRlICogMC44NTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZW5jb2Rpbmc7XG59XG5cbi8qIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByZXNldHNGb3JSZXNvbHV0aW9uKFxuICBpc1NjcmVlblNoYXJlOiBib29sZWFuLFxuICB3aWR0aDogbnVtYmVyLFxuICBoZWlnaHQ6IG51bWJlcixcbik6IFZpZGVvUHJlc2V0W10ge1xuICBpZiAoaXNTY3JlZW5TaGFyZSkge1xuICAgIHJldHVybiBwcmVzZXRzU2NyZWVuU2hhcmU7XG4gIH1cbiAgY29uc3QgYXNwZWN0ID0gd2lkdGggPiBoZWlnaHQgPyB3aWR0aCAvIGhlaWdodCA6IGhlaWdodCAvIHdpZHRoO1xuICBpZiAoTWF0aC5hYnMoYXNwZWN0IC0gMTYuMCAvIDkpIDwgTWF0aC5hYnMoYXNwZWN0IC0gNC4wIC8gMykpIHtcbiAgICByZXR1cm4gcHJlc2V0czE2OTtcbiAgfVxuICByZXR1cm4gcHJlc2V0czQzO1xufVxuXG4vKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0U2ltdWxjYXN0TGF5ZXJzKFxuICBpc1NjcmVlblNoYXJlOiBib29sZWFuLFxuICBvcmlnaW5hbDogVmlkZW9QcmVzZXQsXG4pOiBWaWRlb1ByZXNldFtdIHtcbiAgaWYgKGlzU2NyZWVuU2hhcmUpIHtcbiAgICByZXR1cm4gY29tcHV0ZURlZmF1bHRTY3JlZW5TaGFyZVNpbXVsY2FzdFByZXNldHMob3JpZ2luYWwpO1xuICB9XG4gIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gb3JpZ2luYWw7XG4gIGNvbnN0IGFzcGVjdCA9IHdpZHRoID4gaGVpZ2h0ID8gd2lkdGggLyBoZWlnaHQgOiBoZWlnaHQgLyB3aWR0aDtcbiAgaWYgKE1hdGguYWJzKGFzcGVjdCAtIDE2LjAgLyA5KSA8IE1hdGguYWJzKGFzcGVjdCAtIDQuMCAvIDMpKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRTaW11bGNhc3RQcmVzZXRzMTY5O1xuICB9XG4gIHJldHVybiBkZWZhdWx0U2ltdWxjYXN0UHJlc2V0czQzO1xufVxuXG4vLyBwcmVzZXRzIHNob3VsZCBiZSBvcmRlcmVkIGJ5IGxvdywgbWVkaXVtLCBoaWdoXG5mdW5jdGlvbiBlbmNvZGluZ3NGcm9tUHJlc2V0cyhcbiAgd2lkdGg6IG51bWJlcixcbiAgaGVpZ2h0OiBudW1iZXIsXG4gIHByZXNldHM6IFZpZGVvUHJlc2V0W10sXG4pOiBSVENSdHBFbmNvZGluZ1BhcmFtZXRlcnNbXSB7XG4gIGNvbnN0IGVuY29kaW5nczogUlRDUnRwRW5jb2RpbmdQYXJhbWV0ZXJzW10gPSBbXTtcbiAgcHJlc2V0cy5mb3JFYWNoKChwcmVzZXQsIGlkeCkgPT4ge1xuICAgIGlmIChpZHggPj0gdmlkZW9SaWRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzaXplID0gTWF0aC5taW4od2lkdGgsIGhlaWdodCk7XG4gICAgY29uc3QgcmlkID0gdmlkZW9SaWRzW2lkeF07XG4gICAgY29uc3QgZW5jb2Rpbmc6IFJUQ1J0cEVuY29kaW5nUGFyYW1ldGVycyA9IHtcbiAgICAgIHJpZCxcbiAgICAgIHNjYWxlUmVzb2x1dGlvbkRvd25CeTogTWF0aC5tYXgoMSwgc2l6ZSAvIE1hdGgubWluKHByZXNldC53aWR0aCwgcHJlc2V0LmhlaWdodCkpLFxuICAgICAgbWF4Qml0cmF0ZTogcHJlc2V0LmVuY29kaW5nLm1heEJpdHJhdGUsXG4gICAgfTtcbiAgICBpZiAocHJlc2V0LmVuY29kaW5nLm1heEZyYW1lcmF0ZSkge1xuICAgICAgZW5jb2RpbmcubWF4RnJhbWVyYXRlID0gcHJlc2V0LmVuY29kaW5nLm1heEZyYW1lcmF0ZTtcbiAgICB9XG4gICAgY29uc3QgY2FuU2V0UHJpb3JpdHkgPSBpc0ZpcmVGb3goKSB8fCBpZHggPT09IDA7XG4gICAgaWYgKHByZXNldC5lbmNvZGluZy5wcmlvcml0eSAmJiBjYW5TZXRQcmlvcml0eSkge1xuICAgICAgZW5jb2RpbmcucHJpb3JpdHkgPSBwcmVzZXQuZW5jb2RpbmcucHJpb3JpdHk7XG4gICAgICBlbmNvZGluZy5uZXR3b3JrUHJpb3JpdHkgPSBwcmVzZXQuZW5jb2RpbmcucHJpb3JpdHk7XG4gICAgfVxuICAgIGVuY29kaW5ncy5wdXNoKGVuY29kaW5nKTtcbiAgfSk7XG5cbiAgLy8gUk4gaW9zIHNpbXVsY2FzdCByZXF1aXJlcyBhbGwgc2FtZSBmcmFtZXJhdGVzLlxuICBpZiAoaXNSZWFjdE5hdGl2ZSgpICYmIGdldFJlYWN0TmF0aXZlT3MoKSA9PT0gJ2lvcycpIHtcbiAgICBsZXQgdG9wRnJhbWVyYXRlOiBudW1iZXIgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgZW5jb2RpbmdzLmZvckVhY2goKGVuY29kaW5nKSA9PiB7XG4gICAgICBpZiAoIXRvcEZyYW1lcmF0ZSkge1xuICAgICAgICB0b3BGcmFtZXJhdGUgPSBlbmNvZGluZy5tYXhGcmFtZXJhdGU7XG4gICAgICB9IGVsc2UgaWYgKGVuY29kaW5nLm1heEZyYW1lcmF0ZSAmJiBlbmNvZGluZy5tYXhGcmFtZXJhdGUgPiB0b3BGcmFtZXJhdGUpIHtcbiAgICAgICAgdG9wRnJhbWVyYXRlID0gZW5jb2RpbmcubWF4RnJhbWVyYXRlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgbGV0IG5vdGlmeU9uY2UgPSB0cnVlO1xuICAgIGVuY29kaW5ncy5mb3JFYWNoKChlbmNvZGluZykgPT4ge1xuICAgICAgaWYgKGVuY29kaW5nLm1heEZyYW1lcmF0ZSAhPSB0b3BGcmFtZXJhdGUpIHtcbiAgICAgICAgaWYgKG5vdGlmeU9uY2UpIHtcbiAgICAgICAgICBub3RpZnlPbmNlID0gZmFsc2U7XG4gICAgICAgICAgbG9nLmluZm8oXG4gICAgICAgICAgICBgU2ltdWxjYXN0IG9uIGlPUyBSZWFjdC1OYXRpdmUgcmVxdWlyZXMgYWxsIGVuY29kaW5ncyB0byBzaGFyZSB0aGUgc2FtZSBmcmFtZXJhdGUuYCxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGxvZy5pbmZvKGBTZXR0aW5nIGZyYW1lcmF0ZSBvZiBlbmNvZGluZyBcXFwiJHtlbmNvZGluZy5yaWQgPz8gJyd9XFxcIiB0byAke3RvcEZyYW1lcmF0ZX1gKTtcbiAgICAgICAgZW5jb2RpbmcubWF4RnJhbWVyYXRlID0gdG9wRnJhbWVyYXRlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGVuY29kaW5ncztcbn1cblxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNvcnRQcmVzZXRzKHByZXNldHM6IEFycmF5PFZpZGVvUHJlc2V0PiB8IHVuZGVmaW5lZCkge1xuICBpZiAoIXByZXNldHMpIHJldHVybjtcbiAgcmV0dXJuIHByZXNldHMuc29ydCgoYSwgYikgPT4ge1xuICAgIGNvbnN0IHsgZW5jb2Rpbmc6IGFFbmMgfSA9IGE7XG4gICAgY29uc3QgeyBlbmNvZGluZzogYkVuYyB9ID0gYjtcblxuICAgIGlmIChhRW5jLm1heEJpdHJhdGUgPiBiRW5jLm1heEJpdHJhdGUpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBpZiAoYUVuYy5tYXhCaXRyYXRlIDwgYkVuYy5tYXhCaXRyYXRlKSByZXR1cm4gLTE7XG4gICAgaWYgKGFFbmMubWF4Qml0cmF0ZSA9PT0gYkVuYy5tYXhCaXRyYXRlICYmIGFFbmMubWF4RnJhbWVyYXRlICYmIGJFbmMubWF4RnJhbWVyYXRlKSB7XG4gICAgICByZXR1cm4gYUVuYy5tYXhGcmFtZXJhdGUgPiBiRW5jLm1heEZyYW1lcmF0ZSA/IDEgOiAtMTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0pO1xufVxuXG4vKiogQGludGVybmFsICovXG5leHBvcnQgY2xhc3MgU2NhbGFiaWxpdHlNb2RlIHtcbiAgc3BhdGlhbDogbnVtYmVyO1xuXG4gIHRlbXBvcmFsOiBudW1iZXI7XG5cbiAgc3VmZml4OiB1bmRlZmluZWQgfCAnaCcgfCAnX0tFWScgfCAnX0tFWV9TSElGVCc7XG5cbiAgY29uc3RydWN0b3Ioc2NhbGFiaWxpdHlNb2RlOiBzdHJpbmcpIHtcbiAgICBjb25zdCByZXN1bHRzID0gc2NhbGFiaWxpdHlNb2RlLm1hdGNoKC9eTChcXGQpVChcXGQpKGh8X0tFWXxfS0VZX1NISUZUKXswLDF9JC8pO1xuICAgIGlmICghcmVzdWx0cykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHNjYWxhYmlsaXR5IG1vZGUnKTtcbiAgICB9XG5cbiAgICB0aGlzLnNwYXRpYWwgPSBwYXJzZUludChyZXN1bHRzWzFdKTtcbiAgICB0aGlzLnRlbXBvcmFsID0gcGFyc2VJbnQocmVzdWx0c1syXSk7XG4gICAgaWYgKHJlc3VsdHMubGVuZ3RoID4gMykge1xuICAgICAgc3dpdGNoIChyZXN1bHRzWzNdKSB7XG4gICAgICAgIGNhc2UgJ2gnOlxuICAgICAgICBjYXNlICdfS0VZJzpcbiAgICAgICAgY2FzZSAnX0tFWV9TSElGVCc6XG4gICAgICAgICAgdGhpcy5zdWZmaXggPSByZXN1bHRzWzNdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRvU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGBMJHt0aGlzLnNwYXRpYWx9VCR7dGhpcy50ZW1wb3JhbH0ke3RoaXMuc3VmZml4ID8/ICcnfWA7XG4gIH1cbn1cbiIsImltcG9ydCB0eXBlIHsgU2lnbmFsQ2xpZW50IH0gZnJvbSAnLi4vLi4vYXBpL1NpZ25hbENsaWVudCc7XG5pbXBvcnQgdHlwZSB7IFN0cnVjdHVyZWRMb2dnZXIgfSBmcm9tICcuLi8uLi9sb2dnZXInO1xuaW1wb3J0IHsgVmlkZW9MYXllciwgVmlkZW9RdWFsaXR5IH0gZnJvbSAnLi4vLi4vcHJvdG8vbGl2ZWtpdF9tb2RlbHNfcGInO1xuaW1wb3J0IHsgU3Vic2NyaWJlZENvZGVjLCBTdWJzY3JpYmVkUXVhbGl0eSB9IGZyb20gJy4uLy4uL3Byb3RvL2xpdmVraXRfcnRjX3BiJztcbmltcG9ydCB7IFNjYWxhYmlsaXR5TW9kZSB9IGZyb20gJy4uL3BhcnRpY2lwYW50L3B1Ymxpc2hVdGlscyc7XG5pbXBvcnQgdHlwZSB7IFZpZGVvU2VuZGVyU3RhdHMgfSBmcm9tICcuLi9zdGF0cyc7XG5pbXBvcnQgeyBjb21wdXRlQml0cmF0ZSwgbW9uaXRvckZyZXF1ZW5jeSB9IGZyb20gJy4uL3N0YXRzJztcbmltcG9ydCB0eXBlIHsgTG9nZ2VyT3B0aW9ucyB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IE11dGV4LCBpc0ZpcmVGb3gsIGlzTW9iaWxlLCBpc1dlYiwgdW53cmFwQ29uc3RyYWludCB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCBMb2NhbFRyYWNrIGZyb20gJy4vTG9jYWxUcmFjayc7XG5pbXBvcnQgeyBUcmFjayB9IGZyb20gJy4vVHJhY2snO1xuaW1wb3J0IHR5cGUgeyBWaWRlb0NhcHR1cmVPcHRpb25zLCBWaWRlb0NvZGVjIH0gZnJvbSAnLi9vcHRpb25zJztcbmltcG9ydCB0eXBlIHsgVHJhY2tQcm9jZXNzb3IgfSBmcm9tICcuL3Byb2Nlc3Nvci90eXBlcyc7XG5pbXBvcnQgeyBjb25zdHJhaW50c0Zvck9wdGlvbnMgfSBmcm9tICcuL3V0aWxzJztcblxuZXhwb3J0IGNsYXNzIFNpbXVsY2FzdFRyYWNrSW5mbyB7XG4gIGNvZGVjOiBWaWRlb0NvZGVjO1xuXG4gIG1lZGlhU3RyZWFtVHJhY2s6IE1lZGlhU3RyZWFtVHJhY2s7XG5cbiAgc2VuZGVyPzogUlRDUnRwU2VuZGVyO1xuXG4gIGVuY29kaW5ncz86IFJUQ1J0cEVuY29kaW5nUGFyYW1ldGVyc1tdO1xuXG4gIGNvbnN0cnVjdG9yKGNvZGVjOiBWaWRlb0NvZGVjLCBtZWRpYVN0cmVhbVRyYWNrOiBNZWRpYVN0cmVhbVRyYWNrKSB7XG4gICAgdGhpcy5jb2RlYyA9IGNvZGVjO1xuICAgIHRoaXMubWVkaWFTdHJlYW1UcmFjayA9IG1lZGlhU3RyZWFtVHJhY2s7XG4gIH1cbn1cblxuY29uc3QgcmVmcmVzaFN1YnNjcmliZWRDb2RlY0FmdGVyTmV3Q29kZWMgPSA1MDAwO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMb2NhbFZpZGVvVHJhY2sgZXh0ZW5kcyBMb2NhbFRyYWNrIHtcbiAgLyogQGludGVybmFsICovXG4gIHNpZ25hbENsaWVudD86IFNpZ25hbENsaWVudDtcblxuICBwcml2YXRlIHByZXZTdGF0cz86IE1hcDxzdHJpbmcsIFZpZGVvU2VuZGVyU3RhdHM+O1xuXG4gIHByaXZhdGUgZW5jb2RpbmdzPzogUlRDUnRwRW5jb2RpbmdQYXJhbWV0ZXJzW107XG5cbiAgLyogQGludGVybmFsICovXG4gIHNpbXVsY2FzdENvZGVjczogTWFwPFZpZGVvQ29kZWMsIFNpbXVsY2FzdFRyYWNrSW5mbz4gPSBuZXcgTWFwPFZpZGVvQ29kZWMsIFNpbXVsY2FzdFRyYWNrSW5mbz4oKTtcblxuICBwcml2YXRlIHN1YnNjcmliZWRDb2RlY3M/OiBTdWJzY3JpYmVkQ29kZWNbXTtcblxuICAvLyBwcmV2ZW50cyBjb25jdXJyZW50IG1hbmlwdWxhdGlvbnMgdG8gdHJhY2sgc2VuZGVyXG4gIC8vIGlmIG11bHRpcGxlIGdldC9zZXRQYXJhbWV0ZXIgYXJlIGNhbGxlZCBjb25jdXJyZW50bHksIGNlcnRhaW4gdGltaW5nIG9mIGV2ZW50c1xuICAvLyBjb3VsZCBsZWFkIHRvIHRoZSBicm93c2VyIHRocm93aW5nIGFuIGV4Y2VwdGlvbiBpbiBgc2V0UGFyYW1ldGVyYCwgZHVlIHRvXG4gIC8vIGEgbWlzc2luZyBgZ2V0UGFyYW1ldGVyYCBjYWxsLlxuICBwcml2YXRlIHNlbmRlckxvY2s6IE11dGV4O1xuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0gbWVkaWFUcmFja1xuICAgKiBAcGFyYW0gY29uc3RyYWludHMgTWVkaWFUcmFja0NvbnN0cmFpbnRzIHRoYXQgYXJlIGJlaW5nIHVzZWQgd2hlbiByZXN0YXJ0aW5nIG9yIHJlYWNxdWlyaW5nIHRyYWNrc1xuICAgKiBAcGFyYW0gdXNlclByb3ZpZGVkVHJhY2sgU2lnbmFscyB0byB0aGUgU0RLIHdoZXRoZXIgb3Igbm90IHRoZSBtZWRpYVRyYWNrIHNob3VsZCBiZSBtYW5hZ2VkIChpLmUuIHJlbGVhc2VkIGFuZCByZWFjcXVpcmVkKSBpbnRlcm5hbGx5IGJ5IHRoZSBTREtcbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIG1lZGlhVHJhY2s6IE1lZGlhU3RyZWFtVHJhY2ssXG4gICAgY29uc3RyYWludHM/OiBNZWRpYVRyYWNrQ29uc3RyYWludHMsXG4gICAgdXNlclByb3ZpZGVkVHJhY2sgPSB0cnVlLFxuICAgIGxvZ2dlck9wdGlvbnM/OiBMb2dnZXJPcHRpb25zLFxuICApIHtcbiAgICBzdXBlcihtZWRpYVRyYWNrLCBUcmFjay5LaW5kLlZpZGVvLCBjb25zdHJhaW50cywgdXNlclByb3ZpZGVkVHJhY2ssIGxvZ2dlck9wdGlvbnMpO1xuICAgIHRoaXMuc2VuZGVyTG9jayA9IG5ldyBNdXRleCgpO1xuICB9XG5cbiAgZ2V0IGlzU2ltdWxjYXN0KCk6IGJvb2xlYW4ge1xuICAgIGlmICh0aGlzLnNlbmRlciAmJiB0aGlzLnNlbmRlci5nZXRQYXJhbWV0ZXJzKCkuZW5jb2RpbmdzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKiBAaW50ZXJuYWwgKi9cbiAgc3RhcnRNb25pdG9yKHNpZ25hbENsaWVudDogU2lnbmFsQ2xpZW50KSB7XG4gICAgdGhpcy5zaWduYWxDbGllbnQgPSBzaWduYWxDbGllbnQ7XG4gICAgaWYgKCFpc1dlYigpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHNhdmUgb3JpZ2luYWwgZW5jb2RpbmdzXG4gICAgLy8gVE9ETyA6IG1lcmdlIHNpbXVsY2FzdCB0cmFja3Mgc3RhdHNcbiAgICBjb25zdCBwYXJhbXMgPSB0aGlzLnNlbmRlcj8uZ2V0UGFyYW1ldGVycygpO1xuICAgIGlmIChwYXJhbXMpIHtcbiAgICAgIHRoaXMuZW5jb2RpbmdzID0gcGFyYW1zLmVuY29kaW5ncztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5tb25pdG9ySW50ZXJ2YWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5tb25pdG9ySW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICB0aGlzLm1vbml0b3JTZW5kZXIoKTtcbiAgICB9LCBtb25pdG9yRnJlcXVlbmN5KTtcbiAgfVxuXG4gIHN0b3AoKSB7XG4gICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5nZXRDb25zdHJhaW50cygpO1xuICAgIHRoaXMuc2ltdWxjYXN0Q29kZWNzLmZvckVhY2goKHRyYWNrSW5mbykgPT4ge1xuICAgICAgdHJhY2tJbmZvLm1lZGlhU3RyZWFtVHJhY2suc3RvcCgpO1xuICAgIH0pO1xuICAgIHN1cGVyLnN0b3AoKTtcbiAgfVxuXG4gIGFzeW5jIHBhdXNlVXBzdHJlYW0oKSB7XG4gICAgYXdhaXQgc3VwZXIucGF1c2VVcHN0cmVhbSgpO1xuICAgIGZvciBhd2FpdCAoY29uc3Qgc2Mgb2YgdGhpcy5zaW11bGNhc3RDb2RlY3MudmFsdWVzKCkpIHtcbiAgICAgIGF3YWl0IHNjLnNlbmRlcj8ucmVwbGFjZVRyYWNrKG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHJlc3VtZVVwc3RyZWFtKCkge1xuICAgIGF3YWl0IHN1cGVyLnJlc3VtZVVwc3RyZWFtKCk7XG4gICAgZm9yIGF3YWl0IChjb25zdCBzYyBvZiB0aGlzLnNpbXVsY2FzdENvZGVjcy52YWx1ZXMoKSkge1xuICAgICAgYXdhaXQgc2Muc2VuZGVyPy5yZXBsYWNlVHJhY2soc2MubWVkaWFTdHJlYW1UcmFjayk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgbXV0ZSgpOiBQcm9taXNlPExvY2FsVmlkZW9UcmFjaz4ge1xuICAgIGNvbnN0IHVubG9jayA9IGF3YWl0IHRoaXMubXV0ZUxvY2subG9jaygpO1xuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5DYW1lcmEgJiYgIXRoaXMuaXNVc2VyUHJvdmlkZWQpIHtcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3N0b3BwaW5nIGNhbWVyYSB0cmFjaycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIC8vIGFsc28gc3RvcCB0aGUgdHJhY2ssIHNvIHRoYXQgY2FtZXJhIGluZGljYXRvciBpcyB0dXJuZWQgb2ZmXG4gICAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suc3RvcCgpO1xuICAgICAgfVxuICAgICAgYXdhaXQgc3VwZXIubXV0ZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHVubG9jaygpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHVubXV0ZSgpOiBQcm9taXNlPExvY2FsVmlkZW9UcmFjaz4ge1xuICAgIGNvbnN0IHVubG9jayA9IGF3YWl0IHRoaXMubXV0ZUxvY2subG9jaygpO1xuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5DYW1lcmEgJiYgIXRoaXMuaXNVc2VyUHJvdmlkZWQpIHtcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3JlYWNxdWlyaW5nIGNhbWVyYSB0cmFjaycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIGF3YWl0IHRoaXMucmVzdGFydFRyYWNrKCk7XG4gICAgICB9XG4gICAgICBhd2FpdCBzdXBlci51bm11dGUoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB1bmxvY2soKTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgc2V0VHJhY2tNdXRlZChtdXRlZDogYm9vbGVhbikge1xuICAgIHN1cGVyLnNldFRyYWNrTXV0ZWQobXV0ZWQpO1xuICAgIGZvciAoY29uc3Qgc2Mgb2YgdGhpcy5zaW11bGNhc3RDb2RlY3MudmFsdWVzKCkpIHtcbiAgICAgIHNjLm1lZGlhU3RyZWFtVHJhY2suZW5hYmxlZCA9ICFtdXRlZDtcbiAgICB9XG4gIH1cblxuICBhc3luYyBnZXRTZW5kZXJTdGF0cygpOiBQcm9taXNlPFZpZGVvU2VuZGVyU3RhdHNbXT4ge1xuICAgIGlmICghdGhpcy5zZW5kZXI/LmdldFN0YXRzKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3QgaXRlbXM6IFZpZGVvU2VuZGVyU3RhdHNbXSA9IFtdO1xuXG4gICAgY29uc3Qgc3RhdHMgPSBhd2FpdCB0aGlzLnNlbmRlci5nZXRTdGF0cygpO1xuICAgIHN0YXRzLmZvckVhY2goKHYpID0+IHtcbiAgICAgIGlmICh2LnR5cGUgPT09ICdvdXRib3VuZC1ydHAnKSB7XG4gICAgICAgIGNvbnN0IHZzOiBWaWRlb1NlbmRlclN0YXRzID0ge1xuICAgICAgICAgIHR5cGU6ICd2aWRlbycsXG4gICAgICAgICAgc3RyZWFtSWQ6IHYuaWQsXG4gICAgICAgICAgZnJhbWVIZWlnaHQ6IHYuZnJhbWVIZWlnaHQsXG4gICAgICAgICAgZnJhbWVXaWR0aDogdi5mcmFtZVdpZHRoLFxuICAgICAgICAgIGZpckNvdW50OiB2LmZpckNvdW50LFxuICAgICAgICAgIHBsaUNvdW50OiB2LnBsaUNvdW50LFxuICAgICAgICAgIG5hY2tDb3VudDogdi5uYWNrQ291bnQsXG4gICAgICAgICAgcGFja2V0c1NlbnQ6IHYucGFja2V0c1NlbnQsXG4gICAgICAgICAgYnl0ZXNTZW50OiB2LmJ5dGVzU2VudCxcbiAgICAgICAgICBmcmFtZXNTZW50OiB2LmZyYW1lc1NlbnQsXG4gICAgICAgICAgdGltZXN0YW1wOiB2LnRpbWVzdGFtcCxcbiAgICAgICAgICByaWQ6IHYucmlkID8/IHYuaWQsXG4gICAgICAgICAgcmV0cmFuc21pdHRlZFBhY2tldHNTZW50OiB2LnJldHJhbnNtaXR0ZWRQYWNrZXRzU2VudCxcbiAgICAgICAgICBxdWFsaXR5TGltaXRhdGlvblJlYXNvbjogdi5xdWFsaXR5TGltaXRhdGlvblJlYXNvbixcbiAgICAgICAgICBxdWFsaXR5TGltaXRhdGlvblJlc29sdXRpb25DaGFuZ2VzOiB2LnF1YWxpdHlMaW1pdGF0aW9uUmVzb2x1dGlvbkNoYW5nZXMsXG4gICAgICAgIH07XG5cbiAgICAgICAgLy/CoGxvY2F0ZSB0aGUgYXBwcm9wcmlhdGUgcmVtb3RlLWluYm91bmQtcnRwIGl0ZW1cbiAgICAgICAgY29uc3QgciA9IHN0YXRzLmdldCh2LnJlbW90ZUlkKTtcbiAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICB2cy5qaXR0ZXIgPSByLmppdHRlcjtcbiAgICAgICAgICB2cy5wYWNrZXRzTG9zdCA9IHIucGFja2V0c0xvc3Q7XG4gICAgICAgICAgdnMucm91bmRUcmlwVGltZSA9IHIucm91bmRUcmlwVGltZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGl0ZW1zLnB1c2godnMpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9XG5cbiAgc2V0UHVibGlzaGluZ1F1YWxpdHkobWF4UXVhbGl0eTogVmlkZW9RdWFsaXR5KSB7XG4gICAgY29uc3QgcXVhbGl0aWVzOiBTdWJzY3JpYmVkUXVhbGl0eVtdID0gW107XG4gICAgZm9yIChsZXQgcSA9IFZpZGVvUXVhbGl0eS5MT1c7IHEgPD0gVmlkZW9RdWFsaXR5LkhJR0g7IHEgKz0gMSkge1xuICAgICAgcXVhbGl0aWVzLnB1c2goXG4gICAgICAgIG5ldyBTdWJzY3JpYmVkUXVhbGl0eSh7XG4gICAgICAgICAgcXVhbGl0eTogcSxcbiAgICAgICAgICBlbmFibGVkOiBxIDw9IG1heFF1YWxpdHksXG4gICAgICAgIH0pLFxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5sb2cuZGVidWcoYHNldHRpbmcgcHVibGlzaGluZyBxdWFsaXR5LiBtYXggcXVhbGl0eSAke21heFF1YWxpdHl9YCwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICB0aGlzLnNldFB1Ymxpc2hpbmdMYXllcnMocXVhbGl0aWVzKTtcbiAgfVxuXG4gIGFzeW5jIHNldERldmljZUlkKGRldmljZUlkOiBDb25zdHJhaW5ET01TdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBpZiAoXG4gICAgICB0aGlzLl9jb25zdHJhaW50cy5kZXZpY2VJZCA9PT0gZGV2aWNlSWQgJiZcbiAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suZ2V0U2V0dGluZ3MoKS5kZXZpY2VJZCA9PT0gdW53cmFwQ29uc3RyYWludChkZXZpY2VJZClcbiAgICApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl9jb25zdHJhaW50cy5kZXZpY2VJZCA9IGRldmljZUlkO1xuICAgIC8vIHdoZW4gdmlkZW8gaXMgbXV0ZWQsIHVuZGVybHlpbmcgbWVkaWEgc3RyZWFtIHRyYWNrIGlzIHN0b3BwZWQgYW5kXG4gICAgLy8gd2lsbCBiZSByZXN0YXJ0ZWQgbGF0ZXJcbiAgICBpZiAoIXRoaXMuaXNNdXRlZCkge1xuICAgICAgYXdhaXQgdGhpcy5yZXN0YXJ0VHJhY2soKTtcbiAgICB9XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMuaXNNdXRlZCB8fCB1bndyYXBDb25zdHJhaW50KGRldmljZUlkKSA9PT0gdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5nZXRTZXR0aW5ncygpLmRldmljZUlkXG4gICAgKTtcbiAgfVxuXG4gIGFzeW5jIHJlc3RhcnRUcmFjayhvcHRpb25zPzogVmlkZW9DYXB0dXJlT3B0aW9ucykge1xuICAgIGxldCBjb25zdHJhaW50czogTWVkaWFUcmFja0NvbnN0cmFpbnRzIHwgdW5kZWZpbmVkO1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICBjb25zdCBzdHJlYW1Db25zdHJhaW50cyA9IGNvbnN0cmFpbnRzRm9yT3B0aW9ucyh7IHZpZGVvOiBvcHRpb25zIH0pO1xuICAgICAgaWYgKHR5cGVvZiBzdHJlYW1Db25zdHJhaW50cy52aWRlbyAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIGNvbnN0cmFpbnRzID0gc3RyZWFtQ29uc3RyYWludHMudmlkZW87XG4gICAgICB9XG4gICAgfVxuICAgIGF3YWl0IHRoaXMucmVzdGFydChjb25zdHJhaW50cyk7XG5cbiAgICBmb3IgYXdhaXQgKGNvbnN0IHNjIG9mIHRoaXMuc2ltdWxjYXN0Q29kZWNzLnZhbHVlcygpKSB7XG4gICAgICBpZiAoc2Muc2VuZGVyKSB7XG4gICAgICAgIHNjLm1lZGlhU3RyZWFtVHJhY2sgPSB0aGlzLm1lZGlhU3RyZWFtVHJhY2suY2xvbmUoKTtcbiAgICAgICAgYXdhaXQgc2Muc2VuZGVyLnJlcGxhY2VUcmFjayhzYy5tZWRpYVN0cmVhbVRyYWNrKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhc3luYyBzZXRQcm9jZXNzb3IocHJvY2Vzc29yOiBUcmFja1Byb2Nlc3NvcjxUcmFjay5LaW5kPiwgc2hvd1Byb2Nlc3NlZFN0cmVhbUxvY2FsbHkgPSB0cnVlKSB7XG4gICAgYXdhaXQgc3VwZXIuc2V0UHJvY2Vzc29yKHByb2Nlc3Nvciwgc2hvd1Byb2Nlc3NlZFN0cmVhbUxvY2FsbHkpO1xuXG4gICAgaWYgKHRoaXMucHJvY2Vzc29yPy5wcm9jZXNzZWRUcmFjaykge1xuICAgICAgZm9yIGF3YWl0IChjb25zdCBzYyBvZiB0aGlzLnNpbXVsY2FzdENvZGVjcy52YWx1ZXMoKSkge1xuICAgICAgICBhd2FpdCBzYy5zZW5kZXI/LnJlcGxhY2VUcmFjayh0aGlzLnByb2Nlc3Nvci5wcm9jZXNzZWRUcmFjayk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYWRkU2ltdWxjYXN0VHJhY2soY29kZWM6IFZpZGVvQ29kZWMsIGVuY29kaW5ncz86IFJUQ1J0cEVuY29kaW5nUGFyYW1ldGVyc1tdKTogU2ltdWxjYXN0VHJhY2tJbmZvIHtcbiAgICBpZiAodGhpcy5zaW11bGNhc3RDb2RlY3MuaGFzKGNvZGVjKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2NvZGVjfSBhbHJlYWR5IGFkZGVkYCk7XG4gICAgfVxuICAgIGNvbnN0IHNpbXVsY2FzdENvZGVjSW5mbzogU2ltdWxjYXN0VHJhY2tJbmZvID0ge1xuICAgICAgY29kZWMsXG4gICAgICBtZWRpYVN0cmVhbVRyYWNrOiB0aGlzLm1lZGlhU3RyZWFtVHJhY2suY2xvbmUoKSxcbiAgICAgIHNlbmRlcjogdW5kZWZpbmVkLFxuICAgICAgZW5jb2RpbmdzLFxuICAgIH07XG4gICAgdGhpcy5zaW11bGNhc3RDb2RlY3Muc2V0KGNvZGVjLCBzaW11bGNhc3RDb2RlY0luZm8pO1xuICAgIHJldHVybiBzaW11bGNhc3RDb2RlY0luZm87XG4gIH1cblxuICBzZXRTaW11bGNhc3RUcmFja1NlbmRlcihjb2RlYzogVmlkZW9Db2RlYywgc2VuZGVyOiBSVENSdHBTZW5kZXIpIHtcbiAgICBjb25zdCBzaW11bGNhc3RDb2RlY0luZm8gPSB0aGlzLnNpbXVsY2FzdENvZGVjcy5nZXQoY29kZWMpO1xuICAgIGlmICghc2ltdWxjYXN0Q29kZWNJbmZvKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNpbXVsY2FzdENvZGVjSW5mby5zZW5kZXIgPSBzZW5kZXI7XG5cbiAgICAvLyBicm93c2VyIHdpbGwgcmVlbmFibGUgZGlzYWJsZWQgY29kZWMvbGF5ZXJzIGFmdGVyIG5ldyBjb2RlYyBoYXMgYmVlbiBwdWJsaXNoZWQsXG4gICAgLy8gc28gcmVmcmVzaCBzdWJzY3JpYmVkQ29kZWNzIGFmdGVyIHB1Ymxpc2ggYSBuZXcgY29kZWNcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICh0aGlzLnN1YnNjcmliZWRDb2RlY3MpIHtcbiAgICAgICAgdGhpcy5zZXRQdWJsaXNoaW5nQ29kZWNzKHRoaXMuc3Vic2NyaWJlZENvZGVjcyk7XG4gICAgICB9XG4gICAgfSwgcmVmcmVzaFN1YnNjcmliZWRDb2RlY0FmdGVyTmV3Q29kZWMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBTZXRzIGNvZGVjcyB0aGF0IHNob3VsZCBiZSBwdWJsaXNoaW5nLCByZXR1cm5zIG5ldyBjb2RlY3MgdGhhdCBoYXZlIG5vdCB5ZXRcbiAgICogYmVlbiBwdWJsaXNoZWRcbiAgICovXG4gIGFzeW5jIHNldFB1Ymxpc2hpbmdDb2RlY3MoY29kZWNzOiBTdWJzY3JpYmVkQ29kZWNbXSk6IFByb21pc2U8VmlkZW9Db2RlY1tdPiB7XG4gICAgdGhpcy5sb2cuZGVidWcoJ3NldHRpbmcgcHVibGlzaGluZyBjb2RlY3MnLCB7XG4gICAgICAuLi50aGlzLmxvZ0NvbnRleHQsXG4gICAgICBjb2RlY3MsXG4gICAgICBjdXJyZW50Q29kZWM6IHRoaXMuY29kZWMsXG4gICAgfSk7XG4gICAgLy8gb25seSBlbmFibGUgc2ltdWxjYXN0IGNvZGVjIGZvciBwcmVmZXJlbmNlIGNvZGVjIHNldHRlZFxuICAgIGlmICghdGhpcy5jb2RlYyAmJiBjb2RlY3MubGVuZ3RoID4gMCkge1xuICAgICAgYXdhaXQgdGhpcy5zZXRQdWJsaXNoaW5nTGF5ZXJzKGNvZGVjc1swXS5xdWFsaXRpZXMpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHRoaXMuc3Vic2NyaWJlZENvZGVjcyA9IGNvZGVjcztcblxuICAgIGNvbnN0IG5ld0NvZGVjczogVmlkZW9Db2RlY1tdID0gW107XG4gICAgZm9yIGF3YWl0IChjb25zdCBjb2RlYyBvZiBjb2RlY3MpIHtcbiAgICAgIGlmICghdGhpcy5jb2RlYyB8fCB0aGlzLmNvZGVjID09PSBjb2RlYy5jb2RlYykge1xuICAgICAgICBhd2FpdCB0aGlzLnNldFB1Ymxpc2hpbmdMYXllcnMoY29kZWMucXVhbGl0aWVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHNpbXVsY2FzdENvZGVjSW5mbyA9IHRoaXMuc2ltdWxjYXN0Q29kZWNzLmdldChjb2RlYy5jb2RlYyBhcyBWaWRlb0NvZGVjKTtcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoYHRyeSBzZXRQdWJsaXNoaW5nQ29kZWMgZm9yICR7Y29kZWMuY29kZWN9YCwge1xuICAgICAgICAgIC4uLnRoaXMubG9nQ29udGV4dCxcbiAgICAgICAgICBzaW11bGNhc3RDb2RlY0luZm8sXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXNpbXVsY2FzdENvZGVjSW5mbyB8fCAhc2ltdWxjYXN0Q29kZWNJbmZvLnNlbmRlcikge1xuICAgICAgICAgIGZvciAoY29uc3QgcSBvZiBjb2RlYy5xdWFsaXRpZXMpIHtcbiAgICAgICAgICAgIGlmIChxLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgbmV3Q29kZWNzLnB1c2goY29kZWMuY29kZWMgYXMgVmlkZW9Db2RlYyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzaW11bGNhc3RDb2RlY0luZm8uZW5jb2RpbmdzKSB7XG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoYHRyeSBzZXRQdWJsaXNoaW5nTGF5ZXJzRm9yU2VuZGVyICR7Y29kZWMuY29kZWN9YCwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgICBhd2FpdCBzZXRQdWJsaXNoaW5nTGF5ZXJzRm9yU2VuZGVyKFxuICAgICAgICAgICAgc2ltdWxjYXN0Q29kZWNJbmZvLnNlbmRlcixcbiAgICAgICAgICAgIHNpbXVsY2FzdENvZGVjSW5mby5lbmNvZGluZ3MhLFxuICAgICAgICAgICAgY29kZWMucXVhbGl0aWVzLFxuICAgICAgICAgICAgdGhpcy5zZW5kZXJMb2NrLFxuICAgICAgICAgICAgdGhpcy5sb2csXG4gICAgICAgICAgICB0aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3Q29kZWNzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBTZXRzIGxheWVycyB0aGF0IHNob3VsZCBiZSBwdWJsaXNoaW5nXG4gICAqL1xuICBhc3luYyBzZXRQdWJsaXNoaW5nTGF5ZXJzKHF1YWxpdGllczogU3Vic2NyaWJlZFF1YWxpdHlbXSkge1xuICAgIHRoaXMubG9nLmRlYnVnKCdzZXR0aW5nIHB1Ymxpc2hpbmcgbGF5ZXJzJywgeyAuLi50aGlzLmxvZ0NvbnRleHQsIHF1YWxpdGllcyB9KTtcbiAgICBpZiAoIXRoaXMuc2VuZGVyIHx8ICF0aGlzLmVuY29kaW5ncykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGF3YWl0IHNldFB1Ymxpc2hpbmdMYXllcnNGb3JTZW5kZXIoXG4gICAgICB0aGlzLnNlbmRlcixcbiAgICAgIHRoaXMuZW5jb2RpbmdzLFxuICAgICAgcXVhbGl0aWVzLFxuICAgICAgdGhpcy5zZW5kZXJMb2NrLFxuICAgICAgdGhpcy5sb2csXG4gICAgICB0aGlzLmxvZ0NvbnRleHQsXG4gICAgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBtb25pdG9yU2VuZGVyID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmICghdGhpcy5zZW5kZXIpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRCaXRyYXRlID0gMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgc3RhdHM6IFZpZGVvU2VuZGVyU3RhdHNbXSB8IHVuZGVmaW5lZDtcbiAgICB0cnkge1xuICAgICAgc3RhdHMgPSBhd2FpdCB0aGlzLmdldFNlbmRlclN0YXRzKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5sb2cuZXJyb3IoJ2NvdWxkIG5vdCBnZXQgYXVkaW8gc2VuZGVyIHN0YXRzJywgeyAuLi50aGlzLmxvZ0NvbnRleHQsIGVycm9yOiBlIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzdGF0c01hcCA9IG5ldyBNYXA8c3RyaW5nLCBWaWRlb1NlbmRlclN0YXRzPihzdGF0cy5tYXAoKHMpID0+IFtzLnJpZCwgc10pKTtcblxuICAgIGlmICh0aGlzLnByZXZTdGF0cykge1xuICAgICAgbGV0IHRvdGFsQml0cmF0ZSA9IDA7XG4gICAgICBzdGF0c01hcC5mb3JFYWNoKChzLCBrZXkpID0+IHtcbiAgICAgICAgY29uc3QgcHJldiA9IHRoaXMucHJldlN0YXRzPy5nZXQoa2V5KTtcbiAgICAgICAgdG90YWxCaXRyYXRlICs9IGNvbXB1dGVCaXRyYXRlKHMsIHByZXYpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9jdXJyZW50Qml0cmF0ZSA9IHRvdGFsQml0cmF0ZTtcbiAgICB9XG5cbiAgICB0aGlzLnByZXZTdGF0cyA9IHN0YXRzTWFwO1xuICB9O1xuXG4gIHByb3RlY3RlZCBhc3luYyBoYW5kbGVBcHBWaXNpYmlsaXR5Q2hhbmdlZCgpIHtcbiAgICBhd2FpdCBzdXBlci5oYW5kbGVBcHBWaXNpYmlsaXR5Q2hhbmdlZCgpO1xuICAgIGlmICghaXNNb2JpbGUoKSkgcmV0dXJuO1xuICAgIGlmICh0aGlzLmlzSW5CYWNrZ3JvdW5kICYmIHRoaXMuc291cmNlID09PSBUcmFjay5Tb3VyY2UuQ2FtZXJhKSB7XG4gICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLmVuYWJsZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gc2V0UHVibGlzaGluZ0xheWVyc0ZvclNlbmRlcihcbiAgc2VuZGVyOiBSVENSdHBTZW5kZXIsXG4gIHNlbmRlckVuY29kaW5nczogUlRDUnRwRW5jb2RpbmdQYXJhbWV0ZXJzW10sXG4gIHF1YWxpdGllczogU3Vic2NyaWJlZFF1YWxpdHlbXSxcbiAgc2VuZGVyTG9jazogTXV0ZXgsXG4gIGxvZzogU3RydWN0dXJlZExvZ2dlcixcbiAgbG9nQ29udGV4dDogUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4pIHtcbiAgY29uc3QgdW5sb2NrID0gYXdhaXQgc2VuZGVyTG9jay5sb2NrKCk7XG4gIGxvZy5kZWJ1Zygnc2V0UHVibGlzaGluZ0xheWVyc0ZvclNlbmRlcicsIHsgLi4ubG9nQ29udGV4dCwgc2VuZGVyLCBxdWFsaXRpZXMsIHNlbmRlckVuY29kaW5ncyB9KTtcbiAgdHJ5IHtcbiAgICBjb25zdCBwYXJhbXMgPSBzZW5kZXIuZ2V0UGFyYW1ldGVycygpO1xuICAgIGNvbnN0IHsgZW5jb2RpbmdzIH0gPSBwYXJhbXM7XG4gICAgaWYgKCFlbmNvZGluZ3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZW5jb2RpbmdzLmxlbmd0aCAhPT0gc2VuZGVyRW5jb2RpbmdzLmxlbmd0aCkge1xuICAgICAgbG9nLndhcm4oJ2Nhbm5vdCBzZXQgcHVibGlzaGluZyBsYXllcnMsIGVuY29kaW5ncyBtaXNtYXRjaCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBoYXNDaGFuZ2VkID0gZmFsc2U7XG5cbiAgICAvKiBkaXNhYmxlIGNsb3NhYmxlIHNwYXRpYWwgbGF5ZXIgYXMgaXQgaGFzIHZpZGVvIGJsdXIgLyBmcm96ZW4gaXNzdWUgd2l0aCBjdXJyZW50IHNlcnZlciAvIGNsaWVudFxuICAgIDEuIGNocm9tZSAxMTM6IHdoZW4gc3dpdGNoaW5nIHRvIHVwIGxheWVyIHdpdGggc2NhbGFiaWxpdHkgTW9kZSBjaGFuZ2UsIGl0IHdpbGwgZ2VuZXJhdGUgYVxuICAgICAgICAgIGxvdyByZXNvbHV0aW9uIGZyYW1lIGFuZCByZWNvdmVyIHZlcnkgcXVpY2tseSwgYnV0IG5vdGljYWJsZVxuICAgIDIuIGxpdmVraXQgc2Z1OiBhZGRpdGlvbmFsIHBsaSByZXF1ZXN0IGNhdXNlIHZpZGVvIGZyb3plbiBmb3IgYSBmZXcgZnJhbWVzLCBhbHNvIG5vdGljYWJsZSAqL1xuICAgIGNvbnN0IGNsb3NhYmxlU3BhdGlhbCA9IGZhbHNlO1xuICAgIC8qIEB0cy1pZ25vcmUgKi9cbiAgICBpZiAoY2xvc2FibGVTcGF0aWFsICYmIGVuY29kaW5nc1swXS5zY2FsYWJpbGl0eU1vZGUpIHtcbiAgICAgIC8vIHN2YyBkeW5hY2FzdCBlbmNvZGluZ3NcbiAgICAgIGNvbnN0IGVuY29kaW5nID0gZW5jb2RpbmdzWzBdO1xuICAgICAgLyogQHRzLWlnbm9yZSAqL1xuICAgICAgLy8gY29uc3QgbW9kZSA9IG5ldyBTY2FsYWJpbGl0eU1vZGUoZW5jb2Rpbmcuc2NhbGFiaWxpdHlNb2RlKTtcbiAgICAgIGxldCBtYXhRdWFsaXR5ID0gVmlkZW9RdWFsaXR5Lk9GRjtcbiAgICAgIHF1YWxpdGllcy5mb3JFYWNoKChxKSA9PiB7XG4gICAgICAgIGlmIChxLmVuYWJsZWQgJiYgKG1heFF1YWxpdHkgPT09IFZpZGVvUXVhbGl0eS5PRkYgfHwgcS5xdWFsaXR5ID4gbWF4UXVhbGl0eSkpIHtcbiAgICAgICAgICBtYXhRdWFsaXR5ID0gcS5xdWFsaXR5O1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKG1heFF1YWxpdHkgPT09IFZpZGVvUXVhbGl0eS5PRkYpIHtcbiAgICAgICAgaWYgKGVuY29kaW5nLmFjdGl2ZSkge1xuICAgICAgICAgIGVuY29kaW5nLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgIGhhc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFlbmNvZGluZy5hY3RpdmUgLyogfHwgbW9kZS5zcGF0aWFsICE9PSBtYXhRdWFsaXR5ICsgMSovKSB7XG4gICAgICAgIGhhc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICBlbmNvZGluZy5hY3RpdmUgPSB0cnVlO1xuICAgICAgICAvKlxuICAgICAgICBAdHMtaWdub3JlXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsTW9kZSA9IG5ldyBTY2FsYWJpbGl0eU1vZGUoc2VuZGVyRW5jb2RpbmdzWzBdLnNjYWxhYmlsaXR5TW9kZSlcbiAgICAgICAgbW9kZS5zcGF0aWFsID0gbWF4UXVhbGl0eSArIDE7XG4gICAgICAgIG1vZGUuc3VmZml4ID0gb3JpZ2luYWxNb2RlLnN1ZmZpeDtcbiAgICAgICAgaWYgKG1vZGUuc3BhdGlhbCA9PT0gMSkge1xuICAgICAgICAgIC8vIG5vIHN1ZmZpeCBmb3IgTDFUeFxuICAgICAgICAgIG1vZGUuc3VmZml4ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIEB0cy1pZ25vcmVcbiAgICAgICAgZW5jb2Rpbmcuc2NhbGFiaWxpdHlNb2RlID0gbW9kZS50b1N0cmluZygpO1xuICAgICAgICBlbmNvZGluZy5zY2FsZVJlc29sdXRpb25Eb3duQnkgPSAyICoqICgyIC0gbWF4UXVhbGl0eSk7XG4gICAgICAqL1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzaW11bGNhc3QgZHluYWNhc3QgZW5jb2RpbmdzXG4gICAgICBlbmNvZGluZ3MuZm9yRWFjaCgoZW5jb2RpbmcsIGlkeCkgPT4ge1xuICAgICAgICBsZXQgcmlkID0gZW5jb2RpbmcucmlkID8/ICcnO1xuICAgICAgICBpZiAocmlkID09PSAnJykge1xuICAgICAgICAgIHJpZCA9ICdxJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBxdWFsaXR5ID0gdmlkZW9RdWFsaXR5Rm9yUmlkKHJpZCk7XG4gICAgICAgIGNvbnN0IHN1YnNjcmliZWRRdWFsaXR5ID0gcXVhbGl0aWVzLmZpbmQoKHEpID0+IHEucXVhbGl0eSA9PT0gcXVhbGl0eSk7XG4gICAgICAgIGlmICghc3Vic2NyaWJlZFF1YWxpdHkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuY29kaW5nLmFjdGl2ZSAhPT0gc3Vic2NyaWJlZFF1YWxpdHkuZW5hYmxlZCkge1xuICAgICAgICAgIGhhc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgIGVuY29kaW5nLmFjdGl2ZSA9IHN1YnNjcmliZWRRdWFsaXR5LmVuYWJsZWQ7XG4gICAgICAgICAgbG9nLmRlYnVnKFxuICAgICAgICAgICAgYHNldHRpbmcgbGF5ZXIgJHtzdWJzY3JpYmVkUXVhbGl0eS5xdWFsaXR5fSB0byAke1xuICAgICAgICAgICAgICBlbmNvZGluZy5hY3RpdmUgPyAnZW5hYmxlZCcgOiAnZGlzYWJsZWQnXG4gICAgICAgICAgICB9YCxcbiAgICAgICAgICAgIGxvZ0NvbnRleHQsXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIC8vIEZpcmVGb3ggZG9lcyBub3Qgc3VwcG9ydCBzZXR0aW5nIGVuY29kaW5nLmFjdGl2ZSB0byBmYWxzZSwgc28gd2VcbiAgICAgICAgICAvLyBoYXZlIGEgd29ya2Fyb3VuZCBvZiBsb3dlcmluZyBpdHMgYml0cmF0ZSBhbmQgcmVzb2x1dGlvbiB0byB0aGUgbWluLlxuICAgICAgICAgIGlmIChpc0ZpcmVGb3goKSkge1xuICAgICAgICAgICAgaWYgKHN1YnNjcmliZWRRdWFsaXR5LmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgZW5jb2Rpbmcuc2NhbGVSZXNvbHV0aW9uRG93bkJ5ID0gc2VuZGVyRW5jb2RpbmdzW2lkeF0uc2NhbGVSZXNvbHV0aW9uRG93bkJ5O1xuICAgICAgICAgICAgICBlbmNvZGluZy5tYXhCaXRyYXRlID0gc2VuZGVyRW5jb2RpbmdzW2lkeF0ubWF4Qml0cmF0ZTtcbiAgICAgICAgICAgICAgLyogQHRzLWlnbm9yZSAqL1xuICAgICAgICAgICAgICBlbmNvZGluZy5tYXhGcmFtZVJhdGUgPSBzZW5kZXJFbmNvZGluZ3NbaWR4XS5tYXhGcmFtZVJhdGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbmNvZGluZy5zY2FsZVJlc29sdXRpb25Eb3duQnkgPSA0O1xuICAgICAgICAgICAgICBlbmNvZGluZy5tYXhCaXRyYXRlID0gMTA7XG4gICAgICAgICAgICAgIC8qIEB0cy1pZ25vcmUgKi9cbiAgICAgICAgICAgICAgZW5jb2RpbmcubWF4RnJhbWVSYXRlID0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChoYXNDaGFuZ2VkKSB7XG4gICAgICBwYXJhbXMuZW5jb2RpbmdzID0gZW5jb2RpbmdzO1xuICAgICAgbG9nLmRlYnVnKGBzZXR0aW5nIGVuY29kaW5nc2AsIHsgLi4ubG9nQ29udGV4dCwgZW5jb2RpbmdzOiBwYXJhbXMuZW5jb2RpbmdzIH0pO1xuICAgICAgYXdhaXQgc2VuZGVyLnNldFBhcmFtZXRlcnMocGFyYW1zKTtcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgdW5sb2NrKCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZpZGVvUXVhbGl0eUZvclJpZChyaWQ6IHN0cmluZyk6IFZpZGVvUXVhbGl0eSB7XG4gIHN3aXRjaCAocmlkKSB7XG4gICAgY2FzZSAnZic6XG4gICAgICByZXR1cm4gVmlkZW9RdWFsaXR5LkhJR0g7XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gVmlkZW9RdWFsaXR5Lk1FRElVTTtcbiAgICBjYXNlICdxJzpcbiAgICAgIHJldHVybiBWaWRlb1F1YWxpdHkuTE9XO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gVmlkZW9RdWFsaXR5LkhJR0g7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZpZGVvTGF5ZXJzRnJvbUVuY29kaW5ncyhcbiAgd2lkdGg6IG51bWJlcixcbiAgaGVpZ2h0OiBudW1iZXIsXG4gIGVuY29kaW5ncz86IFJUQ1J0cEVuY29kaW5nUGFyYW1ldGVyc1tdLFxuICBzdmM/OiBib29sZWFuLFxuKTogVmlkZW9MYXllcltdIHtcbiAgLy8gZGVmYXVsdCB0byBhIHNpbmdsZSBsYXllciwgSFFcbiAgaWYgKCFlbmNvZGluZ3MpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbmV3IFZpZGVvTGF5ZXIoe1xuICAgICAgICBxdWFsaXR5OiBWaWRlb1F1YWxpdHkuSElHSCxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgYml0cmF0ZTogMCxcbiAgICAgICAgc3NyYzogMCxcbiAgICAgIH0pLFxuICAgIF07XG4gIH1cblxuICBpZiAoc3ZjKSB7XG4gICAgLy8gc3ZjIGxheWVyc1xuICAgIC8qIEB0cy1pZ25vcmUgKi9cbiAgICBjb25zdCBlbmNvZGluZ1NNID0gZW5jb2RpbmdzWzBdLnNjYWxhYmlsaXR5TW9kZSBhcyBzdHJpbmc7XG4gICAgY29uc3Qgc20gPSBuZXcgU2NhbGFiaWxpdHlNb2RlKGVuY29kaW5nU00pO1xuICAgIGNvbnN0IGxheWVycyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc20uc3BhdGlhbDsgaSArPSAxKSB7XG4gICAgICBsYXllcnMucHVzaChcbiAgICAgICAgbmV3IFZpZGVvTGF5ZXIoe1xuICAgICAgICAgIHF1YWxpdHk6IFZpZGVvUXVhbGl0eS5ISUdIIC0gaSxcbiAgICAgICAgICB3aWR0aDogTWF0aC5jZWlsKHdpZHRoIC8gMiAqKiBpKSxcbiAgICAgICAgICBoZWlnaHQ6IE1hdGguY2VpbChoZWlnaHQgLyAyICoqIGkpLFxuICAgICAgICAgIGJpdHJhdGU6IGVuY29kaW5nc1swXS5tYXhCaXRyYXRlID8gTWF0aC5jZWlsKGVuY29kaW5nc1swXS5tYXhCaXRyYXRlIC8gMyAqKiBpKSA6IDAsXG4gICAgICAgICAgc3NyYzogMCxcbiAgICAgICAgfSksXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gbGF5ZXJzO1xuICB9XG5cbiAgcmV0dXJuIGVuY29kaW5ncy5tYXAoKGVuY29kaW5nKSA9PiB7XG4gICAgY29uc3Qgc2NhbGUgPSBlbmNvZGluZy5zY2FsZVJlc29sdXRpb25Eb3duQnkgPz8gMTtcbiAgICBsZXQgcXVhbGl0eSA9IHZpZGVvUXVhbGl0eUZvclJpZChlbmNvZGluZy5yaWQgPz8gJycpO1xuICAgIHJldHVybiBuZXcgVmlkZW9MYXllcih7XG4gICAgICBxdWFsaXR5LFxuICAgICAgd2lkdGg6IE1hdGguY2VpbCh3aWR0aCAvIHNjYWxlKSxcbiAgICAgIGhlaWdodDogTWF0aC5jZWlsKGhlaWdodCAvIHNjYWxlKSxcbiAgICAgIGJpdHJhdGU6IGVuY29kaW5nLm1heEJpdHJhdGUgPz8gMCxcbiAgICAgIHNzcmM6IDAsXG4gICAgfSk7XG4gIH0pO1xufVxuIiwiaW1wb3J0IHsgVHJhY2tFdmVudCB9IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgeyBtb25pdG9yRnJlcXVlbmN5IH0gZnJvbSAnLi4vc3RhdHMnO1xuaW1wb3J0IHR5cGUgeyBMb2dnZXJPcHRpb25zIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgVHJhY2sgfSBmcm9tICcuL1RyYWNrJztcblxuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgUmVtb3RlVHJhY2sgZXh0ZW5kcyBUcmFjayB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcmVjZWl2ZXI/OiBSVENSdHBSZWNlaXZlcjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBtZWRpYVRyYWNrOiBNZWRpYVN0cmVhbVRyYWNrLFxuICAgIHNpZDogc3RyaW5nLFxuICAgIGtpbmQ6IFRyYWNrLktpbmQsXG4gICAgcmVjZWl2ZXI/OiBSVENSdHBSZWNlaXZlcixcbiAgICBsb2dnZXJPcHRpb25zPzogTG9nZ2VyT3B0aW9ucyxcbiAgKSB7XG4gICAgc3VwZXIobWVkaWFUcmFjaywga2luZCwgbG9nZ2VyT3B0aW9ucyk7XG5cbiAgICB0aGlzLnNpZCA9IHNpZDtcbiAgICB0aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHNldE11dGVkKG11dGVkOiBib29sZWFuKSB7XG4gICAgaWYgKHRoaXMuaXNNdXRlZCAhPT0gbXV0ZWQpIHtcbiAgICAgIHRoaXMuaXNNdXRlZCA9IG11dGVkO1xuICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5lbmFibGVkID0gIW11dGVkO1xuICAgICAgdGhpcy5lbWl0KG11dGVkID8gVHJhY2tFdmVudC5NdXRlZCA6IFRyYWNrRXZlbnQuVW5tdXRlZCwgdGhpcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzZXRNZWRpYVN0cmVhbShzdHJlYW06IE1lZGlhU3RyZWFtKSB7XG4gICAgLy8gdGhpcyBpcyBuZWVkZWQgdG8gZGV0ZXJtaW5lIHdoZW4gdGhlIHRyYWNrIGlzIGZpbmlzaGVkXG4gICAgdGhpcy5tZWRpYVN0cmVhbSA9IHN0cmVhbTtcbiAgICBjb25zdCBvblJlbW92ZVRyYWNrID0gKGV2ZW50OiBNZWRpYVN0cmVhbVRyYWNrRXZlbnQpID0+IHtcbiAgICAgIGlmIChldmVudC50cmFjayA9PT0gdGhpcy5fbWVkaWFTdHJlYW1UcmFjaykge1xuICAgICAgICBzdHJlYW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVtb3ZldHJhY2snLCBvblJlbW92ZVRyYWNrKTtcbiAgICAgICAgdGhpcy5yZWNlaXZlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fY3VycmVudEJpdHJhdGUgPSAwO1xuICAgICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5FbmRlZCwgdGhpcyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBzdHJlYW0uYWRkRXZlbnRMaXN0ZW5lcigncmVtb3ZldHJhY2snLCBvblJlbW92ZVRyYWNrKTtcbiAgfVxuXG4gIHN0YXJ0KCkge1xuICAgIHRoaXMuc3RhcnRNb25pdG9yKCk7XG4gICAgLy8gdXNlIGBlbmFibGVkYCBvZiB0cmFjayB0byBlbmFibGUgcmUtdXNlIG9mIHRyYW5zY2VpdmVyXG4gICAgc3VwZXIuZW5hYmxlKCk7XG4gIH1cblxuICBzdG9wKCkge1xuICAgIHRoaXMuc3RvcE1vbml0b3IoKTtcbiAgICAvLyB1c2UgYGVuYWJsZWRgIG9mIHRyYWNrIHRvIGVuYWJsZSByZS11c2Ugb2YgdHJhbnNjZWl2ZXJcbiAgICBzdXBlci5kaXNhYmxlKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgUlRDU3RhdHNSZXBvcnQgZm9yIHRoZSBSZW1vdGVUcmFjaydzIHVuZGVybHlpbmcgUlRDUnRwUmVjZWl2ZXJcbiAgICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9SVENTdGF0c1JlcG9ydFxuICAgKlxuICAgKiBAcmV0dXJucyBQcm9taXNlPFJUQ1N0YXRzUmVwb3J0PiB8IHVuZGVmaW5lZFxuICAgKi9cbiAgYXN5bmMgZ2V0UlRDU3RhdHNSZXBvcnQoKTogUHJvbWlzZTxSVENTdGF0c1JlcG9ydCB8IHVuZGVmaW5lZD4ge1xuICAgIGlmICghdGhpcy5yZWNlaXZlcj8uZ2V0U3RhdHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3RhdHNSZXBvcnQgPSBhd2FpdCB0aGlzLnJlY2VpdmVyLmdldFN0YXRzKCk7XG4gICAgcmV0dXJuIHN0YXRzUmVwb3J0O1xuICB9XG5cbiAgLyogQGludGVybmFsICovXG4gIHN0YXJ0TW9uaXRvcigpIHtcbiAgICBpZiAoIXRoaXMubW9uaXRvckludGVydmFsKSB7XG4gICAgICB0aGlzLm1vbml0b3JJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHRoaXMubW9uaXRvclJlY2VpdmVyKCksIG1vbml0b3JGcmVxdWVuY3kpO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBhYnN0cmFjdCBtb25pdG9yUmVjZWl2ZXIoKTogdm9pZDtcbn1cbiIsImltcG9ydCB7IFRyYWNrRXZlbnQgfSBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IHsgY29tcHV0ZUJpdHJhdGUgfSBmcm9tICcuLi9zdGF0cyc7XG5pbXBvcnQgdHlwZSB7IEF1ZGlvUmVjZWl2ZXJTdGF0cyB9IGZyb20gJy4uL3N0YXRzJztcbmltcG9ydCB0eXBlIHsgTG9nZ2VyT3B0aW9ucyB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IGlzUmVhY3ROYXRpdmUsIHN1cHBvcnRzU2V0U2lua0lkIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IFJlbW90ZVRyYWNrIGZyb20gJy4vUmVtb3RlVHJhY2snO1xuaW1wb3J0IHsgVHJhY2sgfSBmcm9tICcuL1RyYWNrJztcbmltcG9ydCB0eXBlIHsgQXVkaW9PdXRwdXRPcHRpb25zIH0gZnJvbSAnLi9vcHRpb25zJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVtb3RlQXVkaW9UcmFjayBleHRlbmRzIFJlbW90ZVRyYWNrIHtcbiAgcHJpdmF0ZSBwcmV2U3RhdHM/OiBBdWRpb1JlY2VpdmVyU3RhdHM7XG5cbiAgcHJpdmF0ZSBlbGVtZW50Vm9sdW1lOiBudW1iZXIgfCB1bmRlZmluZWQ7XG5cbiAgcHJpdmF0ZSBhdWRpb0NvbnRleHQ/OiBBdWRpb0NvbnRleHQ7XG5cbiAgcHJpdmF0ZSBnYWluTm9kZT86IEdhaW5Ob2RlO1xuXG4gIHByaXZhdGUgc291cmNlTm9kZT86IE1lZGlhU3RyZWFtQXVkaW9Tb3VyY2VOb2RlO1xuXG4gIHByaXZhdGUgd2ViQXVkaW9QbHVnaW5Ob2RlczogQXVkaW9Ob2RlW107XG5cbiAgcHJpdmF0ZSBzaW5rSWQ/OiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgbWVkaWFUcmFjazogTWVkaWFTdHJlYW1UcmFjayxcbiAgICBzaWQ6IHN0cmluZyxcbiAgICByZWNlaXZlcj86IFJUQ1J0cFJlY2VpdmVyLFxuICAgIGF1ZGlvQ29udGV4dD86IEF1ZGlvQ29udGV4dCxcbiAgICBhdWRpb091dHB1dD86IEF1ZGlvT3V0cHV0T3B0aW9ucyxcbiAgICBsb2dnZXJPcHRpb25zPzogTG9nZ2VyT3B0aW9ucyxcbiAgKSB7XG4gICAgc3VwZXIobWVkaWFUcmFjaywgc2lkLCBUcmFjay5LaW5kLkF1ZGlvLCByZWNlaXZlciwgbG9nZ2VyT3B0aW9ucyk7XG4gICAgdGhpcy5hdWRpb0NvbnRleHQgPSBhdWRpb0NvbnRleHQ7XG4gICAgdGhpcy53ZWJBdWRpb1BsdWdpbk5vZGVzID0gW107XG4gICAgaWYgKGF1ZGlvT3V0cHV0KSB7XG4gICAgICB0aGlzLnNpbmtJZCA9IGF1ZGlvT3V0cHV0LmRldmljZUlkO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBzZXRzIHRoZSB2b2x1bWUgZm9yIGFsbCBhdHRhY2hlZCBhdWRpbyBlbGVtZW50c1xuICAgKi9cbiAgc2V0Vm9sdW1lKHZvbHVtZTogbnVtYmVyKSB7XG4gICAgZm9yIChjb25zdCBlbCBvZiB0aGlzLmF0dGFjaGVkRWxlbWVudHMpIHtcbiAgICAgIGlmICh0aGlzLmF1ZGlvQ29udGV4dCkge1xuICAgICAgICB0aGlzLmdhaW5Ob2RlPy5nYWluLnNldFRhcmdldEF0VGltZSh2b2x1bWUsIDAsIDAuMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbC52b2x1bWUgPSB2b2x1bWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc1JlYWN0TmF0aXZlKCkpIHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suX3NldFZvbHVtZSh2b2x1bWUpO1xuICAgIH1cbiAgICB0aGlzLmVsZW1lbnRWb2x1bWUgPSB2b2x1bWU7XG4gIH1cblxuICAvKipcbiAgICogZ2V0cyB0aGUgdm9sdW1lIG9mIGF0dGFjaGVkIGF1ZGlvIGVsZW1lbnRzIChsb3VkZXN0KVxuICAgKi9cbiAgZ2V0Vm9sdW1lKCk6IG51bWJlciB7XG4gICAgaWYgKHRoaXMuZWxlbWVudFZvbHVtZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudFZvbHVtZTtcbiAgICB9XG4gICAgaWYgKGlzUmVhY3ROYXRpdmUoKSkge1xuICAgICAgLy8gUk4gdm9sdW1lIHZhbHVlIGRlZmF1bHRzIHRvIDEuMCBpZiBoYXNuJ3QgYmVlbiBjaGFuZ2VkLlxuICAgICAgcmV0dXJuIDEuMDtcbiAgICB9XG4gICAgbGV0IGhpZ2hlc3RWb2x1bWUgPSAwO1xuICAgIHRoaXMuYXR0YWNoZWRFbGVtZW50cy5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgICBpZiAoZWxlbWVudC52b2x1bWUgPiBoaWdoZXN0Vm9sdW1lKSB7XG4gICAgICAgIGhpZ2hlc3RWb2x1bWUgPSBlbGVtZW50LnZvbHVtZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gaGlnaGVzdFZvbHVtZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBjYWxscyBzZXRTaW5rSWQgb24gYWxsIGF0dGFjaGVkIGVsZW1lbnRzLCBpZiBzdXBwb3J0ZWRcbiAgICogQHBhcmFtIGRldmljZUlkIGF1ZGlvIG91dHB1dCBkZXZpY2VcbiAgICovXG4gIGFzeW5jIHNldFNpbmtJZChkZXZpY2VJZDogc3RyaW5nKSB7XG4gICAgdGhpcy5zaW5rSWQgPSBkZXZpY2VJZDtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIHRoaXMuYXR0YWNoZWRFbGVtZW50cy5tYXAoKGVsbSkgPT4ge1xuICAgICAgICBpZiAoIXN1cHBvcnRzU2V0U2lua0lkKGVsbSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLyogQHRzLWlnbm9yZSAqL1xuICAgICAgICByZXR1cm4gZWxtLnNldFNpbmtJZChkZXZpY2VJZCkgYXMgUHJvbWlzZTx2b2lkPjtcbiAgICAgIH0pLFxuICAgICk7XG4gIH1cblxuICBhdHRhY2goKTogSFRNTE1lZGlhRWxlbWVudDtcbiAgYXR0YWNoKGVsZW1lbnQ6IEhUTUxNZWRpYUVsZW1lbnQpOiBIVE1MTWVkaWFFbGVtZW50O1xuICBhdHRhY2goZWxlbWVudD86IEhUTUxNZWRpYUVsZW1lbnQpOiBIVE1MTWVkaWFFbGVtZW50IHtcbiAgICBjb25zdCBuZWVkc05ld1dlYkF1ZGlvQ29ubmVjdGlvbiA9IHRoaXMuYXR0YWNoZWRFbGVtZW50cy5sZW5ndGggPT09IDA7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICBlbGVtZW50ID0gc3VwZXIuYXR0YWNoKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1cGVyLmF0dGFjaChlbGVtZW50KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zaW5rSWQgJiYgc3VwcG9ydHNTZXRTaW5rSWQoZWxlbWVudCkpIHtcbiAgICAgIC8qIEB0cy1pZ25vcmUgKi9cbiAgICAgIGVsZW1lbnQuc2V0U2lua0lkKHRoaXMuc2lua0lkKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYXVkaW9Db250ZXh0ICYmIG5lZWRzTmV3V2ViQXVkaW9Db25uZWN0aW9uKSB7XG4gICAgICB0aGlzLmxvZy5kZWJ1ZygndXNpbmcgYXVkaW8gY29udGV4dCBtYXBwaW5nJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHRoaXMuY29ubmVjdFdlYkF1ZGlvKHRoaXMuYXVkaW9Db250ZXh0LCBlbGVtZW50KTtcbiAgICAgIGVsZW1lbnQudm9sdW1lID0gMDtcbiAgICAgIGVsZW1lbnQubXV0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmVsZW1lbnRWb2x1bWUpIHtcbiAgICAgIC8vIG1ha2Ugc3VyZSB2b2x1bWUgc2V0dGluZyBpcyBiZWluZyBhcHBsaWVkIHRvIHRoZSBuZXdseSBhdHRhY2hlZCBlbGVtZW50XG4gICAgICB0aGlzLnNldFZvbHVtZSh0aGlzLmVsZW1lbnRWb2x1bWUpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIERldGFjaGVzIGZyb20gYWxsIGF0dGFjaGVkIGVsZW1lbnRzXG4gICAqL1xuICBkZXRhY2goKTogSFRNTE1lZGlhRWxlbWVudFtdO1xuXG4gIC8qKlxuICAgKiBEZXRhY2ggZnJvbSBhIHNpbmdsZSBlbGVtZW50XG4gICAqIEBwYXJhbSBlbGVtZW50XG4gICAqL1xuICBkZXRhY2goZWxlbWVudDogSFRNTE1lZGlhRWxlbWVudCk6IEhUTUxNZWRpYUVsZW1lbnQ7XG4gIGRldGFjaChlbGVtZW50PzogSFRNTE1lZGlhRWxlbWVudCk6IEhUTUxNZWRpYUVsZW1lbnQgfCBIVE1MTWVkaWFFbGVtZW50W10ge1xuICAgIGxldCBkZXRhY2hlZDogSFRNTE1lZGlhRWxlbWVudCB8IEhUTUxNZWRpYUVsZW1lbnRbXTtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIGRldGFjaGVkID0gc3VwZXIuZGV0YWNoKCk7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3RXZWJBdWRpbygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZXRhY2hlZCA9IHN1cGVyLmRldGFjaChlbGVtZW50KTtcbiAgICAgIC8vIGlmIHRoZXJlIGFyZSBzdGlsbCBhbnkgYXR0YWNoZWQgZWxlbWVudHMgYWZ0ZXIgZGV0YWNoaW5nLCBjb25uZWN0IHdlYmF1ZGlvIHRvIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQncyBsZWZ0XG4gICAgICAvLyBkaXNjb25uZWN0IHdlYmF1ZGlvIG90aGVyd2lzZVxuICAgICAgaWYgKHRoaXMuYXVkaW9Db250ZXh0KSB7XG4gICAgICAgIGlmICh0aGlzLmF0dGFjaGVkRWxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRoaXMuY29ubmVjdFdlYkF1ZGlvKHRoaXMuYXVkaW9Db250ZXh0LCB0aGlzLmF0dGFjaGVkRWxlbWVudHNbMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZGlzY29ubmVjdFdlYkF1ZGlvKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRldGFjaGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAZXhwZXJpbWVudGFsXG4gICAqL1xuICBzZXRBdWRpb0NvbnRleHQoYXVkaW9Db250ZXh0OiBBdWRpb0NvbnRleHQgfCB1bmRlZmluZWQpIHtcbiAgICB0aGlzLmF1ZGlvQ29udGV4dCA9IGF1ZGlvQ29udGV4dDtcbiAgICBpZiAoYXVkaW9Db250ZXh0ICYmIHRoaXMuYXR0YWNoZWRFbGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmNvbm5lY3RXZWJBdWRpbyhhdWRpb0NvbnRleHQsIHRoaXMuYXR0YWNoZWRFbGVtZW50c1swXSk7XG4gICAgfSBlbHNlIGlmICghYXVkaW9Db250ZXh0KSB7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3RXZWJBdWRpbygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQGV4cGVyaW1lbnRhbFxuICAgKiBAcGFyYW0ge0F1ZGlvTm9kZVtdfSBub2RlcyAtIEFuIGFycmF5IG9mIFdlYkF1ZGlvIG5vZGVzLiBUaGVzZSBub2RlcyBzaG91bGQgbm90IGJlIGNvbm5lY3RlZCB0byBlYWNoIG90aGVyIHdoZW4gcGFzc2VkLCBhcyB0aGUgc2RrIHdpbGwgdGFrZSBjYXJlIG9mIGNvbm5lY3RpbmcgdGhlbSBpbiB0aGUgb3JkZXIgb2YgdGhlIGFycmF5LlxuICAgKi9cbiAgc2V0V2ViQXVkaW9QbHVnaW5zKG5vZGVzOiBBdWRpb05vZGVbXSkge1xuICAgIHRoaXMud2ViQXVkaW9QbHVnaW5Ob2RlcyA9IG5vZGVzO1xuICAgIGlmICh0aGlzLmF0dGFjaGVkRWxlbWVudHMubGVuZ3RoID4gMCAmJiB0aGlzLmF1ZGlvQ29udGV4dCkge1xuICAgICAgdGhpcy5jb25uZWN0V2ViQXVkaW8odGhpcy5hdWRpb0NvbnRleHQsIHRoaXMuYXR0YWNoZWRFbGVtZW50c1swXSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjb25uZWN0V2ViQXVkaW8oY29udGV4dDogQXVkaW9Db250ZXh0LCBlbGVtZW50OiBIVE1MTWVkaWFFbGVtZW50KSB7XG4gICAgdGhpcy5kaXNjb25uZWN0V2ViQXVkaW8oKTtcbiAgICAvLyBAdHMtaWdub3JlIGF0dGFjaGVkIGVsZW1lbnRzIGFsd2F5cyBoYXZlIGEgc3JjT2JqZWN0IHNldFxuICAgIHRoaXMuc291cmNlTm9kZSA9IGNvbnRleHQuY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2UoZWxlbWVudC5zcmNPYmplY3QpO1xuICAgIGxldCBsYXN0Tm9kZTogQXVkaW9Ob2RlID0gdGhpcy5zb3VyY2VOb2RlO1xuICAgIHRoaXMud2ViQXVkaW9QbHVnaW5Ob2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICBsYXN0Tm9kZS5jb25uZWN0KG5vZGUpO1xuICAgICAgbGFzdE5vZGUgPSBub2RlO1xuICAgIH0pO1xuICAgIHRoaXMuZ2Fpbk5vZGUgPSBjb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgICBsYXN0Tm9kZS5jb25uZWN0KHRoaXMuZ2Fpbk5vZGUpO1xuICAgIHRoaXMuZ2Fpbk5vZGUuY29ubmVjdChjb250ZXh0LmRlc3RpbmF0aW9uKTtcblxuICAgIGlmICh0aGlzLmVsZW1lbnRWb2x1bWUpIHtcbiAgICAgIHRoaXMuZ2Fpbk5vZGUuZ2Fpbi5zZXRUYXJnZXRBdFRpbWUodGhpcy5lbGVtZW50Vm9sdW1lLCAwLCAwLjEpO1xuICAgIH1cblxuICAgIC8vIHRyeSB0byByZXN1bWUgdGhlIGNvbnRleHQgaWYgaXQgaXNuJ3QgcnVubmluZyBhbHJlYWR5XG4gICAgaWYgKGNvbnRleHQuc3RhdGUgIT09ICdydW5uaW5nJykge1xuICAgICAgY29udGV4dFxuICAgICAgICAucmVzdW1lKClcbiAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIGlmIChjb250ZXh0LnN0YXRlICE9PSAncnVubmluZycpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcbiAgICAgICAgICAgICAgVHJhY2tFdmVudC5BdWRpb1BsYXliYWNrRmFpbGVkLFxuICAgICAgICAgICAgICBuZXcgRXJyb3IoXCJBdWRpbyBDb250ZXh0IGNvdWxkbid0IGJlIHN0YXJ0ZWQgYXV0b21hdGljYWxseVwiKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5BdWRpb1BsYXliYWNrRmFpbGVkLCBlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBkaXNjb25uZWN0V2ViQXVkaW8oKSB7XG4gICAgdGhpcy5nYWluTm9kZT8uZGlzY29ubmVjdCgpO1xuICAgIHRoaXMuc291cmNlTm9kZT8uZGlzY29ubmVjdCgpO1xuICAgIHRoaXMuZ2Fpbk5vZGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zb3VyY2VOb2RlID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgcHJvdGVjdGVkIG1vbml0b3JSZWNlaXZlciA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoIXRoaXMucmVjZWl2ZXIpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRCaXRyYXRlID0gMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3RhdHMgPSBhd2FpdCB0aGlzLmdldFJlY2VpdmVyU3RhdHMoKTtcblxuICAgIGlmIChzdGF0cyAmJiB0aGlzLnByZXZTdGF0cyAmJiB0aGlzLnJlY2VpdmVyKSB7XG4gICAgICB0aGlzLl9jdXJyZW50Qml0cmF0ZSA9IGNvbXB1dGVCaXRyYXRlKHN0YXRzLCB0aGlzLnByZXZTdGF0cyk7XG4gICAgfVxuXG4gICAgdGhpcy5wcmV2U3RhdHMgPSBzdGF0cztcbiAgfTtcblxuICBwcm90ZWN0ZWQgYXN5bmMgZ2V0UmVjZWl2ZXJTdGF0cygpOiBQcm9taXNlPEF1ZGlvUmVjZWl2ZXJTdGF0cyB8IHVuZGVmaW5lZD4ge1xuICAgIGlmICghdGhpcy5yZWNlaXZlciB8fCAhdGhpcy5yZWNlaXZlci5nZXRTdGF0cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXRzID0gYXdhaXQgdGhpcy5yZWNlaXZlci5nZXRTdGF0cygpO1xuICAgIGxldCByZWNlaXZlclN0YXRzOiBBdWRpb1JlY2VpdmVyU3RhdHMgfCB1bmRlZmluZWQ7XG4gICAgc3RhdHMuZm9yRWFjaCgodikgPT4ge1xuICAgICAgaWYgKHYudHlwZSA9PT0gJ2luYm91bmQtcnRwJykge1xuICAgICAgICByZWNlaXZlclN0YXRzID0ge1xuICAgICAgICAgIHR5cGU6ICdhdWRpbycsXG4gICAgICAgICAgdGltZXN0YW1wOiB2LnRpbWVzdGFtcCxcbiAgICAgICAgICBqaXR0ZXI6IHYuaml0dGVyLFxuICAgICAgICAgIGJ5dGVzUmVjZWl2ZWQ6IHYuYnl0ZXNSZWNlaXZlZCxcbiAgICAgICAgICBjb25jZWFsZWRTYW1wbGVzOiB2LmNvbmNlYWxlZFNhbXBsZXMsXG4gICAgICAgICAgY29uY2VhbG1lbnRFdmVudHM6IHYuY29uY2VhbG1lbnRFdmVudHMsXG4gICAgICAgICAgc2lsZW50Q29uY2VhbGVkU2FtcGxlczogdi5zaWxlbnRDb25jZWFsZWRTYW1wbGVzLFxuICAgICAgICAgIHNpbGVudENvbmNlYWxtZW50RXZlbnRzOiB2LnNpbGVudENvbmNlYWxtZW50RXZlbnRzLFxuICAgICAgICAgIHRvdGFsQXVkaW9FbmVyZ3k6IHYudG90YWxBdWRpb0VuZXJneSxcbiAgICAgICAgICB0b3RhbFNhbXBsZXNEdXJhdGlvbjogdi50b3RhbFNhbXBsZXNEdXJhdGlvbixcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVjZWl2ZXJTdGF0cztcbiAgfVxufVxuIiwiaW1wb3J0IHsgZGVib3VuY2UgfSBmcm9tICd0cy1kZWJvdW5jZSc7XG5pbXBvcnQgeyBUcmFja0V2ZW50IH0gZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCB0eXBlIHsgVmlkZW9SZWNlaXZlclN0YXRzIH0gZnJvbSAnLi4vc3RhdHMnO1xuaW1wb3J0IHsgY29tcHV0ZUJpdHJhdGUgfSBmcm9tICcuLi9zdGF0cyc7XG5pbXBvcnQgQ3JpdGljYWxUaW1lcnMgZnJvbSAnLi4vdGltZXJzJztcbmltcG9ydCB0eXBlIHsgTG9nZ2VyT3B0aW9ucyB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB0eXBlIHsgT2JzZXJ2YWJsZU1lZGlhRWxlbWVudCB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IGdldERldmljZVBpeGVsUmF0aW8sIGdldEludGVyc2VjdGlvbk9ic2VydmVyLCBnZXRSZXNpemVPYnNlcnZlciwgaXNXZWIgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgUmVtb3RlVHJhY2sgZnJvbSAnLi9SZW1vdGVUcmFjayc7XG5pbXBvcnQgeyBUcmFjaywgYXR0YWNoVG9FbGVtZW50LCBkZXRhY2hUcmFjayB9IGZyb20gJy4vVHJhY2snO1xuaW1wb3J0IHR5cGUgeyBBZGFwdGl2ZVN0cmVhbVNldHRpbmdzIH0gZnJvbSAnLi90eXBlcyc7XG5cbmNvbnN0IFJFQUNUSU9OX0RFTEFZID0gMTAwO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW1vdGVWaWRlb1RyYWNrIGV4dGVuZHMgUmVtb3RlVHJhY2sge1xuICBwcml2YXRlIHByZXZTdGF0cz86IFZpZGVvUmVjZWl2ZXJTdGF0cztcblxuICBwcml2YXRlIGVsZW1lbnRJbmZvczogRWxlbWVudEluZm9bXSA9IFtdO1xuXG4gIHByaXZhdGUgYWRhcHRpdmVTdHJlYW1TZXR0aW5ncz86IEFkYXB0aXZlU3RyZWFtU2V0dGluZ3M7XG5cbiAgcHJpdmF0ZSBsYXN0VmlzaWJsZT86IGJvb2xlYW47XG5cbiAgcHJpdmF0ZSBsYXN0RGltZW5zaW9ucz86IFRyYWNrLkRpbWVuc2lvbnM7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgbWVkaWFUcmFjazogTWVkaWFTdHJlYW1UcmFjayxcbiAgICBzaWQ6IHN0cmluZyxcbiAgICByZWNlaXZlcj86IFJUQ1J0cFJlY2VpdmVyLFxuICAgIGFkYXB0aXZlU3RyZWFtU2V0dGluZ3M/OiBBZGFwdGl2ZVN0cmVhbVNldHRpbmdzLFxuICAgIGxvZ2dlck9wdGlvbnM/OiBMb2dnZXJPcHRpb25zLFxuICApIHtcbiAgICBzdXBlcihtZWRpYVRyYWNrLCBzaWQsIFRyYWNrLktpbmQuVmlkZW8sIHJlY2VpdmVyLCBsb2dnZXJPcHRpb25zKTtcbiAgICB0aGlzLmFkYXB0aXZlU3RyZWFtU2V0dGluZ3MgPSBhZGFwdGl2ZVN0cmVhbVNldHRpbmdzO1xuICB9XG5cbiAgZ2V0IGlzQWRhcHRpdmVTdHJlYW0oKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuYWRhcHRpdmVTdHJlYW1TZXR0aW5ncyAhPT0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIE5vdGU6IFdoZW4gdXNpbmcgYWRhcHRpdmVTdHJlYW0sIHlvdSBuZWVkIHRvIHVzZSByZW1vdGVWaWRlb1RyYWNrLmF0dGFjaCgpIHRvIGFkZCB0aGUgdHJhY2sgdG8gYSBIVE1MVmlkZW9FbGVtZW50LCBvdGhlcndpc2UgeW91ciB2aWRlbyB0cmFja3MgbWlnaHQgbmV2ZXIgc3RhcnRcbiAgICovXG4gIGdldCBtZWRpYVN0cmVhbVRyYWNrKCkge1xuICAgIHJldHVybiB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzZXRNdXRlZChtdXRlZDogYm9vbGVhbikge1xuICAgIHN1cGVyLnNldE11dGVkKG11dGVkKTtcblxuICAgIHRoaXMuYXR0YWNoZWRFbGVtZW50cy5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgICAvLyBkZXRhY2ggb3IgYXR0YWNoXG4gICAgICBpZiAobXV0ZWQpIHtcbiAgICAgICAgZGV0YWNoVHJhY2sodGhpcy5fbWVkaWFTdHJlYW1UcmFjaywgZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdHRhY2hUb0VsZW1lbnQodGhpcy5fbWVkaWFTdHJlYW1UcmFjaywgZWxlbWVudCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBhdHRhY2goKTogSFRNTE1lZGlhRWxlbWVudDtcbiAgYXR0YWNoKGVsZW1lbnQ6IEhUTUxNZWRpYUVsZW1lbnQpOiBIVE1MTWVkaWFFbGVtZW50O1xuICBhdHRhY2goZWxlbWVudD86IEhUTUxNZWRpYUVsZW1lbnQpOiBIVE1MTWVkaWFFbGVtZW50IHtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIGVsZW1lbnQgPSBzdXBlci5hdHRhY2goKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3VwZXIuYXR0YWNoKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIC8vIEl0J3MgcG9zc2libGUgYXR0YWNoIGlzIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBvbiBhbiBlbGVtZW50LiBXaGVuIHRoYXQnc1xuICAgIC8vIHRoZSBjYXNlLCB3ZSdkIHdhbnQgdG8gYXZvaWQgYWRkaW5nIGR1cGxpY2F0ZSBlbGVtZW50SW5mb3NcbiAgICBpZiAoXG4gICAgICB0aGlzLmFkYXB0aXZlU3RyZWFtU2V0dGluZ3MgJiZcbiAgICAgIHRoaXMuZWxlbWVudEluZm9zLmZpbmQoKGluZm8pID0+IGluZm8uZWxlbWVudCA9PT0gZWxlbWVudCkgPT09IHVuZGVmaW5lZFxuICAgICkge1xuICAgICAgY29uc3QgZWxlbWVudEluZm8gPSBuZXcgSFRNTEVsZW1lbnRJbmZvKGVsZW1lbnQpO1xuICAgICAgdGhpcy5vYnNlcnZlRWxlbWVudEluZm8oZWxlbWVudEluZm8pO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBPYnNlcnZlIGFuIEVsZW1lbnRJbmZvIGZvciBjaGFuZ2VzIHdoZW4gYWRhcHRpdmUgc3RyZWFtaW5nLlxuICAgKiBAcGFyYW0gZWxlbWVudEluZm9cbiAgICogQGludGVybmFsXG4gICAqL1xuICBvYnNlcnZlRWxlbWVudEluZm8oZWxlbWVudEluZm86IEVsZW1lbnRJbmZvKSB7XG4gICAgaWYgKFxuICAgICAgdGhpcy5hZGFwdGl2ZVN0cmVhbVNldHRpbmdzICYmXG4gICAgICB0aGlzLmVsZW1lbnRJbmZvcy5maW5kKChpbmZvKSA9PiBpbmZvID09PSBlbGVtZW50SW5mbykgPT09IHVuZGVmaW5lZFxuICAgICkge1xuICAgICAgZWxlbWVudEluZm8uaGFuZGxlUmVzaXplID0gKCkgPT4ge1xuICAgICAgICB0aGlzLmRlYm91bmNlZEhhbmRsZVJlc2l6ZSgpO1xuICAgICAgfTtcbiAgICAgIGVsZW1lbnRJbmZvLmhhbmRsZVZpc2liaWxpdHlDaGFuZ2VkID0gKCkgPT4ge1xuICAgICAgICB0aGlzLnVwZGF0ZVZpc2liaWxpdHkoKTtcbiAgICAgIH07XG4gICAgICB0aGlzLmVsZW1lbnRJbmZvcy5wdXNoKGVsZW1lbnRJbmZvKTtcbiAgICAgIGVsZW1lbnRJbmZvLm9ic2VydmUoKTtcbiAgICAgIC8vIHRyaWdnZXIgdGhlIGZpcnN0IHJlc2l6ZSB1cGRhdGUgY3ljbGVcbiAgICAgIC8vIGlmIHRoZSB0YWIgaXMgYmFja2dyb3VuZGVkLCB0aGUgaW5pdGlhbCByZXNpemUgZXZlbnQgZG9lcyBub3QgZmlyZSB1bnRpbFxuICAgICAgLy8gdGhlIHRhYiBjb21lcyBpbnRvIGZvY3VzIGZvciB0aGUgZmlyc3QgdGltZS5cbiAgICAgIHRoaXMuZGVib3VuY2VkSGFuZGxlUmVzaXplKCk7XG4gICAgICB0aGlzLnVwZGF0ZVZpc2liaWxpdHkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sb2cud2FybigndmlzaWJpbGl0eSByZXNpemUgb2JzZXJ2ZXIgbm90IHRyaWdnZXJlZCcsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3Agb2JzZXJ2aW5nIGFuIEVsZW1lbnRJbmZvIGZvciBjaGFuZ2VzLlxuICAgKiBAcGFyYW0gZWxlbWVudEluZm9cbiAgICogQGludGVybmFsXG4gICAqL1xuICBzdG9wT2JzZXJ2aW5nRWxlbWVudEluZm8oZWxlbWVudEluZm86IEVsZW1lbnRJbmZvKSB7XG4gICAgaWYgKCF0aGlzLmlzQWRhcHRpdmVTdHJlYW0pIHtcbiAgICAgIHRoaXMubG9nLndhcm4oJ3N0b3BPYnNlcnZpbmdFbGVtZW50SW5mbyBpZ25vcmVkJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3RvcEVsZW1lbnRJbmZvcyA9IHRoaXMuZWxlbWVudEluZm9zLmZpbHRlcigoaW5mbykgPT4gaW5mbyA9PT0gZWxlbWVudEluZm8pO1xuICAgIGZvciAoY29uc3QgaW5mbyBvZiBzdG9wRWxlbWVudEluZm9zKSB7XG4gICAgICBpbmZvLnN0b3BPYnNlcnZpbmcoKTtcbiAgICB9XG4gICAgdGhpcy5lbGVtZW50SW5mb3MgPSB0aGlzLmVsZW1lbnRJbmZvcy5maWx0ZXIoKGluZm8pID0+IGluZm8gIT09IGVsZW1lbnRJbmZvKTtcbiAgICB0aGlzLnVwZGF0ZVZpc2liaWxpdHkoKTtcbiAgICB0aGlzLmRlYm91bmNlZEhhbmRsZVJlc2l6ZSgpO1xuICB9XG5cbiAgZGV0YWNoKCk6IEhUTUxNZWRpYUVsZW1lbnRbXTtcbiAgZGV0YWNoKGVsZW1lbnQ6IEhUTUxNZWRpYUVsZW1lbnQpOiBIVE1MTWVkaWFFbGVtZW50O1xuICBkZXRhY2goZWxlbWVudD86IEhUTUxNZWRpYUVsZW1lbnQpOiBIVE1MTWVkaWFFbGVtZW50IHwgSFRNTE1lZGlhRWxlbWVudFtdIHtcbiAgICBsZXQgZGV0YWNoZWRFbGVtZW50czogSFRNTE1lZGlhRWxlbWVudFtdID0gW107XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHRoaXMuc3RvcE9ic2VydmluZ0VsZW1lbnQoZWxlbWVudCk7XG4gICAgICByZXR1cm4gc3VwZXIuZGV0YWNoKGVsZW1lbnQpO1xuICAgIH1cbiAgICBkZXRhY2hlZEVsZW1lbnRzID0gc3VwZXIuZGV0YWNoKCk7XG5cbiAgICBmb3IgKGNvbnN0IGUgb2YgZGV0YWNoZWRFbGVtZW50cykge1xuICAgICAgdGhpcy5zdG9wT2JzZXJ2aW5nRWxlbWVudChlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGV0YWNoZWRFbGVtZW50cztcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZ2V0RGVjb2RlckltcGxlbWVudGF0aW9uKCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMucHJldlN0YXRzPy5kZWNvZGVySW1wbGVtZW50YXRpb247XG4gIH1cblxuICBwcm90ZWN0ZWQgbW9uaXRvclJlY2VpdmVyID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmICghdGhpcy5yZWNlaXZlcikge1xuICAgICAgdGhpcy5fY3VycmVudEJpdHJhdGUgPSAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzdGF0cyA9IGF3YWl0IHRoaXMuZ2V0UmVjZWl2ZXJTdGF0cygpO1xuXG4gICAgaWYgKHN0YXRzICYmIHRoaXMucHJldlN0YXRzICYmIHRoaXMucmVjZWl2ZXIpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRCaXRyYXRlID0gY29tcHV0ZUJpdHJhdGUoc3RhdHMsIHRoaXMucHJldlN0YXRzKTtcbiAgICB9XG5cbiAgICB0aGlzLnByZXZTdGF0cyA9IHN0YXRzO1xuICB9O1xuXG4gIHByaXZhdGUgYXN5bmMgZ2V0UmVjZWl2ZXJTdGF0cygpOiBQcm9taXNlPFZpZGVvUmVjZWl2ZXJTdGF0cyB8IHVuZGVmaW5lZD4ge1xuICAgIGlmICghdGhpcy5yZWNlaXZlciB8fCAhdGhpcy5yZWNlaXZlci5nZXRTdGF0cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXRzID0gYXdhaXQgdGhpcy5yZWNlaXZlci5nZXRTdGF0cygpO1xuICAgIGxldCByZWNlaXZlclN0YXRzOiBWaWRlb1JlY2VpdmVyU3RhdHMgfCB1bmRlZmluZWQ7XG4gICAgbGV0IGNvZGVjSUQgPSAnJztcbiAgICBsZXQgY29kZWNzID0gbmV3IE1hcDxzdHJpbmcsIGFueT4oKTtcbiAgICBzdGF0cy5mb3JFYWNoKCh2KSA9PiB7XG4gICAgICBpZiAodi50eXBlID09PSAnaW5ib3VuZC1ydHAnKSB7XG4gICAgICAgIGNvZGVjSUQgPSB2LmNvZGVjSWQ7XG4gICAgICAgIHJlY2VpdmVyU3RhdHMgPSB7XG4gICAgICAgICAgdHlwZTogJ3ZpZGVvJyxcbiAgICAgICAgICBmcmFtZXNEZWNvZGVkOiB2LmZyYW1lc0RlY29kZWQsXG4gICAgICAgICAgZnJhbWVzRHJvcHBlZDogdi5mcmFtZXNEcm9wcGVkLFxuICAgICAgICAgIGZyYW1lc1JlY2VpdmVkOiB2LmZyYW1lc1JlY2VpdmVkLFxuICAgICAgICAgIHBhY2tldHNSZWNlaXZlZDogdi5wYWNrZXRzUmVjZWl2ZWQsXG4gICAgICAgICAgcGFja2V0c0xvc3Q6IHYucGFja2V0c0xvc3QsXG4gICAgICAgICAgZnJhbWVXaWR0aDogdi5mcmFtZVdpZHRoLFxuICAgICAgICAgIGZyYW1lSGVpZ2h0OiB2LmZyYW1lSGVpZ2h0LFxuICAgICAgICAgIHBsaUNvdW50OiB2LnBsaUNvdW50LFxuICAgICAgICAgIGZpckNvdW50OiB2LmZpckNvdW50LFxuICAgICAgICAgIG5hY2tDb3VudDogdi5uYWNrQ291bnQsXG4gICAgICAgICAgaml0dGVyOiB2LmppdHRlcixcbiAgICAgICAgICB0aW1lc3RhbXA6IHYudGltZXN0YW1wLFxuICAgICAgICAgIGJ5dGVzUmVjZWl2ZWQ6IHYuYnl0ZXNSZWNlaXZlZCxcbiAgICAgICAgICBkZWNvZGVySW1wbGVtZW50YXRpb246IHYuZGVjb2RlckltcGxlbWVudGF0aW9uLFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICh2LnR5cGUgPT09ICdjb2RlYycpIHtcbiAgICAgICAgY29kZWNzLnNldCh2LmlkLCB2KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAocmVjZWl2ZXJTdGF0cyAmJiBjb2RlY0lEICE9PSAnJyAmJiBjb2RlY3MuZ2V0KGNvZGVjSUQpKSB7XG4gICAgICByZWNlaXZlclN0YXRzLm1pbWVUeXBlID0gY29kZWNzLmdldChjb2RlY0lEKS5taW1lVHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlY2VpdmVyU3RhdHM7XG4gIH1cblxuICBwcml2YXRlIHN0b3BPYnNlcnZpbmdFbGVtZW50KGVsZW1lbnQ6IEhUTUxNZWRpYUVsZW1lbnQpIHtcbiAgICBjb25zdCBzdG9wRWxlbWVudEluZm9zID0gdGhpcy5lbGVtZW50SW5mb3MuZmlsdGVyKChpbmZvKSA9PiBpbmZvLmVsZW1lbnQgPT09IGVsZW1lbnQpO1xuICAgIGZvciAoY29uc3QgaW5mbyBvZiBzdG9wRWxlbWVudEluZm9zKSB7XG4gICAgICB0aGlzLnN0b3BPYnNlcnZpbmdFbGVtZW50SW5mbyhpbmZvKTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWQoKSB7XG4gICAgYXdhaXQgc3VwZXIuaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWQoKTtcbiAgICBpZiAoIXRoaXMuaXNBZGFwdGl2ZVN0cmVhbSkgcmV0dXJuO1xuICAgIHRoaXMudXBkYXRlVmlzaWJpbGl0eSgpO1xuICB9XG5cbiAgcHJpdmF0ZSByZWFkb25seSBkZWJvdW5jZWRIYW5kbGVSZXNpemUgPSBkZWJvdW5jZSgoKSA9PiB7XG4gICAgdGhpcy51cGRhdGVEaW1lbnNpb25zKCk7XG4gIH0sIFJFQUNUSU9OX0RFTEFZKTtcblxuICBwcml2YXRlIHVwZGF0ZVZpc2liaWxpdHkoKSB7XG4gICAgY29uc3QgbGFzdFZpc2liaWxpdHlDaGFuZ2UgPSB0aGlzLmVsZW1lbnRJbmZvcy5yZWR1Y2UoXG4gICAgICAocHJldiwgaW5mbykgPT4gTWF0aC5tYXgocHJldiwgaW5mby52aXNpYmlsaXR5Q2hhbmdlZEF0IHx8IDApLFxuICAgICAgMCxcbiAgICApO1xuXG4gICAgY29uc3QgYmFja2dyb3VuZFBhdXNlID1cbiAgICAgIHRoaXMuYWRhcHRpdmVTdHJlYW1TZXR0aW5ncz8ucGF1c2VWaWRlb0luQmFja2dyb3VuZCA/PyB0cnVlIC8vIGRlZmF1bHQgdG8gdHJ1ZVxuICAgICAgICA/IHRoaXMuaXNJbkJhY2tncm91bmRcbiAgICAgICAgOiBmYWxzZTtcbiAgICBjb25zdCBpc1BpUE1vZGUgPSB0aGlzLmVsZW1lbnRJbmZvcy5zb21lKChpbmZvKSA9PiBpbmZvLnBpY3R1cmVJblBpY3R1cmUpO1xuICAgIGNvbnN0IGlzVmlzaWJsZSA9XG4gICAgICAodGhpcy5lbGVtZW50SW5mb3Muc29tZSgoaW5mbykgPT4gaW5mby52aXNpYmxlKSAmJiAhYmFja2dyb3VuZFBhdXNlKSB8fCBpc1BpUE1vZGU7XG5cbiAgICBpZiAodGhpcy5sYXN0VmlzaWJsZSA9PT0gaXNWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFpc1Zpc2libGUgJiYgRGF0ZS5ub3coKSAtIGxhc3RWaXNpYmlsaXR5Q2hhbmdlIDwgUkVBQ1RJT05fREVMQVkpIHtcbiAgICAgIC8vIGRlbGF5IGhpZGRlbiBldmVudHNcbiAgICAgIENyaXRpY2FsVGltZXJzLnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLnVwZGF0ZVZpc2liaWxpdHkoKTtcbiAgICAgIH0sIFJFQUNUSU9OX0RFTEFZKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmxhc3RWaXNpYmxlID0gaXNWaXNpYmxlO1xuICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlZpc2liaWxpdHlDaGFuZ2VkLCBpc1Zpc2libGUsIHRoaXMpO1xuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVEaW1lbnNpb25zKCkge1xuICAgIGxldCBtYXhXaWR0aCA9IDA7XG4gICAgbGV0IG1heEhlaWdodCA9IDA7XG4gICAgY29uc3QgcGl4ZWxEZW5zaXR5ID0gdGhpcy5nZXRQaXhlbERlbnNpdHkoKTtcbiAgICBmb3IgKGNvbnN0IGluZm8gb2YgdGhpcy5lbGVtZW50SW5mb3MpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRFbGVtZW50V2lkdGggPSBpbmZvLndpZHRoKCkgKiBwaXhlbERlbnNpdHk7XG4gICAgICBjb25zdCBjdXJyZW50RWxlbWVudEhlaWdodCA9IGluZm8uaGVpZ2h0KCkgKiBwaXhlbERlbnNpdHk7XG4gICAgICBpZiAoY3VycmVudEVsZW1lbnRXaWR0aCArIGN1cnJlbnRFbGVtZW50SGVpZ2h0ID4gbWF4V2lkdGggKyBtYXhIZWlnaHQpIHtcbiAgICAgICAgbWF4V2lkdGggPSBjdXJyZW50RWxlbWVudFdpZHRoO1xuICAgICAgICBtYXhIZWlnaHQgPSBjdXJyZW50RWxlbWVudEhlaWdodDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5sYXN0RGltZW5zaW9ucz8ud2lkdGggPT09IG1heFdpZHRoICYmIHRoaXMubGFzdERpbWVuc2lvbnM/LmhlaWdodCA9PT0gbWF4SGVpZ2h0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5sYXN0RGltZW5zaW9ucyA9IHtcbiAgICAgIHdpZHRoOiBtYXhXaWR0aCxcbiAgICAgIGhlaWdodDogbWF4SGVpZ2h0LFxuICAgIH07XG5cbiAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5WaWRlb0RpbWVuc2lvbnNDaGFuZ2VkLCB0aGlzLmxhc3REaW1lbnNpb25zLCB0aGlzKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0UGl4ZWxEZW5zaXR5KCk6IG51bWJlciB7XG4gICAgY29uc3QgcGl4ZWxEZW5zaXR5ID0gdGhpcy5hZGFwdGl2ZVN0cmVhbVNldHRpbmdzPy5waXhlbERlbnNpdHk7XG4gICAgaWYgKHBpeGVsRGVuc2l0eSA9PT0gJ3NjcmVlbicpIHtcbiAgICAgIHJldHVybiBnZXREZXZpY2VQaXhlbFJhdGlvKCk7XG4gICAgfSBlbHNlIGlmICghcGl4ZWxEZW5zaXR5KSB7XG4gICAgICAvLyB3aGVuIHVuc2V0LCB3ZSdsbCBwaWNrIGEgc2FuZSBkZWZhdWx0IGhlcmUuXG4gICAgICAvLyBmb3IgaGlnaGVyIHBpeGVsIGRlbnNpdHkgZGV2aWNlcyAobW9iaWxlIHBob25lcywgZXRjKSwgd2UnbGwgdXNlIDJcbiAgICAgIC8vIG90aGVyd2lzZSBpdCBkZWZhdWx0cyB0byAxXG4gICAgICBjb25zdCBkZXZpY2VQaXhlbFJhdGlvID0gZ2V0RGV2aWNlUGl4ZWxSYXRpbygpO1xuICAgICAgaWYgKGRldmljZVBpeGVsUmF0aW8gPiAyKSB7XG4gICAgICAgIHJldHVybiAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwaXhlbERlbnNpdHk7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBFbGVtZW50SW5mbyB7XG4gIGVsZW1lbnQ6IG9iamVjdDtcbiAgd2lkdGgoKTogbnVtYmVyO1xuICBoZWlnaHQoKTogbnVtYmVyO1xuICB2aXNpYmxlOiBib29sZWFuO1xuICBwaWN0dXJlSW5QaWN0dXJlOiBib29sZWFuO1xuICB2aXNpYmlsaXR5Q2hhbmdlZEF0OiBudW1iZXIgfCB1bmRlZmluZWQ7XG5cbiAgaGFuZGxlUmVzaXplPzogKCkgPT4gdm9pZDtcbiAgaGFuZGxlVmlzaWJpbGl0eUNoYW5nZWQ/OiAoKSA9PiB2b2lkO1xuICBvYnNlcnZlKCk6IHZvaWQ7XG4gIHN0b3BPYnNlcnZpbmcoKTogdm9pZDtcbn1cblxuY2xhc3MgSFRNTEVsZW1lbnRJbmZvIGltcGxlbWVudHMgRWxlbWVudEluZm8ge1xuICBlbGVtZW50OiBIVE1MTWVkaWFFbGVtZW50O1xuXG4gIGdldCB2aXNpYmxlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmlzUGlQIHx8IHRoaXMuaXNJbnRlcnNlY3Rpbmc7XG4gIH1cblxuICBnZXQgcGljdHVyZUluUGljdHVyZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5pc1BpUDtcbiAgfVxuXG4gIHZpc2liaWxpdHlDaGFuZ2VkQXQ6IG51bWJlciB8IHVuZGVmaW5lZDtcblxuICBoYW5kbGVSZXNpemU/OiAoKSA9PiB2b2lkO1xuXG4gIGhhbmRsZVZpc2liaWxpdHlDaGFuZ2VkPzogKCkgPT4gdm9pZDtcblxuICBwcml2YXRlIGlzUGlQOiBib29sZWFuO1xuXG4gIHByaXZhdGUgaXNJbnRlcnNlY3Rpbmc6IGJvb2xlYW47XG5cbiAgY29uc3RydWN0b3IoZWxlbWVudDogSFRNTE1lZGlhRWxlbWVudCwgdmlzaWJsZT86IGJvb2xlYW4pIHtcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuaXNJbnRlcnNlY3RpbmcgPSB2aXNpYmxlID8/IGlzRWxlbWVudEluVmlld3BvcnQoZWxlbWVudCk7XG4gICAgdGhpcy5pc1BpUCA9IGlzV2ViKCkgJiYgZG9jdW1lbnQucGljdHVyZUluUGljdHVyZUVsZW1lbnQgPT09IGVsZW1lbnQ7XG4gICAgdGhpcy52aXNpYmlsaXR5Q2hhbmdlZEF0ID0gMDtcbiAgfVxuXG4gIHdpZHRoKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudC5jbGllbnRXaWR0aDtcbiAgfVxuXG4gIGhlaWdodCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICB9XG5cbiAgb2JzZXJ2ZSgpIHtcbiAgICAvLyBtYWtlIHN1cmUgd2UgdXBkYXRlIHRoZSBjdXJyZW50IHZpc2libGUgc3RhdGUgb25jZSB3ZSBzdGFydCB0byBvYnNlcnZlXG4gICAgdGhpcy5pc0ludGVyc2VjdGluZyA9IGlzRWxlbWVudEluVmlld3BvcnQodGhpcy5lbGVtZW50KTtcbiAgICB0aGlzLmlzUGlQID0gZG9jdW1lbnQucGljdHVyZUluUGljdHVyZUVsZW1lbnQgPT09IHRoaXMuZWxlbWVudDtcblxuICAgICh0aGlzLmVsZW1lbnQgYXMgT2JzZXJ2YWJsZU1lZGlhRWxlbWVudCkuaGFuZGxlUmVzaXplID0gKCkgPT4ge1xuICAgICAgdGhpcy5oYW5kbGVSZXNpemU/LigpO1xuICAgIH07XG4gICAgKHRoaXMuZWxlbWVudCBhcyBPYnNlcnZhYmxlTWVkaWFFbGVtZW50KS5oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlZCA9IHRoaXMub25WaXNpYmlsaXR5Q2hhbmdlZDtcblxuICAgIGdldEludGVyc2VjdGlvbk9ic2VydmVyKCkub2JzZXJ2ZSh0aGlzLmVsZW1lbnQpO1xuICAgIGdldFJlc2l6ZU9ic2VydmVyKCkub2JzZXJ2ZSh0aGlzLmVsZW1lbnQpO1xuICAgICh0aGlzLmVsZW1lbnQgYXMgSFRNTFZpZGVvRWxlbWVudCkuYWRkRXZlbnRMaXN0ZW5lcignZW50ZXJwaWN0dXJlaW5waWN0dXJlJywgdGhpcy5vbkVudGVyUGlQKTtcbiAgICAodGhpcy5lbGVtZW50IGFzIEhUTUxWaWRlb0VsZW1lbnQpLmFkZEV2ZW50TGlzdGVuZXIoJ2xlYXZlcGljdHVyZWlucGljdHVyZScsIHRoaXMub25MZWF2ZVBpUCk7XG4gIH1cblxuICBwcml2YXRlIG9uVmlzaWJpbGl0eUNoYW5nZWQgPSAoZW50cnk6IEludGVyc2VjdGlvbk9ic2VydmVyRW50cnkpID0+IHtcbiAgICBjb25zdCB7IHRhcmdldCwgaXNJbnRlcnNlY3RpbmcgfSA9IGVudHJ5O1xuICAgIGlmICh0YXJnZXQgPT09IHRoaXMuZWxlbWVudCkge1xuICAgICAgdGhpcy5pc0ludGVyc2VjdGluZyA9IGlzSW50ZXJzZWN0aW5nO1xuICAgICAgdGhpcy52aXNpYmlsaXR5Q2hhbmdlZEF0ID0gRGF0ZS5ub3coKTtcbiAgICAgIHRoaXMuaGFuZGxlVmlzaWJpbGl0eUNoYW5nZWQ/LigpO1xuICAgIH1cbiAgfTtcblxuICBwcml2YXRlIG9uRW50ZXJQaVAgPSAoKSA9PiB7XG4gICAgdGhpcy5pc1BpUCA9IHRydWU7XG4gICAgdGhpcy5oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlZD8uKCk7XG4gIH07XG5cbiAgcHJpdmF0ZSBvbkxlYXZlUGlQID0gKCkgPT4ge1xuICAgIHRoaXMuaXNQaVAgPSBmYWxzZTtcbiAgICB0aGlzLmhhbmRsZVZpc2liaWxpdHlDaGFuZ2VkPy4oKTtcbiAgfTtcblxuICBzdG9wT2JzZXJ2aW5nKCkge1xuICAgIGdldEludGVyc2VjdGlvbk9ic2VydmVyKCk/LnVub2JzZXJ2ZSh0aGlzLmVsZW1lbnQpO1xuICAgIGdldFJlc2l6ZU9ic2VydmVyKCk/LnVub2JzZXJ2ZSh0aGlzLmVsZW1lbnQpO1xuICAgICh0aGlzLmVsZW1lbnQgYXMgSFRNTFZpZGVvRWxlbWVudCkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICdlbnRlcnBpY3R1cmVpbnBpY3R1cmUnLFxuICAgICAgdGhpcy5vbkVudGVyUGlQLFxuICAgICk7XG4gICAgKHRoaXMuZWxlbWVudCBhcyBIVE1MVmlkZW9FbGVtZW50KS5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgJ2xlYXZlcGljdHVyZWlucGljdHVyZScsXG4gICAgICB0aGlzLm9uTGVhdmVQaVAsXG4gICAgKTtcbiAgfVxufVxuXG4vLyBkb2VzIG5vdCBhY2NvdW50IGZvciBvY2NsdXNpb24gYnkgb3RoZXIgZWxlbWVudHNcbmZ1bmN0aW9uIGlzRWxlbWVudEluVmlld3BvcnQoZWw6IEhUTUxFbGVtZW50KSB7XG4gIGxldCB0b3AgPSBlbC5vZmZzZXRUb3A7XG4gIGxldCBsZWZ0ID0gZWwub2Zmc2V0TGVmdDtcbiAgY29uc3Qgd2lkdGggPSBlbC5vZmZzZXRXaWR0aDtcbiAgY29uc3QgaGVpZ2h0ID0gZWwub2Zmc2V0SGVpZ2h0O1xuICBjb25zdCB7IGhpZGRlbiB9ID0gZWw7XG4gIGNvbnN0IHsgb3BhY2l0eSwgZGlzcGxheSB9ID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG5cbiAgd2hpbGUgKGVsLm9mZnNldFBhcmVudCkge1xuICAgIGVsID0gZWwub2Zmc2V0UGFyZW50IGFzIEhUTUxFbGVtZW50O1xuICAgIHRvcCArPSBlbC5vZmZzZXRUb3A7XG4gICAgbGVmdCArPSBlbC5vZmZzZXRMZWZ0O1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICB0b3AgPCB3aW5kb3cucGFnZVlPZmZzZXQgKyB3aW5kb3cuaW5uZXJIZWlnaHQgJiZcbiAgICBsZWZ0IDwgd2luZG93LnBhZ2VYT2Zmc2V0ICsgd2luZG93LmlubmVyV2lkdGggJiZcbiAgICB0b3AgKyBoZWlnaHQgPiB3aW5kb3cucGFnZVlPZmZzZXQgJiZcbiAgICBsZWZ0ICsgd2lkdGggPiB3aW5kb3cucGFnZVhPZmZzZXQgJiZcbiAgICAhaGlkZGVuICYmXG4gICAgKG9wYWNpdHkgIT09ICcnID8gcGFyc2VGbG9hdChvcGFjaXR5KSA+IDAgOiB0cnVlKSAmJlxuICAgIGRpc3BsYXkgIT09ICdub25lJ1xuICApO1xufVxuIiwiaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRzJztcbmltcG9ydCB0eXBlIFR5cGVkRXZlbnRFbWl0dGVyIGZyb20gJ3R5cGVkLWVtaXR0ZXInO1xuaW1wb3J0IGxvZywgeyBMb2dnZXJOYW1lcywgZ2V0TG9nZ2VyIH0gZnJvbSAnLi4vLi4vbG9nZ2VyJztcbmltcG9ydCB7IEVuY3J5cHRpb25fVHlwZSB9IGZyb20gJy4uLy4uL3Byb3RvL2xpdmVraXRfbW9kZWxzX3BiJztcbmltcG9ydCB0eXBlIHsgU3Vic2NyaXB0aW9uRXJyb3IsIFRyYWNrSW5mbyB9IGZyb20gJy4uLy4uL3Byb3RvL2xpdmVraXRfbW9kZWxzX3BiJztcbmltcG9ydCB0eXBlIHsgVXBkYXRlU3Vic2NyaXB0aW9uLCBVcGRhdGVUcmFja1NldHRpbmdzIH0gZnJvbSAnLi4vLi4vcHJvdG8vbGl2ZWtpdF9ydGNfcGInO1xuaW1wb3J0IHsgVHJhY2tFdmVudCB9IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgdHlwZSB7IExvZ2dlck9wdGlvbnMgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgTG9jYWxBdWRpb1RyYWNrIGZyb20gJy4vTG9jYWxBdWRpb1RyYWNrJztcbmltcG9ydCBMb2NhbFZpZGVvVHJhY2sgZnJvbSAnLi9Mb2NhbFZpZGVvVHJhY2snO1xuaW1wb3J0IFJlbW90ZUF1ZGlvVHJhY2sgZnJvbSAnLi9SZW1vdGVBdWRpb1RyYWNrJztcbmltcG9ydCB0eXBlIFJlbW90ZVRyYWNrIGZyb20gJy4vUmVtb3RlVHJhY2snO1xuaW1wb3J0IFJlbW90ZVZpZGVvVHJhY2sgZnJvbSAnLi9SZW1vdGVWaWRlb1RyYWNrJztcbmltcG9ydCB7IFRyYWNrIH0gZnJvbSAnLi9UcmFjayc7XG5pbXBvcnQgeyBnZXRMb2dDb250ZXh0RnJvbVRyYWNrIH0gZnJvbSAnLi91dGlscyc7XG5cbmV4cG9ydCBjbGFzcyBUcmFja1B1YmxpY2F0aW9uIGV4dGVuZHMgKEV2ZW50RW1pdHRlciBhcyBuZXcgKCkgPT4gVHlwZWRFdmVudEVtaXR0ZXI8UHVibGljYXRpb25FdmVudENhbGxiYWNrcz4pIHtcbiAga2luZDogVHJhY2suS2luZDtcblxuICB0cmFja05hbWU6IHN0cmluZztcblxuICB0cmFja1NpZDogVHJhY2suU0lEO1xuXG4gIHRyYWNrPzogVHJhY2s7XG5cbiAgc291cmNlOiBUcmFjay5Tb3VyY2U7XG5cbiAgLyoqIE1pbWVUeXBlIG9mIHRoZSBwdWJsaXNoZWQgdHJhY2sgKi9cbiAgbWltZVR5cGU/OiBzdHJpbmc7XG5cbiAgLyoqIGRpbWVuc2lvbiBvZiB0aGUgb3JpZ2luYWwgcHVibGlzaGVkIHN0cmVhbSwgdmlkZW8tb25seSAqL1xuICBkaW1lbnNpb25zPzogVHJhY2suRGltZW5zaW9ucztcblxuICAvKiogdHJ1ZSBpZiB0cmFjayB3YXMgc2ltdWxjYXN0ZWQgdG8gc2VydmVyLCB2aWRlby1vbmx5ICovXG4gIHNpbXVsY2FzdGVkPzogYm9vbGVhbjtcblxuICAvKiogQGludGVybmFsICovXG4gIHRyYWNrSW5mbz86IFRyYWNrSW5mbztcblxuICBwcm90ZWN0ZWQgbWV0YWRhdGFNdXRlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIHByb3RlY3RlZCBlbmNyeXB0aW9uOiBFbmNyeXB0aW9uX1R5cGUgPSBFbmNyeXB0aW9uX1R5cGUuTk9ORTtcblxuICBwcm90ZWN0ZWQgbG9nID0gbG9nO1xuXG4gIHByaXZhdGUgbG9nZ2VyQ29udGV4dENiPzogTG9nZ2VyT3B0aW9uc1snbG9nZ2VyQ29udGV4dENiJ107XG5cbiAgY29uc3RydWN0b3Ioa2luZDogVHJhY2suS2luZCwgaWQ6IHN0cmluZywgbmFtZTogc3RyaW5nLCBsb2dnZXJPcHRpb25zPzogTG9nZ2VyT3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5sb2cgPSBnZXRMb2dnZXIobG9nZ2VyT3B0aW9ucz8ubG9nZ2VyTmFtZSA/PyBMb2dnZXJOYW1lcy5QdWJsaWNhdGlvbik7XG4gICAgdGhpcy5sb2dnZXJDb250ZXh0Q2IgPSB0aGlzLmxvZ2dlckNvbnRleHRDYjtcbiAgICB0aGlzLnNldE1heExpc3RlbmVycygxMDApO1xuICAgIHRoaXMua2luZCA9IGtpbmQ7XG4gICAgdGhpcy50cmFja1NpZCA9IGlkO1xuICAgIHRoaXMudHJhY2tOYW1lID0gbmFtZTtcbiAgICB0aGlzLnNvdXJjZSA9IFRyYWNrLlNvdXJjZS5Vbmtub3duO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzZXRUcmFjayh0cmFjaz86IFRyYWNrKSB7XG4gICAgaWYgKHRoaXMudHJhY2spIHtcbiAgICAgIHRoaXMudHJhY2sub2ZmKFRyYWNrRXZlbnQuTXV0ZWQsIHRoaXMuaGFuZGxlTXV0ZWQpO1xuICAgICAgdGhpcy50cmFjay5vZmYoVHJhY2tFdmVudC5Vbm11dGVkLCB0aGlzLmhhbmRsZVVubXV0ZWQpO1xuICAgIH1cblxuICAgIHRoaXMudHJhY2sgPSB0cmFjaztcblxuICAgIGlmICh0cmFjaykge1xuICAgICAgLy8gZm9yd2FyZCBldmVudHNcbiAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuTXV0ZWQsIHRoaXMuaGFuZGxlTXV0ZWQpO1xuICAgICAgdHJhY2sub24oVHJhY2tFdmVudC5Vbm11dGVkLCB0aGlzLmhhbmRsZVVubXV0ZWQpO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBnZXQgbG9nQ29udGV4dCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4udGhpcy5sb2dnZXJDb250ZXh0Q2I/LigpLFxuICAgICAgLi4uZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0aGlzKSxcbiAgICB9O1xuICB9XG5cbiAgZ2V0IGlzTXV0ZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMubWV0YWRhdGFNdXRlZDtcbiAgfVxuXG4gIGdldCBpc0VuYWJsZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBnZXQgaXNTdWJzY3JpYmVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnRyYWNrICE9PSB1bmRlZmluZWQ7XG4gIH1cblxuICBnZXQgaXNFbmNyeXB0ZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZW5jcnlwdGlvbiAhPT0gRW5jcnlwdGlvbl9UeXBlLk5PTkU7XG4gIH1cblxuICAvKipcbiAgICogYW4gW0F1ZGlvVHJhY2tdIGlmIHRoaXMgcHVibGljYXRpb24gaG9sZHMgYW4gYXVkaW8gdHJhY2tcbiAgICovXG4gIGdldCBhdWRpb1RyYWNrKCk6IExvY2FsQXVkaW9UcmFjayB8IFJlbW90ZUF1ZGlvVHJhY2sgfCB1bmRlZmluZWQge1xuICAgIGlmICh0aGlzLnRyYWNrIGluc3RhbmNlb2YgTG9jYWxBdWRpb1RyYWNrIHx8IHRoaXMudHJhY2sgaW5zdGFuY2VvZiBSZW1vdGVBdWRpb1RyYWNrKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmFjaztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogYW4gW1ZpZGVvVHJhY2tdIGlmIHRoaXMgcHVibGljYXRpb24gaG9sZHMgYSB2aWRlbyB0cmFja1xuICAgKi9cbiAgZ2V0IHZpZGVvVHJhY2soKTogTG9jYWxWaWRlb1RyYWNrIHwgUmVtb3RlVmlkZW9UcmFjayB8IHVuZGVmaW5lZCB7XG4gICAgaWYgKHRoaXMudHJhY2sgaW5zdGFuY2VvZiBMb2NhbFZpZGVvVHJhY2sgfHwgdGhpcy50cmFjayBpbnN0YW5jZW9mIFJlbW90ZVZpZGVvVHJhY2spIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYWNrO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZU11dGVkID0gKCkgPT4ge1xuICAgIHRoaXMuZW1pdChUcmFja0V2ZW50Lk11dGVkKTtcbiAgfTtcblxuICBoYW5kbGVVbm11dGVkID0gKCkgPT4ge1xuICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlVubXV0ZWQpO1xuICB9O1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgdXBkYXRlSW5mbyhpbmZvOiBUcmFja0luZm8pIHtcbiAgICB0aGlzLnRyYWNrU2lkID0gaW5mby5zaWQ7XG4gICAgdGhpcy50cmFja05hbWUgPSBpbmZvLm5hbWU7XG4gICAgdGhpcy5zb3VyY2UgPSBUcmFjay5zb3VyY2VGcm9tUHJvdG8oaW5mby5zb3VyY2UpO1xuICAgIHRoaXMubWltZVR5cGUgPSBpbmZvLm1pbWVUeXBlO1xuICAgIGlmICh0aGlzLmtpbmQgPT09IFRyYWNrLktpbmQuVmlkZW8gJiYgaW5mby53aWR0aCA+IDApIHtcbiAgICAgIHRoaXMuZGltZW5zaW9ucyA9IHtcbiAgICAgICAgd2lkdGg6IGluZm8ud2lkdGgsXG4gICAgICAgIGhlaWdodDogaW5mby5oZWlnaHQsXG4gICAgICB9O1xuICAgICAgdGhpcy5zaW11bGNhc3RlZCA9IGluZm8uc2ltdWxjYXN0O1xuICAgIH1cbiAgICB0aGlzLmVuY3J5cHRpb24gPSBpbmZvLmVuY3J5cHRpb247XG4gICAgdGhpcy50cmFja0luZm8gPSBpbmZvO1xuICAgIHRoaXMubG9nLmRlYnVnKCd1cGRhdGUgcHVibGljYXRpb24gaW5mbycsIHsgLi4udGhpcy5sb2dDb250ZXh0LCBpbmZvIH0pO1xuICB9XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgVHJhY2tQdWJsaWNhdGlvbiB7XG4gIGV4cG9ydCBlbnVtIFN1YnNjcmlwdGlvblN0YXR1cyB7XG4gICAgRGVzaXJlZCA9ICdkZXNpcmVkJyxcbiAgICBTdWJzY3JpYmVkID0gJ3N1YnNjcmliZWQnLFxuICAgIFVuc3Vic2NyaWJlZCA9ICd1bnN1YnNjcmliZWQnLFxuICB9XG5cbiAgZXhwb3J0IGVudW0gUGVybWlzc2lvblN0YXR1cyB7XG4gICAgQWxsb3dlZCA9ICdhbGxvd2VkJyxcbiAgICBOb3RBbGxvd2VkID0gJ25vdF9hbGxvd2VkJyxcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBQdWJsaWNhdGlvbkV2ZW50Q2FsbGJhY2tzID0ge1xuICBtdXRlZDogKCkgPT4gdm9pZDtcbiAgdW5tdXRlZDogKCkgPT4gdm9pZDtcbiAgZW5kZWQ6ICh0cmFjaz86IFRyYWNrKSA9PiB2b2lkO1xuICB1cGRhdGVTZXR0aW5nczogKHNldHRpbmdzOiBVcGRhdGVUcmFja1NldHRpbmdzKSA9PiB2b2lkO1xuICBzdWJzY3JpcHRpb25QZXJtaXNzaW9uQ2hhbmdlZDogKFxuICAgIHN0YXR1czogVHJhY2tQdWJsaWNhdGlvbi5QZXJtaXNzaW9uU3RhdHVzLFxuICAgIHByZXZTdGF0dXM6IFRyYWNrUHVibGljYXRpb24uUGVybWlzc2lvblN0YXR1cyxcbiAgKSA9PiB2b2lkO1xuICB1cGRhdGVTdWJzY3JpcHRpb246IChzdWI6IFVwZGF0ZVN1YnNjcmlwdGlvbikgPT4gdm9pZDtcbiAgc3Vic2NyaWJlZDogKHRyYWNrOiBSZW1vdGVUcmFjaykgPT4gdm9pZDtcbiAgdW5zdWJzY3JpYmVkOiAodHJhY2s6IFJlbW90ZVRyYWNrKSA9PiB2b2lkO1xuICBzdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkOiAoXG4gICAgc3RhdHVzOiBUcmFja1B1YmxpY2F0aW9uLlN1YnNjcmlwdGlvblN0YXR1cyxcbiAgICBwcmV2U3RhdHVzOiBUcmFja1B1YmxpY2F0aW9uLlN1YnNjcmlwdGlvblN0YXR1cyxcbiAgKSA9PiB2b2lkO1xuICBzdWJzY3JpcHRpb25GYWlsZWQ6IChlcnJvcjogU3Vic2NyaXB0aW9uRXJyb3IpID0+IHZvaWQ7XG59O1xuIiwiaW1wb3J0IHR5cGUgeyBUcmFja0luZm8gfSBmcm9tICcuLi8uLi9wcm90by9saXZla2l0X21vZGVsc19wYic7XG5pbXBvcnQgeyBUcmFja0V2ZW50IH0gZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCB0eXBlIHsgTG9nZ2VyT3B0aW9ucyB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB0eXBlIExvY2FsQXVkaW9UcmFjayBmcm9tICcuL0xvY2FsQXVkaW9UcmFjayc7XG5pbXBvcnQgdHlwZSBMb2NhbFRyYWNrIGZyb20gJy4vTG9jYWxUcmFjayc7XG5pbXBvcnQgdHlwZSBMb2NhbFZpZGVvVHJhY2sgZnJvbSAnLi9Mb2NhbFZpZGVvVHJhY2snO1xuaW1wb3J0IHR5cGUgeyBUcmFjayB9IGZyb20gJy4vVHJhY2snO1xuaW1wb3J0IHsgVHJhY2tQdWJsaWNhdGlvbiB9IGZyb20gJy4vVHJhY2tQdWJsaWNhdGlvbic7XG5pbXBvcnQgdHlwZSB7IFRyYWNrUHVibGlzaE9wdGlvbnMgfSBmcm9tICcuL29wdGlvbnMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMb2NhbFRyYWNrUHVibGljYXRpb24gZXh0ZW5kcyBUcmFja1B1YmxpY2F0aW9uIHtcbiAgdHJhY2s/OiBMb2NhbFRyYWNrID0gdW5kZWZpbmVkO1xuXG4gIG9wdGlvbnM/OiBUcmFja1B1Ymxpc2hPcHRpb25zO1xuXG4gIGdldCBpc1Vwc3RyZWFtUGF1c2VkKCkge1xuICAgIHJldHVybiB0aGlzLnRyYWNrPy5pc1Vwc3RyZWFtUGF1c2VkO1xuICB9XG5cbiAgY29uc3RydWN0b3Ioa2luZDogVHJhY2suS2luZCwgdGk6IFRyYWNrSW5mbywgdHJhY2s/OiBMb2NhbFRyYWNrLCBsb2dnZXJPcHRpb25zPzogTG9nZ2VyT3B0aW9ucykge1xuICAgIHN1cGVyKGtpbmQsIHRpLnNpZCwgdGkubmFtZSwgbG9nZ2VyT3B0aW9ucyk7XG5cbiAgICB0aGlzLnVwZGF0ZUluZm8odGkpO1xuICAgIHRoaXMuc2V0VHJhY2sodHJhY2spO1xuICB9XG5cbiAgc2V0VHJhY2sodHJhY2s/OiBUcmFjaykge1xuICAgIGlmICh0aGlzLnRyYWNrKSB7XG4gICAgICB0aGlzLnRyYWNrLm9mZihUcmFja0V2ZW50LkVuZGVkLCB0aGlzLmhhbmRsZVRyYWNrRW5kZWQpO1xuICAgIH1cblxuICAgIHN1cGVyLnNldFRyYWNrKHRyYWNrKTtcblxuICAgIGlmICh0cmFjaykge1xuICAgICAgdHJhY2sub24oVHJhY2tFdmVudC5FbmRlZCwgdGhpcy5oYW5kbGVUcmFja0VuZGVkKTtcbiAgICB9XG4gIH1cblxuICBnZXQgaXNNdXRlZCgpOiBib29sZWFuIHtcbiAgICBpZiAodGhpcy50cmFjaykge1xuICAgICAgcmV0dXJuIHRoaXMudHJhY2suaXNNdXRlZDtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmlzTXV0ZWQ7XG4gIH1cblxuICBnZXQgYXVkaW9UcmFjaygpOiBMb2NhbEF1ZGlvVHJhY2sgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiBzdXBlci5hdWRpb1RyYWNrIGFzIExvY2FsQXVkaW9UcmFjayB8IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGdldCB2aWRlb1RyYWNrKCk6IExvY2FsVmlkZW9UcmFjayB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHN1cGVyLnZpZGVvVHJhY2sgYXMgTG9jYWxWaWRlb1RyYWNrIHwgdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIE11dGUgdGhlIHRyYWNrIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHB1YmxpY2F0aW9uXG4gICAqL1xuICBhc3luYyBtdXRlKCkge1xuICAgIHJldHVybiB0aGlzLnRyYWNrPy5tdXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogVW5tdXRlIHRyYWNrIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHB1YmxpY2F0aW9uXG4gICAqL1xuICBhc3luYyB1bm11dGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhY2s/LnVubXV0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhdXNlcyB0aGUgbWVkaWEgc3RyZWFtIHRyYWNrIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHB1YmxpY2F0aW9uIGZyb20gYmVpbmcgc2VudCB0byB0aGUgc2VydmVyXG4gICAqIGFuZCBzaWduYWxzIFwibXV0ZWRcIiBldmVudCB0byBvdGhlciBwYXJ0aWNpcGFudHNcbiAgICogVXNlZnVsIGlmIHlvdSB3YW50IHRvIHBhdXNlIHRoZSBzdHJlYW0gd2l0aG91dCBwYXVzaW5nIHRoZSBsb2NhbCBtZWRpYSBzdHJlYW0gdHJhY2tcbiAgICovXG4gIGFzeW5jIHBhdXNlVXBzdHJlYW0oKSB7XG4gICAgYXdhaXQgdGhpcy50cmFjaz8ucGF1c2VVcHN0cmVhbSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc3VtZXMgc2VuZGluZyB0aGUgbWVkaWEgc3RyZWFtIHRyYWNrIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHB1YmxpY2F0aW9uIHRvIHRoZSBzZXJ2ZXIgYWZ0ZXIgYSBjYWxsIHRvIFtbcGF1c2VVcHN0cmVhbSgpXV1cbiAgICogYW5kIHNpZ25hbHMgXCJ1bm11dGVkXCIgZXZlbnQgdG8gb3RoZXIgcGFydGljaXBhbnRzICh1bmxlc3MgdGhlIHRyYWNrIGlzIGV4cGxpY2l0bHkgbXV0ZWQpXG4gICAqL1xuICBhc3luYyByZXN1bWVVcHN0cmVhbSgpIHtcbiAgICBhd2FpdCB0aGlzLnRyYWNrPy5yZXN1bWVVcHN0cmVhbSgpO1xuICB9XG5cbiAgaGFuZGxlVHJhY2tFbmRlZCA9ICgpID0+IHtcbiAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5FbmRlZCk7XG4gIH07XG59XG4iLCJpbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnO1xuaW1wb3J0IHR5cGUgVHlwZWRFbWl0dGVyIGZyb20gJ3R5cGVkLWVtaXR0ZXInO1xuaW1wb3J0IGxvZywgeyBMb2dnZXJOYW1lcywgU3RydWN0dXJlZExvZ2dlciwgZ2V0TG9nZ2VyIH0gZnJvbSAnLi4vLi4vbG9nZ2VyJztcbmltcG9ydCB7XG4gIERhdGFQYWNrZXRfS2luZCxcbiAgUGFydGljaXBhbnRJbmZvLFxuICBQYXJ0aWNpcGFudFBlcm1pc3Npb24sXG4gIENvbm5lY3Rpb25RdWFsaXR5IGFzIFByb3RvUXVhbGl0eSxcbiAgU3Vic2NyaXB0aW9uRXJyb3IsXG59IGZyb20gJy4uLy4uL3Byb3RvL2xpdmVraXRfbW9kZWxzX3BiJztcbmltcG9ydCB7IFBhcnRpY2lwYW50RXZlbnQsIFRyYWNrRXZlbnQgfSBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IExvY2FsQXVkaW9UcmFjayBmcm9tICcuLi90cmFjay9Mb2NhbEF1ZGlvVHJhY2snO1xuaW1wb3J0IHR5cGUgTG9jYWxUcmFja1B1YmxpY2F0aW9uIGZyb20gJy4uL3RyYWNrL0xvY2FsVHJhY2tQdWJsaWNhdGlvbic7XG5pbXBvcnQgUmVtb3RlQXVkaW9UcmFjayBmcm9tICcuLi90cmFjay9SZW1vdGVBdWRpb1RyYWNrJztcbmltcG9ydCB0eXBlIFJlbW90ZVRyYWNrIGZyb20gJy4uL3RyYWNrL1JlbW90ZVRyYWNrJztcbmltcG9ydCB0eXBlIFJlbW90ZVRyYWNrUHVibGljYXRpb24gZnJvbSAnLi4vdHJhY2svUmVtb3RlVHJhY2tQdWJsaWNhdGlvbic7XG5pbXBvcnQgeyBUcmFjayB9IGZyb20gJy4uL3RyYWNrL1RyYWNrJztcbmltcG9ydCB0eXBlIHsgVHJhY2tQdWJsaWNhdGlvbiB9IGZyb20gJy4uL3RyYWNrL1RyYWNrUHVibGljYXRpb24nO1xuaW1wb3J0IHR5cGUgeyBMb2dnZXJPcHRpb25zIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgZW51bSBDb25uZWN0aW9uUXVhbGl0eSB7XG4gIEV4Y2VsbGVudCA9ICdleGNlbGxlbnQnLFxuICBHb29kID0gJ2dvb2QnLFxuICBQb29yID0gJ3Bvb3InLFxuICAvKipcbiAgICogSW5kaWNhdGVzIHRoYXQgYSBwYXJ0aWNpcGFudCBoYXMgdGVtcG9yYXJpbHkgKG9yIHBlcm1hbmVudGx5KSBsb3N0IGNvbm5lY3Rpb24gdG8gTGl2ZUtpdC5cbiAgICogRm9yIHBlcm1hbmVudCBkaXNjb25uZWN0aW9uIGEgYFBhcnRpY2lwYW50RGlzY29ubmVjdGVkYCBldmVudCB3aWxsIGJlIGVtaXR0ZWQgYWZ0ZXIgYSB0aW1lb3V0XG4gICAqL1xuICBMb3N0ID0gJ2xvc3QnLFxuICBVbmtub3duID0gJ3Vua25vd24nLFxufVxuXG5mdW5jdGlvbiBxdWFsaXR5RnJvbVByb3RvKHE6IFByb3RvUXVhbGl0eSk6IENvbm5lY3Rpb25RdWFsaXR5IHtcbiAgc3dpdGNoIChxKSB7XG4gICAgY2FzZSBQcm90b1F1YWxpdHkuRVhDRUxMRU5UOlxuICAgICAgcmV0dXJuIENvbm5lY3Rpb25RdWFsaXR5LkV4Y2VsbGVudDtcbiAgICBjYXNlIFByb3RvUXVhbGl0eS5HT09EOlxuICAgICAgcmV0dXJuIENvbm5lY3Rpb25RdWFsaXR5Lkdvb2Q7XG4gICAgY2FzZSBQcm90b1F1YWxpdHkuUE9PUjpcbiAgICAgIHJldHVybiBDb25uZWN0aW9uUXVhbGl0eS5Qb29yO1xuICAgIGNhc2UgUHJvdG9RdWFsaXR5LkxPU1Q6XG4gICAgICByZXR1cm4gQ29ubmVjdGlvblF1YWxpdHkuTG9zdDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIENvbm5lY3Rpb25RdWFsaXR5LlVua25vd247XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGFydGljaXBhbnQgZXh0ZW5kcyAoRXZlbnRFbWl0dGVyIGFzIG5ldyAoKSA9PiBUeXBlZEVtaXR0ZXI8UGFydGljaXBhbnRFdmVudENhbGxiYWNrcz4pIHtcbiAgcHJvdGVjdGVkIHBhcnRpY2lwYW50SW5mbz86IFBhcnRpY2lwYW50SW5mbztcblxuICBhdWRpb1RyYWNrczogTWFwPHN0cmluZywgVHJhY2tQdWJsaWNhdGlvbj47XG5cbiAgdmlkZW9UcmFja3M6IE1hcDxzdHJpbmcsIFRyYWNrUHVibGljYXRpb24+O1xuXG4gIC8qKiBtYXAgb2YgdHJhY2sgc2lkID0+IGFsbCBwdWJsaXNoZWQgdHJhY2tzICovXG4gIHRyYWNrczogTWFwPHN0cmluZywgVHJhY2tQdWJsaWNhdGlvbj47XG5cbiAgLyoqIGF1ZGlvIGxldmVsIGJldHdlZW4gMC0xLjAsIDEgYmVpbmcgbG91ZGVzdCwgMCBiZWluZyBzb2Z0ZXN0ICovXG4gIGF1ZGlvTGV2ZWw6IG51bWJlciA9IDA7XG5cbiAgLyoqIGlmIHBhcnRpY2lwYW50IGlzIGN1cnJlbnRseSBzcGVha2luZyAqL1xuICBpc1NwZWFraW5nOiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqIHNlcnZlciBhc3NpZ25lZCB1bmlxdWUgaWQgKi9cbiAgc2lkOiBzdHJpbmc7XG5cbiAgLyoqIGNsaWVudCBhc3NpZ25lZCBpZGVudGl0eSwgZW5jb2RlZCBpbiBKV1QgdG9rZW4gKi9cbiAgaWRlbnRpdHk6IHN0cmluZztcblxuICAvKiogY2xpZW50IGFzc2lnbmVkIGRpc3BsYXkgbmFtZSwgZW5jb2RlZCBpbiBKV1QgdG9rZW4gKi9cbiAgbmFtZT86IHN0cmluZztcblxuICAvKiogY2xpZW50IG1ldGFkYXRhLCBvcGFxdWUgdG8gbGl2ZWtpdCAqL1xuICBtZXRhZGF0YT86IHN0cmluZztcblxuICBsYXN0U3Bva2VBdD86IERhdGUgfCB1bmRlZmluZWQ7XG5cbiAgcGVybWlzc2lvbnM/OiBQYXJ0aWNpcGFudFBlcm1pc3Npb247XG5cbiAgcHJpdmF0ZSBfY29ubmVjdGlvblF1YWxpdHk6IENvbm5lY3Rpb25RdWFsaXR5ID0gQ29ubmVjdGlvblF1YWxpdHkuVW5rbm93bjtcblxuICBwcm90ZWN0ZWQgYXVkaW9Db250ZXh0PzogQXVkaW9Db250ZXh0O1xuXG4gIHByb3RlY3RlZCBsb2c6IFN0cnVjdHVyZWRMb2dnZXIgPSBsb2c7XG5cbiAgcHJvdGVjdGVkIGxvZ2dlck9wdGlvbnM/OiBMb2dnZXJPcHRpb25zO1xuXG4gIHByb3RlY3RlZCBnZXQgbG9nQ29udGV4dCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4udGhpcy5sb2dnZXJPcHRpb25zPy5sb2dnZXJDb250ZXh0Q2I/LigpLFxuICAgICAgcGFydGljaXBhbnRTaWQ6IHRoaXMuc2lkLFxuICAgICAgcGFydGljaXBhbnRJZDogdGhpcy5pZGVudGl0eSxcbiAgICB9O1xuICB9XG5cbiAgZ2V0IGlzRW5jcnlwdGVkKCkge1xuICAgIHJldHVybiB0aGlzLnRyYWNrcy5zaXplID4gMCAmJiBBcnJheS5mcm9tKHRoaXMudHJhY2tzLnZhbHVlcygpKS5ldmVyeSgodHIpID0+IHRyLmlzRW5jcnlwdGVkKTtcbiAgfVxuXG4gIGdldCBpc0FnZW50KCkge1xuICAgIHJldHVybiB0aGlzLnBlcm1pc3Npb25zPy5hZ2VudCA/PyBmYWxzZTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgc2lkOiBzdHJpbmcsXG4gICAgaWRlbnRpdHk6IHN0cmluZyxcbiAgICBuYW1lPzogc3RyaW5nLFxuICAgIG1ldGFkYXRhPzogc3RyaW5nLFxuICAgIGxvZ2dlck9wdGlvbnM/OiBMb2dnZXJPcHRpb25zLFxuICApIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5sb2cgPSBnZXRMb2dnZXIobG9nZ2VyT3B0aW9ucz8ubG9nZ2VyTmFtZSA/PyBMb2dnZXJOYW1lcy5QYXJ0aWNpcGFudCk7XG4gICAgdGhpcy5sb2dnZXJPcHRpb25zID0gbG9nZ2VyT3B0aW9ucztcblxuICAgIHRoaXMuc2V0TWF4TGlzdGVuZXJzKDEwMCk7XG4gICAgdGhpcy5zaWQgPSBzaWQ7XG4gICAgdGhpcy5pZGVudGl0eSA9IGlkZW50aXR5O1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgIHRoaXMuYXVkaW9UcmFja3MgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy52aWRlb1RyYWNrcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnRyYWNrcyA9IG5ldyBNYXAoKTtcbiAgfVxuXG4gIGdldFRyYWNrcygpOiBUcmFja1B1YmxpY2F0aW9uW10ge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMudHJhY2tzLnZhbHVlcygpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kcyB0aGUgZmlyc3QgdHJhY2sgdGhhdCBtYXRjaGVzIHRoZSBzb3VyY2UgZmlsdGVyLCBmb3IgZXhhbXBsZSwgZ2V0dGluZ1xuICAgKiB0aGUgdXNlcidzIGNhbWVyYSB0cmFjayB3aXRoIGdldFRyYWNrQnlTb3VyY2UoVHJhY2suU291cmNlLkNhbWVyYSkuXG4gICAqIEBwYXJhbSBzb3VyY2VcbiAgICogQHJldHVybnNcbiAgICovXG4gIGdldFRyYWNrKHNvdXJjZTogVHJhY2suU291cmNlKTogVHJhY2tQdWJsaWNhdGlvbiB8IHVuZGVmaW5lZCB7XG4gICAgZm9yIChjb25zdCBbLCBwdWJdIG9mIHRoaXMudHJhY2tzKSB7XG4gICAgICBpZiAocHViLnNvdXJjZSA9PT0gc291cmNlKSB7XG4gICAgICAgIHJldHVybiBwdWI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZpbmRzIHRoZSBmaXJzdCB0cmFjayB0aGF0IG1hdGNoZXMgdGhlIHRyYWNrJ3MgbmFtZS5cbiAgICogQHBhcmFtIG5hbWVcbiAgICogQHJldHVybnNcbiAgICovXG4gIGdldFRyYWNrQnlOYW1lKG5hbWU6IHN0cmluZyk6IFRyYWNrUHVibGljYXRpb24gfCB1bmRlZmluZWQge1xuICAgIGZvciAoY29uc3QgWywgcHViXSBvZiB0aGlzLnRyYWNrcykge1xuICAgICAgaWYgKHB1Yi50cmFja05hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHB1YjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBnZXQgY29ubmVjdGlvblF1YWxpdHkoKTogQ29ubmVjdGlvblF1YWxpdHkge1xuICAgIHJldHVybiB0aGlzLl9jb25uZWN0aW9uUXVhbGl0eTtcbiAgfVxuXG4gIGdldCBpc0NhbWVyYUVuYWJsZWQoKTogYm9vbGVhbiB7XG4gICAgY29uc3QgdHJhY2sgPSB0aGlzLmdldFRyYWNrKFRyYWNrLlNvdXJjZS5DYW1lcmEpO1xuICAgIHJldHVybiAhKHRyYWNrPy5pc011dGVkID8/IHRydWUpO1xuICB9XG5cbiAgZ2V0IGlzTWljcm9waG9uZUVuYWJsZWQoKTogYm9vbGVhbiB7XG4gICAgY29uc3QgdHJhY2sgPSB0aGlzLmdldFRyYWNrKFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lKTtcbiAgICByZXR1cm4gISh0cmFjaz8uaXNNdXRlZCA/PyB0cnVlKTtcbiAgfVxuXG4gIGdldCBpc1NjcmVlblNoYXJlRW5hYmxlZCgpOiBib29sZWFuIHtcbiAgICBjb25zdCB0cmFjayA9IHRoaXMuZ2V0VHJhY2soVHJhY2suU291cmNlLlNjcmVlblNoYXJlKTtcbiAgICByZXR1cm4gISF0cmFjaztcbiAgfVxuXG4gIGdldCBpc0xvY2FsKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKiB3aGVuIHBhcnRpY2lwYW50IGpvaW5lZCB0aGUgcm9vbSAqL1xuICBnZXQgam9pbmVkQXQoKTogRGF0ZSB8IHVuZGVmaW5lZCB7XG4gICAgaWYgKHRoaXMucGFydGljaXBhbnRJbmZvKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoTnVtYmVyLnBhcnNlSW50KHRoaXMucGFydGljaXBhbnRJbmZvLmpvaW5lZEF0LnRvU3RyaW5nKCkpICogMTAwMCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRGF0ZSgpO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICB1cGRhdGVJbmZvKGluZm86IFBhcnRpY2lwYW50SW5mbyk6IGJvb2xlYW4ge1xuICAgIC8vIGl0J3MgcG9zc2libGUgdGhlIHVwZGF0ZSBjb3VsZCBiZSBhcHBsaWVkIG91dCBvZiBvcmRlciBkdWUgdG8gYXdhaXRcbiAgICAvLyBkdXJpbmcgcmVjb25uZWN0IHNlcXVlbmNlcy4gd2hlbiB0aGF0IGhhcHBlbnMsIGl0J3MgcG9zc2libGUgZm9yIHNlcnZlclxuICAgIC8vIHRvIGhhdmUgc2VudCBtb3JlIHJlY2VudCB2ZXJzaW9uIG9mIHBhcnRpY2lwYW50IGluZm8gd2hpbGUgSlMgaXMgd2FpdGluZ1xuICAgIC8vIHRvIHByb2Nlc3MgdGhlIGV4aXN0aW5nIHBheWxvYWQuXG4gICAgLy8gd2hlbiB0aGUgcGFydGljaXBhbnQgc2lkIHJlbWFpbnMgdGhlIHNhbWUsIGFuZCB3ZSBhbHJlYWR5IGhhdmUgYSBsYXRlciB2ZXJzaW9uXG4gICAgLy8gb2YgdGhlIHBheWxvYWQsIHRoZXkgY2FuIGJlIHNhZmVseSBza2lwcGVkXG4gICAgaWYgKFxuICAgICAgdGhpcy5wYXJ0aWNpcGFudEluZm8gJiZcbiAgICAgIHRoaXMucGFydGljaXBhbnRJbmZvLnNpZCA9PT0gaW5mby5zaWQgJiZcbiAgICAgIHRoaXMucGFydGljaXBhbnRJbmZvLnZlcnNpb24gPiBpbmZvLnZlcnNpb25cbiAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5pZGVudGl0eSA9IGluZm8uaWRlbnRpdHk7XG4gICAgdGhpcy5zaWQgPSBpbmZvLnNpZDtcbiAgICB0aGlzLl9zZXROYW1lKGluZm8ubmFtZSk7XG4gICAgdGhpcy5fc2V0TWV0YWRhdGEoaW5mby5tZXRhZGF0YSk7XG4gICAgaWYgKGluZm8ucGVybWlzc2lvbikge1xuICAgICAgdGhpcy5zZXRQZXJtaXNzaW9ucyhpbmZvLnBlcm1pc3Npb24pO1xuICAgIH1cbiAgICAvLyBzZXQgdGhpcyBsYXN0IHNvIHNldE1ldGFkYXRhIGNhbiBkZXRlY3QgY2hhbmdlc1xuICAgIHRoaXMucGFydGljaXBhbnRJbmZvID0gaW5mbztcbiAgICB0aGlzLmxvZy50cmFjZSgndXBkYXRlIHBhcnRpY2lwYW50IGluZm8nLCB7IC4uLnRoaXMubG9nQ29udGV4dCwgaW5mbyB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIG1ldGFkYXRhIGZyb20gc2VydmVyXG4gICAqKi9cbiAgcHJpdmF0ZSBfc2V0TWV0YWRhdGEobWQ6IHN0cmluZykge1xuICAgIGNvbnN0IGNoYW5nZWQgPSB0aGlzLm1ldGFkYXRhICE9PSBtZDtcbiAgICBjb25zdCBwcmV2TWV0YWRhdGEgPSB0aGlzLm1ldGFkYXRhO1xuICAgIHRoaXMubWV0YWRhdGEgPSBtZDtcblxuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5QYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZCwgcHJldk1ldGFkYXRhKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9zZXROYW1lKG5hbWU6IHN0cmluZykge1xuICAgIGNvbnN0IGNoYW5nZWQgPSB0aGlzLm5hbWUgIT09IG5hbWU7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcblxuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5QYXJ0aWNpcGFudE5hbWVDaGFuZ2VkLCBuYW1lKTtcbiAgICB9XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHNldFBlcm1pc3Npb25zKHBlcm1pc3Npb25zOiBQYXJ0aWNpcGFudFBlcm1pc3Npb24pOiBib29sZWFuIHtcbiAgICBjb25zdCBwcmV2UGVybWlzc2lvbnMgPSB0aGlzLnBlcm1pc3Npb25zO1xuICAgIGNvbnN0IGNoYW5nZWQgPVxuICAgICAgcGVybWlzc2lvbnMuY2FuUHVibGlzaCAhPT0gdGhpcy5wZXJtaXNzaW9ucz8uY2FuUHVibGlzaCB8fFxuICAgICAgcGVybWlzc2lvbnMuY2FuU3Vic2NyaWJlICE9PSB0aGlzLnBlcm1pc3Npb25zPy5jYW5TdWJzY3JpYmUgfHxcbiAgICAgIHBlcm1pc3Npb25zLmNhblB1Ymxpc2hEYXRhICE9PSB0aGlzLnBlcm1pc3Npb25zPy5jYW5QdWJsaXNoRGF0YSB8fFxuICAgICAgcGVybWlzc2lvbnMuaGlkZGVuICE9PSB0aGlzLnBlcm1pc3Npb25zPy5oaWRkZW4gfHxcbiAgICAgIHBlcm1pc3Npb25zLnJlY29yZGVyICE9PSB0aGlzLnBlcm1pc3Npb25zPy5yZWNvcmRlciB8fFxuICAgICAgcGVybWlzc2lvbnMuY2FuUHVibGlzaFNvdXJjZXMubGVuZ3RoICE9PSB0aGlzLnBlcm1pc3Npb25zLmNhblB1Ymxpc2hTb3VyY2VzLmxlbmd0aCB8fFxuICAgICAgcGVybWlzc2lvbnMuY2FuUHVibGlzaFNvdXJjZXMuc29tZShcbiAgICAgICAgKHZhbHVlLCBpbmRleCkgPT4gdmFsdWUgIT09IHRoaXMucGVybWlzc2lvbnM/LmNhblB1Ymxpc2hTb3VyY2VzW2luZGV4XSxcbiAgICAgICk7XG4gICAgdGhpcy5wZXJtaXNzaW9ucyA9IHBlcm1pc3Npb25zO1xuXG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkLCBwcmV2UGVybWlzc2lvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc2V0SXNTcGVha2luZyhzcGVha2luZzogYm9vbGVhbikge1xuICAgIGlmIChzcGVha2luZyA9PT0gdGhpcy5pc1NwZWFraW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuaXNTcGVha2luZyA9IHNwZWFraW5nO1xuICAgIGlmIChzcGVha2luZykge1xuICAgICAgdGhpcy5sYXN0U3Bva2VBdCA9IG5ldyBEYXRlKCk7XG4gICAgfVxuICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LklzU3BlYWtpbmdDaGFuZ2VkLCBzcGVha2luZyk7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHNldENvbm5lY3Rpb25RdWFsaXR5KHE6IFByb3RvUXVhbGl0eSkge1xuICAgIGNvbnN0IHByZXZRdWFsaXR5ID0gdGhpcy5fY29ubmVjdGlvblF1YWxpdHk7XG4gICAgdGhpcy5fY29ubmVjdGlvblF1YWxpdHkgPSBxdWFsaXR5RnJvbVByb3RvKHEpO1xuICAgIGlmIChwcmV2UXVhbGl0eSAhPT0gdGhpcy5fY29ubmVjdGlvblF1YWxpdHkpIHtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LkNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCwgdGhpcy5fY29ubmVjdGlvblF1YWxpdHkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHNldEF1ZGlvQ29udGV4dChjdHg6IEF1ZGlvQ29udGV4dCB8IHVuZGVmaW5lZCkge1xuICAgIHRoaXMuYXVkaW9Db250ZXh0ID0gY3R4O1xuICAgIHRoaXMuYXVkaW9UcmFja3MuZm9yRWFjaChcbiAgICAgICh0cmFjaykgPT5cbiAgICAgICAgKHRyYWNrLnRyYWNrIGluc3RhbmNlb2YgUmVtb3RlQXVkaW9UcmFjayB8fCB0cmFjay50cmFjayBpbnN0YW5jZW9mIExvY2FsQXVkaW9UcmFjaykgJiZcbiAgICAgICAgdHJhY2sudHJhY2suc2V0QXVkaW9Db250ZXh0KGN0eCksXG4gICAgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhZGRUcmFja1B1YmxpY2F0aW9uKHB1YmxpY2F0aW9uOiBUcmFja1B1YmxpY2F0aW9uKSB7XG4gICAgLy8gZm9yd2FyZCBwdWJsaWNhdGlvbiBkcml2ZW4gZXZlbnRzXG4gICAgcHVibGljYXRpb24ub24oVHJhY2tFdmVudC5NdXRlZCwgKCkgPT4ge1xuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuVHJhY2tNdXRlZCwgcHVibGljYXRpb24pO1xuICAgIH0pO1xuXG4gICAgcHVibGljYXRpb24ub24oVHJhY2tFdmVudC5Vbm11dGVkLCAoKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5UcmFja1VubXV0ZWQsIHB1YmxpY2F0aW9uKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IHB1YiA9IHB1YmxpY2F0aW9uO1xuICAgIGlmIChwdWIudHJhY2spIHtcbiAgICAgIHB1Yi50cmFjay5zaWQgPSBwdWJsaWNhdGlvbi50cmFja1NpZDtcbiAgICB9XG5cbiAgICB0aGlzLnRyYWNrcy5zZXQocHVibGljYXRpb24udHJhY2tTaWQsIHB1YmxpY2F0aW9uKTtcbiAgICBzd2l0Y2ggKHB1YmxpY2F0aW9uLmtpbmQpIHtcbiAgICAgIGNhc2UgVHJhY2suS2luZC5BdWRpbzpcbiAgICAgICAgdGhpcy5hdWRpb1RyYWNrcy5zZXQocHVibGljYXRpb24udHJhY2tTaWQsIHB1YmxpY2F0aW9uKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRyYWNrLktpbmQuVmlkZW86XG4gICAgICAgIHRoaXMudmlkZW9UcmFja3Muc2V0KHB1YmxpY2F0aW9uLnRyYWNrU2lkLCBwdWJsaWNhdGlvbik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB0eXBlIFBhcnRpY2lwYW50RXZlbnRDYWxsYmFja3MgPSB7XG4gIHRyYWNrUHVibGlzaGVkOiAocHVibGljYXRpb246IFJlbW90ZVRyYWNrUHVibGljYXRpb24pID0+IHZvaWQ7XG4gIHRyYWNrU3Vic2NyaWJlZDogKHRyYWNrOiBSZW1vdGVUcmFjaywgcHVibGljYXRpb246IFJlbW90ZVRyYWNrUHVibGljYXRpb24pID0+IHZvaWQ7XG4gIHRyYWNrU3Vic2NyaXB0aW9uRmFpbGVkOiAodHJhY2tTaWQ6IHN0cmluZywgcmVhc29uPzogU3Vic2NyaXB0aW9uRXJyb3IpID0+IHZvaWQ7XG4gIHRyYWNrVW5wdWJsaXNoZWQ6IChwdWJsaWNhdGlvbjogUmVtb3RlVHJhY2tQdWJsaWNhdGlvbikgPT4gdm9pZDtcbiAgdHJhY2tVbnN1YnNjcmliZWQ6ICh0cmFjazogUmVtb3RlVHJhY2ssIHB1YmxpY2F0aW9uOiBSZW1vdGVUcmFja1B1YmxpY2F0aW9uKSA9PiB2b2lkO1xuICB0cmFja011dGVkOiAocHVibGljYXRpb246IFRyYWNrUHVibGljYXRpb24pID0+IHZvaWQ7XG4gIHRyYWNrVW5tdXRlZDogKHB1YmxpY2F0aW9uOiBUcmFja1B1YmxpY2F0aW9uKSA9PiB2b2lkO1xuICBsb2NhbFRyYWNrUHVibGlzaGVkOiAocHVibGljYXRpb246IExvY2FsVHJhY2tQdWJsaWNhdGlvbikgPT4gdm9pZDtcbiAgbG9jYWxUcmFja1VucHVibGlzaGVkOiAocHVibGljYXRpb246IExvY2FsVHJhY2tQdWJsaWNhdGlvbikgPT4gdm9pZDtcbiAgcGFydGljaXBhbnRNZXRhZGF0YUNoYW5nZWQ6IChwcmV2TWV0YWRhdGE6IHN0cmluZyB8IHVuZGVmaW5lZCwgcGFydGljaXBhbnQ/OiBhbnkpID0+IHZvaWQ7XG4gIHBhcnRpY2lwYW50TmFtZUNoYW5nZWQ6IChuYW1lOiBzdHJpbmcpID0+IHZvaWQ7XG4gIGRhdGFSZWNlaXZlZDogKHBheWxvYWQ6IFVpbnQ4QXJyYXksIGtpbmQ6IERhdGFQYWNrZXRfS2luZCkgPT4gdm9pZDtcbiAgaXNTcGVha2luZ0NoYW5nZWQ6IChzcGVha2luZzogYm9vbGVhbikgPT4gdm9pZDtcbiAgY29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkOiAoY29ubmVjdGlvblF1YWxpdHk6IENvbm5lY3Rpb25RdWFsaXR5KSA9PiB2b2lkO1xuICB0cmFja1N0cmVhbVN0YXRlQ2hhbmdlZDogKFxuICAgIHB1YmxpY2F0aW9uOiBSZW1vdGVUcmFja1B1YmxpY2F0aW9uLFxuICAgIHN0cmVhbVN0YXRlOiBUcmFjay5TdHJlYW1TdGF0ZSxcbiAgKSA9PiB2b2lkO1xuICB0cmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkOiAoXG4gICAgcHVibGljYXRpb246IFJlbW90ZVRyYWNrUHVibGljYXRpb24sXG4gICAgc3RhdHVzOiBUcmFja1B1YmxpY2F0aW9uLlBlcm1pc3Npb25TdGF0dXMsXG4gICkgPT4gdm9pZDtcbiAgbWVkaWFEZXZpY2VzRXJyb3I6IChlcnJvcjogRXJyb3IpID0+IHZvaWQ7XG4gIGF1ZGlvU3RyZWFtQWNxdWlyZWQ6ICgpID0+IHZvaWQ7XG4gIHBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkOiAocHJldlBlcm1pc3Npb25zPzogUGFydGljaXBhbnRQZXJtaXNzaW9uKSA9PiB2b2lkO1xuICB0cmFja1N1YnNjcmlwdGlvblN0YXR1c0NoYW5nZWQ6IChcbiAgICBwdWJsaWNhdGlvbjogUmVtb3RlVHJhY2tQdWJsaWNhdGlvbixcbiAgICBzdGF0dXM6IFRyYWNrUHVibGljYXRpb24uU3Vic2NyaXB0aW9uU3RhdHVzLFxuICApID0+IHZvaWQ7XG59O1xuIiwiaW1wb3J0IHsgVHJhY2tQZXJtaXNzaW9uIH0gZnJvbSAnLi4vLi4vcHJvdG8vbGl2ZWtpdF9ydGNfcGInO1xuXG5leHBvcnQgaW50ZXJmYWNlIFBhcnRpY2lwYW50VHJhY2tQZXJtaXNzaW9uIHtcbiAgLyoqXG4gICAqIFRoZSBwYXJ0aWNpcGFudCBpZGVudGl0eSB0aGlzIHBlcm1pc3Npb24gYXBwbGllcyB0by5cbiAgICogWW91IGNhbiBlaXRoZXIgcHJvdmlkZSB0aGlzIG9yIGBwYXJ0aWNpcGFudFNpZGBcbiAgICovXG4gIHBhcnRpY2lwYW50SWRlbnRpdHk/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBwYXJ0aWNpcGFudCBzZXJ2ZXIgaWQgdGhpcyBwZXJtaXNzaW9uIGFwcGxpZXMgdG8uXG4gICAqIFlvdSBjYW4gZWl0aGVyIHByb3ZpZGUgdGhpcyBvciBgcGFydGljaXBhbnRJZGVudGl0eWBcbiAgICovXG4gIHBhcnRpY2lwYW50U2lkPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBHcmFudCBwZXJtaXNzaW9uIHRvIGFsbCBhbGwgdHJhY2tzLiBUYWtlcyBwcmVjZWRlbmNlIG92ZXIgYWxsb3dlZFRyYWNrU2lkcy5cbiAgICogZmFsc2UgaWYgdW5zZXQuXG4gICAqL1xuICBhbGxvd0FsbD86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFRoZSBsaXN0IG9mIHRyYWNrIGlkcyB0aGF0IHRoZSB0YXJnZXQgcGFydGljaXBhbnQgY2FuIHN1YnNjcmliZSB0by5cbiAgICogV2hlbiB1bnNldCwgaXQnbGwgYWxsb3cgYWxsIHRyYWNrcyB0byBiZSBzdWJzY3JpYmVkIGJ5IHRoZSBwYXJ0aWNpcGFudC5cbiAgICogV2hlbiBlbXB0eSwgdGhpcyBwYXJ0aWNpcGFudCBpcyBkaXNhbGxvd2VkIGZyb20gc3Vic2NyaWJpbmcgdG8gYW55IHRyYWNrcy5cbiAgICovXG4gIGFsbG93ZWRUcmFja1NpZHM/OiBzdHJpbmdbXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYWNrUGVybWlzc2lvblRvUHJvdG8ocGVybXM6IFBhcnRpY2lwYW50VHJhY2tQZXJtaXNzaW9uKTogVHJhY2tQZXJtaXNzaW9uIHtcbiAgaWYgKCFwZXJtcy5wYXJ0aWNpcGFudFNpZCAmJiAhcGVybXMucGFydGljaXBhbnRJZGVudGl0eSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdJbnZhbGlkIHRyYWNrIHBlcm1pc3Npb24sIG11c3QgcHJvdmlkZSBhdCBsZWFzdCBvbmUgb2YgcGFydGljaXBhbnRJZGVudGl0eSBhbmQgcGFydGljaXBhbnRTaWQnLFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIG5ldyBUcmFja1Blcm1pc3Npb24oe1xuICAgIHBhcnRpY2lwYW50SWRlbnRpdHk6IHBlcm1zLnBhcnRpY2lwYW50SWRlbnRpdHkgPz8gJycsXG4gICAgcGFydGljaXBhbnRTaWQ6IHBlcm1zLnBhcnRpY2lwYW50U2lkID8/ICcnLFxuICAgIGFsbFRyYWNrczogcGVybXMuYWxsb3dBbGwgPz8gZmFsc2UsXG4gICAgdHJhY2tTaWRzOiBwZXJtcy5hbGxvd2VkVHJhY2tTaWRzIHx8IFtdLFxuICB9KTtcbn1cbiIsImltcG9ydCB7XG4gIFBhcnRpY2lwYW50VHJhY2tzLFxuICBTdWJzY3JpcHRpb25FcnJvcixcbiAgVHJhY2tJbmZvLFxuICBWaWRlb1F1YWxpdHksXG59IGZyb20gJy4uLy4uL3Byb3RvL2xpdmVraXRfbW9kZWxzX3BiJztcbmltcG9ydCB7IFVwZGF0ZVN1YnNjcmlwdGlvbiwgVXBkYXRlVHJhY2tTZXR0aW5ncyB9IGZyb20gJy4uLy4uL3Byb3RvL2xpdmVraXRfcnRjX3BiJztcbmltcG9ydCB7IFRyYWNrRXZlbnQgfSBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IHR5cGUgeyBMb2dnZXJPcHRpb25zIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHR5cGUgUmVtb3RlVHJhY2sgZnJvbSAnLi9SZW1vdGVUcmFjayc7XG5pbXBvcnQgUmVtb3RlVmlkZW9UcmFjayBmcm9tICcuL1JlbW90ZVZpZGVvVHJhY2snO1xuaW1wb3J0IHsgVHJhY2sgfSBmcm9tICcuL1RyYWNrJztcbmltcG9ydCB7IFRyYWNrUHVibGljYXRpb24gfSBmcm9tICcuL1RyYWNrUHVibGljYXRpb24nO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW1vdGVUcmFja1B1YmxpY2F0aW9uIGV4dGVuZHMgVHJhY2tQdWJsaWNhdGlvbiB7XG4gIHRyYWNrPzogUmVtb3RlVHJhY2sgPSB1bmRlZmluZWQ7XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcm90ZWN0ZWQgYWxsb3dlZCA9IHRydWU7XG5cbiAgLy8ga2VlcHMgdHJhY2sgb2YgY2xpZW50J3MgZGVzaXJlIHRvIHN1YnNjcmliZSB0byBhIHRyYWNrLCBhbHNvIHRydWUgaWYgYXV0b1N1YnNjcmliZSBpcyBhY3RpdmVcbiAgcHJvdGVjdGVkIHN1YnNjcmliZWQ/OiBib29sZWFuO1xuXG4gIHByb3RlY3RlZCBkaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIHByb3RlY3RlZCBjdXJyZW50VmlkZW9RdWFsaXR5PzogVmlkZW9RdWFsaXR5ID0gVmlkZW9RdWFsaXR5LkhJR0g7XG5cbiAgcHJvdGVjdGVkIHZpZGVvRGltZW5zaW9ucz86IFRyYWNrLkRpbWVuc2lvbnM7XG5cbiAgcHJvdGVjdGVkIGZwcz86IG51bWJlcjtcblxuICBwcm90ZWN0ZWQgc3Vic2NyaXB0aW9uRXJyb3I/OiBTdWJzY3JpcHRpb25FcnJvcjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBraW5kOiBUcmFjay5LaW5kLFxuICAgIHRpOiBUcmFja0luZm8sXG4gICAgYXV0b1N1YnNjcmliZTogYm9vbGVhbiB8IHVuZGVmaW5lZCxcbiAgICBsb2dnZXJPcHRpb25zPzogTG9nZ2VyT3B0aW9ucyxcbiAgKSB7XG4gICAgc3VwZXIoa2luZCwgdGkuc2lkLCB0aS5uYW1lLCBsb2dnZXJPcHRpb25zKTtcbiAgICB0aGlzLnN1YnNjcmliZWQgPSBhdXRvU3Vic2NyaWJlO1xuICAgIHRoaXMudXBkYXRlSW5mbyh0aSk7XG4gIH1cblxuICAvKipcbiAgICogU3Vic2NyaWJlIG9yIHVuc3Vic2NyaWJlIHRvIHRoaXMgcmVtb3RlIHRyYWNrXG4gICAqIEBwYXJhbSBzdWJzY3JpYmVkIHRydWUgdG8gc3Vic2NyaWJlIHRvIGEgdHJhY2ssIGZhbHNlIHRvIHVuc3Vic2NyaWJlXG4gICAqL1xuICBzZXRTdWJzY3JpYmVkKHN1YnNjcmliZWQ6IGJvb2xlYW4pIHtcbiAgICBjb25zdCBwcmV2U3RhdHVzID0gdGhpcy5zdWJzY3JpcHRpb25TdGF0dXM7XG4gICAgY29uc3QgcHJldlBlcm1pc3Npb24gPSB0aGlzLnBlcm1pc3Npb25TdGF0dXM7XG4gICAgdGhpcy5zdWJzY3JpYmVkID0gc3Vic2NyaWJlZDtcbiAgICAvLyByZXNldCBhbGxvd2VkIHN0YXR1cyB3aGVuIGRlc2lyZWQgc3Vic2NyaXB0aW9uIHN0YXRlIGNoYW5nZXNcbiAgICAvLyBzZXJ2ZXIgd2lsbCBub3RpZnkgY2xpZW50IHZpYSBzaWduYWwgbWVzc2FnZSBpZiBpdCdzIG5vdCBhbGxvd2VkXG4gICAgaWYgKHN1YnNjcmliZWQpIHtcbiAgICAgIHRoaXMuYWxsb3dlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgY29uc3Qgc3ViID0gbmV3IFVwZGF0ZVN1YnNjcmlwdGlvbih7XG4gICAgICB0cmFja1NpZHM6IFt0aGlzLnRyYWNrU2lkXSxcbiAgICAgIHN1YnNjcmliZTogdGhpcy5zdWJzY3JpYmVkLFxuICAgICAgcGFydGljaXBhbnRUcmFja3M6IFtcbiAgICAgICAgbmV3IFBhcnRpY2lwYW50VHJhY2tzKHtcbiAgICAgICAgICAvLyBzZW5kaW5nIGFuIGVtcHR5IHBhcnRpY2lwYW50IGlkIHNpbmNlIFRyYWNrUHVibGljYXRpb24gZG9lc24ndCBrZWVwIGl0XG4gICAgICAgICAgLy8gdGhpcyBpcyBmaWxsZWQgaW4gYnkgdGhlIHBhcnRpY2lwYW50IHRoYXQgcmVjZWl2ZXMgdGhpcyBtZXNzYWdlXG4gICAgICAgICAgcGFydGljaXBhbnRTaWQ6ICcnLFxuICAgICAgICAgIHRyYWNrU2lkczogW3RoaXMudHJhY2tTaWRdLFxuICAgICAgICB9KSxcbiAgICAgIF0sXG4gICAgfSk7XG4gICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuVXBkYXRlU3Vic2NyaXB0aW9uLCBzdWIpO1xuICAgIHRoaXMuZW1pdFN1YnNjcmlwdGlvblVwZGF0ZUlmQ2hhbmdlZChwcmV2U3RhdHVzKTtcbiAgICB0aGlzLmVtaXRQZXJtaXNzaW9uVXBkYXRlSWZDaGFuZ2VkKHByZXZQZXJtaXNzaW9uKTtcbiAgfVxuXG4gIGdldCBzdWJzY3JpcHRpb25TdGF0dXMoKTogVHJhY2tQdWJsaWNhdGlvbi5TdWJzY3JpcHRpb25TdGF0dXMge1xuICAgIGlmICh0aGlzLnN1YnNjcmliZWQgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gVHJhY2tQdWJsaWNhdGlvbi5TdWJzY3JpcHRpb25TdGF0dXMuVW5zdWJzY3JpYmVkO1xuICAgIH1cbiAgICBpZiAoIXN1cGVyLmlzU3Vic2NyaWJlZCkge1xuICAgICAgcmV0dXJuIFRyYWNrUHVibGljYXRpb24uU3Vic2NyaXB0aW9uU3RhdHVzLkRlc2lyZWQ7XG4gICAgfVxuICAgIHJldHVybiBUcmFja1B1YmxpY2F0aW9uLlN1YnNjcmlwdGlvblN0YXR1cy5TdWJzY3JpYmVkO1xuICB9XG5cbiAgZ2V0IHBlcm1pc3Npb25TdGF0dXMoKTogVHJhY2tQdWJsaWNhdGlvbi5QZXJtaXNzaW9uU3RhdHVzIHtcbiAgICByZXR1cm4gdGhpcy5hbGxvd2VkXG4gICAgICA/IFRyYWNrUHVibGljYXRpb24uUGVybWlzc2lvblN0YXR1cy5BbGxvd2VkXG4gICAgICA6IFRyYWNrUHVibGljYXRpb24uUGVybWlzc2lvblN0YXR1cy5Ob3RBbGxvd2VkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0cmFjayBpcyBzdWJzY3JpYmVkLCBhbmQgcmVhZHkgZm9yIHBsYXliYWNrXG4gICAqL1xuICBnZXQgaXNTdWJzY3JpYmVkKCk6IGJvb2xlYW4ge1xuICAgIGlmICh0aGlzLnN1YnNjcmliZWQgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5pc1N1YnNjcmliZWQ7XG4gIH1cblxuICAvLyByZXR1cm5zIGNsaWVudCdzIGRlc2lyZSB0byBzdWJzY3JpYmUgdG8gYSB0cmFjaywgYWxzbyB0cnVlIGlmIGF1dG9TdWJzY3JpYmUgaXMgZW5hYmxlZFxuICBnZXQgaXNEZXNpcmVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnN1YnNjcmliZWQgIT09IGZhbHNlO1xuICB9XG5cbiAgZ2V0IGlzRW5hYmxlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gIXRoaXMuZGlzYWJsZWQ7XG4gIH1cblxuICAvKipcbiAgICogZGlzYWJsZSBzZXJ2ZXIgZnJvbSBzZW5kaW5nIGRvd24gZGF0YSBmb3IgdGhpcyB0cmFjay4gdGhpcyBpcyB1c2VmdWwgd2hlblxuICAgKiB0aGUgcGFydGljaXBhbnQgaXMgb2ZmIHNjcmVlbiwgeW91IG1heSBkaXNhYmxlIHN0cmVhbWluZyBkb3duIHRoZWlyIHZpZGVvXG4gICAqIHRvIHJlZHVjZSBiYW5kd2lkdGggcmVxdWlyZW1lbnRzXG4gICAqIEBwYXJhbSBlbmFibGVkXG4gICAqL1xuICBzZXRFbmFibGVkKGVuYWJsZWQ6IGJvb2xlYW4pIHtcbiAgICBpZiAoIXRoaXMuaXNNYW51YWxPcGVyYXRpb25BbGxvd2VkKCkgfHwgdGhpcy5kaXNhYmxlZCA9PT0gIWVuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5kaXNhYmxlZCA9ICFlbmFibGVkO1xuXG4gICAgdGhpcy5lbWl0VHJhY2tVcGRhdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBmb3IgdHJhY2tzIHRoYXQgc3VwcG9ydCBzaW11bGNhc3RpbmcsIGFkanVzdCBzdWJzY3JpYmVkIHF1YWxpdHlcbiAgICpcbiAgICogVGhpcyBpbmRpY2F0ZXMgdGhlIGhpZ2hlc3QgcXVhbGl0eSB0aGUgY2xpZW50IGNhbiBhY2NlcHQuIGlmIG5ldHdvcmtcbiAgICogYmFuZHdpZHRoIGRvZXMgbm90IGFsbG93LCBzZXJ2ZXIgd2lsbCBhdXRvbWF0aWNhbGx5IHJlZHVjZSBxdWFsaXR5IHRvXG4gICAqIG9wdGltaXplIGZvciB1bmludGVycnVwdGVkIHZpZGVvXG4gICAqL1xuICBzZXRWaWRlb1F1YWxpdHkocXVhbGl0eTogVmlkZW9RdWFsaXR5KSB7XG4gICAgaWYgKCF0aGlzLmlzTWFudWFsT3BlcmF0aW9uQWxsb3dlZCgpIHx8IHRoaXMuY3VycmVudFZpZGVvUXVhbGl0eSA9PT0gcXVhbGl0eSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnRWaWRlb1F1YWxpdHkgPSBxdWFsaXR5O1xuICAgIHRoaXMudmlkZW9EaW1lbnNpb25zID0gdW5kZWZpbmVkO1xuXG4gICAgdGhpcy5lbWl0VHJhY2tVcGRhdGUoKTtcbiAgfVxuXG4gIHNldFZpZGVvRGltZW5zaW9ucyhkaW1lbnNpb25zOiBUcmFjay5EaW1lbnNpb25zKSB7XG4gICAgaWYgKCF0aGlzLmlzTWFudWFsT3BlcmF0aW9uQWxsb3dlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChcbiAgICAgIHRoaXMudmlkZW9EaW1lbnNpb25zPy53aWR0aCA9PT0gZGltZW5zaW9ucy53aWR0aCAmJlxuICAgICAgdGhpcy52aWRlb0RpbWVuc2lvbnM/LmhlaWdodCA9PT0gZGltZW5zaW9ucy5oZWlnaHRcbiAgICApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMudHJhY2sgaW5zdGFuY2VvZiBSZW1vdGVWaWRlb1RyYWNrKSB7XG4gICAgICB0aGlzLnZpZGVvRGltZW5zaW9ucyA9IGRpbWVuc2lvbnM7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudFZpZGVvUXVhbGl0eSA9IHVuZGVmaW5lZDtcblxuICAgIHRoaXMuZW1pdFRyYWNrVXBkYXRlKCk7XG4gIH1cblxuICBzZXRWaWRlb0ZQUyhmcHM6IG51bWJlcikge1xuICAgIGlmICghdGhpcy5pc01hbnVhbE9wZXJhdGlvbkFsbG93ZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghKHRoaXMudHJhY2sgaW5zdGFuY2VvZiBSZW1vdGVWaWRlb1RyYWNrKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZwcyA9PT0gZnBzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5mcHMgPSBmcHM7XG4gICAgdGhpcy5lbWl0VHJhY2tVcGRhdGUoKTtcbiAgfVxuXG4gIGdldCB2aWRlb1F1YWxpdHkoKTogVmlkZW9RdWFsaXR5IHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50VmlkZW9RdWFsaXR5O1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzZXRUcmFjayh0cmFjaz86IFJlbW90ZVRyYWNrKSB7XG4gICAgY29uc3QgcHJldlN0YXR1cyA9IHRoaXMuc3Vic2NyaXB0aW9uU3RhdHVzO1xuICAgIGNvbnN0IHByZXZQZXJtaXNzaW9uID0gdGhpcy5wZXJtaXNzaW9uU3RhdHVzO1xuICAgIGNvbnN0IHByZXZUcmFjayA9IHRoaXMudHJhY2s7XG4gICAgaWYgKHByZXZUcmFjayA9PT0gdHJhY2spIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHByZXZUcmFjaykge1xuICAgICAgLy8gdW5yZWdpc3RlciBsaXN0ZW5lclxuICAgICAgcHJldlRyYWNrLm9mZihUcmFja0V2ZW50LlZpZGVvRGltZW5zaW9uc0NoYW5nZWQsIHRoaXMuaGFuZGxlVmlkZW9EaW1lbnNpb25zQ2hhbmdlKTtcbiAgICAgIHByZXZUcmFjay5vZmYoVHJhY2tFdmVudC5WaXNpYmlsaXR5Q2hhbmdlZCwgdGhpcy5oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlKTtcbiAgICAgIHByZXZUcmFjay5vZmYoVHJhY2tFdmVudC5FbmRlZCwgdGhpcy5oYW5kbGVFbmRlZCk7XG4gICAgICBwcmV2VHJhY2suZGV0YWNoKCk7XG4gICAgICBwcmV2VHJhY2suc3RvcE1vbml0b3IoKTtcbiAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlVuc3Vic2NyaWJlZCwgcHJldlRyYWNrKTtcbiAgICB9XG4gICAgc3VwZXIuc2V0VHJhY2sodHJhY2spO1xuICAgIGlmICh0cmFjaykge1xuICAgICAgdHJhY2suc2lkID0gdGhpcy50cmFja1NpZDtcbiAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuVmlkZW9EaW1lbnNpb25zQ2hhbmdlZCwgdGhpcy5oYW5kbGVWaWRlb0RpbWVuc2lvbnNDaGFuZ2UpO1xuICAgICAgdHJhY2sub24oVHJhY2tFdmVudC5WaXNpYmlsaXR5Q2hhbmdlZCwgdGhpcy5oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlKTtcbiAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuRW5kZWQsIHRoaXMuaGFuZGxlRW5kZWQpO1xuICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuU3Vic2NyaWJlZCwgdHJhY2spO1xuICAgIH1cbiAgICB0aGlzLmVtaXRQZXJtaXNzaW9uVXBkYXRlSWZDaGFuZ2VkKHByZXZQZXJtaXNzaW9uKTtcbiAgICB0aGlzLmVtaXRTdWJzY3JpcHRpb25VcGRhdGVJZkNoYW5nZWQocHJldlN0YXR1cyk7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHNldEFsbG93ZWQoYWxsb3dlZDogYm9vbGVhbikge1xuICAgIGNvbnN0IHByZXZTdGF0dXMgPSB0aGlzLnN1YnNjcmlwdGlvblN0YXR1cztcbiAgICBjb25zdCBwcmV2UGVybWlzc2lvbiA9IHRoaXMucGVybWlzc2lvblN0YXR1cztcbiAgICB0aGlzLmFsbG93ZWQgPSBhbGxvd2VkO1xuICAgIHRoaXMuZW1pdFBlcm1pc3Npb25VcGRhdGVJZkNoYW5nZWQocHJldlBlcm1pc3Npb24pO1xuICAgIHRoaXMuZW1pdFN1YnNjcmlwdGlvblVwZGF0ZUlmQ2hhbmdlZChwcmV2U3RhdHVzKTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc2V0U3Vic2NyaXB0aW9uRXJyb3IoZXJyb3I6IFN1YnNjcmlwdGlvbkVycm9yKSB7XG4gICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuU3Vic2NyaXB0aW9uRmFpbGVkLCBlcnJvcik7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHVwZGF0ZUluZm8oaW5mbzogVHJhY2tJbmZvKSB7XG4gICAgc3VwZXIudXBkYXRlSW5mbyhpbmZvKTtcbiAgICBjb25zdCBwcmV2TWV0YWRhdGFNdXRlZCA9IHRoaXMubWV0YWRhdGFNdXRlZDtcbiAgICB0aGlzLm1ldGFkYXRhTXV0ZWQgPSBpbmZvLm11dGVkO1xuICAgIGlmICh0aGlzLnRyYWNrKSB7XG4gICAgICB0aGlzLnRyYWNrLnNldE11dGVkKGluZm8ubXV0ZWQpO1xuICAgIH0gZWxzZSBpZiAocHJldk1ldGFkYXRhTXV0ZWQgIT09IGluZm8ubXV0ZWQpIHtcbiAgICAgIHRoaXMuZW1pdChpbmZvLm11dGVkID8gVHJhY2tFdmVudC5NdXRlZCA6IFRyYWNrRXZlbnQuVW5tdXRlZCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBlbWl0U3Vic2NyaXB0aW9uVXBkYXRlSWZDaGFuZ2VkKHByZXZpb3VzU3RhdHVzOiBUcmFja1B1YmxpY2F0aW9uLlN1YnNjcmlwdGlvblN0YXR1cykge1xuICAgIGNvbnN0IGN1cnJlbnRTdGF0dXMgPSB0aGlzLnN1YnNjcmlwdGlvblN0YXR1cztcbiAgICBpZiAocHJldmlvdXNTdGF0dXMgPT09IGN1cnJlbnRTdGF0dXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuU3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZCwgY3VycmVudFN0YXR1cywgcHJldmlvdXNTdGF0dXMpO1xuICB9XG5cbiAgcHJpdmF0ZSBlbWl0UGVybWlzc2lvblVwZGF0ZUlmQ2hhbmdlZChcbiAgICBwcmV2aW91c1Blcm1pc3Npb25TdGF0dXM6IFRyYWNrUHVibGljYXRpb24uUGVybWlzc2lvblN0YXR1cyxcbiAgKSB7XG4gICAgY29uc3QgY3VycmVudFBlcm1pc3Npb25TdGF0dXMgPSB0aGlzLnBlcm1pc3Npb25TdGF0dXM7XG4gICAgaWYgKGN1cnJlbnRQZXJtaXNzaW9uU3RhdHVzICE9PSBwcmV2aW91c1Blcm1pc3Npb25TdGF0dXMpIHtcbiAgICAgIHRoaXMuZW1pdChcbiAgICAgICAgVHJhY2tFdmVudC5TdWJzY3JpcHRpb25QZXJtaXNzaW9uQ2hhbmdlZCxcbiAgICAgICAgdGhpcy5wZXJtaXNzaW9uU3RhdHVzLFxuICAgICAgICBwcmV2aW91c1Blcm1pc3Npb25TdGF0dXMsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgaXNNYW51YWxPcGVyYXRpb25BbGxvd2VkKCk6IGJvb2xlYW4ge1xuICAgIGlmICh0aGlzLmtpbmQgPT09IFRyYWNrLktpbmQuVmlkZW8gJiYgdGhpcy5pc0FkYXB0aXZlU3RyZWFtKSB7XG4gICAgICB0aGlzLmxvZy53YXJuKFxuICAgICAgICAnYWRhcHRpdmUgc3RyZWFtIGlzIGVuYWJsZWQsIGNhbm5vdCBjaGFuZ2UgdmlkZW8gdHJhY2sgc2V0dGluZ3MnLFxuICAgICAgICB0aGlzLmxvZ0NvbnRleHQsXG4gICAgICApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaXNEZXNpcmVkKSB7XG4gICAgICB0aGlzLmxvZy53YXJuKCdjYW5ub3QgdXBkYXRlIHRyYWNrIHNldHRpbmdzIHdoZW4gbm90IHN1YnNjcmliZWQnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHByb3RlY3RlZCBoYW5kbGVFbmRlZCA9ICh0cmFjazogUmVtb3RlVHJhY2spID0+IHtcbiAgICB0aGlzLnNldFRyYWNrKHVuZGVmaW5lZCk7XG4gICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuRW5kZWQsIHRyYWNrKTtcbiAgfTtcblxuICBwcm90ZWN0ZWQgZ2V0IGlzQWRhcHRpdmVTdHJlYW0oKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMudHJhY2sgaW5zdGFuY2VvZiBSZW1vdGVWaWRlb1RyYWNrICYmIHRoaXMudHJhY2suaXNBZGFwdGl2ZVN0cmVhbTtcbiAgfVxuXG4gIHByb3RlY3RlZCBoYW5kbGVWaXNpYmlsaXR5Q2hhbmdlID0gKHZpc2libGU6IGJvb2xlYW4pID0+IHtcbiAgICB0aGlzLmxvZy5kZWJ1ZyhcbiAgICAgIGBhZGFwdGl2ZXN0cmVhbSB2aWRlbyB2aXNpYmlsaXR5ICR7dGhpcy50cmFja1NpZH0sIHZpc2libGU9JHt2aXNpYmxlfWAsXG4gICAgICB0aGlzLmxvZ0NvbnRleHQsXG4gICAgKTtcbiAgICB0aGlzLmRpc2FibGVkID0gIXZpc2libGU7XG4gICAgdGhpcy5lbWl0VHJhY2tVcGRhdGUoKTtcbiAgfTtcblxuICBwcm90ZWN0ZWQgaGFuZGxlVmlkZW9EaW1lbnNpb25zQ2hhbmdlID0gKGRpbWVuc2lvbnM6IFRyYWNrLkRpbWVuc2lvbnMpID0+IHtcbiAgICB0aGlzLmxvZy5kZWJ1ZyhcbiAgICAgIGBhZGFwdGl2ZXN0cmVhbSB2aWRlbyBkaW1lbnNpb25zICR7ZGltZW5zaW9ucy53aWR0aH14JHtkaW1lbnNpb25zLmhlaWdodH1gLFxuICAgICAgdGhpcy5sb2dDb250ZXh0LFxuICAgICk7XG4gICAgdGhpcy52aWRlb0RpbWVuc2lvbnMgPSBkaW1lbnNpb25zO1xuICAgIHRoaXMuZW1pdFRyYWNrVXBkYXRlKCk7XG4gIH07XG5cbiAgLyogQGludGVybmFsICovXG4gIGVtaXRUcmFja1VwZGF0ZSgpIHtcbiAgICBjb25zdCBzZXR0aW5nczogVXBkYXRlVHJhY2tTZXR0aW5ncyA9IG5ldyBVcGRhdGVUcmFja1NldHRpbmdzKHtcbiAgICAgIHRyYWNrU2lkczogW3RoaXMudHJhY2tTaWRdLFxuICAgICAgZGlzYWJsZWQ6IHRoaXMuZGlzYWJsZWQsXG4gICAgICBmcHM6IHRoaXMuZnBzLFxuICAgIH0pO1xuICAgIGlmICh0aGlzLnZpZGVvRGltZW5zaW9ucykge1xuICAgICAgc2V0dGluZ3Mud2lkdGggPSBNYXRoLmNlaWwodGhpcy52aWRlb0RpbWVuc2lvbnMud2lkdGgpO1xuICAgICAgc2V0dGluZ3MuaGVpZ2h0ID0gTWF0aC5jZWlsKHRoaXMudmlkZW9EaW1lbnNpb25zLmhlaWdodCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmN1cnJlbnRWaWRlb1F1YWxpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgc2V0dGluZ3MucXVhbGl0eSA9IHRoaXMuY3VycmVudFZpZGVvUXVhbGl0eTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZGVmYXVsdHMgdG8gaGlnaCBxdWFsaXR5XG4gICAgICBzZXR0aW5ncy5xdWFsaXR5ID0gVmlkZW9RdWFsaXR5LkhJR0g7XG4gICAgfVxuXG4gICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuVXBkYXRlU2V0dGluZ3MsIHNldHRpbmdzKTtcbiAgfVxufVxuIiwiaW1wb3J0IHR5cGUgeyBTaWduYWxDbGllbnQgfSBmcm9tICcuLi8uLi9hcGkvU2lnbmFsQ2xpZW50JztcbmltcG9ydCB0eXBlIHsgUGFydGljaXBhbnRJbmZvLCBTdWJzY3JpcHRpb25FcnJvciB9IGZyb20gJy4uLy4uL3Byb3RvL2xpdmVraXRfbW9kZWxzX3BiJztcbmltcG9ydCB0eXBlIHsgVXBkYXRlU3Vic2NyaXB0aW9uLCBVcGRhdGVUcmFja1NldHRpbmdzIH0gZnJvbSAnLi4vLi4vcHJvdG8vbGl2ZWtpdF9ydGNfcGInO1xuaW1wb3J0IHsgUGFydGljaXBhbnRFdmVudCwgVHJhY2tFdmVudCB9IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgUmVtb3RlQXVkaW9UcmFjayBmcm9tICcuLi90cmFjay9SZW1vdGVBdWRpb1RyYWNrJztcbmltcG9ydCB0eXBlIFJlbW90ZVRyYWNrIGZyb20gJy4uL3RyYWNrL1JlbW90ZVRyYWNrJztcbmltcG9ydCBSZW1vdGVUcmFja1B1YmxpY2F0aW9uIGZyb20gJy4uL3RyYWNrL1JlbW90ZVRyYWNrUHVibGljYXRpb24nO1xuaW1wb3J0IFJlbW90ZVZpZGVvVHJhY2sgZnJvbSAnLi4vdHJhY2svUmVtb3RlVmlkZW9UcmFjayc7XG5pbXBvcnQgeyBUcmFjayB9IGZyb20gJy4uL3RyYWNrL1RyYWNrJztcbmltcG9ydCB0eXBlIHsgVHJhY2tQdWJsaWNhdGlvbiB9IGZyb20gJy4uL3RyYWNrL1RyYWNrUHVibGljYXRpb24nO1xuaW1wb3J0IHR5cGUgeyBBdWRpb091dHB1dE9wdGlvbnMgfSBmcm9tICcuLi90cmFjay9vcHRpb25zJztcbmltcG9ydCB0eXBlIHsgQWRhcHRpdmVTdHJlYW1TZXR0aW5ncyB9IGZyb20gJy4uL3RyYWNrL3R5cGVzJztcbmltcG9ydCB7IGdldExvZ0NvbnRleHRGcm9tVHJhY2sgfSBmcm9tICcuLi90cmFjay91dGlscyc7XG5pbXBvcnQgdHlwZSB7IExvZ2dlck9wdGlvbnMgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgUGFydGljaXBhbnQgZnJvbSAnLi9QYXJ0aWNpcGFudCc7XG5pbXBvcnQgdHlwZSB7IFBhcnRpY2lwYW50RXZlbnRDYWxsYmFja3MgfSBmcm9tICcuL1BhcnRpY2lwYW50JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVtb3RlUGFydGljaXBhbnQgZXh0ZW5kcyBQYXJ0aWNpcGFudCB7XG4gIGF1ZGlvVHJhY2tzOiBNYXA8c3RyaW5nLCBSZW1vdGVUcmFja1B1YmxpY2F0aW9uPjtcblxuICB2aWRlb1RyYWNrczogTWFwPHN0cmluZywgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbj47XG5cbiAgdHJhY2tzOiBNYXA8c3RyaW5nLCBSZW1vdGVUcmFja1B1YmxpY2F0aW9uPjtcblxuICBzaWduYWxDbGllbnQ6IFNpZ25hbENsaWVudDtcblxuICBwcml2YXRlIHZvbHVtZU1hcDogTWFwPFRyYWNrLlNvdXJjZSwgbnVtYmVyPjtcblxuICBwcml2YXRlIGF1ZGlvT3V0cHV0PzogQXVkaW9PdXRwdXRPcHRpb25zO1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIGZyb21QYXJ0aWNpcGFudEluZm8oc2lnbmFsQ2xpZW50OiBTaWduYWxDbGllbnQsIHBpOiBQYXJ0aWNpcGFudEluZm8pOiBSZW1vdGVQYXJ0aWNpcGFudCB7XG4gICAgcmV0dXJuIG5ldyBSZW1vdGVQYXJ0aWNpcGFudChzaWduYWxDbGllbnQsIHBpLnNpZCwgcGkuaWRlbnRpdHksIHBpLm5hbWUsIHBpLm1ldGFkYXRhKTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgc2lnbmFsQ2xpZW50OiBTaWduYWxDbGllbnQsXG4gICAgc2lkOiBzdHJpbmcsXG4gICAgaWRlbnRpdHk/OiBzdHJpbmcsXG4gICAgbmFtZT86IHN0cmluZyxcbiAgICBtZXRhZGF0YT86IHN0cmluZyxcbiAgICBsb2dnZXJPcHRpb25zPzogTG9nZ2VyT3B0aW9ucyxcbiAgKSB7XG4gICAgc3VwZXIoc2lkLCBpZGVudGl0eSB8fCAnJywgbmFtZSwgbWV0YWRhdGEsIGxvZ2dlck9wdGlvbnMpO1xuICAgIHRoaXMuc2lnbmFsQ2xpZW50ID0gc2lnbmFsQ2xpZW50O1xuICAgIHRoaXMudHJhY2tzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuYXVkaW9UcmFja3MgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy52aWRlb1RyYWNrcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnZvbHVtZU1hcCA9IG5ldyBNYXAoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhZGRUcmFja1B1YmxpY2F0aW9uKHB1YmxpY2F0aW9uOiBSZW1vdGVUcmFja1B1YmxpY2F0aW9uKSB7XG4gICAgc3VwZXIuYWRkVHJhY2tQdWJsaWNhdGlvbihwdWJsaWNhdGlvbik7XG5cbiAgICAvLyByZWdpc3RlciBhY3Rpb24gZXZlbnRzXG4gICAgcHVibGljYXRpb24ub24oVHJhY2tFdmVudC5VcGRhdGVTZXR0aW5ncywgKHNldHRpbmdzOiBVcGRhdGVUcmFja1NldHRpbmdzKSA9PiB7XG4gICAgICB0aGlzLmxvZy5kZWJ1Zygnc2VuZCB1cGRhdGUgc2V0dGluZ3MnLCB7XG4gICAgICAgIC4uLnRoaXMubG9nQ29udGV4dCxcbiAgICAgICAgLi4uZ2V0TG9nQ29udGV4dEZyb21UcmFjayhwdWJsaWNhdGlvbiksXG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2lnbmFsQ2xpZW50LnNlbmRVcGRhdGVUcmFja1NldHRpbmdzKHNldHRpbmdzKTtcbiAgICB9KTtcbiAgICBwdWJsaWNhdGlvbi5vbihUcmFja0V2ZW50LlVwZGF0ZVN1YnNjcmlwdGlvbiwgKHN1YjogVXBkYXRlU3Vic2NyaXB0aW9uKSA9PiB7XG4gICAgICBzdWIucGFydGljaXBhbnRUcmFja3MuZm9yRWFjaCgocHQpID0+IHtcbiAgICAgICAgcHQucGFydGljaXBhbnRTaWQgPSB0aGlzLnNpZDtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zaWduYWxDbGllbnQuc2VuZFVwZGF0ZVN1YnNjcmlwdGlvbihzdWIpO1xuICAgIH0pO1xuICAgIHB1YmxpY2F0aW9uLm9uKFxuICAgICAgVHJhY2tFdmVudC5TdWJzY3JpcHRpb25QZXJtaXNzaW9uQ2hhbmdlZCxcbiAgICAgIChzdGF0dXM6IFRyYWNrUHVibGljYXRpb24uUGVybWlzc2lvblN0YXR1cykgPT4ge1xuICAgICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5UcmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkLCBwdWJsaWNhdGlvbiwgc3RhdHVzKTtcbiAgICAgIH0sXG4gICAgKTtcbiAgICBwdWJsaWNhdGlvbi5vbihcbiAgICAgIFRyYWNrRXZlbnQuU3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZCxcbiAgICAgIChzdGF0dXM6IFRyYWNrUHVibGljYXRpb24uU3Vic2NyaXB0aW9uU3RhdHVzKSA9PiB7XG4gICAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZCwgcHVibGljYXRpb24sIHN0YXR1cyk7XG4gICAgICB9LFxuICAgICk7XG4gICAgcHVibGljYXRpb24ub24oVHJhY2tFdmVudC5TdWJzY3JpYmVkLCAodHJhY2s6IFJlbW90ZVRyYWNrKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5UcmFja1N1YnNjcmliZWQsIHRyYWNrLCBwdWJsaWNhdGlvbik7XG4gICAgfSk7XG4gICAgcHVibGljYXRpb24ub24oVHJhY2tFdmVudC5VbnN1YnNjcmliZWQsIChwcmV2aW91c1RyYWNrOiBSZW1vdGVUcmFjaykgPT4ge1xuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuVHJhY2tVbnN1YnNjcmliZWQsIHByZXZpb3VzVHJhY2ssIHB1YmxpY2F0aW9uKTtcbiAgICB9KTtcbiAgICBwdWJsaWNhdGlvbi5vbihUcmFja0V2ZW50LlN1YnNjcmlwdGlvbkZhaWxlZCwgKGVycm9yOiBTdWJzY3JpcHRpb25FcnJvcikgPT4ge1xuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuVHJhY2tTdWJzY3JpcHRpb25GYWlsZWQsIHB1YmxpY2F0aW9uLnRyYWNrU2lkLCBlcnJvcik7XG4gICAgfSk7XG4gIH1cblxuICBnZXRUcmFjayhzb3VyY2U6IFRyYWNrLlNvdXJjZSk6IFJlbW90ZVRyYWNrUHVibGljYXRpb24gfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IHRyYWNrID0gc3VwZXIuZ2V0VHJhY2soc291cmNlKTtcbiAgICBpZiAodHJhY2spIHtcbiAgICAgIHJldHVybiB0cmFjayBhcyBSZW1vdGVUcmFja1B1YmxpY2F0aW9uO1xuICAgIH1cbiAgfVxuXG4gIGdldFRyYWNrQnlOYW1lKG5hbWU6IHN0cmluZyk6IFJlbW90ZVRyYWNrUHVibGljYXRpb24gfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IHRyYWNrID0gc3VwZXIuZ2V0VHJhY2tCeU5hbWUobmFtZSk7XG4gICAgaWYgKHRyYWNrKSB7XG4gICAgICByZXR1cm4gdHJhY2sgYXMgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogc2V0cyB0aGUgdm9sdW1lIG9uIHRoZSBwYXJ0aWNpcGFudCdzIGF1ZGlvIHRyYWNrXG4gICAqIGJ5IGRlZmF1bHQsIHRoaXMgYWZmZWN0cyB0aGUgbWljcm9waG9uZSBwdWJsaWNhdGlvblxuICAgKiBhIGRpZmZlcmVudCBzb3VyY2UgY2FuIGJlIHBhc3NlZCBpbiBhcyBhIHNlY29uZCBhcmd1bWVudFxuICAgKiBpZiBubyB0cmFjayBleGlzdHMgdGhlIHZvbHVtZSB3aWxsIGJlIGFwcGxpZWQgd2hlbiB0aGUgbWljcm9waG9uZSB0cmFjayBpcyBhZGRlZFxuICAgKi9cbiAgc2V0Vm9sdW1lKFxuICAgIHZvbHVtZTogbnVtYmVyLFxuICAgIHNvdXJjZTogVHJhY2suU291cmNlLk1pY3JvcGhvbmUgfCBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmVBdWRpbyA9IFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lLFxuICApIHtcbiAgICB0aGlzLnZvbHVtZU1hcC5zZXQoc291cmNlLCB2b2x1bWUpO1xuICAgIGNvbnN0IGF1ZGlvUHVibGljYXRpb24gPSB0aGlzLmdldFRyYWNrKHNvdXJjZSk7XG4gICAgaWYgKGF1ZGlvUHVibGljYXRpb24gJiYgYXVkaW9QdWJsaWNhdGlvbi50cmFjaykge1xuICAgICAgKGF1ZGlvUHVibGljYXRpb24udHJhY2sgYXMgUmVtb3RlQXVkaW9UcmFjaykuc2V0Vm9sdW1lKHZvbHVtZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGdldHMgdGhlIHZvbHVtZSBvbiB0aGUgcGFydGljaXBhbnQncyBtaWNyb3Bob25lIHRyYWNrXG4gICAqL1xuICBnZXRWb2x1bWUoXG4gICAgc291cmNlOiBUcmFjay5Tb3VyY2UuTWljcm9waG9uZSB8IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZUF1ZGlvID0gVHJhY2suU291cmNlLk1pY3JvcGhvbmUsXG4gICkge1xuICAgIGNvbnN0IGF1ZGlvUHVibGljYXRpb24gPSB0aGlzLmdldFRyYWNrKHNvdXJjZSk7XG4gICAgaWYgKGF1ZGlvUHVibGljYXRpb24gJiYgYXVkaW9QdWJsaWNhdGlvbi50cmFjaykge1xuICAgICAgcmV0dXJuIChhdWRpb1B1YmxpY2F0aW9uLnRyYWNrIGFzIFJlbW90ZUF1ZGlvVHJhY2spLmdldFZvbHVtZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy52b2x1bWVNYXAuZ2V0KHNvdXJjZSk7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIGFkZFN1YnNjcmliZWRNZWRpYVRyYWNrKFxuICAgIG1lZGlhVHJhY2s6IE1lZGlhU3RyZWFtVHJhY2ssXG4gICAgc2lkOiBUcmFjay5TSUQsXG4gICAgbWVkaWFTdHJlYW06IE1lZGlhU3RyZWFtLFxuICAgIHJlY2VpdmVyPzogUlRDUnRwUmVjZWl2ZXIsXG4gICAgYWRhcHRpdmVTdHJlYW1TZXR0aW5ncz86IEFkYXB0aXZlU3RyZWFtU2V0dGluZ3MsXG4gICAgdHJpZXNMZWZ0PzogbnVtYmVyLFxuICApIHtcbiAgICAvLyBmaW5kIHRoZSB0cmFjayBwdWJsaWNhdGlvblxuICAgIC8vIGl0J3MgcG9zc2libGUgZm9yIHRoZSBtZWRpYSB0cmFjayB0byBhcnJpdmUgYmVmb3JlIHBhcnRpY2lwYW50IGluZm9cbiAgICBsZXQgcHVibGljYXRpb24gPSB0aGlzLmdldFRyYWNrUHVibGljYXRpb24oc2lkKTtcblxuICAgIC8vIGl0J3MgYWxzbyBwb3NzaWJsZSB0aGF0IHRoZSBicm93c2VyIGRpZG4ndCBob25vciBvdXIgb3JpZ2luYWwgdHJhY2sgaWRcbiAgICAvLyBGaXJlRm94IHdvdWxkIHVzZSBpdHMgb3duIGxvY2FsIHV1aWQgaW5zdGVhZCBvZiBzZXJ2ZXIgdHJhY2sgaWRcbiAgICBpZiAoIXB1YmxpY2F0aW9uKSB7XG4gICAgICBpZiAoIXNpZC5zdGFydHNXaXRoKCdUUicpKSB7XG4gICAgICAgIC8vIGZpbmQgdGhlIGZpcnN0IHRyYWNrIHRoYXQgbWF0Y2hlcyB0eXBlXG4gICAgICAgIHRoaXMudHJhY2tzLmZvckVhY2goKHApID0+IHtcbiAgICAgICAgICBpZiAoIXB1YmxpY2F0aW9uICYmIG1lZGlhVHJhY2sua2luZCA9PT0gcC5raW5kLnRvU3RyaW5nKCkpIHtcbiAgICAgICAgICAgIHB1YmxpY2F0aW9uID0gcDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHdoZW4gd2UgY291bGRuJ3QgbG9jYXRlIHRoZSB0cmFjaywgaXQncyBwb3NzaWJsZSB0aGF0IHRoZSBtZXRhZGF0YSBoYXNuJ3RcbiAgICAvLyB5ZXQgYXJyaXZlZC4gV2FpdCBhIGJpdCBsb25nZXIgZm9yIGl0IHRvIGFycml2ZSwgb3IgZmlyZSBhbiBlcnJvclxuICAgIGlmICghcHVibGljYXRpb24pIHtcbiAgICAgIGlmICh0cmllc0xlZnQgPT09IDApIHtcbiAgICAgICAgdGhpcy5sb2cuZXJyb3IoJ2NvdWxkIG5vdCBmaW5kIHB1Ymxpc2hlZCB0cmFjaycsIHtcbiAgICAgICAgICAuLi50aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgICAgdHJhY2tTaWQ6IHNpZCxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3Vic2NyaXB0aW9uRmFpbGVkLCBzaWQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0cmllc0xlZnQgPT09IHVuZGVmaW5lZCkgdHJpZXNMZWZ0ID0gMjA7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5hZGRTdWJzY3JpYmVkTWVkaWFUcmFjayhcbiAgICAgICAgICBtZWRpYVRyYWNrLFxuICAgICAgICAgIHNpZCxcbiAgICAgICAgICBtZWRpYVN0cmVhbSxcbiAgICAgICAgICByZWNlaXZlcixcbiAgICAgICAgICBhZGFwdGl2ZVN0cmVhbVNldHRpbmdzLFxuICAgICAgICAgIHRyaWVzTGVmdCEgLSAxLFxuICAgICAgICApO1xuICAgICAgfSwgMTUwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobWVkaWFUcmFjay5yZWFkeVN0YXRlID09PSAnZW5kZWQnKSB7XG4gICAgICB0aGlzLmxvZy5lcnJvcihcbiAgICAgICAgJ3VuYWJsZSB0byBzdWJzY3JpYmUgYmVjYXVzZSBNZWRpYVN0cmVhbVRyYWNrIGlzIGVuZGVkLiBEbyBub3QgY2FsbCBNZWRpYVN0cmVhbVRyYWNrLnN0b3AoKScsXG4gICAgICAgIHsgLi4udGhpcy5sb2dDb250ZXh0LCAuLi5nZXRMb2dDb250ZXh0RnJvbVRyYWNrKHB1YmxpY2F0aW9uKSB9LFxuICAgICAgKTtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3Vic2NyaXB0aW9uRmFpbGVkLCBzaWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGlzVmlkZW8gPSBtZWRpYVRyYWNrLmtpbmQgPT09ICd2aWRlbyc7XG4gICAgbGV0IHRyYWNrOiBSZW1vdGVUcmFjaztcbiAgICBpZiAoaXNWaWRlbykge1xuICAgICAgdHJhY2sgPSBuZXcgUmVtb3RlVmlkZW9UcmFjayhtZWRpYVRyYWNrLCBzaWQsIHJlY2VpdmVyLCBhZGFwdGl2ZVN0cmVhbVNldHRpbmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhY2sgPSBuZXcgUmVtb3RlQXVkaW9UcmFjayhtZWRpYVRyYWNrLCBzaWQsIHJlY2VpdmVyLCB0aGlzLmF1ZGlvQ29udGV4dCwgdGhpcy5hdWRpb091dHB1dCk7XG4gICAgfVxuXG4gICAgLy8gc2V0IHRyYWNrIGluZm9cbiAgICB0cmFjay5zb3VyY2UgPSBwdWJsaWNhdGlvbi5zb3VyY2U7XG4gICAgLy8ga2VlcCBwdWJsaWNhdGlvbidzIG11dGVkIHN0YXR1c1xuICAgIHRyYWNrLmlzTXV0ZWQgPSBwdWJsaWNhdGlvbi5pc011dGVkO1xuICAgIHRyYWNrLnNldE1lZGlhU3RyZWFtKG1lZGlhU3RyZWFtKTtcbiAgICB0cmFjay5zdGFydCgpO1xuXG4gICAgcHVibGljYXRpb24uc2V0VHJhY2sodHJhY2spO1xuICAgIC8vIHNldCBwYXJ0aWNpcGFudCB2b2x1bWVzIG9uIG5ldyBhdWRpbyB0cmFja3NcbiAgICBpZiAodGhpcy52b2x1bWVNYXAuaGFzKHB1YmxpY2F0aW9uLnNvdXJjZSkgJiYgdHJhY2sgaW5zdGFuY2VvZiBSZW1vdGVBdWRpb1RyYWNrKSB7XG4gICAgICB0cmFjay5zZXRWb2x1bWUodGhpcy52b2x1bWVNYXAuZ2V0KHB1YmxpY2F0aW9uLnNvdXJjZSkhKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHVibGljYXRpb247XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIGdldCBoYXNNZXRhZGF0YSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gISF0aGlzLnBhcnRpY2lwYW50SW5mbztcbiAgfVxuXG4gIGdldFRyYWNrUHVibGljYXRpb24oc2lkOiBUcmFjay5TSUQpOiBSZW1vdGVUcmFja1B1YmxpY2F0aW9uIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy50cmFja3MuZ2V0KHNpZCk7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHVwZGF0ZUluZm8oaW5mbzogUGFydGljaXBhbnRJbmZvKTogYm9vbGVhbiB7XG4gICAgaWYgKCFzdXBlci51cGRhdGVJbmZvKGluZm8pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gd2UgYXJlIGdldHRpbmcgYSBsaXN0IG9mIGFsbCBhdmFpbGFibGUgdHJhY2tzLCByZWNvbmNpbGUgaW4gaGVyZVxuICAgIC8vIGFuZCBzZW5kIG91dCBldmVudHMgZm9yIGNoYW5nZXNcblxuICAgIC8vIHJlY29uY2lsZSB0cmFjayBwdWJsaWNhdGlvbnMsIHB1Ymxpc2ggZXZlbnRzIG9ubHkgaWYgbWV0YWRhdGEgaXMgYWxyZWFkeSB0aGVyZVxuICAgIC8vIGkuZS4gY2hhbmdlcyBzaW5jZSB0aGUgbG9jYWwgcGFydGljaXBhbnQgaGFzIGpvaW5lZFxuICAgIGNvbnN0IHZhbGlkVHJhY2tzID0gbmV3IE1hcDxzdHJpbmcsIFJlbW90ZVRyYWNrUHVibGljYXRpb24+KCk7XG4gICAgY29uc3QgbmV3VHJhY2tzID0gbmV3IE1hcDxzdHJpbmcsIFJlbW90ZVRyYWNrUHVibGljYXRpb24+KCk7XG5cbiAgICBpbmZvLnRyYWNrcy5mb3JFYWNoKCh0aSkgPT4ge1xuICAgICAgbGV0IHB1YmxpY2F0aW9uID0gdGhpcy5nZXRUcmFja1B1YmxpY2F0aW9uKHRpLnNpZCk7XG4gICAgICBpZiAoIXB1YmxpY2F0aW9uKSB7XG4gICAgICAgIC8vIG5ldyBwdWJsaWNhdGlvblxuICAgICAgICBjb25zdCBraW5kID0gVHJhY2sua2luZEZyb21Qcm90byh0aS50eXBlKTtcbiAgICAgICAgaWYgKCFraW5kKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHB1YmxpY2F0aW9uID0gbmV3IFJlbW90ZVRyYWNrUHVibGljYXRpb24oXG4gICAgICAgICAga2luZCxcbiAgICAgICAgICB0aSxcbiAgICAgICAgICB0aGlzLnNpZ25hbENsaWVudC5jb25uZWN0T3B0aW9ucz8uYXV0b1N1YnNjcmliZSxcbiAgICAgICAgICB7IGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0LCBsb2dnZXJOYW1lOiB0aGlzLmxvZ2dlck9wdGlvbnM/LmxvZ2dlck5hbWUgfSxcbiAgICAgICAgKTtcbiAgICAgICAgcHVibGljYXRpb24udXBkYXRlSW5mbyh0aSk7XG4gICAgICAgIG5ld1RyYWNrcy5zZXQodGkuc2lkLCBwdWJsaWNhdGlvbik7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nVHJhY2tPZlNvdXJjZSA9IEFycmF5LmZyb20odGhpcy50cmFja3MudmFsdWVzKCkpLmZpbmQoXG4gICAgICAgICAgKHB1Ymxpc2hlZFRyYWNrKSA9PiBwdWJsaXNoZWRUcmFjay5zb3VyY2UgPT09IHB1YmxpY2F0aW9uPy5zb3VyY2UsXG4gICAgICAgICk7XG4gICAgICAgIGlmIChleGlzdGluZ1RyYWNrT2ZTb3VyY2UgJiYgcHVibGljYXRpb24uc291cmNlICE9PSBUcmFjay5Tb3VyY2UuVW5rbm93bikge1xuICAgICAgICAgIHRoaXMubG9nLmRlYnVnKFxuICAgICAgICAgICAgYHJlY2VpdmVkIGEgc2Vjb25kIHRyYWNrIHB1YmxpY2F0aW9uIGZvciAke3RoaXMuaWRlbnRpdHl9IHdpdGggdGhlIHNhbWUgc291cmNlOiAke3B1YmxpY2F0aW9uLnNvdXJjZX1gLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAuLi50aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgICAgICAgIG9sZFRyYWNrOiBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKGV4aXN0aW5nVHJhY2tPZlNvdXJjZSksXG4gICAgICAgICAgICAgIG5ld1RyYWNrOiBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHB1YmxpY2F0aW9uKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZFRyYWNrUHVibGljYXRpb24ocHVibGljYXRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHVibGljYXRpb24udXBkYXRlSW5mbyh0aSk7XG4gICAgICB9XG4gICAgICB2YWxpZFRyYWNrcy5zZXQodGkuc2lkLCBwdWJsaWNhdGlvbik7XG4gICAgfSk7XG5cbiAgICAvLyBkZXRlY3QgcmVtb3ZlZCB0cmFja3NcbiAgICB0aGlzLnRyYWNrcy5mb3JFYWNoKChwdWJsaWNhdGlvbikgPT4ge1xuICAgICAgaWYgKCF2YWxpZFRyYWNrcy5oYXMocHVibGljYXRpb24udHJhY2tTaWQpKSB7XG4gICAgICAgIHRoaXMubG9nLnRyYWNlKCdkZXRlY3RlZCByZW1vdmVkIHRyYWNrIG9uIHJlbW90ZSBwYXJ0aWNpcGFudCwgdW5wdWJsaXNoaW5nJywge1xuICAgICAgICAgIC4uLnRoaXMubG9nQ29udGV4dCxcbiAgICAgICAgICAuLi5nZXRMb2dDb250ZXh0RnJvbVRyYWNrKHB1YmxpY2F0aW9uKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudW5wdWJsaXNoVHJhY2socHVibGljYXRpb24udHJhY2tTaWQsIHRydWUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gYWx3YXlzIGVtaXQgZXZlbnRzIGZvciBuZXcgcHVibGljYXRpb25zLCBSb29tIHdpbGwgbm90IGZvcndhcmQgdGhlbSB1bmxlc3MgaXQncyByZWFkeVxuICAgIG5ld1RyYWNrcy5mb3JFYWNoKChwdWJsaWNhdGlvbikgPT4ge1xuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuVHJhY2tQdWJsaXNoZWQsIHB1YmxpY2F0aW9uKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgdW5wdWJsaXNoVHJhY2soc2lkOiBUcmFjay5TSUQsIHNlbmRVbnB1Ymxpc2g/OiBib29sZWFuKSB7XG4gICAgY29uc3QgcHVibGljYXRpb24gPSA8UmVtb3RlVHJhY2tQdWJsaWNhdGlvbj50aGlzLnRyYWNrcy5nZXQoc2lkKTtcbiAgICBpZiAoIXB1YmxpY2F0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYWxzbyBzZW5kIHVuc3Vic2NyaWJlLCBpZiB0cmFjayBpcyBhY3RpdmVseSBzdWJzY3JpYmVkXG4gICAgY29uc3QgeyB0cmFjayB9ID0gcHVibGljYXRpb247XG4gICAgaWYgKHRyYWNrKSB7XG4gICAgICB0cmFjay5zdG9wKCk7XG4gICAgICBwdWJsaWNhdGlvbi5zZXRUcmFjayh1bmRlZmluZWQpO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSB0cmFjayBmcm9tIG1hcHMgb25seSBhZnRlciB1bnN1YnNjcmliZWQgaGFzIGJlZW4gZmlyZWRcbiAgICB0aGlzLnRyYWNrcy5kZWxldGUoc2lkKTtcblxuICAgIC8vIHJlbW92ZSBmcm9tIHRoZSByaWdodCB0eXBlIG1hcFxuICAgIHN3aXRjaCAocHVibGljYXRpb24ua2luZCkge1xuICAgICAgY2FzZSBUcmFjay5LaW5kLkF1ZGlvOlxuICAgICAgICB0aGlzLmF1ZGlvVHJhY2tzLmRlbGV0ZShzaWQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVHJhY2suS2luZC5WaWRlbzpcbiAgICAgICAgdGhpcy52aWRlb1RyYWNrcy5kZWxldGUoc2lkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc2VuZFVucHVibGlzaCkge1xuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuVHJhY2tVbnB1Ymxpc2hlZCwgcHVibGljYXRpb24pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGFzeW5jIHNldEF1ZGlvT3V0cHV0KG91dHB1dDogQXVkaW9PdXRwdXRPcHRpb25zKSB7XG4gICAgdGhpcy5hdWRpb091dHB1dCA9IG91dHB1dDtcbiAgICBjb25zdCBwcm9taXNlczogUHJvbWlzZTx2b2lkPltdID0gW107XG4gICAgdGhpcy5hdWRpb1RyYWNrcy5mb3JFYWNoKChwdWIpID0+IHtcbiAgICAgIGlmIChwdWIudHJhY2sgaW5zdGFuY2VvZiBSZW1vdGVBdWRpb1RyYWNrKSB7XG4gICAgICAgIHByb21pc2VzLnB1c2gocHViLnRyYWNrLnNldFNpbmtJZChvdXRwdXQuZGV2aWNlSWQgPz8gJ2RlZmF1bHQnKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBlbWl0PEUgZXh0ZW5kcyBrZXlvZiBQYXJ0aWNpcGFudEV2ZW50Q2FsbGJhY2tzPihcbiAgICBldmVudDogRSxcbiAgICAuLi5hcmdzOiBQYXJhbWV0ZXJzPFBhcnRpY2lwYW50RXZlbnRDYWxsYmFja3NbRV0+XG4gICk6IGJvb2xlYW4ge1xuICAgIHRoaXMubG9nLnRyYWNlKCdwYXJ0aWNpcGFudCBldmVudCcsIHsgLi4udGhpcy5sb2dDb250ZXh0LCBldmVudCwgYXJncyB9KTtcbiAgICByZXR1cm4gc3VwZXIuZW1pdChldmVudCwgLi4uYXJncyk7XG4gIH1cbn1cbiIsImltcG9ydCB0eXBlIHsgSW50ZXJuYWxSb29tT3B0aW9ucyB9IGZyb20gJy4uLy4uL29wdGlvbnMnO1xuaW1wb3J0IHtcbiAgRGF0YVBhY2tldCxcbiAgRGF0YVBhY2tldF9LaW5kLFxuICBFbmNyeXB0aW9uX1R5cGUsXG4gIFBhcnRpY2lwYW50SW5mbyxcbiAgUGFydGljaXBhbnRQZXJtaXNzaW9uLFxuICBVc2VyUGFja2V0LFxufSBmcm9tICcuLi8uLi9wcm90by9saXZla2l0X21vZGVsc19wYic7XG5pbXBvcnQge1xuICBBZGRUcmFja1JlcXVlc3QsXG4gIFNpbXVsY2FzdENvZGVjLFxuICBTdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSxcbiAgVHJhY2tVbnB1Ymxpc2hlZFJlc3BvbnNlLFxufSBmcm9tICcuLi8uLi9wcm90by9saXZla2l0X3J0Y19wYic7XG5pbXBvcnQgeyBQQ1RyYW5zcG9ydFN0YXRlIH0gZnJvbSAnLi4vUENUcmFuc3BvcnRNYW5hZ2VyJztcbmltcG9ydCB0eXBlIFJUQ0VuZ2luZSBmcm9tICcuLi9SVENFbmdpbmUnO1xuaW1wb3J0IHsgZGVmYXVsdFZpZGVvQ29kZWMgfSBmcm9tICcuLi9kZWZhdWx0cyc7XG5pbXBvcnQgeyBEZXZpY2VVbnN1cHBvcnRlZEVycm9yLCBUcmFja0ludmFsaWRFcnJvciwgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSB9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBFbmdpbmVFdmVudCwgUGFydGljaXBhbnRFdmVudCwgVHJhY2tFdmVudCB9IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgTG9jYWxBdWRpb1RyYWNrIGZyb20gJy4uL3RyYWNrL0xvY2FsQXVkaW9UcmFjayc7XG5pbXBvcnQgTG9jYWxUcmFjayBmcm9tICcuLi90cmFjay9Mb2NhbFRyYWNrJztcbmltcG9ydCBMb2NhbFRyYWNrUHVibGljYXRpb24gZnJvbSAnLi4vdHJhY2svTG9jYWxUcmFja1B1YmxpY2F0aW9uJztcbmltcG9ydCBMb2NhbFZpZGVvVHJhY2ssIHsgdmlkZW9MYXllcnNGcm9tRW5jb2RpbmdzIH0gZnJvbSAnLi4vdHJhY2svTG9jYWxWaWRlb1RyYWNrJztcbmltcG9ydCB7IFRyYWNrIH0gZnJvbSAnLi4vdHJhY2svVHJhY2snO1xuaW1wb3J0IHR5cGUge1xuICBBdWRpb0NhcHR1cmVPcHRpb25zLFxuICBCYWNrdXBWaWRlb0NvZGVjLFxuICBDcmVhdGVMb2NhbFRyYWNrc09wdGlvbnMsXG4gIFNjcmVlblNoYXJlQ2FwdHVyZU9wdGlvbnMsXG4gIFRyYWNrUHVibGlzaE9wdGlvbnMsXG4gIFZpZGVvQ2FwdHVyZU9wdGlvbnMsXG59IGZyb20gJy4uL3RyYWNrL29wdGlvbnMnO1xuaW1wb3J0IHsgU2NyZWVuU2hhcmVQcmVzZXRzLCBWaWRlb1ByZXNldHMsIGlzQmFja3VwQ29kZWMgfSBmcm9tICcuLi90cmFjay9vcHRpb25zJztcbmltcG9ydCB7XG4gIGNvbnN0cmFpbnRzRm9yT3B0aW9ucyxcbiAgZ2V0TG9nQ29udGV4dEZyb21UcmFjayxcbiAgbWVyZ2VEZWZhdWx0T3B0aW9ucyxcbiAgbWltZVR5cGVUb1ZpZGVvQ29kZWNTdHJpbmcsXG4gIHNjcmVlbkNhcHR1cmVUb0Rpc3BsYXlNZWRpYVN0cmVhbU9wdGlvbnMsXG59IGZyb20gJy4uL3RyYWNrL3V0aWxzJztcbmltcG9ydCB0eXBlIHsgRGF0YVB1Ymxpc2hPcHRpb25zIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHtcbiAgRnV0dXJlLFxuICBpc0ZpcmVGb3gsXG4gIGlzU1ZDQ29kZWMsXG4gIGlzU2FmYXJpLFxuICBpc1NhZmFyaTE3LFxuICBpc1dlYixcbiAgc3VwcG9ydHNBVjEsXG4gIHN1cHBvcnRzVlA5LFxufSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgUGFydGljaXBhbnQgZnJvbSAnLi9QYXJ0aWNpcGFudCc7XG5pbXBvcnQgdHlwZSB7IFBhcnRpY2lwYW50VHJhY2tQZXJtaXNzaW9uIH0gZnJvbSAnLi9QYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbic7XG5pbXBvcnQgeyB0cmFja1Blcm1pc3Npb25Ub1Byb3RvIH0gZnJvbSAnLi9QYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbic7XG5pbXBvcnQgUmVtb3RlUGFydGljaXBhbnQgZnJvbSAnLi9SZW1vdGVQYXJ0aWNpcGFudCc7XG5pbXBvcnQge1xuICBjb21wdXRlVHJhY2tCYWNrdXBFbmNvZGluZ3MsXG4gIGNvbXB1dGVWaWRlb0VuY29kaW5ncyxcbiAgbWVkaWFUcmFja1RvTG9jYWxUcmFjayxcbn0gZnJvbSAnLi9wdWJsaXNoVXRpbHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMb2NhbFBhcnRpY2lwYW50IGV4dGVuZHMgUGFydGljaXBhbnQge1xuICBhdWRpb1RyYWNrczogTWFwPHN0cmluZywgTG9jYWxUcmFja1B1YmxpY2F0aW9uPjtcblxuICB2aWRlb1RyYWNrczogTWFwPHN0cmluZywgTG9jYWxUcmFja1B1YmxpY2F0aW9uPjtcblxuICAvKiogbWFwIG9mIHRyYWNrIHNpZCA9PiBhbGwgcHVibGlzaGVkIHRyYWNrcyAqL1xuICB0cmFja3M6IE1hcDxzdHJpbmcsIExvY2FsVHJhY2tQdWJsaWNhdGlvbj47XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBlbmdpbmU6IFJUQ0VuZ2luZTtcblxuICAvKiogQGludGVybmFsICovXG4gIGFjdGl2ZURldmljZU1hcDogTWFwPE1lZGlhRGV2aWNlS2luZCwgc3RyaW5nPjtcblxuICBwcml2YXRlIHBlbmRpbmdQdWJsaXNoaW5nID0gbmV3IFNldDxUcmFjay5Tb3VyY2U+KCk7XG5cbiAgcHJpdmF0ZSBwZW5kaW5nUHVibGlzaFByb21pc2VzID0gbmV3IE1hcDxMb2NhbFRyYWNrLCBQcm9taXNlPExvY2FsVHJhY2tQdWJsaWNhdGlvbj4+KCk7XG5cbiAgcHJpdmF0ZSBjYW1lcmFFcnJvcjogRXJyb3IgfCB1bmRlZmluZWQ7XG5cbiAgcHJpdmF0ZSBtaWNyb3Bob25lRXJyb3I6IEVycm9yIHwgdW5kZWZpbmVkO1xuXG4gIHByaXZhdGUgcGFydGljaXBhbnRUcmFja1Blcm1pc3Npb25zOiBBcnJheTxQYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbj4gPSBbXTtcblxuICBwcml2YXRlIGFsbFBhcnRpY2lwYW50c0FsbG93ZWRUb1N1YnNjcmliZTogYm9vbGVhbiA9IHRydWU7XG5cbiAgLy8ga2VlcCBhIHBvaW50ZXIgdG8gcm9vbSBvcHRpb25zXG4gIHByaXZhdGUgcm9vbU9wdGlvbnM6IEludGVybmFsUm9vbU9wdGlvbnM7XG5cbiAgcHJpdmF0ZSBlbmNyeXB0aW9uVHlwZTogRW5jcnlwdGlvbl9UeXBlID0gRW5jcnlwdGlvbl9UeXBlLk5PTkU7XG5cbiAgcHJpdmF0ZSByZWNvbm5lY3RGdXR1cmU/OiBGdXR1cmU8dm9pZD47XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBjb25zdHJ1Y3RvcihzaWQ6IHN0cmluZywgaWRlbnRpdHk6IHN0cmluZywgZW5naW5lOiBSVENFbmdpbmUsIG9wdGlvbnM6IEludGVybmFsUm9vbU9wdGlvbnMpIHtcbiAgICBzdXBlcihzaWQsIGlkZW50aXR5LCB1bmRlZmluZWQsIHVuZGVmaW5lZCwge1xuICAgICAgbG9nZ2VyTmFtZTogb3B0aW9ucy5sb2dnZXJOYW1lLFxuICAgICAgbG9nZ2VyQ29udGV4dENiOiAoKSA9PiB0aGlzLmVuZ2luZS5sb2dDb250ZXh0LFxuICAgIH0pO1xuICAgIHRoaXMuYXVkaW9UcmFja3MgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy52aWRlb1RyYWNrcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnRyYWNrcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmVuZ2luZSA9IGVuZ2luZTtcbiAgICB0aGlzLnJvb21PcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnNldHVwRW5naW5lKGVuZ2luZSk7XG4gICAgdGhpcy5hY3RpdmVEZXZpY2VNYXAgPSBuZXcgTWFwKCk7XG4gIH1cblxuICBnZXQgbGFzdENhbWVyYUVycm9yKCk6IEVycm9yIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5jYW1lcmFFcnJvcjtcbiAgfVxuXG4gIGdldCBsYXN0TWljcm9waG9uZUVycm9yKCk6IEVycm9yIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5taWNyb3Bob25lRXJyb3I7XG4gIH1cblxuICBnZXQgaXNFMkVFRW5hYmxlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5lbmNyeXB0aW9uVHlwZSAhPT0gRW5jcnlwdGlvbl9UeXBlLk5PTkU7XG4gIH1cblxuICBnZXRUcmFjayhzb3VyY2U6IFRyYWNrLlNvdXJjZSk6IExvY2FsVHJhY2tQdWJsaWNhdGlvbiB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3QgdHJhY2sgPSBzdXBlci5nZXRUcmFjayhzb3VyY2UpO1xuICAgIGlmICh0cmFjaykge1xuICAgICAgcmV0dXJuIHRyYWNrIGFzIExvY2FsVHJhY2tQdWJsaWNhdGlvbjtcbiAgICB9XG4gIH1cblxuICBnZXRUcmFja0J5TmFtZShuYW1lOiBzdHJpbmcpOiBMb2NhbFRyYWNrUHVibGljYXRpb24gfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IHRyYWNrID0gc3VwZXIuZ2V0VHJhY2tCeU5hbWUobmFtZSk7XG4gICAgaWYgKHRyYWNrKSB7XG4gICAgICByZXR1cm4gdHJhY2sgYXMgTG9jYWxUcmFja1B1YmxpY2F0aW9uO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHNldHVwRW5naW5lKGVuZ2luZTogUlRDRW5naW5lKSB7XG4gICAgdGhpcy5lbmdpbmUgPSBlbmdpbmU7XG4gICAgdGhpcy5lbmdpbmUub24oRW5naW5lRXZlbnQuUmVtb3RlTXV0ZSwgKHRyYWNrU2lkOiBzdHJpbmcsIG11dGVkOiBib29sZWFuKSA9PiB7XG4gICAgICBjb25zdCBwdWIgPSB0aGlzLnRyYWNrcy5nZXQodHJhY2tTaWQpO1xuICAgICAgaWYgKCFwdWIgfHwgIXB1Yi50cmFjaykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAobXV0ZWQpIHtcbiAgICAgICAgcHViLm11dGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHB1Yi51bm11dGUoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuZW5naW5lXG4gICAgICAub24oRW5naW5lRXZlbnQuQ29ubmVjdGVkLCB0aGlzLmhhbmRsZVJlY29ubmVjdGVkKVxuICAgICAgLm9uKEVuZ2luZUV2ZW50LlNpZ25hbFJlc3RhcnRlZCwgdGhpcy5oYW5kbGVSZWNvbm5lY3RlZClcbiAgICAgIC5vbihFbmdpbmVFdmVudC5TaWduYWxSZXN1bWVkLCB0aGlzLmhhbmRsZVJlY29ubmVjdGVkKVxuICAgICAgLm9uKEVuZ2luZUV2ZW50LlJlc3RhcnRpbmcsIHRoaXMuaGFuZGxlUmVjb25uZWN0aW5nKVxuICAgICAgLm9uKEVuZ2luZUV2ZW50LlJlc3VtaW5nLCB0aGlzLmhhbmRsZVJlY29ubmVjdGluZylcbiAgICAgIC5vbihFbmdpbmVFdmVudC5Mb2NhbFRyYWNrVW5wdWJsaXNoZWQsIHRoaXMuaGFuZGxlTG9jYWxUcmFja1VucHVibGlzaGVkKVxuICAgICAgLm9uKEVuZ2luZUV2ZW50LlN1YnNjcmliZWRRdWFsaXR5VXBkYXRlLCB0aGlzLmhhbmRsZVN1YnNjcmliZWRRdWFsaXR5VXBkYXRlKVxuICAgICAgLm9uKEVuZ2luZUV2ZW50LkRpc2Nvbm5lY3RlZCwgdGhpcy5oYW5kbGVEaXNjb25uZWN0ZWQpO1xuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVSZWNvbm5lY3RpbmcgPSAoKSA9PiB7XG4gICAgaWYgKCF0aGlzLnJlY29ubmVjdEZ1dHVyZSkge1xuICAgICAgdGhpcy5yZWNvbm5lY3RGdXR1cmUgPSBuZXcgRnV0dXJlPHZvaWQ+KCk7XG4gICAgfVxuICB9O1xuXG4gIHByaXZhdGUgaGFuZGxlUmVjb25uZWN0ZWQgPSAoKSA9PiB7XG4gICAgdGhpcy5yZWNvbm5lY3RGdXR1cmU/LnJlc29sdmU/LigpO1xuICAgIHRoaXMucmVjb25uZWN0RnV0dXJlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudXBkYXRlVHJhY2tTdWJzY3JpcHRpb25QZXJtaXNzaW9ucygpO1xuICB9O1xuXG4gIHByaXZhdGUgaGFuZGxlRGlzY29ubmVjdGVkID0gKCkgPT4ge1xuICAgIGlmICh0aGlzLnJlY29ubmVjdEZ1dHVyZSkge1xuICAgICAgdGhpcy5yZWNvbm5lY3RGdXR1cmUucHJvbWlzZS5jYXRjaCgoZSkgPT4gdGhpcy5sb2cud2FybihlLm1lc3NhZ2UsIHRoaXMubG9nQ29udGV4dCkpO1xuICAgICAgdGhpcy5yZWNvbm5lY3RGdXR1cmU/LnJlamVjdD8uKCdHb3QgZGlzY29ubmVjdGVkIGR1cmluZyByZWNvbm5lY3Rpb24gYXR0ZW1wdCcpO1xuICAgICAgdGhpcy5yZWNvbm5lY3RGdXR1cmUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXRzIGFuZCB1cGRhdGVzIHRoZSBtZXRhZGF0YSBvZiB0aGUgbG9jYWwgcGFydGljaXBhbnQuXG4gICAqIFRoZSBjaGFuZ2UgZG9lcyBub3QgdGFrZSBpbW1lZGlhdGUgZWZmZWN0LlxuICAgKiBJZiBzdWNjZXNzZnVsLCBhIGBQYXJ0aWNpcGFudEV2ZW50Lk1ldGFkYXRhQ2hhbmdlZGAgZXZlbnQgd2lsbCBiZSBlbWl0dGVkIG9uIHRoZSBsb2NhbCBwYXJ0aWNpcGFudC5cbiAgICogTm90ZTogdGhpcyByZXF1aXJlcyBgY2FuVXBkYXRlT3duTWV0YWRhdGFgIHBlcm1pc3Npb24uXG4gICAqIEBwYXJhbSBtZXRhZGF0YVxuICAgKi9cbiAgc2V0TWV0YWRhdGEobWV0YWRhdGE6IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMuZW5naW5lLmNsaWVudC5zZW5kVXBkYXRlTG9jYWxNZXRhZGF0YShtZXRhZGF0YSwgdGhpcy5uYW1lID8/ICcnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGFuZCB1cGRhdGVzIHRoZSBuYW1lIG9mIHRoZSBsb2NhbCBwYXJ0aWNpcGFudC5cbiAgICogVGhlIGNoYW5nZSBkb2VzIG5vdCB0YWtlIGltbWVkaWF0ZSBlZmZlY3QuXG4gICAqIElmIHN1Y2Nlc3NmdWwsIGEgYFBhcnRpY2lwYW50RXZlbnQuUGFydGljaXBhbnROYW1lQ2hhbmdlZGAgZXZlbnQgd2lsbCBiZSBlbWl0dGVkIG9uIHRoZSBsb2NhbCBwYXJ0aWNpcGFudC5cbiAgICogTm90ZTogdGhpcyByZXF1aXJlcyBgY2FuVXBkYXRlT3duTWV0YWRhdGFgIHBlcm1pc3Npb24uXG4gICAqIEBwYXJhbSBtZXRhZGF0YVxuICAgKi9cbiAgc2V0TmFtZShuYW1lOiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aGlzLmVuZ2luZS5jbGllbnQuc2VuZFVwZGF0ZUxvY2FsTWV0YWRhdGEodGhpcy5tZXRhZGF0YSA/PyAnJywgbmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogRW5hYmxlIG9yIGRpc2FibGUgYSBwYXJ0aWNpcGFudCdzIGNhbWVyYSB0cmFjay5cbiAgICpcbiAgICogSWYgYSB0cmFjayBoYXMgYWxyZWFkeSBwdWJsaXNoZWQsIGl0J2xsIG11dGUgb3IgdW5tdXRlIHRoZSB0cmFjay5cbiAgICogUmVzb2x2ZXMgd2l0aCBhIGBMb2NhbFRyYWNrUHVibGljYXRpb25gIGluc3RhbmNlIGlmIHN1Y2Nlc3NmdWwgYW5kIGB1bmRlZmluZWRgIG90aGVyd2lzZVxuICAgKi9cbiAgc2V0Q2FtZXJhRW5hYmxlZChcbiAgICBlbmFibGVkOiBib29sZWFuLFxuICAgIG9wdGlvbnM/OiBWaWRlb0NhcHR1cmVPcHRpb25zLFxuICAgIHB1Ymxpc2hPcHRpb25zPzogVHJhY2tQdWJsaXNoT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxMb2NhbFRyYWNrUHVibGljYXRpb24gfCB1bmRlZmluZWQ+IHtcbiAgICByZXR1cm4gdGhpcy5zZXRUcmFja0VuYWJsZWQoVHJhY2suU291cmNlLkNhbWVyYSwgZW5hYmxlZCwgb3B0aW9ucywgcHVibGlzaE9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuYWJsZSBvciBkaXNhYmxlIGEgcGFydGljaXBhbnQncyBtaWNyb3Bob25lIHRyYWNrLlxuICAgKlxuICAgKiBJZiBhIHRyYWNrIGhhcyBhbHJlYWR5IHB1Ymxpc2hlZCwgaXQnbGwgbXV0ZSBvciB1bm11dGUgdGhlIHRyYWNrLlxuICAgKiBSZXNvbHZlcyB3aXRoIGEgYExvY2FsVHJhY2tQdWJsaWNhdGlvbmAgaW5zdGFuY2UgaWYgc3VjY2Vzc2Z1bCBhbmQgYHVuZGVmaW5lZGAgb3RoZXJ3aXNlXG4gICAqL1xuICBzZXRNaWNyb3Bob25lRW5hYmxlZChcbiAgICBlbmFibGVkOiBib29sZWFuLFxuICAgIG9wdGlvbnM/OiBBdWRpb0NhcHR1cmVPcHRpb25zLFxuICAgIHB1Ymxpc2hPcHRpb25zPzogVHJhY2tQdWJsaXNoT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxMb2NhbFRyYWNrUHVibGljYXRpb24gfCB1bmRlZmluZWQ+IHtcbiAgICByZXR1cm4gdGhpcy5zZXRUcmFja0VuYWJsZWQoVHJhY2suU291cmNlLk1pY3JvcGhvbmUsIGVuYWJsZWQsIG9wdGlvbnMsIHB1Ymxpc2hPcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCBvciBzdG9wIHNoYXJpbmcgYSBwYXJ0aWNpcGFudCdzIHNjcmVlblxuICAgKiBSZXNvbHZlcyB3aXRoIGEgYExvY2FsVHJhY2tQdWJsaWNhdGlvbmAgaW5zdGFuY2UgaWYgc3VjY2Vzc2Z1bCBhbmQgYHVuZGVmaW5lZGAgb3RoZXJ3aXNlXG4gICAqL1xuICBzZXRTY3JlZW5TaGFyZUVuYWJsZWQoXG4gICAgZW5hYmxlZDogYm9vbGVhbixcbiAgICBvcHRpb25zPzogU2NyZWVuU2hhcmVDYXB0dXJlT3B0aW9ucyxcbiAgICBwdWJsaXNoT3B0aW9ucz86IFRyYWNrUHVibGlzaE9wdGlvbnMsXG4gICk6IFByb21pc2U8TG9jYWxUcmFja1B1YmxpY2F0aW9uIHwgdW5kZWZpbmVkPiB7XG4gICAgcmV0dXJuIHRoaXMuc2V0VHJhY2tFbmFibGVkKFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZSwgZW5hYmxlZCwgb3B0aW9ucywgcHVibGlzaE9wdGlvbnMpO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzZXRQZXJtaXNzaW9ucyhwZXJtaXNzaW9uczogUGFydGljaXBhbnRQZXJtaXNzaW9uKTogYm9vbGVhbiB7XG4gICAgY29uc3QgcHJldlBlcm1pc3Npb25zID0gdGhpcy5wZXJtaXNzaW9ucztcbiAgICBjb25zdCBjaGFuZ2VkID0gc3VwZXIuc2V0UGVybWlzc2lvbnMocGVybWlzc2lvbnMpO1xuICAgIGlmIChjaGFuZ2VkICYmIHByZXZQZXJtaXNzaW9ucykge1xuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuUGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWQsIHByZXZQZXJtaXNzaW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VkO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBhc3luYyBzZXRFMkVFRW5hYmxlZChlbmFibGVkOiBib29sZWFuKSB7XG4gICAgdGhpcy5lbmNyeXB0aW9uVHlwZSA9IGVuYWJsZWQgPyBFbmNyeXB0aW9uX1R5cGUuR0NNIDogRW5jcnlwdGlvbl9UeXBlLk5PTkU7XG4gICAgYXdhaXQgdGhpcy5yZXB1Ymxpc2hBbGxUcmFja3ModW5kZWZpbmVkLCBmYWxzZSk7XG4gIH1cblxuICAvKipcbiAgICogRW5hYmxlIG9yIGRpc2FibGUgcHVibGlzaGluZyBmb3IgYSB0cmFjayBieSBzb3VyY2UuIFRoaXMgc2VydmVzIGFzIGEgc2ltcGxlXG4gICAqIHdheSB0byBtYW5hZ2UgdGhlIGNvbW1vbiB0cmFja3MgKGNhbWVyYSwgbWljLCBvciBzY3JlZW4gc2hhcmUpLlxuICAgKiBSZXNvbHZlcyB3aXRoIExvY2FsVHJhY2tQdWJsaWNhdGlvbiBpZiBzdWNjZXNzZnVsIGFuZCB2b2lkIG90aGVyd2lzZVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBzZXRUcmFja0VuYWJsZWQoXG4gICAgc291cmNlOiBFeHRyYWN0PFRyYWNrLlNvdXJjZSwgVHJhY2suU291cmNlLkNhbWVyYT4sXG4gICAgZW5hYmxlZDogYm9vbGVhbixcbiAgICBvcHRpb25zPzogVmlkZW9DYXB0dXJlT3B0aW9ucyxcbiAgICBwdWJsaXNoT3B0aW9ucz86IFRyYWNrUHVibGlzaE9wdGlvbnMsXG4gICk6IFByb21pc2U8TG9jYWxUcmFja1B1YmxpY2F0aW9uIHwgdW5kZWZpbmVkPjtcbiAgcHJpdmF0ZSBhc3luYyBzZXRUcmFja0VuYWJsZWQoXG4gICAgc291cmNlOiBFeHRyYWN0PFRyYWNrLlNvdXJjZSwgVHJhY2suU291cmNlLk1pY3JvcGhvbmU+LFxuICAgIGVuYWJsZWQ6IGJvb2xlYW4sXG4gICAgb3B0aW9ucz86IEF1ZGlvQ2FwdHVyZU9wdGlvbnMsXG4gICAgcHVibGlzaE9wdGlvbnM/OiBUcmFja1B1Ymxpc2hPcHRpb25zLFxuICApOiBQcm9taXNlPExvY2FsVHJhY2tQdWJsaWNhdGlvbiB8IHVuZGVmaW5lZD47XG4gIHByaXZhdGUgYXN5bmMgc2V0VHJhY2tFbmFibGVkKFxuICAgIHNvdXJjZTogRXh0cmFjdDxUcmFjay5Tb3VyY2UsIFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZT4sXG4gICAgZW5hYmxlZDogYm9vbGVhbixcbiAgICBvcHRpb25zPzogU2NyZWVuU2hhcmVDYXB0dXJlT3B0aW9ucyxcbiAgICBwdWJsaXNoT3B0aW9ucz86IFRyYWNrUHVibGlzaE9wdGlvbnMsXG4gICk6IFByb21pc2U8TG9jYWxUcmFja1B1YmxpY2F0aW9uIHwgdW5kZWZpbmVkPjtcbiAgcHJpdmF0ZSBhc3luYyBzZXRUcmFja0VuYWJsZWQoXG4gICAgc291cmNlOiBUcmFjay5Tb3VyY2UsXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBvcHRpb25zPzogVmlkZW9DYXB0dXJlT3B0aW9ucyB8IEF1ZGlvQ2FwdHVyZU9wdGlvbnMgfCBTY3JlZW5TaGFyZUNhcHR1cmVPcHRpb25zLFxuICAgIHB1Ymxpc2hPcHRpb25zPzogVHJhY2tQdWJsaXNoT3B0aW9ucyxcbiAgKSB7XG4gICAgdGhpcy5sb2cuZGVidWcoJ3NldFRyYWNrRW5hYmxlZCcsIHsgLi4udGhpcy5sb2dDb250ZXh0LCBzb3VyY2UsIGVuYWJsZWQgfSk7XG4gICAgbGV0IHRyYWNrID0gdGhpcy5nZXRUcmFjayhzb3VyY2UpO1xuICAgIGlmIChlbmFibGVkKSB7XG4gICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgYXdhaXQgdHJhY2sudW5tdXRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgbG9jYWxUcmFja3M6IEFycmF5PExvY2FsVHJhY2s+IHwgdW5kZWZpbmVkO1xuICAgICAgICBpZiAodGhpcy5wZW5kaW5nUHVibGlzaGluZy5oYXMoc291cmNlKSkge1xuICAgICAgICAgIHRoaXMubG9nLmluZm8oJ3NraXBwaW5nIGR1cGxpY2F0ZSBwdWJsaXNoZWQgc291cmNlJywgeyAuLi50aGlzLmxvZ0NvbnRleHQsIHNvdXJjZSB9KTtcbiAgICAgICAgICAvLyBuby1vcCBpdCdzIGFscmVhZHkgYmVlbiByZXF1ZXN0ZWRcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wZW5kaW5nUHVibGlzaGluZy5hZGQoc291cmNlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzd2l0Y2ggKHNvdXJjZSkge1xuICAgICAgICAgICAgY2FzZSBUcmFjay5Tb3VyY2UuQ2FtZXJhOlxuICAgICAgICAgICAgICBsb2NhbFRyYWNrcyA9IGF3YWl0IHRoaXMuY3JlYXRlVHJhY2tzKHtcbiAgICAgICAgICAgICAgICB2aWRlbzogKG9wdGlvbnMgYXMgVmlkZW9DYXB0dXJlT3B0aW9ucyB8IHVuZGVmaW5lZCkgPz8gdHJ1ZSxcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lOlxuICAgICAgICAgICAgICBsb2NhbFRyYWNrcyA9IGF3YWl0IHRoaXMuY3JlYXRlVHJhY2tzKHtcbiAgICAgICAgICAgICAgICBhdWRpbzogKG9wdGlvbnMgYXMgQXVkaW9DYXB0dXJlT3B0aW9ucyB8IHVuZGVmaW5lZCkgPz8gdHJ1ZSxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmU6XG4gICAgICAgICAgICAgIGxvY2FsVHJhY2tzID0gYXdhaXQgdGhpcy5jcmVhdGVTY3JlZW5UcmFja3Moe1xuICAgICAgICAgICAgICAgIC4uLihvcHRpb25zIGFzIFNjcmVlblNoYXJlQ2FwdHVyZU9wdGlvbnMgfCB1bmRlZmluZWQpLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHJhY2tJbnZhbGlkRXJyb3Ioc291cmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgcHVibGlzaFByb21pc2VzOiBBcnJheTxQcm9taXNlPExvY2FsVHJhY2tQdWJsaWNhdGlvbj4+ID0gW107XG4gICAgICAgICAgZm9yIChjb25zdCBsb2NhbFRyYWNrIG9mIGxvY2FsVHJhY2tzKSB7XG4gICAgICAgICAgICB0aGlzLmxvZy5pbmZvKCdwdWJsaXNoaW5nIHRyYWNrJywge1xuICAgICAgICAgICAgICAuLi50aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgICAgICAgIC4uLmdldExvZ0NvbnRleHRGcm9tVHJhY2sobG9jYWxUcmFjayksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHB1Ymxpc2hQcm9taXNlcy5wdXNoKHRoaXMucHVibGlzaFRyYWNrKGxvY2FsVHJhY2ssIHB1Ymxpc2hPcHRpb25zKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHB1Ymxpc2hlZFRyYWNrcyA9IGF3YWl0IFByb21pc2UuYWxsKHB1Ymxpc2hQcm9taXNlcyk7XG4gICAgICAgICAgLy8gZm9yIHNjcmVlbiBzaGFyZSBwdWJsaWNhdGlvbnMgaW5jbHVkaW5nIGF1ZGlvLCB0aGlzIHdpbGwgb25seSByZXR1cm4gdGhlIHNjcmVlbiBzaGFyZSBwdWJsaWNhdGlvbiwgbm90IHRoZSBzY3JlZW4gc2hhcmUgYXVkaW8gb25lXG4gICAgICAgICAgLy8gcmV2aXNpdCBpZiB3ZSB3YW50IHRvIHJldHVybiBhbiBhcnJheSBvZiB0cmFja3MgaW5zdGVhZCBmb3IgdjJcbiAgICAgICAgICBbdHJhY2tdID0gcHVibGlzaGVkVHJhY2tzO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgbG9jYWxUcmFja3M/LmZvckVhY2goKHRyKSA9PiB7XG4gICAgICAgICAgICB0ci5zdG9wKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGUgaW5zdGFuY2VvZiBUcmFja0ludmFsaWRFcnJvcikpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50Lk1lZGlhRGV2aWNlc0Vycm9yLCBlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0aGlzLnBlbmRpbmdQdWJsaXNoaW5nLmRlbGV0ZShzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0cmFjayAmJiB0cmFjay50cmFjaykge1xuICAgICAgLy8gc2NyZWVuc2hhcmUgY2Fubm90IGJlIG11dGVkLCB1bnB1Ymxpc2ggaW5zdGVhZFxuICAgICAgaWYgKHNvdXJjZSA9PT0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlKSB7XG4gICAgICAgIHRyYWNrID0gYXdhaXQgdGhpcy51bnB1Ymxpc2hUcmFjayh0cmFjay50cmFjayk7XG4gICAgICAgIGNvbnN0IHNjcmVlbkF1ZGlvVHJhY2sgPSB0aGlzLmdldFRyYWNrKFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZUF1ZGlvKTtcbiAgICAgICAgaWYgKHNjcmVlbkF1ZGlvVHJhY2sgJiYgc2NyZWVuQXVkaW9UcmFjay50cmFjaykge1xuICAgICAgICAgIHRoaXMudW5wdWJsaXNoVHJhY2soc2NyZWVuQXVkaW9UcmFjay50cmFjayk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF3YWl0IHRyYWNrLm11dGUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRyYWNrO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1Ymxpc2ggYm90aCBjYW1lcmEgYW5kIG1pY3JvcGhvbmUgYXQgdGhlIHNhbWUgdGltZS4gVGhpcyBpcyB1c2VmdWwgZm9yXG4gICAqIGRpc3BsYXlpbmcgYSBzaW5nbGUgUGVybWlzc2lvbiBEaWFsb2cgYm94IHRvIHRoZSBlbmQgdXNlci5cbiAgICovXG4gIGFzeW5jIGVuYWJsZUNhbWVyYUFuZE1pY3JvcGhvbmUoKSB7XG4gICAgaWYgKFxuICAgICAgdGhpcy5wZW5kaW5nUHVibGlzaGluZy5oYXMoVHJhY2suU291cmNlLkNhbWVyYSkgfHxcbiAgICAgIHRoaXMucGVuZGluZ1B1Ymxpc2hpbmcuaGFzKFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lKVxuICAgICkge1xuICAgICAgLy8gbm8tb3AgaXQncyBhbHJlYWR5IGJlZW4gcmVxdWVzdGVkXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5wZW5kaW5nUHVibGlzaGluZy5hZGQoVHJhY2suU291cmNlLkNhbWVyYSk7XG4gICAgdGhpcy5wZW5kaW5nUHVibGlzaGluZy5hZGQoVHJhY2suU291cmNlLk1pY3JvcGhvbmUpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB0cmFja3M6IExvY2FsVHJhY2tbXSA9IGF3YWl0IHRoaXMuY3JlYXRlVHJhY2tzKHtcbiAgICAgICAgYXVkaW86IHRydWUsXG4gICAgICAgIHZpZGVvOiB0cnVlLFxuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRyYWNrcy5tYXAoKHRyYWNrKSA9PiB0aGlzLnB1Ymxpc2hUcmFjayh0cmFjaykpKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5wZW5kaW5nUHVibGlzaGluZy5kZWxldGUoVHJhY2suU291cmNlLkNhbWVyYSk7XG4gICAgICB0aGlzLnBlbmRpbmdQdWJsaXNoaW5nLmRlbGV0ZShUcmFjay5Tb3VyY2UuTWljcm9waG9uZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBsb2NhbCBjYW1lcmEgYW5kL29yIG1pY3JvcGhvbmUgdHJhY2tzXG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBhc3luYyBjcmVhdGVUcmFja3Mob3B0aW9ucz86IENyZWF0ZUxvY2FsVHJhY2tzT3B0aW9ucyk6IFByb21pc2U8TG9jYWxUcmFja1tdPiB7XG4gICAgY29uc3Qgb3B0cyA9IG1lcmdlRGVmYXVsdE9wdGlvbnMoXG4gICAgICBvcHRpb25zLFxuICAgICAgdGhpcy5yb29tT3B0aW9ucz8uYXVkaW9DYXB0dXJlRGVmYXVsdHMsXG4gICAgICB0aGlzLnJvb21PcHRpb25zPy52aWRlb0NhcHR1cmVEZWZhdWx0cyxcbiAgICApO1xuXG4gICAgY29uc3QgY29uc3RyYWludHMgPSBjb25zdHJhaW50c0Zvck9wdGlvbnMob3B0cyk7XG4gICAgbGV0IHN0cmVhbTogTWVkaWFTdHJlYW0gfCB1bmRlZmluZWQ7XG4gICAgdHJ5IHtcbiAgICAgIHN0cmVhbSA9IGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBpZiAoY29uc3RyYWludHMuYXVkaW8pIHtcbiAgICAgICAgICB0aGlzLm1pY3JvcGhvbmVFcnJvciA9IGVycjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uc3RyYWludHMudmlkZW8pIHtcbiAgICAgICAgICB0aGlzLmNhbWVyYUVycm9yID0gZXJyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycjtcbiAgICB9XG5cbiAgICBpZiAoY29uc3RyYWludHMuYXVkaW8pIHtcbiAgICAgIHRoaXMubWljcm9waG9uZUVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuQXVkaW9TdHJlYW1BY3F1aXJlZCk7XG4gICAgfVxuICAgIGlmIChjb25zdHJhaW50cy52aWRlbykge1xuICAgICAgdGhpcy5jYW1lcmFFcnJvciA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyZWFtLmdldFRyYWNrcygpLm1hcCgobWVkaWFTdHJlYW1UcmFjaykgPT4ge1xuICAgICAgY29uc3QgaXNBdWRpbyA9IG1lZGlhU3RyZWFtVHJhY2sua2luZCA9PT0gJ2F1ZGlvJztcbiAgICAgIGxldCB0cmFja09wdGlvbnMgPSBpc0F1ZGlvID8gb3B0aW9ucyEuYXVkaW8gOiBvcHRpb25zIS52aWRlbztcbiAgICAgIGlmICh0eXBlb2YgdHJhY2tPcHRpb25zID09PSAnYm9vbGVhbicgfHwgIXRyYWNrT3B0aW9ucykge1xuICAgICAgICB0cmFja09wdGlvbnMgPSB7fTtcbiAgICAgIH1cbiAgICAgIGxldCB0cmFja0NvbnN0cmFpbnRzOiBNZWRpYVRyYWNrQ29uc3RyYWludHMgfCB1bmRlZmluZWQ7XG4gICAgICBjb25zdCBjb25PckJvb2wgPSBpc0F1ZGlvID8gY29uc3RyYWludHMuYXVkaW8gOiBjb25zdHJhaW50cy52aWRlbztcbiAgICAgIGlmICh0eXBlb2YgY29uT3JCb29sICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdHJhY2tDb25zdHJhaW50cyA9IGNvbk9yQm9vbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRyYWNrID0gbWVkaWFUcmFja1RvTG9jYWxUcmFjayhtZWRpYVN0cmVhbVRyYWNrLCB0cmFja0NvbnN0cmFpbnRzLCB7XG4gICAgICAgIGxvZ2dlck5hbWU6IHRoaXMucm9vbU9wdGlvbnMubG9nZ2VyTmFtZSxcbiAgICAgICAgbG9nZ2VyQ29udGV4dENiOiAoKSA9PiB0aGlzLmxvZ0NvbnRleHQsXG4gICAgICB9KTtcbiAgICAgIGlmICh0cmFjay5raW5kID09PSBUcmFjay5LaW5kLlZpZGVvKSB7XG4gICAgICAgIHRyYWNrLnNvdXJjZSA9IFRyYWNrLlNvdXJjZS5DYW1lcmE7XG4gICAgICB9IGVsc2UgaWYgKHRyYWNrLmtpbmQgPT09IFRyYWNrLktpbmQuQXVkaW8pIHtcbiAgICAgICAgdHJhY2suc291cmNlID0gVHJhY2suU291cmNlLk1pY3JvcGhvbmU7XG4gICAgICB9XG4gICAgICB0cmFjay5tZWRpYVN0cmVhbSA9IHN0cmVhbTtcbiAgICAgIHJldHVybiB0cmFjaztcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgc2NyZWVuIGNhcHR1cmUgdHJhY2tzIHdpdGggZ2V0RGlzcGxheU1lZGlhKCkuXG4gICAqIEEgTG9jYWxWaWRlb1RyYWNrIGlzIGFsd2F5cyBjcmVhdGVkIGFuZCByZXR1cm5lZC5cbiAgICogSWYgeyBhdWRpbzogdHJ1ZSB9LCBhbmQgdGhlIGJyb3dzZXIgc3VwcG9ydHMgYXVkaW8gY2FwdHVyZSwgYSBMb2NhbEF1ZGlvVHJhY2sgaXMgYWxzbyBjcmVhdGVkLlxuICAgKi9cbiAgYXN5bmMgY3JlYXRlU2NyZWVuVHJhY2tzKG9wdGlvbnM/OiBTY3JlZW5TaGFyZUNhcHR1cmVPcHRpb25zKTogUHJvbWlzZTxBcnJheTxMb2NhbFRyYWNrPj4ge1xuICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAobmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXREaXNwbGF5TWVkaWEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IERldmljZVVuc3VwcG9ydGVkRXJyb3IoJ2dldERpc3BsYXlNZWRpYSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMucmVzb2x1dGlvbiA9PT0gdW5kZWZpbmVkICYmICFpc1NhZmFyaTE3KCkpIHtcbiAgICAgIC8vIHdlIG5lZWQgdG8gY29uc3RyYWluIHRoZSBkaW1lbnNpb25zLCBvdGhlcndpc2UgaXQgY291bGQgbGVhZCB0byBsb3cgYml0cmF0ZVxuICAgICAgLy8gZHVlIHRvIGVuY29kaW5nIGEgaHVnZSB2aWRlby4gRW5jb2Rpbmcgc3VjaCBsYXJnZSBzdXJmYWNlcyBpcyByZWFsbHkgZXhwZW5zaXZlXG4gICAgICAvLyB1bmZvcnR1bmF0ZWx5IFNhZmFyaSAxNyBoYXMgYSBidXQgYW5kIGNhbm5vdCBiZSBjb25zdHJhaW5lZCBieSBkZWZhdWx0XG4gICAgICBvcHRpb25zLnJlc29sdXRpb24gPSBTY3JlZW5TaGFyZVByZXNldHMuaDEwODBmcHMzMC5yZXNvbHV0aW9uO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gc2NyZWVuQ2FwdHVyZVRvRGlzcGxheU1lZGlhU3RyZWFtT3B0aW9ucyhvcHRpb25zKTtcbiAgICBjb25zdCBzdHJlYW06IE1lZGlhU3RyZWFtID0gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXREaXNwbGF5TWVkaWEoY29uc3RyYWludHMpO1xuXG4gICAgY29uc3QgdHJhY2tzID0gc3RyZWFtLmdldFZpZGVvVHJhY2tzKCk7XG4gICAgaWYgKHRyYWNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUcmFja0ludmFsaWRFcnJvcignbm8gdmlkZW8gdHJhY2sgZm91bmQnKTtcbiAgICB9XG4gICAgY29uc3Qgc2NyZWVuVmlkZW8gPSBuZXcgTG9jYWxWaWRlb1RyYWNrKHRyYWNrc1swXSwgdW5kZWZpbmVkLCBmYWxzZSwge1xuICAgICAgbG9nZ2VyTmFtZTogdGhpcy5yb29tT3B0aW9ucy5sb2dnZXJOYW1lLFxuICAgICAgbG9nZ2VyQ29udGV4dENiOiAoKSA9PiB0aGlzLmxvZ0NvbnRleHQsXG4gICAgfSk7XG4gICAgc2NyZWVuVmlkZW8uc291cmNlID0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlO1xuICAgIGlmIChvcHRpb25zLmNvbnRlbnRIaW50KSB7XG4gICAgICBzY3JlZW5WaWRlby5tZWRpYVN0cmVhbVRyYWNrLmNvbnRlbnRIaW50ID0gb3B0aW9ucy5jb250ZW50SGludDtcbiAgICB9XG5cbiAgICBjb25zdCBsb2NhbFRyYWNrczogQXJyYXk8TG9jYWxUcmFjaz4gPSBbc2NyZWVuVmlkZW9dO1xuICAgIGlmIChzdHJlYW0uZ2V0QXVkaW9UcmFja3MoKS5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5BdWRpb1N0cmVhbUFjcXVpcmVkKTtcbiAgICAgIGNvbnN0IHNjcmVlbkF1ZGlvID0gbmV3IExvY2FsQXVkaW9UcmFjayhcbiAgICAgICAgc3RyZWFtLmdldEF1ZGlvVHJhY2tzKClbMF0sXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuYXVkaW9Db250ZXh0LFxuICAgICAgICB7IGxvZ2dlck5hbWU6IHRoaXMucm9vbU9wdGlvbnMubG9nZ2VyTmFtZSwgbG9nZ2VyQ29udGV4dENiOiAoKSA9PiB0aGlzLmxvZ0NvbnRleHQgfSxcbiAgICAgICk7XG4gICAgICBzY3JlZW5BdWRpby5zb3VyY2UgPSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmVBdWRpbztcbiAgICAgIGxvY2FsVHJhY2tzLnB1c2goc2NyZWVuQXVkaW8pO1xuICAgIH1cbiAgICByZXR1cm4gbG9jYWxUcmFja3M7XG4gIH1cblxuICAvKipcbiAgICogUHVibGlzaCBhIG5ldyB0cmFjayB0byB0aGUgcm9vbVxuICAgKiBAcGFyYW0gdHJhY2tcbiAgICogQHBhcmFtIG9wdGlvbnNcbiAgICovXG4gIGFzeW5jIHB1Ymxpc2hUcmFjayhcbiAgICB0cmFjazogTG9jYWxUcmFjayB8IE1lZGlhU3RyZWFtVHJhY2ssXG4gICAgb3B0aW9ucz86IFRyYWNrUHVibGlzaE9wdGlvbnMsXG4gICk6IFByb21pc2U8TG9jYWxUcmFja1B1YmxpY2F0aW9uPiB7XG4gICAgYXdhaXQgdGhpcy5yZWNvbm5lY3RGdXR1cmU/LnByb21pc2U7XG4gICAgaWYgKHRyYWNrIGluc3RhbmNlb2YgTG9jYWxUcmFjayAmJiB0aGlzLnBlbmRpbmdQdWJsaXNoUHJvbWlzZXMuaGFzKHRyYWNrKSkge1xuICAgICAgYXdhaXQgdGhpcy5wZW5kaW5nUHVibGlzaFByb21pc2VzLmdldCh0cmFjayk7XG4gICAgfVxuICAgIGxldCBkZWZhdWx0Q29uc3RyYWludHM6IE1lZGlhVHJhY2tDb25zdHJhaW50cyB8IHVuZGVmaW5lZDtcbiAgICBpZiAodHJhY2sgaW5zdGFuY2VvZiBNZWRpYVN0cmVhbVRyYWNrKSB7XG4gICAgICBkZWZhdWx0Q29uc3RyYWludHMgPSB0cmFjay5nZXRDb25zdHJhaW50cygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB3ZSB3YW50IHRvIGFjY2VzcyBjb25zdHJhaW50cyBkaXJlY3RseSBhcyBgdHJhY2subWVkaWFTdHJlYW1UcmFja2BcbiAgICAgIC8vIG1pZ2h0IGJlIHBvaW50aW5nIHRvIGEgbm9uLWRldmljZSB0cmFjayAoZS5nLiBwcm9jZXNzZWQgdHJhY2spIGFscmVhZHlcbiAgICAgIGRlZmF1bHRDb25zdHJhaW50cyA9IHRyYWNrLmNvbnN0cmFpbnRzO1xuICAgICAgbGV0IGRldmljZUtpbmQ6IE1lZGlhRGV2aWNlS2luZCB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICAgIHN3aXRjaCAodHJhY2suc291cmNlKSB7XG4gICAgICAgIGNhc2UgVHJhY2suU291cmNlLk1pY3JvcGhvbmU6XG4gICAgICAgICAgZGV2aWNlS2luZCA9ICdhdWRpb2lucHV0JztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBUcmFjay5Tb3VyY2UuQ2FtZXJhOlxuICAgICAgICAgIGRldmljZUtpbmQgPSAndmlkZW9pbnB1dCc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoZGV2aWNlS2luZCAmJiB0aGlzLmFjdGl2ZURldmljZU1hcC5oYXMoZGV2aWNlS2luZCkpIHtcbiAgICAgICAgZGVmYXVsdENvbnN0cmFpbnRzID0ge1xuICAgICAgICAgIC4uLmRlZmF1bHRDb25zdHJhaW50cyxcbiAgICAgICAgICBkZXZpY2VJZDogdGhpcy5hY3RpdmVEZXZpY2VNYXAuZ2V0KGRldmljZUtpbmQpLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBjb252ZXJ0IHJhdyBtZWRpYSB0cmFjayBpbnRvIGF1ZGlvIG9yIHZpZGVvIHRyYWNrXG4gICAgaWYgKHRyYWNrIGluc3RhbmNlb2YgTWVkaWFTdHJlYW1UcmFjaykge1xuICAgICAgc3dpdGNoICh0cmFjay5raW5kKSB7XG4gICAgICAgIGNhc2UgJ2F1ZGlvJzpcbiAgICAgICAgICB0cmFjayA9IG5ldyBMb2NhbEF1ZGlvVHJhY2sodHJhY2ssIGRlZmF1bHRDb25zdHJhaW50cywgdHJ1ZSwgdGhpcy5hdWRpb0NvbnRleHQsIHtcbiAgICAgICAgICAgIGxvZ2dlck5hbWU6IHRoaXMucm9vbU9wdGlvbnMubG9nZ2VyTmFtZSxcbiAgICAgICAgICAgIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0LFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd2aWRlbyc6XG4gICAgICAgICAgdHJhY2sgPSBuZXcgTG9jYWxWaWRlb1RyYWNrKHRyYWNrLCBkZWZhdWx0Q29uc3RyYWludHMsIHRydWUsIHtcbiAgICAgICAgICAgIGxvZ2dlck5hbWU6IHRoaXMucm9vbU9wdGlvbnMubG9nZ2VyTmFtZSxcbiAgICAgICAgICAgIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0LFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBUcmFja0ludmFsaWRFcnJvcihgdW5zdXBwb3J0ZWQgTWVkaWFTdHJlYW1UcmFjayBraW5kICR7dHJhY2sua2luZH1gKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJhY2sudXBkYXRlTG9nZ2VyT3B0aW9ucyh7XG4gICAgICAgIGxvZ2dlck5hbWU6IHRoaXMucm9vbU9wdGlvbnMubG9nZ2VyTmFtZSxcbiAgICAgICAgbG9nZ2VyQ29udGV4dENiOiAoKSA9PiB0aGlzLmxvZ0NvbnRleHQsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodHJhY2sgaW5zdGFuY2VvZiBMb2NhbEF1ZGlvVHJhY2spIHtcbiAgICAgIHRyYWNrLnNldEF1ZGlvQ29udGV4dCh0aGlzLmF1ZGlvQ29udGV4dCk7XG4gICAgfVxuXG4gICAgLy8gaXMgaXQgYWxyZWFkeSBwdWJsaXNoZWQ/IGlmIHNvIHNraXBcbiAgICBsZXQgZXhpc3RpbmdQdWJsaWNhdGlvbjogTG9jYWxUcmFja1B1YmxpY2F0aW9uIHwgdW5kZWZpbmVkO1xuICAgIHRoaXMudHJhY2tzLmZvckVhY2goKHB1YmxpY2F0aW9uKSA9PiB7XG4gICAgICBpZiAoIXB1YmxpY2F0aW9uLnRyYWNrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChwdWJsaWNhdGlvbi50cmFjayA9PT0gdHJhY2spIHtcbiAgICAgICAgZXhpc3RpbmdQdWJsaWNhdGlvbiA9IDxMb2NhbFRyYWNrUHVibGljYXRpb24+cHVibGljYXRpb247XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoZXhpc3RpbmdQdWJsaWNhdGlvbikge1xuICAgICAgdGhpcy5sb2cud2FybigndHJhY2sgaGFzIGFscmVhZHkgYmVlbiBwdWJsaXNoZWQsIHNraXBwaW5nJywge1xuICAgICAgICAuLi50aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgIC4uLmdldExvZ0NvbnRleHRGcm9tVHJhY2soZXhpc3RpbmdQdWJsaWNhdGlvbiksXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBleGlzdGluZ1B1YmxpY2F0aW9uO1xuICAgIH1cblxuICAgIGNvbnN0IGlzU3RlcmVvSW5wdXQgPVxuICAgICAgKCdjaGFubmVsQ291bnQnIGluIHRyYWNrLm1lZGlhU3RyZWFtVHJhY2suZ2V0U2V0dGluZ3MoKSAmJlxuICAgICAgICAvLyBAdHMtaWdub3JlIGBjaGFubmVsQ291bnRgIG9uIGdldFNldHRpbmdzKCkgaXMgY3VycmVudGx5IG9ubHkgYXZhaWxhYmxlIGZvciBTYWZhcmksIGJ1dCBpcyBnZW5lcmFsbHkgdGhlIGJlc3Qgd2F5IHRvIGRldGVybWluZSBhIHN0ZXJlbyB0cmFjayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTWVkaWFUcmFja1NldHRpbmdzL2NoYW5uZWxDb3VudFxuICAgICAgICB0cmFjay5tZWRpYVN0cmVhbVRyYWNrLmdldFNldHRpbmdzKCkuY2hhbm5lbENvdW50ID09PSAyKSB8fFxuICAgICAgdHJhY2subWVkaWFTdHJlYW1UcmFjay5nZXRDb25zdHJhaW50cygpLmNoYW5uZWxDb3VudCA9PT0gMjtcbiAgICBjb25zdCBpc1N0ZXJlbyA9IG9wdGlvbnM/LmZvcmNlU3RlcmVvID8/IGlzU3RlcmVvSW5wdXQ7XG5cbiAgICAvLyBkaXNhYmxlIGR0eCBmb3Igc3RlcmVvIHRyYWNrIGlmIG5vdCBlbmFibGVkIGV4cGxpY2l0bHlcbiAgICBpZiAoaXNTdGVyZW8pIHtcbiAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5kdHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmxvZy5pbmZvKFxuICAgICAgICAgIGBPcHVzIERUWCB3aWxsIGJlIGRpc2FibGVkIGZvciBzdGVyZW8gdHJhY2tzIGJ5IGRlZmF1bHQuIEVuYWJsZSB0aGVtIGV4cGxpY2l0bHkgdG8gbWFrZSBpdCB3b3JrLmAsXG4gICAgICAgICAge1xuICAgICAgICAgICAgLi4udGhpcy5sb2dDb250ZXh0LFxuICAgICAgICAgICAgLi4uZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjayksXG4gICAgICAgICAgfSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnJlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMubG9nLmluZm8oXG4gICAgICAgICAgYE9wdXMgUkVEIHdpbGwgYmUgZGlzYWJsZWQgZm9yIHN0ZXJlbyB0cmFja3MgYnkgZGVmYXVsdC4gRW5hYmxlIHRoZW0gZXhwbGljaXRseSB0byBtYWtlIGl0IHdvcmsuYCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMuZHR4ID8/PSBmYWxzZTtcbiAgICAgIG9wdGlvbnMucmVkID8/PSBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qgb3B0czogVHJhY2tQdWJsaXNoT3B0aW9ucyA9IHtcbiAgICAgIC4uLnRoaXMucm9vbU9wdGlvbnMucHVibGlzaERlZmF1bHRzLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICB9O1xuXG4gICAgLy8gZGlzYWJsZSBzaW11bGNhc3QgaWYgZTJlZSBpcyBzZXQgb24gc2FmYXJpXG4gICAgaWYgKGlzU2FmYXJpKCkgJiYgdGhpcy5yb29tT3B0aW9ucy5lMmVlKSB7XG4gICAgICB0aGlzLmxvZy5pbmZvKFxuICAgICAgICBgRW5kLXRvLWVuZCBlbmNyeXB0aW9uIGlzIHNldCB1cCwgc2ltdWxjYXN0IHB1Ymxpc2hpbmcgd2lsbCBiZSBkaXNhYmxlZCBvbiBTYWZhcmlgLFxuICAgICAgICB7XG4gICAgICAgICAgLi4udGhpcy5sb2dDb250ZXh0LFxuICAgICAgICB9LFxuICAgICAgKTtcbiAgICAgIG9wdHMuc2ltdWxjYXN0ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMuc291cmNlKSB7XG4gICAgICB0cmFjay5zb3VyY2UgPSBvcHRzLnNvdXJjZTtcbiAgICB9XG4gICAgY29uc3QgcHVibGlzaFByb21pc2UgPSB0aGlzLnB1Ymxpc2godHJhY2ssIG9wdHMsIGlzU3RlcmVvKTtcbiAgICB0aGlzLnBlbmRpbmdQdWJsaXNoUHJvbWlzZXMuc2V0KHRyYWNrLCBwdWJsaXNoUHJvbWlzZSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHB1YmxpY2F0aW9uID0gYXdhaXQgcHVibGlzaFByb21pc2U7XG4gICAgICByZXR1cm4gcHVibGljYXRpb247XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5wZW5kaW5nUHVibGlzaFByb21pc2VzLmRlbGV0ZSh0cmFjayk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBwdWJsaXNoKHRyYWNrOiBMb2NhbFRyYWNrLCBvcHRzOiBUcmFja1B1Ymxpc2hPcHRpb25zLCBpc1N0ZXJlbzogYm9vbGVhbikge1xuICAgIGNvbnN0IGV4aXN0aW5nVHJhY2tPZlNvdXJjZSA9IEFycmF5LmZyb20odGhpcy50cmFja3MudmFsdWVzKCkpLmZpbmQoXG4gICAgICAocHVibGlzaGVkVHJhY2spID0+IHRyYWNrIGluc3RhbmNlb2YgTG9jYWxUcmFjayAmJiBwdWJsaXNoZWRUcmFjay5zb3VyY2UgPT09IHRyYWNrLnNvdXJjZSxcbiAgICApO1xuICAgIGlmIChleGlzdGluZ1RyYWNrT2ZTb3VyY2UgJiYgdHJhY2suc291cmNlICE9PSBUcmFjay5Tb3VyY2UuVW5rbm93bikge1xuICAgICAgdGhpcy5sb2cuaW5mbyhgcHVibGlzaGluZyBhIHNlY29uZCB0cmFjayB3aXRoIHRoZSBzYW1lIHNvdXJjZTogJHt0cmFjay5zb3VyY2V9YCwge1xuICAgICAgICAuLi50aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgIC4uLmdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spLFxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChvcHRzLnN0b3BNaWNUcmFja09uTXV0ZSAmJiB0cmFjayBpbnN0YW5jZW9mIExvY2FsQXVkaW9UcmFjaykge1xuICAgICAgdHJhY2suc3RvcE9uTXV0ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRyYWNrLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlICYmIGlzRmlyZUZveCgpKSB7XG4gICAgICAvLyBGaXJlZm94IGRvZXMgbm90IHdvcmsgd2VsbCB3aXRoIHNpbXVsY2FzdGVkIHNjcmVlbiBzaGFyZVxuICAgICAgLy8gd2UgZnJlcXVlbnRseSBnZXQgbm8gZGF0YSBvbiBsYXllciAwIHdoZW4gZW5hYmxlZFxuICAgICAgb3B0cy5zaW11bGNhc3QgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyByZXF1aXJlIGZ1bGwgQVYxL1ZQOSBTVkMgc3VwcG9ydCBwcmlvciB0byB1c2luZyBpdFxuICAgIGlmIChvcHRzLnZpZGVvQ29kZWMgPT09ICdhdjEnICYmICFzdXBwb3J0c0FWMSgpKSB7XG4gICAgICBvcHRzLnZpZGVvQ29kZWMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChvcHRzLnZpZGVvQ29kZWMgPT09ICd2cDknICYmICFzdXBwb3J0c1ZQOSgpKSB7XG4gICAgICBvcHRzLnZpZGVvQ29kZWMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChvcHRzLnZpZGVvQ29kZWMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgb3B0cy52aWRlb0NvZGVjID0gZGVmYXVsdFZpZGVvQ29kZWM7XG4gICAgfVxuICAgIGNvbnN0IHZpZGVvQ29kZWMgPSBvcHRzLnZpZGVvQ29kZWM7XG5cbiAgICAvLyBoYW5kbGUgdHJhY2sgYWN0aW9uc1xuICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuTXV0ZWQsIHRoaXMub25UcmFja011dGVkKTtcbiAgICB0cmFjay5vbihUcmFja0V2ZW50LlVubXV0ZWQsIHRoaXMub25UcmFja1VubXV0ZWQpO1xuICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuRW5kZWQsIHRoaXMuaGFuZGxlVHJhY2tFbmRlZCk7XG4gICAgdHJhY2sub24oVHJhY2tFdmVudC5VcHN0cmVhbVBhdXNlZCwgdGhpcy5vblRyYWNrVXBzdHJlYW1QYXVzZWQpO1xuICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuVXBzdHJlYW1SZXN1bWVkLCB0aGlzLm9uVHJhY2tVcHN0cmVhbVJlc3VtZWQpO1xuXG4gICAgLy8gY3JlYXRlIHRyYWNrIHB1YmxpY2F0aW9uIGZyb20gdHJhY2tcbiAgICBjb25zdCByZXEgPSBuZXcgQWRkVHJhY2tSZXF1ZXN0KHtcbiAgICAgIC8vIGdldCBsb2NhbCB0cmFjayBpZCBmb3IgdXNlIGR1cmluZyBwdWJsaXNoaW5nXG4gICAgICBjaWQ6IHRyYWNrLm1lZGlhU3RyZWFtVHJhY2suaWQsXG4gICAgICBuYW1lOiBvcHRzLm5hbWUsXG4gICAgICB0eXBlOiBUcmFjay5raW5kVG9Qcm90byh0cmFjay5raW5kKSxcbiAgICAgIG11dGVkOiB0cmFjay5pc011dGVkLFxuICAgICAgc291cmNlOiBUcmFjay5zb3VyY2VUb1Byb3RvKHRyYWNrLnNvdXJjZSksXG4gICAgICBkaXNhYmxlRHR4OiAhKG9wdHMuZHR4ID8/IHRydWUpLFxuICAgICAgZW5jcnlwdGlvbjogdGhpcy5lbmNyeXB0aW9uVHlwZSxcbiAgICAgIHN0ZXJlbzogaXNTdGVyZW8sXG4gICAgICBkaXNhYmxlUmVkOiB0aGlzLmlzRTJFRUVuYWJsZWQgfHwgIShvcHRzLnJlZCA/PyB0cnVlKSxcbiAgICAgIHN0cmVhbTogb3B0cz8uc3RyZWFtLFxuICAgIH0pO1xuXG4gICAgLy8gY29tcHV0ZSBlbmNvZGluZ3MgYW5kIGxheWVycyBmb3IgdmlkZW9cbiAgICBsZXQgZW5jb2RpbmdzOiBSVENSdHBFbmNvZGluZ1BhcmFtZXRlcnNbXSB8IHVuZGVmaW5lZDtcbiAgICBpZiAodHJhY2sua2luZCA9PT0gVHJhY2suS2luZC5WaWRlbykge1xuICAgICAgbGV0IGRpbXM6IFRyYWNrLkRpbWVuc2lvbnMgPSB7XG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICB9O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGltcyA9IGF3YWl0IHRyYWNrLndhaXRGb3JEaW1lbnNpb25zKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIHVzZSBkZWZhdWx0cywgaXQncyBxdWl0ZSBwYWluZnVsIGZvciBjb25nZXN0aW9uIGNvbnRyb2wgd2l0aG91dCBzaW11bGNhc3RcbiAgICAgICAgLy8gc28gdXNpbmcgZGVmYXVsdCBkaW1zIGFjY29yZGluZyB0byBwdWJsaXNoIHNldHRpbmdzXG4gICAgICAgIGNvbnN0IGRlZmF1bHRSZXMgPVxuICAgICAgICAgIHRoaXMucm9vbU9wdGlvbnMudmlkZW9DYXB0dXJlRGVmYXVsdHM/LnJlc29sdXRpb24gPz8gVmlkZW9QcmVzZXRzLmg3MjAucmVzb2x1dGlvbjtcbiAgICAgICAgZGltcyA9IHtcbiAgICAgICAgICB3aWR0aDogZGVmYXVsdFJlcy53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGRlZmF1bHRSZXMuaGVpZ2h0LFxuICAgICAgICB9O1xuICAgICAgICAvLyBsb2cgZmFpbHVyZVxuICAgICAgICB0aGlzLmxvZy5lcnJvcignY291bGQgbm90IGRldGVybWluZSB0cmFjayBkaW1lbnNpb25zLCB1c2luZyBkZWZhdWx0cycsIHtcbiAgICAgICAgICAuLi50aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgICAgLi4uZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjayksXG4gICAgICAgICAgZGltcyxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvLyB3aWR0aCBhbmQgaGVpZ2h0IHNob3VsZCBiZSBkZWZpbmVkIGZvciB2aWRlb1xuICAgICAgcmVxLndpZHRoID0gZGltcy53aWR0aDtcbiAgICAgIHJlcS5oZWlnaHQgPSBkaW1zLmhlaWdodDtcbiAgICAgIC8vIGZvciBzdmMgY29kZWNzLCBkaXNhYmxlIHNpbXVsY2FzdCBhbmQgdXNlIHZwOCBmb3IgYmFja3VwIGNvZGVjXG4gICAgICBpZiAodHJhY2sgaW5zdGFuY2VvZiBMb2NhbFZpZGVvVHJhY2spIHtcbiAgICAgICAgaWYgKGlzU1ZDQ29kZWModmlkZW9Db2RlYykpIHtcbiAgICAgICAgICAvLyB2cDkgc3ZjIHdpdGggc2NyZWVuc2hhcmUgaGFzIHByb2JsZW0gdG8gZW5jb2RlLCBhbHdheXMgdXNlIEwxVDMgaGVyZVxuICAgICAgICAgIGlmICh0cmFjay5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZSAmJiB2aWRlb0NvZGVjID09PSAndnA5Jykge1xuICAgICAgICAgICAgb3B0cy5zY2FsYWJpbGl0eU1vZGUgPSAnTDFUMyc7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHNldCBzY2FsYWJpbGl0eU1vZGUgdG8gJ0wzVDNfS0VZJyBieSBkZWZhdWx0XG4gICAgICAgICAgb3B0cy5zY2FsYWJpbGl0eU1vZGUgPSBvcHRzLnNjYWxhYmlsaXR5TW9kZSA/PyAnTDNUM19LRVknO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVxLnNpbXVsY2FzdENvZGVjcyA9IFtcbiAgICAgICAgICBuZXcgU2ltdWxjYXN0Q29kZWMoe1xuICAgICAgICAgICAgY29kZWM6IHZpZGVvQ29kZWMsXG4gICAgICAgICAgICBjaWQ6IHRyYWNrLm1lZGlhU3RyZWFtVHJhY2suaWQsXG4gICAgICAgICAgfSksXG4gICAgICAgIF07XG5cbiAgICAgICAgLy8gc2V0IHVwIGJhY2t1cFxuICAgICAgICBpZiAob3B0cy5iYWNrdXBDb2RlYyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIG9wdHMuYmFja3VwQ29kZWMgPSB7IGNvZGVjOiBkZWZhdWx0VmlkZW9Db2RlYyB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICBvcHRzLmJhY2t1cENvZGVjICYmXG4gICAgICAgICAgdmlkZW9Db2RlYyAhPT0gb3B0cy5iYWNrdXBDb2RlYy5jb2RlYyAmJlxuICAgICAgICAgIC8vIFRPRE8gcmVtb3ZlIHRoaXMgb25jZSBlMmVlIGlzIHN1cHBvcnRlZCBmb3IgYmFja3VwIGNvZGVjc1xuICAgICAgICAgIHJlcS5lbmNyeXB0aW9uID09PSBFbmNyeXB0aW9uX1R5cGUuTk9ORVxuICAgICAgICApIHtcbiAgICAgICAgICAvLyBtdWx0aS1jb2RlYyBzaW11bGNhc3QgcmVxdWlyZXMgZHluYWNhc3RcbiAgICAgICAgICBpZiAoIXRoaXMucm9vbU9wdGlvbnMuZHluYWNhc3QpIHtcbiAgICAgICAgICAgIHRoaXMucm9vbU9wdGlvbnMuZHluYWNhc3QgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXEuc2ltdWxjYXN0Q29kZWNzLnB1c2goXG4gICAgICAgICAgICBuZXcgU2ltdWxjYXN0Q29kZWMoe1xuICAgICAgICAgICAgICBjb2RlYzogb3B0cy5iYWNrdXBDb2RlYy5jb2RlYyxcbiAgICAgICAgICAgICAgY2lkOiAnJyxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZW5jb2RpbmdzID0gY29tcHV0ZVZpZGVvRW5jb2RpbmdzKFxuICAgICAgICB0cmFjay5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZSxcbiAgICAgICAgcmVxLndpZHRoLFxuICAgICAgICByZXEuaGVpZ2h0LFxuICAgICAgICBvcHRzLFxuICAgICAgKTtcbiAgICAgIHJlcS5sYXllcnMgPSB2aWRlb0xheWVyc0Zyb21FbmNvZGluZ3MoXG4gICAgICAgIHJlcS53aWR0aCxcbiAgICAgICAgcmVxLmhlaWdodCxcbiAgICAgICAgZW5jb2RpbmdzLFxuICAgICAgICBpc1NWQ0NvZGVjKG9wdHMudmlkZW9Db2RlYyksXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAodHJhY2sua2luZCA9PT0gVHJhY2suS2luZC5BdWRpbykge1xuICAgICAgZW5jb2RpbmdzID0gW1xuICAgICAgICB7XG4gICAgICAgICAgbWF4Qml0cmF0ZTogb3B0cy5hdWRpb1ByZXNldD8ubWF4Qml0cmF0ZSA/PyBvcHRzLmF1ZGlvQml0cmF0ZSxcbiAgICAgICAgICBwcmlvcml0eTogb3B0cy5hdWRpb1ByZXNldD8ucHJpb3JpdHkgPz8gJ2hpZ2gnLFxuICAgICAgICAgIG5ldHdvcmtQcmlvcml0eTogb3B0cy5hdWRpb1ByZXNldD8ucHJpb3JpdHkgPz8gJ2hpZ2gnLFxuICAgICAgICB9LFxuICAgICAgXTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZW5naW5lIHx8IHRoaXMuZW5naW5lLmlzQ2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgnY2Fubm90IHB1Ymxpc2ggdHJhY2sgd2hlbiBub3QgY29ubmVjdGVkJyk7XG4gICAgfVxuXG4gICAgY29uc3QgdGkgPSBhd2FpdCB0aGlzLmVuZ2luZS5hZGRUcmFjayhyZXEpO1xuICAgIC8vIHNlcnZlciBtaWdodCBub3Qgc3VwcG9ydCB0aGUgY29kZWMgdGhlIGNsaWVudCBoYXMgcmVxdWVzdGVkLCBpbiB0aGF0IGNhc2UsIGZhbGxiYWNrXG4gICAgLy8gdG8gYSBzdXBwb3J0ZWQgY29kZWNcbiAgICBsZXQgcHJpbWFyeUNvZGVjTWltZTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIHRpLmNvZGVjcy5mb3JFYWNoKChjb2RlYykgPT4ge1xuICAgICAgaWYgKHByaW1hcnlDb2RlY01pbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcmltYXJ5Q29kZWNNaW1lID0gY29kZWMubWltZVR5cGU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHByaW1hcnlDb2RlY01pbWUgJiYgdHJhY2sua2luZCA9PT0gVHJhY2suS2luZC5WaWRlbykge1xuICAgICAgY29uc3QgdXBkYXRlZENvZGVjID0gbWltZVR5cGVUb1ZpZGVvQ29kZWNTdHJpbmcocHJpbWFyeUNvZGVjTWltZSk7XG4gICAgICBpZiAodXBkYXRlZENvZGVjICE9PSB2aWRlb0NvZGVjKSB7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKCdmYWxsaW5nIGJhY2sgdG8gc2VydmVyIHNlbGVjdGVkIGNvZGVjJywge1xuICAgICAgICAgIC4uLnRoaXMubG9nQ29udGV4dCxcbiAgICAgICAgICAuLi5nZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSxcbiAgICAgICAgICBjb2RlYzogdXBkYXRlZENvZGVjLFxuICAgICAgICB9KTtcbiAgICAgICAgLyogQHRzLWlnbm9yZSAqL1xuICAgICAgICBvcHRzLnZpZGVvQ29kZWMgPSB1cGRhdGVkQ29kZWM7XG5cbiAgICAgICAgLy8gcmVjb21wdXRlIGVuY29kaW5ncyBzaW5jZSBiaXRyYXRlcy9ldGMgY291bGQgaGF2ZSBjaGFuZ2VkXG4gICAgICAgIGVuY29kaW5ncyA9IGNvbXB1dGVWaWRlb0VuY29kaW5ncyhcbiAgICAgICAgICB0cmFjay5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZSxcbiAgICAgICAgICByZXEud2lkdGgsXG4gICAgICAgICAgcmVxLmhlaWdodCxcbiAgICAgICAgICBvcHRzLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHB1YmxpY2F0aW9uID0gbmV3IExvY2FsVHJhY2tQdWJsaWNhdGlvbih0cmFjay5raW5kLCB0aSwgdHJhY2ssIHtcbiAgICAgIGxvZ2dlck5hbWU6IHRoaXMucm9vbU9wdGlvbnMubG9nZ2VyTmFtZSxcbiAgICAgIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0LFxuICAgIH0pO1xuICAgIC8vIHNhdmUgb3B0aW9ucyBmb3Igd2hlbiBpdCBuZWVkcyB0byBiZSByZXB1Ymxpc2hlZCBhZ2FpblxuICAgIHB1YmxpY2F0aW9uLm9wdGlvbnMgPSBvcHRzO1xuICAgIHRyYWNrLnNpZCA9IHRpLnNpZDtcblxuICAgIGlmICghdGhpcy5lbmdpbmUucGNNYW5hZ2VyKSB7XG4gICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgncGNNYW5hZ2VyIGlzIG5vdCByZWFkeScpO1xuICAgIH1cbiAgICB0aGlzLmxvZy5kZWJ1ZyhgcHVibGlzaGluZyAke3RyYWNrLmtpbmR9IHdpdGggZW5jb2RpbmdzYCwge1xuICAgICAgLi4udGhpcy5sb2dDb250ZXh0LFxuICAgICAgZW5jb2RpbmdzLFxuICAgICAgdHJhY2tJbmZvOiB0aSxcbiAgICB9KTtcblxuICAgIHRyYWNrLnNlbmRlciA9IGF3YWl0IHRoaXMuZW5naW5lLmNyZWF0ZVNlbmRlcih0cmFjaywgb3B0cywgZW5jb2RpbmdzKTtcblxuICAgIGlmIChlbmNvZGluZ3MpIHtcbiAgICAgIGlmIChpc0ZpcmVGb3goKSAmJiB0cmFjay5raW5kID09PSBUcmFjay5LaW5kLkF1ZGlvKSB7XG4gICAgICAgIC8qIFJlZmVyIHRvIFJGQyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzc1ODcjc2VjdGlvbi02LjEsXG4gICAgICAgICAgIGxpdmVraXQtc2VydmVyIHVzZXMgbWF4YXZlcmFnZWJpdHJhdGU9NTEwMDAwIGluIHRoZSBhbnN3ZXIgc2RwIHRvIHBlcm1pdCBjbGllbnQgdG9cbiAgICAgICAgICAgcHVibGlzaCBoaWdoIHF1YWxpdHkgYXVkaW8gdHJhY2suIEJ1dCBmaXJlZm94IGFsd2F5cyB1c2VzIHRoaXMgdmFsdWUgYXMgdGhlIGFjdHVhbFxuICAgICAgICAgICBiaXRyYXRlcywgY2F1c2luZyB0aGUgYXVkaW8gYml0cmF0ZXMgdG8gcmlzZSB0byA1MTBLYnBzIGluIGFueSBzdGVyZW8gY2FzZSB1bmV4cGVjdGVkbHkuXG4gICAgICAgICAgIFNvIHRoZSBjbGllbnQgbmVlZCB0byBtb2RpZnkgbWF4YXZlcnJhZ2ViaXRyYXRlcyBpbiBhbnN3ZXIgc2RwIHRvIHVzZXIgcHJvdmlkZWQgdmFsdWUgdG9cbiAgICAgICAgICAgZml4IHRoZSBpc3N1ZS5cbiAgICAgICAgICovXG4gICAgICAgIGxldCB0cmFja1RyYW5zY2VpdmVyOiBSVENSdHBUcmFuc2NlaXZlciB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCB0cmFuc2NlaXZlciBvZiB0aGlzLmVuZ2luZS5wY01hbmFnZXIucHVibGlzaGVyLmdldFRyYW5zY2VpdmVycygpKSB7XG4gICAgICAgICAgaWYgKHRyYW5zY2VpdmVyLnNlbmRlciA9PT0gdHJhY2suc2VuZGVyKSB7XG4gICAgICAgICAgICB0cmFja1RyYW5zY2VpdmVyID0gdHJhbnNjZWl2ZXI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYWNrVHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICB0aGlzLmVuZ2luZS5wY01hbmFnZXIucHVibGlzaGVyLnNldFRyYWNrQ29kZWNCaXRyYXRlKHtcbiAgICAgICAgICAgIHRyYW5zY2VpdmVyOiB0cmFja1RyYW5zY2VpdmVyLFxuICAgICAgICAgICAgY29kZWM6ICdvcHVzJyxcbiAgICAgICAgICAgIG1heGJyOiBlbmNvZGluZ3NbMF0/Lm1heEJpdHJhdGUgPyBlbmNvZGluZ3NbMF0ubWF4Qml0cmF0ZSAvIDEwMDAgOiAwLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRyYWNrLmNvZGVjICYmIGlzU1ZDQ29kZWModHJhY2suY29kZWMpICYmIGVuY29kaW5nc1swXT8ubWF4Qml0cmF0ZSkge1xuICAgICAgICB0aGlzLmVuZ2luZS5wY01hbmFnZXIucHVibGlzaGVyLnNldFRyYWNrQ29kZWNCaXRyYXRlKHtcbiAgICAgICAgICBjaWQ6IHJlcS5jaWQsXG4gICAgICAgICAgY29kZWM6IHRyYWNrLmNvZGVjLFxuICAgICAgICAgIG1heGJyOiBlbmNvZGluZ3NbMF0ubWF4Qml0cmF0ZSAvIDEwMDAsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGF3YWl0IHRoaXMuZW5naW5lLm5lZ290aWF0ZSgpO1xuXG4gICAgaWYgKHRyYWNrIGluc3RhbmNlb2YgTG9jYWxWaWRlb1RyYWNrKSB7XG4gICAgICB0cmFjay5zdGFydE1vbml0b3IodGhpcy5lbmdpbmUuY2xpZW50KTtcbiAgICB9IGVsc2UgaWYgKHRyYWNrIGluc3RhbmNlb2YgTG9jYWxBdWRpb1RyYWNrKSB7XG4gICAgICB0cmFjay5zdGFydE1vbml0b3IoKTtcbiAgICB9XG5cbiAgICB0aGlzLmFkZFRyYWNrUHVibGljYXRpb24ocHVibGljYXRpb24pO1xuXG4gICAgLy8gc2VuZCBldmVudCBmb3IgcHVibGljYXRpb25cbiAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5Mb2NhbFRyYWNrUHVibGlzaGVkLCBwdWJsaWNhdGlvbik7XG4gICAgcmV0dXJuIHB1YmxpY2F0aW9uO1xuICB9XG5cbiAgb3ZlcnJpZGUgZ2V0IGlzTG9jYWwoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKiogQGludGVybmFsXG4gICAqIHB1Ymxpc2ggYWRkaXRpb25hbCBjb2RlYyB0byBleGlzdGluZyB0cmFja1xuICAgKi9cbiAgYXN5bmMgcHVibGlzaEFkZGl0aW9uYWxDb2RlY0ZvclRyYWNrKFxuICAgIHRyYWNrOiBMb2NhbFRyYWNrIHwgTWVkaWFTdHJlYW1UcmFjayxcbiAgICB2aWRlb0NvZGVjOiBCYWNrdXBWaWRlb0NvZGVjLFxuICAgIG9wdGlvbnM/OiBUcmFja1B1Ymxpc2hPcHRpb25zLFxuICApIHtcbiAgICAvLyBUT0RPIHJlbW92ZSBvbmNlIGUyZWUgaXMgc3VwcG9ydGVkIGZvciBiYWNrdXAgdHJhY2tzXG4gICAgaWYgKHRoaXMuZW5jcnlwdGlvblR5cGUgIT09IEVuY3J5cHRpb25fVHlwZS5OT05FKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gaXMgaXQgbm90IHB1Ymxpc2hlZD8gaWYgc28gc2tpcFxuICAgIGxldCBleGlzdGluZ1B1YmxpY2F0aW9uOiBMb2NhbFRyYWNrUHVibGljYXRpb24gfCB1bmRlZmluZWQ7XG4gICAgdGhpcy50cmFja3MuZm9yRWFjaCgocHVibGljYXRpb24pID0+IHtcbiAgICAgIGlmICghcHVibGljYXRpb24udHJhY2spIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHB1YmxpY2F0aW9uLnRyYWNrID09PSB0cmFjaykge1xuICAgICAgICBleGlzdGluZ1B1YmxpY2F0aW9uID0gPExvY2FsVHJhY2tQdWJsaWNhdGlvbj5wdWJsaWNhdGlvbjtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIWV4aXN0aW5nUHVibGljYXRpb24pIHtcbiAgICAgIHRocm93IG5ldyBUcmFja0ludmFsaWRFcnJvcigndHJhY2sgaXMgbm90IHB1Ymxpc2hlZCcpO1xuICAgIH1cblxuICAgIGlmICghKHRyYWNrIGluc3RhbmNlb2YgTG9jYWxWaWRlb1RyYWNrKSkge1xuICAgICAgdGhyb3cgbmV3IFRyYWNrSW52YWxpZEVycm9yKCd0cmFjayBpcyBub3QgYSB2aWRlbyB0cmFjaycpO1xuICAgIH1cblxuICAgIGNvbnN0IG9wdHM6IFRyYWNrUHVibGlzaE9wdGlvbnMgPSB7XG4gICAgICAuLi50aGlzLnJvb21PcHRpb25zPy5wdWJsaXNoRGVmYXVsdHMsXG4gICAgICAuLi5vcHRpb25zLFxuICAgIH07XG5cbiAgICBjb25zdCBlbmNvZGluZ3MgPSBjb21wdXRlVHJhY2tCYWNrdXBFbmNvZGluZ3ModHJhY2ssIHZpZGVvQ29kZWMsIG9wdHMpO1xuICAgIGlmICghZW5jb2RpbmdzKSB7XG4gICAgICB0aGlzLmxvZy5pbmZvKFxuICAgICAgICBgYmFja3VwIGNvZGVjIGhhcyBiZWVuIGRpc2FibGVkLCBpZ25vcmluZyByZXF1ZXN0IHRvIGFkZCBhZGRpdGlvbmFsIGNvZGVjIGZvciB0cmFja2AsXG4gICAgICAgIHtcbiAgICAgICAgICAuLi50aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgICAgLi4uZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjayksXG4gICAgICAgIH0sXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzaW11bGNhc3RUcmFjayA9IHRyYWNrLmFkZFNpbXVsY2FzdFRyYWNrKHZpZGVvQ29kZWMsIGVuY29kaW5ncyk7XG4gICAgY29uc3QgcmVxID0gbmV3IEFkZFRyYWNrUmVxdWVzdCh7XG4gICAgICBjaWQ6IHNpbXVsY2FzdFRyYWNrLm1lZGlhU3RyZWFtVHJhY2suaWQsXG4gICAgICB0eXBlOiBUcmFjay5raW5kVG9Qcm90byh0cmFjay5raW5kKSxcbiAgICAgIG11dGVkOiB0cmFjay5pc011dGVkLFxuICAgICAgc291cmNlOiBUcmFjay5zb3VyY2VUb1Byb3RvKHRyYWNrLnNvdXJjZSksXG4gICAgICBzaWQ6IHRyYWNrLnNpZCxcbiAgICAgIHNpbXVsY2FzdENvZGVjczogW1xuICAgICAgICB7XG4gICAgICAgICAgY29kZWM6IG9wdHMudmlkZW9Db2RlYyxcbiAgICAgICAgICBjaWQ6IHNpbXVsY2FzdFRyYWNrLm1lZGlhU3RyZWFtVHJhY2suaWQsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgIH0pO1xuICAgIHJlcS5sYXllcnMgPSB2aWRlb0xheWVyc0Zyb21FbmNvZGluZ3MocmVxLndpZHRoLCByZXEuaGVpZ2h0LCBlbmNvZGluZ3MpO1xuXG4gICAgaWYgKCF0aGlzLmVuZ2luZSB8fCB0aGlzLmVuZ2luZS5pc0Nsb3NlZCkge1xuICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ2Nhbm5vdCBwdWJsaXNoIHRyYWNrIHdoZW4gbm90IGNvbm5lY3RlZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IHRpID0gYXdhaXQgdGhpcy5lbmdpbmUuYWRkVHJhY2socmVxKTtcblxuICAgIGNvbnN0IHRyYW5zY2VpdmVySW5pdDogUlRDUnRwVHJhbnNjZWl2ZXJJbml0ID0geyBkaXJlY3Rpb246ICdzZW5kb25seScgfTtcbiAgICBpZiAoZW5jb2RpbmdzKSB7XG4gICAgICB0cmFuc2NlaXZlckluaXQuc2VuZEVuY29kaW5ncyA9IGVuY29kaW5ncztcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5lbmdpbmUuY3JlYXRlU2ltdWxjYXN0U2VuZGVyKHRyYWNrLCBzaW11bGNhc3RUcmFjaywgb3B0cywgZW5jb2RpbmdzKTtcblxuICAgIGF3YWl0IHRoaXMuZW5naW5lLm5lZ290aWF0ZSgpO1xuICAgIHRoaXMubG9nLmRlYnVnKGBwdWJsaXNoZWQgJHt2aWRlb0NvZGVjfSBmb3IgdHJhY2sgJHt0cmFjay5zaWR9YCwge1xuICAgICAgLi4udGhpcy5sb2dDb250ZXh0LFxuICAgICAgZW5jb2RpbmdzLFxuICAgICAgdHJhY2tJbmZvOiB0aSxcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIHVucHVibGlzaFRyYWNrKFxuICAgIHRyYWNrOiBMb2NhbFRyYWNrIHwgTWVkaWFTdHJlYW1UcmFjayxcbiAgICBzdG9wT25VbnB1Ymxpc2g/OiBib29sZWFuLFxuICApOiBQcm9taXNlPExvY2FsVHJhY2tQdWJsaWNhdGlvbiB8IHVuZGVmaW5lZD4ge1xuICAgIC8vIGxvb2sgdGhyb3VnaCBhbGwgcHVibGlzaGVkIHRyYWNrcyB0byBmaW5kIHRoZSByaWdodCBvbmVzXG4gICAgY29uc3QgcHVibGljYXRpb24gPSB0aGlzLmdldFB1YmxpY2F0aW9uRm9yVHJhY2sodHJhY2spO1xuXG4gICAgY29uc3QgcHViTG9nQ29udGV4dCA9IHB1YmxpY2F0aW9uID8gZ2V0TG9nQ29udGV4dEZyb21UcmFjayhwdWJsaWNhdGlvbikgOiB1bmRlZmluZWQ7XG5cbiAgICB0aGlzLmxvZy5kZWJ1ZygndW5wdWJsaXNoaW5nIHRyYWNrJywge1xuICAgICAgLi4udGhpcy5sb2dDb250ZXh0LFxuICAgICAgLi4ucHViTG9nQ29udGV4dCxcbiAgICB9KTtcblxuICAgIGlmICghcHVibGljYXRpb24gfHwgIXB1YmxpY2F0aW9uLnRyYWNrKSB7XG4gICAgICB0aGlzLmxvZy53YXJuKCd0cmFjayB3YXMgbm90IHVucHVibGlzaGVkIGJlY2F1c2Ugbm8gcHVibGljYXRpb24gd2FzIGZvdW5kJywge1xuICAgICAgICAuLi50aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgIC4uLnB1YkxvZ0NvbnRleHQsXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdHJhY2sgPSBwdWJsaWNhdGlvbi50cmFjaztcbiAgICB0cmFjay5vZmYoVHJhY2tFdmVudC5NdXRlZCwgdGhpcy5vblRyYWNrTXV0ZWQpO1xuICAgIHRyYWNrLm9mZihUcmFja0V2ZW50LlVubXV0ZWQsIHRoaXMub25UcmFja1VubXV0ZWQpO1xuICAgIHRyYWNrLm9mZihUcmFja0V2ZW50LkVuZGVkLCB0aGlzLmhhbmRsZVRyYWNrRW5kZWQpO1xuICAgIHRyYWNrLm9mZihUcmFja0V2ZW50LlVwc3RyZWFtUGF1c2VkLCB0aGlzLm9uVHJhY2tVcHN0cmVhbVBhdXNlZCk7XG4gICAgdHJhY2sub2ZmKFRyYWNrRXZlbnQuVXBzdHJlYW1SZXN1bWVkLCB0aGlzLm9uVHJhY2tVcHN0cmVhbVJlc3VtZWQpO1xuXG4gICAgaWYgKHN0b3BPblVucHVibGlzaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzdG9wT25VbnB1Ymxpc2ggPSB0aGlzLnJvb21PcHRpb25zPy5zdG9wTG9jYWxUcmFja09uVW5wdWJsaXNoID8/IHRydWU7XG4gICAgfVxuICAgIGlmIChzdG9wT25VbnB1Ymxpc2gpIHtcbiAgICAgIHRyYWNrLnN0b3AoKTtcbiAgICB9XG5cbiAgICBsZXQgbmVnb3RpYXRpb25OZWVkZWQgPSBmYWxzZTtcbiAgICBjb25zdCB0cmFja1NlbmRlciA9IHRyYWNrLnNlbmRlcjtcbiAgICB0cmFjay5zZW5kZXIgPSB1bmRlZmluZWQ7XG4gICAgaWYgKFxuICAgICAgdGhpcy5lbmdpbmUucGNNYW5hZ2VyICYmXG4gICAgICB0aGlzLmVuZ2luZS5wY01hbmFnZXIuY3VycmVudFN0YXRlIDwgUENUcmFuc3BvcnRTdGF0ZS5GQUlMRUQgJiZcbiAgICAgIHRyYWNrU2VuZGVyXG4gICAgKSB7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKGNvbnN0IHRyYW5zY2VpdmVyIG9mIHRoaXMuZW5naW5lLnBjTWFuYWdlci5wdWJsaXNoZXIuZ2V0VHJhbnNjZWl2ZXJzKCkpIHtcbiAgICAgICAgICAvLyBpZiBzZW5kZXIgaXMgbm90IGN1cnJlbnRseSBzZW5kaW5nIChhZnRlciByZXBsYWNlVHJhY2sobnVsbCkpXG4gICAgICAgICAgLy8gcmVtb3ZlVHJhY2sgd291bGQgaGF2ZSBubyBlZmZlY3QuXG4gICAgICAgICAgLy8gdG8gZW5zdXJlIHdlIGVuZCB1cCBzdWNjZXNzZnVsbHkgcmVtb3ZpbmcgdGhlIHRyYWNrLCBtYW51YWxseSBzZXRcbiAgICAgICAgICAvLyB0aGUgdHJhbnNjZWl2ZXIgdG8gaW5hY3RpdmVcbiAgICAgICAgICBpZiAodHJhbnNjZWl2ZXIuc2VuZGVyID09PSB0cmFja1NlbmRlcikge1xuICAgICAgICAgICAgdHJhbnNjZWl2ZXIuZGlyZWN0aW9uID0gJ2luYWN0aXZlJztcbiAgICAgICAgICAgIG5lZ290aWF0aW9uTmVlZGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZW5naW5lLnJlbW92ZVRyYWNrKHRyYWNrU2VuZGVyKSkge1xuICAgICAgICAgIG5lZ290aWF0aW9uTmVlZGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhY2sgaW5zdGFuY2VvZiBMb2NhbFZpZGVvVHJhY2spIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IFssIHRyYWNrSW5mb10gb2YgdHJhY2suc2ltdWxjYXN0Q29kZWNzKSB7XG4gICAgICAgICAgICBpZiAodHJhY2tJbmZvLnNlbmRlcikge1xuICAgICAgICAgICAgICBpZiAodGhpcy5lbmdpbmUucmVtb3ZlVHJhY2sodHJhY2tJbmZvLnNlbmRlcikpIHtcbiAgICAgICAgICAgICAgICBuZWdvdGlhdGlvbk5lZWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdHJhY2tJbmZvLnNlbmRlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdHJhY2suc2ltdWxjYXN0Q29kZWNzLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpcy5sb2cud2FybignZmFpbGVkIHRvIHVucHVibGlzaCB0cmFjaycsIHtcbiAgICAgICAgICAuLi50aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgICAgLi4ucHViTG9nQ29udGV4dCxcbiAgICAgICAgICBlcnJvcjogZSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGZyb20gb3VyIG1hcHNcbiAgICB0aGlzLnRyYWNrcy5kZWxldGUocHVibGljYXRpb24udHJhY2tTaWQpO1xuICAgIHN3aXRjaCAocHVibGljYXRpb24ua2luZCkge1xuICAgICAgY2FzZSBUcmFjay5LaW5kLkF1ZGlvOlxuICAgICAgICB0aGlzLmF1ZGlvVHJhY2tzLmRlbGV0ZShwdWJsaWNhdGlvbi50cmFja1NpZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUcmFjay5LaW5kLlZpZGVvOlxuICAgICAgICB0aGlzLnZpZGVvVHJhY2tzLmRlbGV0ZShwdWJsaWNhdGlvbi50cmFja1NpZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuTG9jYWxUcmFja1VucHVibGlzaGVkLCBwdWJsaWNhdGlvbik7XG4gICAgcHVibGljYXRpb24uc2V0VHJhY2sodW5kZWZpbmVkKTtcblxuICAgIGlmIChuZWdvdGlhdGlvbk5lZWRlZCkge1xuICAgICAgYXdhaXQgdGhpcy5lbmdpbmUubmVnb3RpYXRlKCk7XG4gICAgfVxuICAgIHJldHVybiBwdWJsaWNhdGlvbjtcbiAgfVxuXG4gIGFzeW5jIHVucHVibGlzaFRyYWNrcyhcbiAgICB0cmFja3M6IExvY2FsVHJhY2tbXSB8IE1lZGlhU3RyZWFtVHJhY2tbXSxcbiAgKTogUHJvbWlzZTxMb2NhbFRyYWNrUHVibGljYXRpb25bXT4ge1xuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbCh0cmFja3MubWFwKCh0cmFjaykgPT4gdGhpcy51bnB1Ymxpc2hUcmFjayh0cmFjaykpKTtcbiAgICByZXR1cm4gcmVzdWx0cy5maWx0ZXIoXG4gICAgICAodHJhY2spID0+IHRyYWNrIGluc3RhbmNlb2YgTG9jYWxUcmFja1B1YmxpY2F0aW9uLFxuICAgICkgYXMgTG9jYWxUcmFja1B1YmxpY2F0aW9uW107XG4gIH1cblxuICBhc3luYyByZXB1Ymxpc2hBbGxUcmFja3Mob3B0aW9ucz86IFRyYWNrUHVibGlzaE9wdGlvbnMsIHJlc3RhcnRUcmFja3M6IGJvb2xlYW4gPSB0cnVlKSB7XG4gICAgY29uc3QgbG9jYWxQdWJzOiBMb2NhbFRyYWNrUHVibGljYXRpb25bXSA9IFtdO1xuICAgIHRoaXMudHJhY2tzLmZvckVhY2goKHB1YikgPT4ge1xuICAgICAgaWYgKHB1Yi50cmFjaykge1xuICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgIHB1Yi5vcHRpb25zID0geyAuLi5wdWIub3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICB9XG4gICAgICAgIGxvY2FsUHVicy5wdXNoKHB1Yik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIGxvY2FsUHVicy5tYXAoYXN5bmMgKHB1YikgPT4ge1xuICAgICAgICBjb25zdCB0cmFjayA9IHB1Yi50cmFjayE7XG4gICAgICAgIGF3YWl0IHRoaXMudW5wdWJsaXNoVHJhY2sodHJhY2ssIGZhbHNlKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHJlc3RhcnRUcmFja3MgJiZcbiAgICAgICAgICAhdHJhY2suaXNNdXRlZCAmJlxuICAgICAgICAgIHRyYWNrLnNvdXJjZSAhPT0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlICYmXG4gICAgICAgICAgdHJhY2suc291cmNlICE9PSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmVBdWRpbyAmJlxuICAgICAgICAgICh0cmFjayBpbnN0YW5jZW9mIExvY2FsQXVkaW9UcmFjayB8fCB0cmFjayBpbnN0YW5jZW9mIExvY2FsVmlkZW9UcmFjaykgJiZcbiAgICAgICAgICAhdHJhY2suaXNVc2VyUHJvdmlkZWRcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gZ2VuZXJhbGx5IHdlIG5lZWQgdG8gcmVzdGFydCB0aGUgdHJhY2sgYmVmb3JlIHB1Ymxpc2hpbmcsIG9mdGVuIGEgZnVsbCByZWNvbm5lY3RcbiAgICAgICAgICAvLyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBjb21wdXRlciBoYWQgZ29uZSB0byBzbGVlcC5cbiAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygncmVzdGFydGluZyBleGlzdGluZyB0cmFjaycsIHtcbiAgICAgICAgICAgIC4uLnRoaXMubG9nQ29udGV4dCxcbiAgICAgICAgICAgIHRyYWNrOiBwdWIudHJhY2tTaWQsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYXdhaXQgdHJhY2sucmVzdGFydFRyYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5wdWJsaXNoVHJhY2sodHJhY2ssIHB1Yi5vcHRpb25zKTtcbiAgICAgIH0pLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUHVibGlzaCBhIG5ldyBkYXRhIHBheWxvYWQgdG8gdGhlIHJvb20uIERhdGEgd2lsbCBiZSBmb3J3YXJkZWQgdG8gZWFjaFxuICAgKiBwYXJ0aWNpcGFudCBpbiB0aGUgcm9vbSBpZiB0aGUgZGVzdGluYXRpb24gZmllbGQgaW4gcHVibGlzaE9wdGlvbnMgaXMgZW1wdHlcbiAgICpcbiAgICogQHBhcmFtIGRhdGEgVWludDhBcnJheSBvZiB0aGUgcGF5bG9hZC4gVG8gc2VuZCBzdHJpbmcgZGF0YSwgdXNlIFRleHRFbmNvZGVyLmVuY29kZVxuICAgKiBAcGFyYW0ga2luZCB3aGV0aGVyIHRvIHNlbmQgdGhpcyBhcyByZWxpYWJsZSBvciBsb3NzeS5cbiAgICogRm9yIGRhdGEgdGhhdCB5b3UgbmVlZCBkZWxpdmVyeSBndWFyYW50ZWUgKHN1Y2ggYXMgY2hhdCBtZXNzYWdlcyksIHVzZSBSZWxpYWJsZS5cbiAgICogRm9yIGRhdGEgdGhhdCBzaG91bGQgYXJyaXZlIGFzIHF1aWNrbHkgYXMgcG9zc2libGUsIGJ1dCB5b3UgYXJlIG9rIHdpdGggZHJvcHBlZFxuICAgKiBwYWNrZXRzLCB1c2UgTG9zc3kuXG4gICAqIEBwYXJhbSBwdWJsaXNoT3B0aW9ucyBvcHRpb25hbGx5IHNwZWNpZnkgYSBgdG9waWNgIGFuZCBgZGVzdGluYXRpb25gXG4gICAqL1xuICBhc3luYyBwdWJsaXNoRGF0YShcbiAgICBkYXRhOiBVaW50OEFycmF5LFxuICAgIGtpbmQ6IERhdGFQYWNrZXRfS2luZCxcbiAgICBwdWJsaXNoT3B0aW9ucz86IERhdGFQdWJsaXNoT3B0aW9ucyxcbiAgKTogUHJvbWlzZTx2b2lkPjtcbiAgLyoqXG4gICAqIFB1Ymxpc2ggYSBuZXcgZGF0YSBwYXlsb2FkIHRvIHRoZSByb29tLiBEYXRhIHdpbGwgYmUgZm9yd2FyZGVkIHRvIGVhY2hcbiAgICogcGFydGljaXBhbnQgaW4gdGhlIHJvb20gaWYgdGhlIGRlc3RpbmF0aW9uIGFyZ3VtZW50IGlzIGVtcHR5XG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIFVpbnQ4QXJyYXkgb2YgdGhlIHBheWxvYWQuIFRvIHNlbmQgc3RyaW5nIGRhdGEsIHVzZSBUZXh0RW5jb2Rlci5lbmNvZGVcbiAgICogQHBhcmFtIGtpbmQgd2hldGhlciB0byBzZW5kIHRoaXMgYXMgcmVsaWFibGUgb3IgbG9zc3kuXG4gICAqIEZvciBkYXRhIHRoYXQgeW91IG5lZWQgZGVsaXZlcnkgZ3VhcmFudGVlIChzdWNoIGFzIGNoYXQgbWVzc2FnZXMpLCB1c2UgUmVsaWFibGUuXG4gICAqIEZvciBkYXRhIHRoYXQgc2hvdWxkIGFycml2ZSBhcyBxdWlja2x5IGFzIHBvc3NpYmxlLCBidXQgeW91IGFyZSBvayB3aXRoIGRyb3BwZWRcbiAgICogcGFja2V0cywgdXNlIExvc3N5LlxuICAgKiBAcGFyYW0gZGVzdGluYXRpb24gdGhlIHBhcnRpY2lwYW50cyB3aG8gd2lsbCByZWNlaXZlIHRoZSBtZXNzYWdlXG4gICAqL1xuICBhc3luYyBwdWJsaXNoRGF0YShcbiAgICBkYXRhOiBVaW50OEFycmF5LFxuICAgIGtpbmQ6IERhdGFQYWNrZXRfS2luZCxcbiAgICBkZXN0aW5hdGlvbj86IFJlbW90ZVBhcnRpY2lwYW50W10gfCBzdHJpbmdbXSxcbiAgKTogUHJvbWlzZTx2b2lkPjtcblxuICBhc3luYyBwdWJsaXNoRGF0YShcbiAgICBkYXRhOiBVaW50OEFycmF5LFxuICAgIGtpbmQ6IERhdGFQYWNrZXRfS2luZCxcbiAgICBwdWJsaXNoT3B0aW9uczogRGF0YVB1Ymxpc2hPcHRpb25zIHwgUmVtb3RlUGFydGljaXBhbnRbXSB8IHN0cmluZ1tdID0ge30sXG4gICkge1xuICAgIGNvbnN0IGRlc3RpbmF0aW9uID0gQXJyYXkuaXNBcnJheShwdWJsaXNoT3B0aW9ucylcbiAgICAgID8gcHVibGlzaE9wdGlvbnNcbiAgICAgIDogcHVibGlzaE9wdGlvbnM/LmRlc3RpbmF0aW9uO1xuICAgIGNvbnN0IGRlc3RpbmF0aW9uU2lkczogc3RyaW5nW10gPSBbXTtcblxuICAgIGNvbnN0IHRvcGljID0gIUFycmF5LmlzQXJyYXkocHVibGlzaE9wdGlvbnMpID8gcHVibGlzaE9wdGlvbnMudG9waWMgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoZGVzdGluYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgZGVzdGluYXRpb24uZm9yRWFjaCgodmFsOiBhbnkpID0+IHtcbiAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIFJlbW90ZVBhcnRpY2lwYW50KSB7XG4gICAgICAgICAgZGVzdGluYXRpb25TaWRzLnB1c2godmFsLnNpZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVzdGluYXRpb25TaWRzLnB1c2godmFsKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgcGFja2V0ID0gbmV3IERhdGFQYWNrZXQoe1xuICAgICAga2luZCxcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIGNhc2U6ICd1c2VyJyxcbiAgICAgICAgdmFsdWU6IG5ldyBVc2VyUGFja2V0KHtcbiAgICAgICAgICBwYXJ0aWNpcGFudFNpZDogdGhpcy5zaWQsXG4gICAgICAgICAgcGF5bG9hZDogZGF0YSxcbiAgICAgICAgICBkZXN0aW5hdGlvblNpZHM6IGRlc3RpbmF0aW9uU2lkcyxcbiAgICAgICAgICB0b3BpYyxcbiAgICAgICAgfSksXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgYXdhaXQgdGhpcy5lbmdpbmUuc2VuZERhdGFQYWNrZXQocGFja2V0LCBraW5kKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb250cm9sIHdobyBjYW4gc3Vic2NyaWJlIHRvIExvY2FsUGFydGljaXBhbnQncyBwdWJsaXNoZWQgdHJhY2tzLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBhbGwgcGFydGljaXBhbnRzIGNhbiBzdWJzY3JpYmUuIFRoaXMgYWxsb3dzIGZpbmUtZ3JhaW5lZCBjb250cm9sIG92ZXJcbiAgICogd2hvIGlzIGFibGUgdG8gc3Vic2NyaWJlIGF0IGEgcGFydGljaXBhbnQgYW5kIHRyYWNrIGxldmVsLlxuICAgKlxuICAgKiBOb3RlOiBpZiBhY2Nlc3MgaXMgZ2l2ZW4gYXQgYSB0cmFjay1sZXZlbCAoaS5lLiBib3RoIFthbGxQYXJ0aWNpcGFudHNBbGxvd2VkXSBhbmRcbiAgICogW1BhcnRpY2lwYW50VHJhY2tQZXJtaXNzaW9uLmFsbFRyYWNrc0FsbG93ZWRdIGFyZSBmYWxzZSksIGFueSBuZXdlciBwdWJsaXNoZWQgdHJhY2tzXG4gICAqIHdpbGwgbm90IGdyYW50IHBlcm1pc3Npb25zIHRvIGFueSBwYXJ0aWNpcGFudHMgYW5kIHdpbGwgcmVxdWlyZSBhIHN1YnNlcXVlbnRcbiAgICogcGVybWlzc2lvbnMgdXBkYXRlIHRvIGFsbG93IHN1YnNjcmlwdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIGFsbFBhcnRpY2lwYW50c0FsbG93ZWQgQWxsb3dzIGFsbCBwYXJ0aWNpcGFudHMgdG8gc3Vic2NyaWJlIGFsbCB0cmFja3MuXG4gICAqICBUYWtlcyBwcmVjZWRlbmNlIG92ZXIgW1twYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbnNdXSBpZiBzZXQgdG8gdHJ1ZS5cbiAgICogIEJ5IGRlZmF1bHQgdGhpcyBpcyBzZXQgdG8gdHJ1ZS5cbiAgICogQHBhcmFtIHBhcnRpY2lwYW50VHJhY2tQZXJtaXNzaW9ucyBGdWxsIGxpc3Qgb2YgaW5kaXZpZHVhbCBwZXJtaXNzaW9ucyBwZXJcbiAgICogIHBhcnRpY2lwYW50L3RyYWNrLiBBbnkgb21pdHRlZCBwYXJ0aWNpcGFudHMgd2lsbCBub3QgcmVjZWl2ZSBhbnkgcGVybWlzc2lvbnMuXG4gICAqL1xuICBzZXRUcmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25zKFxuICAgIGFsbFBhcnRpY2lwYW50c0FsbG93ZWQ6IGJvb2xlYW4sXG4gICAgcGFydGljaXBhbnRUcmFja1Blcm1pc3Npb25zOiBQYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbltdID0gW10sXG4gICkge1xuICAgIHRoaXMucGFydGljaXBhbnRUcmFja1Blcm1pc3Npb25zID0gcGFydGljaXBhbnRUcmFja1Blcm1pc3Npb25zO1xuICAgIHRoaXMuYWxsUGFydGljaXBhbnRzQWxsb3dlZFRvU3Vic2NyaWJlID0gYWxsUGFydGljaXBhbnRzQWxsb3dlZDtcbiAgICBpZiAoIXRoaXMuZW5naW5lLmNsaWVudC5pc0Rpc2Nvbm5lY3RlZCkge1xuICAgICAgdGhpcy51cGRhdGVUcmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25zKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICB1cGRhdGVJbmZvKGluZm86IFBhcnRpY2lwYW50SW5mbyk6IGJvb2xlYW4ge1xuICAgIGlmIChpbmZvLnNpZCAhPT0gdGhpcy5zaWQpIHtcbiAgICAgIC8vIGRyb3AgdXBkYXRlcyB0aGF0IHNwZWNpZnkgYSB3cm9uZyBzaWQuXG4gICAgICAvLyB0aGUgc2lkIGZvciBsb2NhbCBwYXJ0aWNpcGFudCBpcyBvbmx5IGV4cGxpY2l0bHkgc2V0IG9uIGpvaW4gYW5kIGZ1bGwgcmVjb25uZWN0XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghc3VwZXIudXBkYXRlSW5mbyhpbmZvKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIHJlY29uY2lsZSB0cmFjayBtdXRlIHN0YXR1cy5cbiAgICAvLyBpZiBzZXJ2ZXIncyB0cmFjayBtdXRlIHN0YXR1cyBkb2Vzbid0IG1hdGNoIGFjdHVhbCwgd2UnbGwgaGF2ZSB0byB1cGRhdGVcbiAgICAvLyB0aGUgc2VydmVyJ3MgY29weVxuICAgIGluZm8udHJhY2tzLmZvckVhY2goKHRpKSA9PiB7XG4gICAgICBjb25zdCBwdWIgPSB0aGlzLnRyYWNrcy5nZXQodGkuc2lkKTtcblxuICAgICAgaWYgKHB1Yikge1xuICAgICAgICBjb25zdCBtdXRlZE9uU2VydmVyID0gcHViLmlzTXV0ZWQgfHwgKHB1Yi50cmFjaz8uaXNVcHN0cmVhbVBhdXNlZCA/PyBmYWxzZSk7XG4gICAgICAgIGlmIChtdXRlZE9uU2VydmVyICE9PSB0aS5tdXRlZCkge1xuICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCd1cGRhdGluZyBzZXJ2ZXIgbXV0ZSBzdGF0ZSBhZnRlciByZWNvbmNpbGUnLCB7XG4gICAgICAgICAgICAuLi50aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgICAgICAuLi5nZXRMb2dDb250ZXh0RnJvbVRyYWNrKHB1YiksXG4gICAgICAgICAgICBtdXRlZE9uU2VydmVyLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuZW5naW5lLmNsaWVudC5zZW5kTXV0ZVRyYWNrKHRpLnNpZCwgbXV0ZWRPblNlcnZlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlVHJhY2tTdWJzY3JpcHRpb25QZXJtaXNzaW9ucyA9ICgpID0+IHtcbiAgICB0aGlzLmxvZy5kZWJ1ZygndXBkYXRpbmcgdHJhY2sgc3Vic2NyaXB0aW9uIHBlcm1pc3Npb25zJywge1xuICAgICAgLi4udGhpcy5sb2dDb250ZXh0LFxuICAgICAgYWxsUGFydGljaXBhbnRzQWxsb3dlZDogdGhpcy5hbGxQYXJ0aWNpcGFudHNBbGxvd2VkVG9TdWJzY3JpYmUsXG4gICAgICBwYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbnM6IHRoaXMucGFydGljaXBhbnRUcmFja1Blcm1pc3Npb25zLFxuICAgIH0pO1xuICAgIHRoaXMuZW5naW5lLmNsaWVudC5zZW5kVXBkYXRlU3Vic2NyaXB0aW9uUGVybWlzc2lvbnMoXG4gICAgICB0aGlzLmFsbFBhcnRpY2lwYW50c0FsbG93ZWRUb1N1YnNjcmliZSxcbiAgICAgIHRoaXMucGFydGljaXBhbnRUcmFja1Blcm1pc3Npb25zLm1hcCgocCkgPT4gdHJhY2tQZXJtaXNzaW9uVG9Qcm90byhwKSksXG4gICAgKTtcbiAgfTtcblxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgb25UcmFja1VubXV0ZWQgPSAodHJhY2s6IExvY2FsVHJhY2spID0+IHtcbiAgICB0aGlzLm9uVHJhY2tNdXRlZCh0cmFjaywgdHJhY2suaXNVcHN0cmVhbVBhdXNlZCk7XG4gIH07XG5cbiAgLy8gd2hlbiB0aGUgbG9jYWwgdHJhY2sgY2hhbmdlcyBpbiBtdXRlIHN0YXR1cywgd2UnbGwgbm90aWZ5IHNlcnZlciBhcyBzdWNoXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBvblRyYWNrTXV0ZWQgPSAodHJhY2s6IExvY2FsVHJhY2ssIG11dGVkPzogYm9vbGVhbikgPT4ge1xuICAgIGlmIChtdXRlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBtdXRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKCF0cmFjay5zaWQpIHtcbiAgICAgIHRoaXMubG9nLmVycm9yKCdjb3VsZCBub3QgdXBkYXRlIG11dGUgc3RhdHVzIGZvciB1bnB1Ymxpc2hlZCB0cmFjaycsIHtcbiAgICAgICAgLi4udGhpcy5sb2dDb250ZXh0LFxuICAgICAgICAuLi5nZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZW5naW5lLnVwZGF0ZU11dGVTdGF0dXModHJhY2suc2lkLCBtdXRlZCk7XG4gIH07XG5cbiAgcHJpdmF0ZSBvblRyYWNrVXBzdHJlYW1QYXVzZWQgPSAodHJhY2s6IExvY2FsVHJhY2spID0+IHtcbiAgICB0aGlzLmxvZy5kZWJ1ZygndXBzdHJlYW0gcGF1c2VkJywge1xuICAgICAgLi4udGhpcy5sb2dDb250ZXh0LFxuICAgICAgLi4uZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjayksXG4gICAgfSk7XG4gICAgdGhpcy5vblRyYWNrTXV0ZWQodHJhY2ssIHRydWUpO1xuICB9O1xuXG4gIHByaXZhdGUgb25UcmFja1Vwc3RyZWFtUmVzdW1lZCA9ICh0cmFjazogTG9jYWxUcmFjaykgPT4ge1xuICAgIHRoaXMubG9nLmRlYnVnKCd1cHN0cmVhbSByZXN1bWVkJywge1xuICAgICAgLi4udGhpcy5sb2dDb250ZXh0LFxuICAgICAgLi4uZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjayksXG4gICAgfSk7XG4gICAgdGhpcy5vblRyYWNrTXV0ZWQodHJhY2ssIHRyYWNrLmlzTXV0ZWQpO1xuICB9O1xuXG4gIHByaXZhdGUgaGFuZGxlU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUgPSBhc3luYyAodXBkYXRlOiBTdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSkgPT4ge1xuICAgIGlmICghdGhpcy5yb29tT3B0aW9ucz8uZHluYWNhc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcHViID0gdGhpcy52aWRlb1RyYWNrcy5nZXQodXBkYXRlLnRyYWNrU2lkKTtcbiAgICBpZiAoIXB1Yikge1xuICAgICAgdGhpcy5sb2cud2FybigncmVjZWl2ZWQgc3Vic2NyaWJlZCBxdWFsaXR5IHVwZGF0ZSBmb3IgdW5rbm93biB0cmFjaycsIHtcbiAgICAgICAgLi4udGhpcy5sb2dDb250ZXh0LFxuICAgICAgICB0cmFja1NpZDogdXBkYXRlLnRyYWNrU2lkLFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh1cGRhdGUuc3Vic2NyaWJlZENvZGVjcy5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAoIXB1Yi52aWRlb1RyYWNrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5ld0NvZGVjcyA9IGF3YWl0IHB1Yi52aWRlb1RyYWNrLnNldFB1Ymxpc2hpbmdDb2RlY3ModXBkYXRlLnN1YnNjcmliZWRDb2RlY3MpO1xuICAgICAgZm9yIGF3YWl0IChjb25zdCBjb2RlYyBvZiBuZXdDb2RlY3MpIHtcbiAgICAgICAgaWYgKGlzQmFja3VwQ29kZWMoY29kZWMpKSB7XG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoYHB1Ymxpc2ggJHtjb2RlY30gZm9yICR7cHViLnZpZGVvVHJhY2suc2lkfWAsIHtcbiAgICAgICAgICAgIC4uLnRoaXMubG9nQ29udGV4dCxcbiAgICAgICAgICAgIC4uLmdldExvZ0NvbnRleHRGcm9tVHJhY2socHViKSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBhd2FpdCB0aGlzLnB1Ymxpc2hBZGRpdGlvbmFsQ29kZWNGb3JUcmFjayhwdWIudmlkZW9UcmFjaywgY29kZWMsIHB1Yi5vcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodXBkYXRlLnN1YnNjcmliZWRRdWFsaXRpZXMubGVuZ3RoID4gMCkge1xuICAgICAgYXdhaXQgcHViLnZpZGVvVHJhY2s/LnNldFB1Ymxpc2hpbmdMYXllcnModXBkYXRlLnN1YnNjcmliZWRRdWFsaXRpZXMpO1xuICAgIH1cbiAgfTtcblxuICBwcml2YXRlIGhhbmRsZUxvY2FsVHJhY2tVbnB1Ymxpc2hlZCA9ICh1bnB1Ymxpc2hlZDogVHJhY2tVbnB1Ymxpc2hlZFJlc3BvbnNlKSA9PiB7XG4gICAgY29uc3QgdHJhY2sgPSB0aGlzLnRyYWNrcy5nZXQodW5wdWJsaXNoZWQudHJhY2tTaWQpO1xuICAgIGlmICghdHJhY2spIHtcbiAgICAgIHRoaXMubG9nLndhcm4oJ3JlY2VpdmVkIHVucHVibGlzaGVkIGV2ZW50IGZvciB1bmtub3duIHRyYWNrJywge1xuICAgICAgICAuLi50aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgIHRyYWNrU2lkOiB1bnB1Ymxpc2hlZC50cmFja1NpZCxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnVucHVibGlzaFRyYWNrKHRyYWNrLnRyYWNrISk7XG4gIH07XG5cbiAgcHJpdmF0ZSBoYW5kbGVUcmFja0VuZGVkID0gYXN5bmMgKHRyYWNrOiBMb2NhbFRyYWNrKSA9PiB7XG4gICAgaWYgKFxuICAgICAgdHJhY2suc291cmNlID09PSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmUgfHxcbiAgICAgIHRyYWNrLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlQXVkaW9cbiAgICApIHtcbiAgICAgIHRoaXMubG9nLmRlYnVnKCd1bnB1Ymxpc2hpbmcgbG9jYWwgdHJhY2sgZHVlIHRvIFRyYWNrRW5kZWQnLCB7XG4gICAgICAgIC4uLnRoaXMubG9nQ29udGV4dCxcbiAgICAgICAgLi4uZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjayksXG4gICAgICB9KTtcbiAgICAgIHRoaXMudW5wdWJsaXNoVHJhY2sodHJhY2spO1xuICAgIH0gZWxzZSBpZiAodHJhY2suaXNVc2VyUHJvdmlkZWQpIHtcbiAgICAgIGF3YWl0IHRyYWNrLm11dGUoKTtcbiAgICB9IGVsc2UgaWYgKHRyYWNrIGluc3RhbmNlb2YgTG9jYWxBdWRpb1RyYWNrIHx8IHRyYWNrIGluc3RhbmNlb2YgTG9jYWxWaWRlb1RyYWNrKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoaXNXZWIoKSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50UGVybWlzc2lvbnMgPSBhd2FpdCBuYXZpZ2F0b3I/LnBlcm1pc3Npb25zLnF1ZXJ5KHtcbiAgICAgICAgICAgICAgLy8gdGhlIHBlcm1pc3Npb24gcXVlcnkgZm9yIGNhbWVyYSBhbmQgbWljcm9waG9uZSBjdXJyZW50bHkgbm90IHN1cHBvcnRlZCBpbiBTYWZhcmkgYW5kIEZpcmVmb3hcbiAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICBuYW1lOiB0cmFjay5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5DYW1lcmEgPyAnY2FtZXJhJyA6ICdtaWNyb3Bob25lJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRQZXJtaXNzaW9ucyAmJiBjdXJyZW50UGVybWlzc2lvbnMuc3RhdGUgPT09ICdkZW5pZWQnKSB7XG4gICAgICAgICAgICAgIHRoaXMubG9nLndhcm4oYHVzZXIgaGFzIHJldm9rZWQgYWNjZXNzIHRvICR7dHJhY2suc291cmNlfWAsIHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgICAgICAgICAgLi4uZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjayksXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIC8vIGRldGVjdCBncmFudGVkIGNoYW5nZSBhZnRlciBwZXJtaXNzaW9ucyB3ZXJlIGRlbmllZCB0byB0cnkgYW5kIHJlc3VtZSB0aGVuXG4gICAgICAgICAgICAgIGN1cnJlbnRQZXJtaXNzaW9ucy5vbmNoYW5nZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFBlcm1pc3Npb25zLnN0YXRlICE9PSAnZGVuaWVkJykge1xuICAgICAgICAgICAgICAgICAgaWYgKCF0cmFjay5pc011dGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrLnJlc3RhcnRUcmFjaygpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgY3VycmVudFBlcm1pc3Npb25zLm9uY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignR2V0VXNlck1lZGlhIFBlcm1pc3Npb24gZGVuaWVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICAgICAgICAvLyBwZXJtaXNzaW9ucyBxdWVyeSBmYWlscyBmb3IgZmlyZWZveCwgd2UgY29udGludWUgYW5kIHRyeSB0byByZXN0YXJ0IHRoZSB0cmFja1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRyYWNrLmlzTXV0ZWQpIHtcbiAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygndHJhY2sgZW5kZWQsIGF0dGVtcHRpbmcgdG8gdXNlIGEgZGlmZmVyZW50IGRldmljZScsIHtcbiAgICAgICAgICAgIC4uLnRoaXMubG9nQ29udGV4dCxcbiAgICAgICAgICAgIC4uLmdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGF3YWl0IHRyYWNrLnJlc3RhcnRUcmFjaygpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRoaXMubG9nLndhcm4oYGNvdWxkIG5vdCByZXN0YXJ0IHRyYWNrLCBtdXRpbmcgaW5zdGVhZGAsIHtcbiAgICAgICAgICAuLi50aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgICAgLi4uZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjayksXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0cmFjay5tdXRlKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHByaXZhdGUgZ2V0UHVibGljYXRpb25Gb3JUcmFjayhcbiAgICB0cmFjazogTG9jYWxUcmFjayB8IE1lZGlhU3RyZWFtVHJhY2ssXG4gICk6IExvY2FsVHJhY2tQdWJsaWNhdGlvbiB8IHVuZGVmaW5lZCB7XG4gICAgbGV0IHB1YmxpY2F0aW9uOiBMb2NhbFRyYWNrUHVibGljYXRpb24gfCB1bmRlZmluZWQ7XG4gICAgdGhpcy50cmFja3MuZm9yRWFjaCgocHViKSA9PiB7XG4gICAgICBjb25zdCBsb2NhbFRyYWNrID0gcHViLnRyYWNrO1xuICAgICAgaWYgKCFsb2NhbFRyYWNrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gdGhpcyBsb29rcyBvdmVybHkgY29tcGxpY2F0ZWQgZHVlIHRvIHRoaXMgb2JqZWN0IHRyZWVcbiAgICAgIGlmICh0cmFjayBpbnN0YW5jZW9mIE1lZGlhU3RyZWFtVHJhY2spIHtcbiAgICAgICAgaWYgKGxvY2FsVHJhY2sgaW5zdGFuY2VvZiBMb2NhbEF1ZGlvVHJhY2sgfHwgbG9jYWxUcmFjayBpbnN0YW5jZW9mIExvY2FsVmlkZW9UcmFjaykge1xuICAgICAgICAgIGlmIChsb2NhbFRyYWNrLm1lZGlhU3RyZWFtVHJhY2sgPT09IHRyYWNrKSB7XG4gICAgICAgICAgICBwdWJsaWNhdGlvbiA9IDxMb2NhbFRyYWNrUHVibGljYXRpb24+cHViO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0cmFjayA9PT0gbG9jYWxUcmFjaykge1xuICAgICAgICBwdWJsaWNhdGlvbiA9IDxMb2NhbFRyYWNrUHVibGljYXRpb24+cHViO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBwdWJsaWNhdGlvbjtcbiAgfVxufVxuIiwiaW1wb3J0IHsgcHJvdG9JbnQ2NCB9IGZyb20gJ0BidWZidWlsZC9wcm90b2J1Zic7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnO1xuaW1wb3J0IHR5cGUgVHlwZWRFbWl0dGVyIGZyb20gJ3R5cGVkLWVtaXR0ZXInO1xuaW1wb3J0ICd3ZWJydGMtYWRhcHRlcic7XG5pbXBvcnQgeyBFbmNyeXB0aW9uRXZlbnQgfSBmcm9tICcuLi9lMmVlJztcbmltcG9ydCB7IEUyRUVNYW5hZ2VyIH0gZnJvbSAnLi4vZTJlZS9FMmVlTWFuYWdlcic7XG5pbXBvcnQgbG9nLCB7IExvZ2dlck5hbWVzLCBnZXRMb2dnZXIgfSBmcm9tICcuLi9sb2dnZXInO1xuaW1wb3J0IHR5cGUge1xuICBJbnRlcm5hbFJvb21Db25uZWN0T3B0aW9ucyxcbiAgSW50ZXJuYWxSb29tT3B0aW9ucyxcbiAgUm9vbUNvbm5lY3RPcHRpb25zLFxuICBSb29tT3B0aW9ucyxcbn0gZnJvbSAnLi4vb3B0aW9ucyc7XG5pbXBvcnQge1xuICBEYXRhUGFja2V0X0tpbmQsXG4gIERpc2Nvbm5lY3RSZWFzb24sXG4gIFBhcnRpY2lwYW50SW5mbyxcbiAgUGFydGljaXBhbnRJbmZvX1N0YXRlLFxuICBQYXJ0aWNpcGFudFBlcm1pc3Npb24sXG4gIFJvb20gYXMgUm9vbU1vZGVsLFxuICBTZXJ2ZXJJbmZvLFxuICBTcGVha2VySW5mbyxcbiAgU3Vic2NyaXB0aW9uRXJyb3IsXG4gIFRyYWNrSW5mbyxcbiAgVHJhY2tTb3VyY2UsXG4gIFRyYWNrVHlwZSxcbiAgVXNlclBhY2tldCxcbn0gZnJvbSAnLi4vcHJvdG8vbGl2ZWtpdF9tb2RlbHNfcGInO1xuaW1wb3J0IHtcbiAgQ29ubmVjdGlvblF1YWxpdHlVcGRhdGUsXG4gIEpvaW5SZXNwb25zZSxcbiAgTGVhdmVSZXF1ZXN0LFxuICBTaW11bGF0ZVNjZW5hcmlvLFxuICBTdHJlYW1TdGF0ZVVwZGF0ZSxcbiAgU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSxcbiAgU3Vic2NyaXB0aW9uUmVzcG9uc2UsXG59IGZyb20gJy4uL3Byb3RvL2xpdmVraXRfcnRjX3BiJztcbmltcG9ydCB7IGdldEJyb3dzZXIgfSBmcm9tICcuLi91dGlscy9icm93c2VyUGFyc2VyJztcbmltcG9ydCBEZXZpY2VNYW5hZ2VyIGZyb20gJy4vRGV2aWNlTWFuYWdlcic7XG5pbXBvcnQgUlRDRW5naW5lIGZyb20gJy4vUlRDRW5naW5lJztcbmltcG9ydCB7IFJlZ2lvblVybFByb3ZpZGVyIH0gZnJvbSAnLi9SZWdpb25VcmxQcm92aWRlcic7XG5pbXBvcnQge1xuICBhdWRpb0RlZmF1bHRzLFxuICBwdWJsaXNoRGVmYXVsdHMsXG4gIHJvb21Db25uZWN0T3B0aW9uRGVmYXVsdHMsXG4gIHJvb21PcHRpb25EZWZhdWx0cyxcbiAgdmlkZW9EZWZhdWx0cyxcbn0gZnJvbSAnLi9kZWZhdWx0cyc7XG5pbXBvcnQgeyBDb25uZWN0aW9uRXJyb3IsIENvbm5lY3Rpb25FcnJvclJlYXNvbiwgVW5zdXBwb3J0ZWRTZXJ2ZXIgfSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQgeyBFbmdpbmVFdmVudCwgUGFydGljaXBhbnRFdmVudCwgUm9vbUV2ZW50LCBUcmFja0V2ZW50IH0gZnJvbSAnLi9ldmVudHMnO1xuaW1wb3J0IExvY2FsUGFydGljaXBhbnQgZnJvbSAnLi9wYXJ0aWNpcGFudC9Mb2NhbFBhcnRpY2lwYW50JztcbmltcG9ydCB0eXBlIFBhcnRpY2lwYW50IGZyb20gJy4vcGFydGljaXBhbnQvUGFydGljaXBhbnQnO1xuaW1wb3J0IHR5cGUgeyBDb25uZWN0aW9uUXVhbGl0eSB9IGZyb20gJy4vcGFydGljaXBhbnQvUGFydGljaXBhbnQnO1xuaW1wb3J0IFJlbW90ZVBhcnRpY2lwYW50IGZyb20gJy4vcGFydGljaXBhbnQvUmVtb3RlUGFydGljaXBhbnQnO1xuaW1wb3J0IENyaXRpY2FsVGltZXJzIGZyb20gJy4vdGltZXJzJztcbmltcG9ydCBMb2NhbEF1ZGlvVHJhY2sgZnJvbSAnLi90cmFjay9Mb2NhbEF1ZGlvVHJhY2snO1xuaW1wb3J0IExvY2FsVHJhY2tQdWJsaWNhdGlvbiBmcm9tICcuL3RyYWNrL0xvY2FsVHJhY2tQdWJsaWNhdGlvbic7XG5pbXBvcnQgTG9jYWxWaWRlb1RyYWNrIGZyb20gJy4vdHJhY2svTG9jYWxWaWRlb1RyYWNrJztcbmltcG9ydCB0eXBlIFJlbW90ZVRyYWNrIGZyb20gJy4vdHJhY2svUmVtb3RlVHJhY2snO1xuaW1wb3J0IFJlbW90ZVRyYWNrUHVibGljYXRpb24gZnJvbSAnLi90cmFjay9SZW1vdGVUcmFja1B1YmxpY2F0aW9uJztcbmltcG9ydCB7IFRyYWNrIH0gZnJvbSAnLi90cmFjay9UcmFjayc7XG5pbXBvcnQgdHlwZSB7IFRyYWNrUHVibGljYXRpb24gfSBmcm9tICcuL3RyYWNrL1RyYWNrUHVibGljYXRpb24nO1xuaW1wb3J0IHR5cGUgeyBBZGFwdGl2ZVN0cmVhbVNldHRpbmdzIH0gZnJvbSAnLi90cmFjay90eXBlcyc7XG5pbXBvcnQgeyBnZXROZXdBdWRpb0NvbnRleHQsIHNvdXJjZVRvS2luZCB9IGZyb20gJy4vdHJhY2svdXRpbHMnO1xuaW1wb3J0IHR5cGUgeyBTaW11bGF0aW9uT3B0aW9ucywgU2ltdWxhdGlvblNjZW5hcmlvIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQge1xuICBGdXR1cmUsXG4gIE11dGV4LFxuICBjcmVhdGVEdW1teVZpZGVvU3RyZWFtVHJhY2ssXG4gIGdldEVtcHR5QXVkaW9TdHJlYW1UcmFjayxcbiAgaXNDbG91ZCxcbiAgaXNXZWIsXG4gIHN1cHBvcnRzU2V0U2lua0lkLFxuICB0b0h0dHBVcmwsXG4gIHVucGFja1N0cmVhbUlkLFxuICB1bndyYXBDb25zdHJhaW50LFxufSBmcm9tICcuL3V0aWxzJztcblxuZXhwb3J0IGVudW0gQ29ubmVjdGlvblN0YXRlIHtcbiAgRGlzY29ubmVjdGVkID0gJ2Rpc2Nvbm5lY3RlZCcsXG4gIENvbm5lY3RpbmcgPSAnY29ubmVjdGluZycsXG4gIENvbm5lY3RlZCA9ICdjb25uZWN0ZWQnLFxuICBSZWNvbm5lY3RpbmcgPSAncmVjb25uZWN0aW5nJyxcbn1cblxuY29uc3QgY29ubmVjdGlvblJlY29uY2lsZUZyZXF1ZW5jeSA9IDIgKiAxMDAwO1xuXG4vKiogQGRlcHJlY2F0ZWQgUm9vbVN0YXRlIGhhcyBiZWVuIHJlbmFtZWQgdG8gW1tDb25uZWN0aW9uU3RhdGVdXSAqL1xuZXhwb3J0IGNvbnN0IFJvb21TdGF0ZSA9IENvbm5lY3Rpb25TdGF0ZTtcblxuLyoqXG4gKiBJbiBMaXZlS2l0LCBhIHJvb20gaXMgdGhlIGxvZ2ljYWwgZ3JvdXBpbmcgZm9yIGEgbGlzdCBvZiBwYXJ0aWNpcGFudHMuXG4gKiBQYXJ0aWNpcGFudHMgaW4gYSByb29tIGNhbiBwdWJsaXNoIHRyYWNrcywgYW5kIHN1YnNjcmliZSB0byBvdGhlcnMnIHRyYWNrcy5cbiAqXG4gKiBhIFJvb20gZmlyZXMgW1tSb29tRXZlbnQgfCBSb29tRXZlbnRzXV0uXG4gKlxuICogQG5vSW5oZXJpdERvY1xuICovXG5jbGFzcyBSb29tIGV4dGVuZHMgKEV2ZW50RW1pdHRlciBhcyBuZXcgKCkgPT4gVHlwZWRFbWl0dGVyPFJvb21FdmVudENhbGxiYWNrcz4pIHtcbiAgc3RhdGU6IENvbm5lY3Rpb25TdGF0ZSA9IENvbm5lY3Rpb25TdGF0ZS5EaXNjb25uZWN0ZWQ7XG5cbiAgLyoqIG1hcCBvZiBzaWQ6IFtbUmVtb3RlUGFydGljaXBhbnRdXSAqL1xuICBwYXJ0aWNpcGFudHM6IE1hcDxzdHJpbmcsIFJlbW90ZVBhcnRpY2lwYW50PjtcblxuICAvKipcbiAgICogbGlzdCBvZiBwYXJ0aWNpcGFudHMgdGhhdCBhcmUgYWN0aXZlbHkgc3BlYWtpbmcuIHdoZW4gdGhpcyBjaGFuZ2VzXG4gICAqIGEgW1tSb29tRXZlbnQuQWN0aXZlU3BlYWtlcnNDaGFuZ2VkXV0gZXZlbnQgaXMgZmlyZWRcbiAgICovXG4gIGFjdGl2ZVNwZWFrZXJzOiBQYXJ0aWNpcGFudFtdID0gW107XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBlbmdpbmUhOiBSVENFbmdpbmU7XG5cbiAgLyoqIHRoZSBjdXJyZW50IHBhcnRpY2lwYW50ICovXG4gIGxvY2FsUGFydGljaXBhbnQ6IExvY2FsUGFydGljaXBhbnQ7XG5cbiAgLyoqIG9wdGlvbnMgb2Ygcm9vbSAqL1xuICBvcHRpb25zOiBJbnRlcm5hbFJvb21PcHRpb25zO1xuXG4gIC8qKiByZWZsZWN0cyB0aGUgc2VuZGVyIGVuY3J5cHRpb24gc3RhdHVzIG9mIHRoZSBsb2NhbCBwYXJ0aWNpcGFudCAqL1xuICBpc0UyRUVFbmFibGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgcHJpdmF0ZSByb29tSW5mbz86IFJvb21Nb2RlbDtcblxuICBwcml2YXRlIGlkZW50aXR5VG9TaWQ6IE1hcDxzdHJpbmcsIHN0cmluZz47XG5cbiAgLyoqIGNvbm5lY3Qgb3B0aW9ucyBvZiByb29tICovXG4gIHByaXZhdGUgY29ubk9wdGlvbnM/OiBJbnRlcm5hbFJvb21Db25uZWN0T3B0aW9ucztcblxuICBwcml2YXRlIGF1ZGlvRW5hYmxlZCA9IHRydWU7XG5cbiAgcHJpdmF0ZSBhdWRpb0NvbnRleHQ/OiBBdWRpb0NvbnRleHQ7XG5cbiAgLyoqIHVzZWQgZm9yIGFib3J0aW5nIHBlbmRpbmcgY29ubmVjdGlvbnMgdG8gYSBMaXZlS2l0IHNlcnZlciAqL1xuICBwcml2YXRlIGFib3J0Q29udHJvbGxlcj86IEFib3J0Q29udHJvbGxlcjtcblxuICAvKiogZnV0dXJlIGhvbGRpbmcgY2xpZW50IGluaXRpYXRlZCBjb25uZWN0aW9uIGF0dGVtcHQgKi9cbiAgcHJpdmF0ZSBjb25uZWN0RnV0dXJlPzogRnV0dXJlPHZvaWQ+O1xuXG4gIHByaXZhdGUgZGlzY29ubmVjdExvY2s6IE11dGV4O1xuXG4gIHByaXZhdGUgZTJlZU1hbmFnZXI6IEUyRUVNYW5hZ2VyIHwgdW5kZWZpbmVkO1xuXG4gIHByaXZhdGUgY29ubmVjdGlvblJlY29uY2lsZUludGVydmFsPzogUmV0dXJuVHlwZTx0eXBlb2Ygc2V0SW50ZXJ2YWw+O1xuXG4gIHByaXZhdGUgcmVnaW9uVXJsUHJvdmlkZXI/OiBSZWdpb25VcmxQcm92aWRlcjtcblxuICBwcml2YXRlIHJlZ2lvblVybD86IHN0cmluZztcblxuICBwcml2YXRlIGlzVmlkZW9QbGF5YmFja0Jsb2NrZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBwcml2YXRlIGxvZyA9IGxvZztcblxuICBwcml2YXRlIGJ1ZmZlcmVkRXZlbnRzOiBBcnJheTxhbnk+ID0gW107XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgUm9vbSwgdGhlIHByaW1hcnkgY29uc3RydWN0IGZvciBhIExpdmVLaXQgc2Vzc2lvbi5cbiAgICogQHBhcmFtIG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM/OiBSb29tT3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zZXRNYXhMaXN0ZW5lcnMoMTAwKTtcbiAgICB0aGlzLnBhcnRpY2lwYW50cyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmlkZW50aXR5VG9TaWQgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5vcHRpb25zID0geyAuLi5yb29tT3B0aW9uRGVmYXVsdHMsIC4uLm9wdGlvbnMgfTtcblxuICAgIHRoaXMubG9nID0gZ2V0TG9nZ2VyKHRoaXMub3B0aW9ucy5sb2dnZXJOYW1lID8/IExvZ2dlck5hbWVzLlJvb20pO1xuXG4gICAgdGhpcy5vcHRpb25zLmF1ZGlvQ2FwdHVyZURlZmF1bHRzID0ge1xuICAgICAgLi4uYXVkaW9EZWZhdWx0cyxcbiAgICAgIC4uLm9wdGlvbnM/LmF1ZGlvQ2FwdHVyZURlZmF1bHRzLFxuICAgIH07XG4gICAgdGhpcy5vcHRpb25zLnZpZGVvQ2FwdHVyZURlZmF1bHRzID0ge1xuICAgICAgLi4udmlkZW9EZWZhdWx0cyxcbiAgICAgIC4uLm9wdGlvbnM/LnZpZGVvQ2FwdHVyZURlZmF1bHRzLFxuICAgIH07XG4gICAgdGhpcy5vcHRpb25zLnB1Ymxpc2hEZWZhdWx0cyA9IHtcbiAgICAgIC4uLnB1Ymxpc2hEZWZhdWx0cyxcbiAgICAgIC4uLm9wdGlvbnM/LnB1Ymxpc2hEZWZhdWx0cyxcbiAgICB9O1xuXG4gICAgdGhpcy5tYXliZUNyZWF0ZUVuZ2luZSgpO1xuXG4gICAgdGhpcy5kaXNjb25uZWN0TG9jayA9IG5ldyBNdXRleCgpO1xuXG4gICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50ID0gbmV3IExvY2FsUGFydGljaXBhbnQoJycsICcnLCB0aGlzLmVuZ2luZSwgdGhpcy5vcHRpb25zKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMudmlkZW9DYXB0dXJlRGVmYXVsdHMuZGV2aWNlSWQpIHtcbiAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5hY3RpdmVEZXZpY2VNYXAuc2V0KFxuICAgICAgICAndmlkZW9pbnB1dCcsXG4gICAgICAgIHVud3JhcENvbnN0cmFpbnQodGhpcy5vcHRpb25zLnZpZGVvQ2FwdHVyZURlZmF1bHRzLmRldmljZUlkKSxcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuYXVkaW9DYXB0dXJlRGVmYXVsdHMuZGV2aWNlSWQpIHtcbiAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5hY3RpdmVEZXZpY2VNYXAuc2V0KFxuICAgICAgICAnYXVkaW9pbnB1dCcsXG4gICAgICAgIHVud3JhcENvbnN0cmFpbnQodGhpcy5vcHRpb25zLmF1ZGlvQ2FwdHVyZURlZmF1bHRzLmRldmljZUlkKSxcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuYXVkaW9PdXRwdXQ/LmRldmljZUlkKSB7XG4gICAgICB0aGlzLnN3aXRjaEFjdGl2ZURldmljZShcbiAgICAgICAgJ2F1ZGlvb3V0cHV0JyxcbiAgICAgICAgdW53cmFwQ29uc3RyYWludCh0aGlzLm9wdGlvbnMuYXVkaW9PdXRwdXQuZGV2aWNlSWQpLFxuICAgICAgKS5jYXRjaCgoZSkgPT4gdGhpcy5sb2cud2FybihgQ291bGQgbm90IHNldCBhdWRpbyBvdXRwdXQ6ICR7ZS5tZXNzYWdlfWAsIHRoaXMubG9nQ29udGV4dCkpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuZTJlZSkge1xuICAgICAgdGhpcy5zZXR1cEUyRUUoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGV4cGVyaW1lbnRhbFxuICAgKi9cbiAgYXN5bmMgc2V0RTJFRUVuYWJsZWQoZW5hYmxlZDogYm9vbGVhbikge1xuICAgIGlmICh0aGlzLmUyZWVNYW5hZ2VyKSB7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChbdGhpcy5sb2NhbFBhcnRpY2lwYW50LnNldEUyRUVFbmFibGVkKGVuYWJsZWQpXSk7XG4gICAgICBpZiAodGhpcy5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5ICE9PSAnJykge1xuICAgICAgICB0aGlzLmUyZWVNYW5hZ2VyLnNldFBhcnRpY2lwYW50Q3J5cHRvckVuYWJsZWQoZW5hYmxlZCwgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoJ2UyZWUgbm90IGNvbmZpZ3VyZWQsIHBsZWFzZSBzZXQgZTJlZSBzZXR0aW5ncyB3aXRoaW4gdGhlIHJvb20gb3B0aW9ucycpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc2V0dXBFMkVFKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZTJlZSkge1xuICAgICAgdGhpcy5lMmVlTWFuYWdlciA9IG5ldyBFMkVFTWFuYWdlcih0aGlzLm9wdGlvbnMuZTJlZSk7XG4gICAgICB0aGlzLmUyZWVNYW5hZ2VyLm9uKFxuICAgICAgICBFbmNyeXB0aW9uRXZlbnQuUGFydGljaXBhbnRFbmNyeXB0aW9uU3RhdHVzQ2hhbmdlZCxcbiAgICAgICAgKGVuYWJsZWQsIHBhcnRpY2lwYW50KSA9PiB7XG4gICAgICAgICAgaWYgKHBhcnRpY2lwYW50IGluc3RhbmNlb2YgTG9jYWxQYXJ0aWNpcGFudCkge1xuICAgICAgICAgICAgdGhpcy5pc0UyRUVFbmFibGVkID0gZW5hYmxlZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5QYXJ0aWNpcGFudEVuY3J5cHRpb25TdGF0dXNDaGFuZ2VkLCBlbmFibGVkLCBwYXJ0aWNpcGFudCk7XG4gICAgICAgIH0sXG4gICAgICApO1xuICAgICAgdGhpcy5lMmVlTWFuYWdlci5vbihFbmNyeXB0aW9uRXZlbnQuRW5jcnlwdGlvbkVycm9yLCAoZXJyb3IpID0+XG4gICAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuRW5jcnlwdGlvbkVycm9yLCBlcnJvciksXG4gICAgICApO1xuICAgICAgdGhpcy5lMmVlTWFuYWdlcj8uc2V0dXAodGhpcyk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZXQgbG9nQ29udGV4dCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcm9vbTogdGhpcy5uYW1lLFxuICAgICAgcm9vbVNpZDogdGhpcy5zaWQsXG4gICAgICBpZGVudGl0eTogdGhpcy5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5LFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogaWYgdGhlIGN1cnJlbnQgcm9vbSBoYXMgYSBwYXJ0aWNpcGFudCB3aXRoIGByZWNvcmRlcjogdHJ1ZWAgaW4gaXRzIEpXVCBncmFudFxuICAgKiovXG4gIGdldCBpc1JlY29yZGluZygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5yb29tSW5mbz8uYWN0aXZlUmVjb3JkaW5nID8/IGZhbHNlO1xuICB9XG5cbiAgLyoqIHNlcnZlciBhc3NpZ25lZCB1bmlxdWUgcm9vbSBpZCAqL1xuICBnZXQgc2lkKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMucm9vbUluZm8/LnNpZCA/PyAnJztcbiAgfVxuXG4gIC8qKiB1c2VyIGFzc2lnbmVkIG5hbWUsIGRlcml2ZWQgZnJvbSBKV1QgdG9rZW4gKi9cbiAgZ2V0IG5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5yb29tSW5mbz8ubmFtZSA/PyAnJztcbiAgfVxuXG4gIC8qKiByb29tIG1ldGFkYXRhICovXG4gIGdldCBtZXRhZGF0YSgpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLnJvb21JbmZvPy5tZXRhZGF0YTtcbiAgfVxuXG4gIGdldCBudW1QYXJ0aWNpcGFudHMoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5yb29tSW5mbz8ubnVtUGFydGljaXBhbnRzID8/IDA7XG4gIH1cblxuICBnZXQgbnVtUHVibGlzaGVycygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnJvb21JbmZvPy5udW1QdWJsaXNoZXJzID8/IDA7XG4gIH1cblxuICBwcml2YXRlIG1heWJlQ3JlYXRlRW5naW5lKCkge1xuICAgIGlmICh0aGlzLmVuZ2luZSAmJiAhdGhpcy5lbmdpbmUuaXNDbG9zZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmVuZ2luZSA9IG5ldyBSVENFbmdpbmUodGhpcy5vcHRpb25zKTtcblxuICAgIHRoaXMuZW5naW5lXG4gICAgICAub24oRW5naW5lRXZlbnQuUGFydGljaXBhbnRVcGRhdGUsIHRoaXMuaGFuZGxlUGFydGljaXBhbnRVcGRhdGVzKVxuICAgICAgLm9uKEVuZ2luZUV2ZW50LlJvb21VcGRhdGUsIHRoaXMuaGFuZGxlUm9vbVVwZGF0ZSlcbiAgICAgIC5vbihFbmdpbmVFdmVudC5TcGVha2Vyc0NoYW5nZWQsIHRoaXMuaGFuZGxlU3BlYWtlcnNDaGFuZ2VkKVxuICAgICAgLm9uKEVuZ2luZUV2ZW50LlN0cmVhbVN0YXRlQ2hhbmdlZCwgdGhpcy5oYW5kbGVTdHJlYW1TdGF0ZVVwZGF0ZSlcbiAgICAgIC5vbihFbmdpbmVFdmVudC5Db25uZWN0aW9uUXVhbGl0eVVwZGF0ZSwgdGhpcy5oYW5kbGVDb25uZWN0aW9uUXVhbGl0eVVwZGF0ZSlcbiAgICAgIC5vbihFbmdpbmVFdmVudC5TdWJzY3JpcHRpb25FcnJvciwgdGhpcy5oYW5kbGVTdWJzY3JpcHRpb25FcnJvcilcbiAgICAgIC5vbihFbmdpbmVFdmVudC5TdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlLCB0aGlzLmhhbmRsZVN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUpXG4gICAgICAub24oXG4gICAgICAgIEVuZ2luZUV2ZW50Lk1lZGlhVHJhY2tBZGRlZCxcbiAgICAgICAgKG1lZGlhVHJhY2s6IE1lZGlhU3RyZWFtVHJhY2ssIHN0cmVhbTogTWVkaWFTdHJlYW0sIHJlY2VpdmVyPzogUlRDUnRwUmVjZWl2ZXIpID0+IHtcbiAgICAgICAgICB0aGlzLm9uVHJhY2tBZGRlZChtZWRpYVRyYWNrLCBzdHJlYW0sIHJlY2VpdmVyKTtcbiAgICAgICAgfSxcbiAgICAgIClcbiAgICAgIC5vbihFbmdpbmVFdmVudC5EaXNjb25uZWN0ZWQsIChyZWFzb24/OiBEaXNjb25uZWN0UmVhc29uKSA9PiB7XG4gICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCh0aGlzLm9wdGlvbnMuc3RvcExvY2FsVHJhY2tPblVucHVibGlzaCwgcmVhc29uKTtcbiAgICAgIH0pXG4gICAgICAub24oRW5naW5lRXZlbnQuQWN0aXZlU3BlYWtlcnNVcGRhdGUsIHRoaXMuaGFuZGxlQWN0aXZlU3BlYWtlcnNVcGRhdGUpXG4gICAgICAub24oRW5naW5lRXZlbnQuRGF0YVBhY2tldFJlY2VpdmVkLCB0aGlzLmhhbmRsZURhdGFQYWNrZXQpXG4gICAgICAub24oRW5naW5lRXZlbnQuUmVzdW1pbmcsICgpID0+IHtcbiAgICAgICAgdGhpcy5jbGVhckNvbm5lY3Rpb25SZWNvbmNpbGUoKTtcbiAgICAgICAgaWYgKHRoaXMuc2V0QW5kRW1pdENvbm5lY3Rpb25TdGF0ZShDb25uZWN0aW9uU3RhdGUuUmVjb25uZWN0aW5nKSkge1xuICAgICAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuUmVjb25uZWN0aW5nKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5vbihFbmdpbmVFdmVudC5SZXN1bWVkLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuc2V0QW5kRW1pdENvbm5lY3Rpb25TdGF0ZShDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGVkKTtcbiAgICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5SZWNvbm5lY3RlZCk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJDb25uZWN0aW9uUmVjb25jaWxlKCk7XG4gICAgICAgIHRoaXMudXBkYXRlU3Vic2NyaXB0aW9ucygpO1xuICAgICAgICB0aGlzLmVtaXRCdWZmZXJlZEV2ZW50cygpO1xuICAgICAgfSlcbiAgICAgIC5vbihFbmdpbmVFdmVudC5TaWduYWxSZXN1bWVkLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuYnVmZmVyZWRFdmVudHMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5SZWNvbm5lY3RpbmcpIHtcbiAgICAgICAgICB0aGlzLnNlbmRTeW5jU3RhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5vbihFbmdpbmVFdmVudC5SZXN0YXJ0aW5nLCB0aGlzLmhhbmRsZVJlc3RhcnRpbmcpXG4gICAgICAub24oRW5naW5lRXZlbnQuU2lnbmFsUmVzdGFydGVkLCB0aGlzLmhhbmRsZVNpZ25hbFJlc3RhcnRlZClcbiAgICAgIC5vbihFbmdpbmVFdmVudC5EQ0J1ZmZlclN0YXR1c0NoYW5nZWQsIChzdGF0dXMsIGtpbmQpID0+IHtcbiAgICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5EQ0J1ZmZlclN0YXR1c0NoYW5nZWQsIHN0YXR1cywga2luZCk7XG4gICAgICB9KTtcblxuICAgIGlmICh0aGlzLmxvY2FsUGFydGljaXBhbnQpIHtcbiAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zZXR1cEVuZ2luZSh0aGlzLmVuZ2luZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmUyZWVNYW5hZ2VyKSB7XG4gICAgICB0aGlzLmUyZWVNYW5hZ2VyLnNldHVwRW5naW5lKHRoaXMuZW5naW5lKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogZ2V0TG9jYWxEZXZpY2VzIGFic3RyYWN0cyBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMuXG4gICAqIEluIHBhcnRpY3VsYXIsIGl0IGhhbmRsZXMgQ2hyb21lJ3MgdW5pcXVlIGJlaGF2aW9yIG9mIGNyZWF0aW5nIGBkZWZhdWx0YFxuICAgKiBkZXZpY2VzLiBXaGVuIGVuY291bnRlcmVkLCBpdCdsbCBiZSByZW1vdmVkIGZyb20gdGhlIGxpc3Qgb2YgZGV2aWNlcy5cbiAgICogVGhlIGFjdHVhbCBkZWZhdWx0IGRldmljZSB3aWxsIGJlIHBsYWNlZCBhdCB0b3AuXG4gICAqIEBwYXJhbSBraW5kXG4gICAqIEByZXR1cm5zIGEgbGlzdCBvZiBhdmFpbGFibGUgbG9jYWwgZGV2aWNlc1xuICAgKi9cbiAgc3RhdGljIGdldExvY2FsRGV2aWNlcyhcbiAgICBraW5kPzogTWVkaWFEZXZpY2VLaW5kLFxuICAgIHJlcXVlc3RQZXJtaXNzaW9uczogYm9vbGVhbiA9IHRydWUsXG4gICk6IFByb21pc2U8TWVkaWFEZXZpY2VJbmZvW10+IHtcbiAgICByZXR1cm4gRGV2aWNlTWFuYWdlci5nZXRJbnN0YW5jZSgpLmdldERldmljZXMoa2luZCwgcmVxdWVzdFBlcm1pc3Npb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBwcmVwYXJlQ29ubmVjdGlvbiBzaG91bGQgYmUgY2FsbGVkIGFzIHNvb24gYXMgdGhlIHBhZ2UgaXMgbG9hZGVkLCBpbiBvcmRlclxuICAgKiB0byBzcGVlZCB1cCB0aGUgY29ubmVjdGlvbiBhdHRlbXB0LiBUaGlzIGZ1bmN0aW9uIHdpbGxcbiAgICogLSBwZXJmb3JtIEROUyByZXNvbHV0aW9uIGFuZCBwcmUtd2FybSB0aGUgRE5TIGNhY2hlXG4gICAqIC0gZXN0YWJsaXNoIFRMUyBjb25uZWN0aW9uIGFuZCBjYWNoZSBUTFMga2V5c1xuICAgKlxuICAgKiBXaXRoIExpdmVLaXQgQ2xvdWQsIGl0IHdpbGwgYWxzbyBkZXRlcm1pbmUgdGhlIGJlc3QgZWRnZSBkYXRhIGNlbnRlciBmb3JcbiAgICogdGhlIGN1cnJlbnQgY2xpZW50IHRvIGNvbm5lY3QgdG8gaWYgYSB0b2tlbiBpcyBwcm92aWRlZC5cbiAgICovXG4gIGFzeW5jIHByZXBhcmVDb25uZWN0aW9uKHVybDogc3RyaW5nLCB0b2tlbj86IHN0cmluZykge1xuICAgIGlmICh0aGlzLnN0YXRlICE9PSBDb25uZWN0aW9uU3RhdGUuRGlzY29ubmVjdGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubG9nLmRlYnVnKGBwcmVwYXJlQ29ubmVjdGlvbiB0byAke3VybH1gLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgIHRyeSB7XG4gICAgICBpZiAoaXNDbG91ZChuZXcgVVJMKHVybCkpICYmIHRva2VuKSB7XG4gICAgICAgIHRoaXMucmVnaW9uVXJsUHJvdmlkZXIgPSBuZXcgUmVnaW9uVXJsUHJvdmlkZXIodXJsLCB0b2tlbik7XG4gICAgICAgIGNvbnN0IHJlZ2lvblVybCA9IGF3YWl0IHRoaXMucmVnaW9uVXJsUHJvdmlkZXIuZ2V0TmV4dEJlc3RSZWdpb25VcmwoKTtcbiAgICAgICAgLy8gd2Ugd2lsbCBub3QgcmVwbGFjZSB0aGUgcmVnaW9uVXJsIGlmIGFuIGF0dGVtcHQgaGFkIGFscmVhZHkgc3RhcnRlZFxuICAgICAgICAvLyB0byBhdm9pZCBvdmVycmlkaW5nIHJlZ2lvblVybCBhZnRlciBhIG5ldyBjb25uZWN0aW9uIGF0dGVtcHQgaGFkIHN0YXJ0ZWRcbiAgICAgICAgaWYgKHJlZ2lvblVybCAmJiB0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuRGlzY29ubmVjdGVkKSB7XG4gICAgICAgICAgdGhpcy5yZWdpb25VcmwgPSByZWdpb25Vcmw7XG4gICAgICAgICAgYXdhaXQgZmV0Y2godG9IdHRwVXJsKHJlZ2lvblVybCksIHsgbWV0aG9kOiAnSEVBRCcgfSk7XG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoYHByZXBhcmVkIGNvbm5lY3Rpb24gdG8gJHtyZWdpb25Vcmx9YCwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXdhaXQgZmV0Y2godG9IdHRwVXJsKHVybCksIHsgbWV0aG9kOiAnSEVBRCcgfSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5sb2cud2FybignY291bGQgbm90IHByZXBhcmUgY29ubmVjdGlvbicsIHsgLi4udGhpcy5sb2dDb250ZXh0LCBlcnJvcjogZSB9KTtcbiAgICB9XG4gIH1cblxuICBjb25uZWN0ID0gYXN5bmMgKHVybDogc3RyaW5nLCB0b2tlbjogc3RyaW5nLCBvcHRzPzogUm9vbUNvbm5lY3RPcHRpb25zKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgLy8gSW4gY2FzZSBhIGRpc2Nvbm5lY3QgY2FsbGVkIGhhcHBlbmVkIHJpZ2h0IGJlZm9yZSB0aGUgY29ubmVjdCBjYWxsLCBtYWtlIHN1cmUgdGhlIGRpc2Nvbm5lY3QgaXMgY29tcGxldGVkIGZpcnN0IGJ5IGF3YWl0aW5nIGl0cyBsb2NrXG4gICAgY29uc3QgdW5sb2NrRGlzY29ubmVjdCA9IGF3YWl0IHRoaXMuZGlzY29ubmVjdExvY2subG9jaygpO1xuXG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0ZWQpIHtcbiAgICAgIC8vIHdoZW4gdGhlIHN0YXRlIGlzIHJlY29ubmVjdGluZyBvciBjb25uZWN0ZWQsIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBpbW1lZGlhdGVseVxuICAgICAgdGhpcy5sb2cuaW5mbyhgYWxyZWFkeSBjb25uZWN0ZWQgdG8gcm9vbSAke3RoaXMubmFtZX1gLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgdW5sb2NrRGlzY29ubmVjdCgpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmNvbm5lY3RGdXR1cmUpIHtcbiAgICAgIHVubG9ja0Rpc2Nvbm5lY3QoKTtcbiAgICAgIHJldHVybiB0aGlzLmNvbm5lY3RGdXR1cmUucHJvbWlzZTtcbiAgICB9XG5cbiAgICB0aGlzLnNldEFuZEVtaXRDb25uZWN0aW9uU3RhdGUoQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RpbmcpO1xuICAgIGlmICh0aGlzLnJlZ2lvblVybFByb3ZpZGVyPy5nZXRTZXJ2ZXJVcmwoKS50b1N0cmluZygpICE9PSB1cmwpIHtcbiAgICAgIHRoaXMucmVnaW9uVXJsID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5yZWdpb25VcmxQcm92aWRlciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKGlzQ2xvdWQobmV3IFVSTCh1cmwpKSkge1xuICAgICAgaWYgKHRoaXMucmVnaW9uVXJsUHJvdmlkZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnJlZ2lvblVybFByb3ZpZGVyID0gbmV3IFJlZ2lvblVybFByb3ZpZGVyKHVybCwgdG9rZW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZWdpb25VcmxQcm92aWRlci51cGRhdGVUb2tlbih0b2tlbik7XG4gICAgICB9XG4gICAgICAvLyB0cmlnZ2VyIHRoZSBmaXJzdCBmZXRjaCB3aXRob3V0IHdhaXRpbmcgZm9yIGEgcmVzcG9uc2VcbiAgICAgIC8vIGlmIGluaXRpYWwgY29ubmVjdGlvbiBmYWlscywgdGhpcyB3aWxsIHNwZWVkIHVwIHBpY2tpbmcgcmVnaW9uYWwgdXJsXG4gICAgICAvLyBvbiBzdWJzZXF1ZW50IHJ1bnNcbiAgICAgIHRoaXMucmVnaW9uVXJsUHJvdmlkZXIuZmV0Y2hSZWdpb25TZXR0aW5ncygpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgIHRoaXMubG9nLndhcm4oJ2NvdWxkIG5vdCBmZXRjaCByZWdpb24gc2V0dGluZ3MnLCB7IC4uLnRoaXMubG9nQ29udGV4dCwgZXJyb3I6IGUgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBjb25uZWN0Rm4gPSBhc3luYyAoXG4gICAgICByZXNvbHZlOiAoKSA9PiB2b2lkLFxuICAgICAgcmVqZWN0OiAocmVhc29uOiBhbnkpID0+IHZvaWQsXG4gICAgICByZWdpb25Vcmw/OiBzdHJpbmcsXG4gICAgKSA9PiB7XG4gICAgICBpZiAodGhpcy5hYm9ydENvbnRyb2xsZXIpIHtcbiAgICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgIH1cblxuICAgICAgLy8gZXhwbGljaXQgY3JlYXRpb24gYXMgbG9jYWwgdmFyIG5lZWRlZCB0byBzYXRpc2Z5IFRTIGNvbXBpbGVyIHdoZW4gcGFzc2luZyBpdCB0byBgYXR0ZW1wdENvbm5lY3Rpb25gIGZ1cnRoZXIgZG93blxuICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXIgPSBhYm9ydENvbnRyb2xsZXI7XG5cbiAgICAgIC8vIGF0IHRoaXMgcG9pbnQgdGhlIGludGVudGlvbiB0byBjb25uZWN0IGhhcyBiZWVuIHNpZ25hbGxlZCBzbyB3ZSBjYW4gYWxsb3cgY2FuY2VsbGluZyBvZiB0aGUgY29ubmVjdGlvbiB2aWEgZGlzY29ubmVjdCgpIGFnYWluXG4gICAgICB1bmxvY2tEaXNjb25uZWN0Py4oKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5hdHRlbXB0Q29ubmVjdGlvbihyZWdpb25VcmwgPz8gdXJsLCB0b2tlbiwgb3B0cywgYWJvcnRDb250cm9sbGVyKTtcbiAgICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHRoaXMucmVnaW9uVXJsUHJvdmlkZXIgJiZcbiAgICAgICAgICBlIGluc3RhbmNlb2YgQ29ubmVjdGlvbkVycm9yICYmXG4gICAgICAgICAgZS5yZWFzb24gIT09IENvbm5lY3Rpb25FcnJvclJlYXNvbi5DYW5jZWxsZWQgJiZcbiAgICAgICAgICBlLnJlYXNvbiAhPT0gQ29ubmVjdGlvbkVycm9yUmVhc29uLk5vdEFsbG93ZWRcbiAgICAgICAgKSB7XG4gICAgICAgICAgbGV0IG5leHRVcmw6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBuZXh0VXJsID0gYXdhaXQgdGhpcy5yZWdpb25VcmxQcm92aWRlci5nZXROZXh0QmVzdFJlZ2lvblVybChcbiAgICAgICAgICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXI/LnNpZ25hbCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgZXJyb3IgaW5zdGFuY2VvZiBDb25uZWN0aW9uRXJyb3IgJiZcbiAgICAgICAgICAgICAgKGVycm9yLnN0YXR1cyA9PT0gNDAxIHx8IGVycm9yLnJlYXNvbiA9PT0gQ29ubmVjdGlvbkVycm9yUmVhc29uLkNhbmNlbGxlZClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QodGhpcy5vcHRpb25zLnN0b3BMb2NhbFRyYWNrT25VbnB1Ymxpc2gpO1xuICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChuZXh0VXJsKSB7XG4gICAgICAgICAgICB0aGlzLmxvZy5pbmZvKFxuICAgICAgICAgICAgICBgSW5pdGlhbCBjb25uZWN0aW9uIGZhaWxlZCB3aXRoIENvbm5lY3Rpb25FcnJvcjogJHtlLm1lc3NhZ2V9LiBSZXRyeWluZyB3aXRoIGFub3RoZXIgcmVnaW9uOiAke25leHRVcmx9YCxcbiAgICAgICAgICAgICAgdGhpcy5sb2dDb250ZXh0LFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGF3YWl0IGNvbm5lY3RGbihyZXNvbHZlLCByZWplY3QsIG5leHRVcmwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QodGhpcy5vcHRpb25zLnN0b3BMb2NhbFRyYWNrT25VbnB1Ymxpc2gpO1xuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QodGhpcy5vcHRpb25zLnN0b3BMb2NhbFRyYWNrT25VbnB1Ymxpc2gpO1xuICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCByZWdpb25VcmwgPSB0aGlzLnJlZ2lvblVybDtcbiAgICB0aGlzLnJlZ2lvblVybCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNvbm5lY3RGdXR1cmUgPSBuZXcgRnV0dXJlKFxuICAgICAgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25uZWN0Rm4ocmVzb2x2ZSwgcmVqZWN0LCByZWdpb25VcmwpO1xuICAgICAgfSxcbiAgICAgICgpID0+IHtcbiAgICAgICAgdGhpcy5jbGVhckNvbm5lY3Rpb25GdXR1cmVzKCk7XG4gICAgICB9LFxuICAgICk7XG5cbiAgICByZXR1cm4gdGhpcy5jb25uZWN0RnV0dXJlLnByb21pc2U7XG4gIH07XG5cbiAgcHJpdmF0ZSBjb25uZWN0U2lnbmFsID0gYXN5bmMgKFxuICAgIHVybDogc3RyaW5nLFxuICAgIHRva2VuOiBzdHJpbmcsXG4gICAgZW5naW5lOiBSVENFbmdpbmUsXG4gICAgY29ubmVjdE9wdGlvbnM6IEludGVybmFsUm9vbUNvbm5lY3RPcHRpb25zLFxuICAgIHJvb21PcHRpb25zOiBJbnRlcm5hbFJvb21PcHRpb25zLFxuICAgIGFib3J0Q29udHJvbGxlcjogQWJvcnRDb250cm9sbGVyLFxuICApOiBQcm9taXNlPEpvaW5SZXNwb25zZT4gPT4ge1xuICAgIGNvbnN0IGpvaW5SZXNwb25zZSA9IGF3YWl0IGVuZ2luZS5qb2luKFxuICAgICAgdXJsLFxuICAgICAgdG9rZW4sXG4gICAgICB7XG4gICAgICAgIGF1dG9TdWJzY3JpYmU6IGNvbm5lY3RPcHRpb25zLmF1dG9TdWJzY3JpYmUsXG4gICAgICAgIHB1Ymxpc2hPbmx5OiBjb25uZWN0T3B0aW9ucy5wdWJsaXNoT25seSxcbiAgICAgICAgYWRhcHRpdmVTdHJlYW06XG4gICAgICAgICAgdHlwZW9mIHJvb21PcHRpb25zLmFkYXB0aXZlU3RyZWFtID09PSAnb2JqZWN0JyA/IHRydWUgOiByb29tT3B0aW9ucy5hZGFwdGl2ZVN0cmVhbSxcbiAgICAgICAgbWF4UmV0cmllczogY29ubmVjdE9wdGlvbnMubWF4UmV0cmllcyxcbiAgICAgICAgZTJlZUVuYWJsZWQ6ICEhdGhpcy5lMmVlTWFuYWdlcixcbiAgICAgICAgd2Vic29ja2V0VGltZW91dDogY29ubmVjdE9wdGlvbnMud2Vic29ja2V0VGltZW91dCxcbiAgICAgIH0sXG4gICAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgICk7XG5cbiAgICBsZXQgc2VydmVySW5mbzogUGFydGlhbDxTZXJ2ZXJJbmZvPiB8IHVuZGVmaW5lZCA9IGpvaW5SZXNwb25zZS5zZXJ2ZXJJbmZvO1xuICAgIGlmICghc2VydmVySW5mbykge1xuICAgICAgc2VydmVySW5mbyA9IHsgdmVyc2lvbjogam9pblJlc3BvbnNlLnNlcnZlclZlcnNpb24sIHJlZ2lvbjogam9pblJlc3BvbnNlLnNlcnZlclJlZ2lvbiB9O1xuICAgIH1cblxuICAgIHRoaXMubG9nLmRlYnVnKFxuICAgICAgYGNvbm5lY3RlZCB0byBMaXZla2l0IFNlcnZlciAke09iamVjdC5lbnRyaWVzKHNlcnZlckluZm8pXG4gICAgICAgIC5tYXAoKFtrZXksIHZhbHVlXSkgPT4gYCR7a2V5fTogJHt2YWx1ZX1gKVxuICAgICAgICAuam9pbignLCAnKX1gLFxuICAgICAge1xuICAgICAgICByb29tOiBqb2luUmVzcG9uc2Uucm9vbT8ubmFtZSxcbiAgICAgICAgcm9vbVNpZDogam9pblJlc3BvbnNlLnJvb20/LnNpZCxcbiAgICAgICAgaWRlbnRpdHk6IGpvaW5SZXNwb25zZS5wYXJ0aWNpcGFudD8uaWRlbnRpdHksXG4gICAgICB9LFxuICAgICk7XG5cbiAgICBpZiAoIWpvaW5SZXNwb25zZS5zZXJ2ZXJWZXJzaW9uKSB7XG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRTZXJ2ZXIoJ3Vua25vd24gc2VydmVyIHZlcnNpb24nKTtcbiAgICB9XG5cbiAgICBpZiAoam9pblJlc3BvbnNlLnNlcnZlclZlcnNpb24gPT09ICcwLjE1LjEnICYmIHRoaXMub3B0aW9ucy5keW5hY2FzdCkge1xuICAgICAgdGhpcy5sb2cuZGVidWcoJ2Rpc2FibGluZyBkeW5hY2FzdCBkdWUgdG8gc2VydmVyIHZlcnNpb24nLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgLy8gZHluYWNhc3QgaGFzIGEgYnVnIGluIDAuMTUuMSwgc28gd2UgY2Fubm90IHVzZSBpdCB0aGVuXG4gICAgICByb29tT3B0aW9ucy5keW5hY2FzdCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBqb2luUmVzcG9uc2U7XG4gIH07XG5cbiAgcHJpdmF0ZSBhcHBseUpvaW5SZXNwb25zZSA9IChqb2luUmVzcG9uc2U6IEpvaW5SZXNwb25zZSkgPT4ge1xuICAgIGNvbnN0IHBpID0gam9pblJlc3BvbnNlLnBhcnRpY2lwYW50ITtcblxuICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zaWQgPSBwaS5zaWQ7XG4gICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5ID0gcGkuaWRlbnRpdHk7XG5cbiAgICAvLyBwb3B1bGF0ZSByZW1vdGUgcGFydGljaXBhbnRzLCB0aGVzZSBzaG91bGQgbm90IHRyaWdnZXIgbmV3IGV2ZW50c1xuICAgIHRoaXMuaGFuZGxlUGFydGljaXBhbnRVcGRhdGVzKFtwaSwgLi4uam9pblJlc3BvbnNlLm90aGVyUGFydGljaXBhbnRzXSk7XG5cbiAgICBpZiAoam9pblJlc3BvbnNlLnJvb20pIHtcbiAgICAgIHRoaXMuaGFuZGxlUm9vbVVwZGF0ZShqb2luUmVzcG9uc2Uucm9vbSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5lMmVlICYmIHRoaXMuZTJlZU1hbmFnZXIpIHtcbiAgICAgIHRoaXMuZTJlZU1hbmFnZXIuc2V0U2lmVHJhaWxlcihqb2luUmVzcG9uc2Uuc2lmVHJhaWxlcik7XG4gICAgfVxuICB9O1xuXG4gIHByaXZhdGUgYXR0ZW1wdENvbm5lY3Rpb24gPSBhc3luYyAoXG4gICAgdXJsOiBzdHJpbmcsXG4gICAgdG9rZW46IHN0cmluZyxcbiAgICBvcHRzOiBSb29tQ29ubmVjdE9wdGlvbnMgfCB1bmRlZmluZWQsXG4gICAgYWJvcnRDb250cm9sbGVyOiBBYm9ydENvbnRyb2xsZXIsXG4gICkgPT4ge1xuICAgIGlmICh0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuUmVjb25uZWN0aW5nKSB7XG4gICAgICB0aGlzLmxvZy5pbmZvKCdSZWNvbm5lY3Rpb24gYXR0ZW1wdCByZXBsYWNlZCBieSBuZXcgY29ubmVjdGlvbiBhdHRlbXB0JywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBjbG9zZSBhbmQgcmVjcmVhdGUgdGhlIGV4aXN0aW5nIGVuZ2luZSBpbiBvcmRlciB0byBnZXQgcmlkIG9mIGFueSBwb3RlbnRpYWxseSBvbmdvaW5nIHJlY29ubmVjdGlvbiBhdHRlbXB0c1xuICAgICAgdGhpcy5yZWNyZWF0ZUVuZ2luZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjcmVhdGUgZW5naW5lIGlmIHByZXZpb3VzbHkgZGlzY29ubmVjdGVkXG4gICAgICB0aGlzLm1heWJlQ3JlYXRlRW5naW5lKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnJlZ2lvblVybFByb3ZpZGVyPy5pc0Nsb3VkKCkpIHtcbiAgICAgIHRoaXMuZW5naW5lLnNldFJlZ2lvblVybFByb3ZpZGVyKHRoaXMucmVnaW9uVXJsUHJvdmlkZXIpO1xuICAgIH1cblxuICAgIHRoaXMuYWNxdWlyZUF1ZGlvQ29udGV4dCgpO1xuXG4gICAgdGhpcy5jb25uT3B0aW9ucyA9IHsgLi4ucm9vbUNvbm5lY3RPcHRpb25EZWZhdWx0cywgLi4ub3B0cyB9IGFzIEludGVybmFsUm9vbUNvbm5lY3RPcHRpb25zO1xuXG4gICAgaWYgKHRoaXMuY29ubk9wdGlvbnMucnRjQ29uZmlnKSB7XG4gICAgICB0aGlzLmVuZ2luZS5ydGNDb25maWcgPSB0aGlzLmNvbm5PcHRpb25zLnJ0Y0NvbmZpZztcbiAgICB9XG4gICAgaWYgKHRoaXMuY29ubk9wdGlvbnMucGVlckNvbm5lY3Rpb25UaW1lb3V0KSB7XG4gICAgICB0aGlzLmVuZ2luZS5wZWVyQ29ubmVjdGlvblRpbWVvdXQgPSB0aGlzLmNvbm5PcHRpb25zLnBlZXJDb25uZWN0aW9uVGltZW91dDtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3Qgam9pblJlc3BvbnNlID0gYXdhaXQgdGhpcy5jb25uZWN0U2lnbmFsKFxuICAgICAgICB1cmwsXG4gICAgICAgIHRva2VuLFxuICAgICAgICB0aGlzLmVuZ2luZSxcbiAgICAgICAgdGhpcy5jb25uT3B0aW9ucyxcbiAgICAgICAgdGhpcy5vcHRpb25zLFxuICAgICAgICBhYm9ydENvbnRyb2xsZXIsXG4gICAgICApO1xuXG4gICAgICB0aGlzLmFwcGx5Sm9pblJlc3BvbnNlKGpvaW5SZXNwb25zZSk7XG4gICAgICAvLyBmb3J3YXJkIG1ldGFkYXRhIGNoYW5nZWQgZm9yIHRoZSBsb2NhbCBwYXJ0aWNpcGFudFxuICAgICAgdGhpcy5zZXR1cExvY2FsUGFydGljaXBhbnRFdmVudHMoKTtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuU2lnbmFsQ29ubmVjdGVkKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGF3YWl0IHRoaXMuZW5naW5lLmNsb3NlKCk7XG4gICAgICB0aGlzLnJlY3JlYXRlRW5naW5lKCk7XG4gICAgICBjb25zdCByZXN1bHRpbmdFcnJvciA9IG5ldyBDb25uZWN0aW9uRXJyb3IoYGNvdWxkIG5vdCBlc3RhYmxpc2ggc2lnbmFsIGNvbm5lY3Rpb25gKTtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICByZXN1bHRpbmdFcnJvci5tZXNzYWdlID0gYCR7cmVzdWx0aW5nRXJyb3IubWVzc2FnZX06ICR7ZXJyLm1lc3NhZ2V9YDtcbiAgICAgIH1cbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBDb25uZWN0aW9uRXJyb3IpIHtcbiAgICAgICAgcmVzdWx0aW5nRXJyb3IucmVhc29uID0gZXJyLnJlYXNvbjtcbiAgICAgICAgcmVzdWx0aW5nRXJyb3Iuc3RhdHVzID0gZXJyLnN0YXR1cztcbiAgICAgIH1cbiAgICAgIHRoaXMubG9nLmRlYnVnKGBlcnJvciB0cnlpbmcgdG8gZXN0YWJsaXNoIHNpZ25hbCBjb25uZWN0aW9uYCwge1xuICAgICAgICAuLi50aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgIGVycm9yOiBlcnIsXG4gICAgICB9KTtcbiAgICAgIHRocm93IHJlc3VsdGluZ0Vycm9yO1xuICAgIH1cblxuICAgIGlmIChhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIGF3YWl0IHRoaXMuZW5naW5lLmNsb3NlKCk7XG4gICAgICB0aGlzLnJlY3JlYXRlRW5naW5lKCk7XG4gICAgICB0aHJvdyBuZXcgQ29ubmVjdGlvbkVycm9yKGBDb25uZWN0aW9uIGF0dGVtcHQgYWJvcnRlZGApO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmVuZ2luZS53YWl0Rm9yUENJbml0aWFsQ29ubmVjdGlvbihcbiAgICAgICAgdGhpcy5jb25uT3B0aW9ucy5wZWVyQ29ubmVjdGlvblRpbWVvdXQsXG4gICAgICAgIGFib3J0Q29udHJvbGxlcixcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgYXdhaXQgdGhpcy5lbmdpbmUuY2xvc2UoKTtcbiAgICAgIHRoaXMucmVjcmVhdGVFbmdpbmUoKTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuXG4gICAgLy8gYWxzbyBob29rIHVubG9hZCBldmVudFxuICAgIGlmIChpc1dlYigpICYmIHRoaXMub3B0aW9ucy5kaXNjb25uZWN0T25QYWdlTGVhdmUpIHtcbiAgICAgIC8vIGNhcHR1cmluZyBib3RoICdwYWdlaGlkZScgYW5kICdiZWZvcmV1bmxvYWQnIHRvIGNhcHR1cmUgYnJvYWRlc3Qgc2V0IG9mIGJyb3dzZXIgYmVoYXZpb3JzXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncGFnZWhpZGUnLCB0aGlzLm9uUGFnZUxlYXZlKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCB0aGlzLm9uUGFnZUxlYXZlKTtcbiAgICB9XG4gICAgaWYgKGlzV2ViKCkpIHtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZyZWV6ZScsIHRoaXMub25QYWdlTGVhdmUpO1xuICAgICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcz8uYWRkRXZlbnRMaXN0ZW5lcignZGV2aWNlY2hhbmdlJywgdGhpcy5oYW5kbGVEZXZpY2VDaGFuZ2UpO1xuICAgIH1cbiAgICB0aGlzLnNldEFuZEVtaXRDb25uZWN0aW9uU3RhdGUoQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RlZCk7XG4gICAgdGhpcy5lbWl0KFJvb21FdmVudC5Db25uZWN0ZWQpO1xuICAgIHRoaXMucmVnaXN0ZXJDb25uZWN0aW9uUmVjb25jaWxlKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIGRpc2Nvbm5lY3RzIHRoZSByb29tLCBlbWl0cyBbW1Jvb21FdmVudC5EaXNjb25uZWN0ZWRdXVxuICAgKi9cbiAgZGlzY29ubmVjdCA9IGFzeW5jIChzdG9wVHJhY2tzID0gdHJ1ZSkgPT4ge1xuICAgIGNvbnN0IHVubG9jayA9IGF3YWl0IHRoaXMuZGlzY29ubmVjdExvY2subG9jaygpO1xuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkRpc2Nvbm5lY3RlZCkge1xuICAgICAgICB0aGlzLmxvZy5kZWJ1ZygnYWxyZWFkeSBkaXNjb25uZWN0ZWQnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmxvZy5pbmZvKCdkaXNjb25uZWN0IGZyb20gcm9vbScsIHtcbiAgICAgICAgLi4udGhpcy5sb2dDb250ZXh0LFxuICAgICAgfSk7XG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0aW5nIHx8XG4gICAgICAgIHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5SZWNvbm5lY3RpbmdcbiAgICAgICkge1xuICAgICAgICAvLyB0cnkgYWJvcnRpbmcgcGVuZGluZyBjb25uZWN0aW9uIGF0dGVtcHRcbiAgICAgICAgdGhpcy5sb2cud2FybignYWJvcnQgY29ubmVjdGlvbiBhdHRlbXB0JywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXI/LmFib3J0KCk7XG4gICAgICAgIC8vIGluIGNhc2UgdGhlIGFib3J0IGNvbnRyb2xsZXIgZGlkbid0IG1hbmFnZSB0byBjYW5jZWwgdGhlIGNvbm5lY3Rpb24gYXR0ZW1wdCwgcmVqZWN0IHRoZSBjb25uZWN0IHByb21pc2UgZXhwbGljaXRseVxuICAgICAgICB0aGlzLmNvbm5lY3RGdXR1cmU/LnJlamVjdD8uKG5ldyBDb25uZWN0aW9uRXJyb3IoJ0NsaWVudCBpbml0aWF0ZWQgZGlzY29ubmVjdCcpKTtcbiAgICAgICAgdGhpcy5jb25uZWN0RnV0dXJlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgLy8gc2VuZCBsZWF2ZVxuICAgICAgaWYgKCF0aGlzLmVuZ2luZT8uY2xpZW50LmlzRGlzY29ubmVjdGVkKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZW5naW5lLmNsaWVudC5zZW5kTGVhdmUoKTtcbiAgICAgIH1cbiAgICAgIC8vIGNsb3NlIGVuZ2luZSAoYWxzbyBjbG9zZXMgY2xpZW50KVxuICAgICAgaWYgKHRoaXMuZW5naW5lKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZW5naW5lLmNsb3NlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3Qoc3RvcFRyYWNrcywgRGlzY29ubmVjdFJlYXNvbi5DTElFTlRfSU5JVElBVEVEKTtcbiAgICAgIC8qIEB0cy1pZ25vcmUgKi9cbiAgICAgIHRoaXMuZW5naW5lID0gdW5kZWZpbmVkO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB1bmxvY2soKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIHJldHJpZXZlcyBhIHBhcnRpY2lwYW50IGJ5IGlkZW50aXR5XG4gICAqIEBwYXJhbSBpZGVudGl0eVxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgZ2V0UGFydGljaXBhbnRCeUlkZW50aXR5KGlkZW50aXR5OiBzdHJpbmcpOiBQYXJ0aWNpcGFudCB8IHVuZGVmaW5lZCB7XG4gICAgaWYgKHRoaXMubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eSA9PT0gaWRlbnRpdHkpIHtcbiAgICAgIHJldHVybiB0aGlzLmxvY2FsUGFydGljaXBhbnQ7XG4gICAgfVxuICAgIGNvbnN0IHNpZCA9IHRoaXMuaWRlbnRpdHlUb1NpZC5nZXQoaWRlbnRpdHkpO1xuICAgIGlmIChzaWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnRpY2lwYW50cy5nZXQoc2lkKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNsZWFyQ29ubmVjdGlvbkZ1dHVyZXMoKSB7XG4gICAgdGhpcy5jb25uZWN0RnV0dXJlID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbCBmb3IgdGVzdGluZ1xuICAgKi9cbiAgYXN5bmMgc2ltdWxhdGVTY2VuYXJpbyhzY2VuYXJpbzogU2ltdWxhdGlvblNjZW5hcmlvLCBhcmc/OiBhbnkpIHtcbiAgICBsZXQgcG9zdEFjdGlvbiA9ICgpID0+IHt9O1xuICAgIGxldCByZXE6IFNpbXVsYXRlU2NlbmFyaW8gfCB1bmRlZmluZWQ7XG4gICAgc3dpdGNoIChzY2VuYXJpbykge1xuICAgICAgY2FzZSAnc2lnbmFsLXJlY29ubmVjdCc6XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgZnVuY3Rpb24gaXMgcHJpdmF0ZVxuICAgICAgICBhd2FpdCB0aGlzLmVuZ2luZS5jbGllbnQuaGFuZGxlT25DbG9zZSgnc2ltdWxhdGUgZGlzY29ubmVjdCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NwZWFrZXInOlxuICAgICAgICByZXEgPSBuZXcgU2ltdWxhdGVTY2VuYXJpbyh7XG4gICAgICAgICAgc2NlbmFyaW86IHtcbiAgICAgICAgICAgIGNhc2U6ICdzcGVha2VyVXBkYXRlJyxcbiAgICAgICAgICAgIHZhbHVlOiAzLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ25vZGUtZmFpbHVyZSc6XG4gICAgICAgIHJlcSA9IG5ldyBTaW11bGF0ZVNjZW5hcmlvKHtcbiAgICAgICAgICBzY2VuYXJpbzoge1xuICAgICAgICAgICAgY2FzZTogJ25vZGVGYWlsdXJlJyxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NlcnZlci1sZWF2ZSc6XG4gICAgICAgIHJlcSA9IG5ldyBTaW11bGF0ZVNjZW5hcmlvKHtcbiAgICAgICAgICBzY2VuYXJpbzoge1xuICAgICAgICAgICAgY2FzZTogJ3NlcnZlckxlYXZlJyxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21pZ3JhdGlvbic6XG4gICAgICAgIHJlcSA9IG5ldyBTaW11bGF0ZVNjZW5hcmlvKHtcbiAgICAgICAgICBzY2VuYXJpbzoge1xuICAgICAgICAgICAgY2FzZTogJ21pZ3JhdGlvbicsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyZXN1bWUtcmVjb25uZWN0JzpcbiAgICAgICAgdGhpcy5lbmdpbmUuZmFpbE5leHQoKTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBmdW5jdGlvbiBpcyBwcml2YXRlXG4gICAgICAgIGF3YWl0IHRoaXMuZW5naW5lLmNsaWVudC5oYW5kbGVPbkNsb3NlKCdzaW11bGF0ZSByZXN1bWUtZGlzY29ubmVjdCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2Rpc2Nvbm5lY3Qtc2lnbmFsLW9uLXJlc3VtZSc6XG4gICAgICAgIHBvc3RBY3Rpb24gPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBmdW5jdGlvbiBpcyBwcml2YXRlXG4gICAgICAgICAgYXdhaXQgdGhpcy5lbmdpbmUuY2xpZW50LmhhbmRsZU9uQ2xvc2UoJ3NpbXVsYXRlIHJlc3VtZS1kaXNjb25uZWN0Jyk7XG4gICAgICAgIH07XG4gICAgICAgIHJlcSA9IG5ldyBTaW11bGF0ZVNjZW5hcmlvKHtcbiAgICAgICAgICBzY2VuYXJpbzoge1xuICAgICAgICAgICAgY2FzZTogJ2Rpc2Nvbm5lY3RTaWduYWxPblJlc3VtZScsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdkaXNjb25uZWN0LXNpZ25hbC1vbi1yZXN1bWUtbm8tbWVzc2FnZXMnOlxuICAgICAgICBwb3N0QWN0aW9uID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgZnVuY3Rpb24gaXMgcHJpdmF0ZVxuICAgICAgICAgIGF3YWl0IHRoaXMuZW5naW5lLmNsaWVudC5oYW5kbGVPbkNsb3NlKCdzaW11bGF0ZSByZXN1bWUtZGlzY29ubmVjdCcpO1xuICAgICAgICB9O1xuICAgICAgICByZXEgPSBuZXcgU2ltdWxhdGVTY2VuYXJpbyh7XG4gICAgICAgICAgc2NlbmFyaW86IHtcbiAgICAgICAgICAgIGNhc2U6ICdkaXNjb25uZWN0U2lnbmFsT25SZXN1bWVOb01lc3NhZ2VzJyxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2Z1bGwtcmVjb25uZWN0JzpcbiAgICAgICAgdGhpcy5lbmdpbmUuZnVsbFJlY29ubmVjdE9uTmV4dCA9IHRydWU7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgZnVuY3Rpb24gaXMgcHJpdmF0ZVxuICAgICAgICBhd2FpdCB0aGlzLmVuZ2luZS5jbGllbnQuaGFuZGxlT25DbG9zZSgnc2ltdWxhdGUgZnVsbC1yZWNvbm5lY3QnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdmb3JjZS10Y3AnOlxuICAgICAgY2FzZSAnZm9yY2UtdGxzJzpcbiAgICAgICAgcmVxID0gbmV3IFNpbXVsYXRlU2NlbmFyaW8oe1xuICAgICAgICAgIHNjZW5hcmlvOiB7XG4gICAgICAgICAgICBjYXNlOiAnc3dpdGNoQ2FuZGlkYXRlUHJvdG9jb2wnLFxuICAgICAgICAgICAgdmFsdWU6IHNjZW5hcmlvID09PSAnZm9yY2UtdGxzJyA/IDIgOiAxLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBwb3N0QWN0aW9uID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IG9uTGVhdmUgPSB0aGlzLmVuZ2luZS5jbGllbnQub25MZWF2ZTtcbiAgICAgICAgICBpZiAob25MZWF2ZSkge1xuICAgICAgICAgICAgb25MZWF2ZShcbiAgICAgICAgICAgICAgbmV3IExlYXZlUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcmVhc29uOiBEaXNjb25uZWN0UmVhc29uLkNMSUVOVF9JTklUSUFURUQsXG4gICAgICAgICAgICAgICAgY2FuUmVjb25uZWN0OiB0cnVlLFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3N1YnNjcmliZXItYmFuZHdpZHRoJzpcbiAgICAgICAgaWYgKGFyZyA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBhcmcgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdWJzY3JpYmVyLWJhbmR3aWR0aCByZXF1aXJlcyBhIG51bWJlciBhcyBhcmd1bWVudCcpO1xuICAgICAgICB9XG4gICAgICAgIHJlcSA9IG5ldyBTaW11bGF0ZVNjZW5hcmlvKHtcbiAgICAgICAgICBzY2VuYXJpbzoge1xuICAgICAgICAgICAgY2FzZTogJ3N1YnNjcmliZXJCYW5kd2lkdGgnLFxuICAgICAgICAgICAgdmFsdWU6IEJpZ0ludChhcmcpLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICB9XG4gICAgaWYgKHJlcSkge1xuICAgICAgYXdhaXQgdGhpcy5lbmdpbmUuY2xpZW50LnNlbmRTaW11bGF0ZVNjZW5hcmlvKHJlcSk7XG4gICAgICBhd2FpdCBwb3N0QWN0aW9uKCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBvblBhZ2VMZWF2ZSA9IGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgfTtcblxuICAvKipcbiAgICogQnJvd3NlcnMgaGF2ZSBkaWZmZXJlbnQgcG9saWNpZXMgcmVnYXJkaW5nIGF1ZGlvIHBsYXliYWNrLiBNb3N0IHJlcXVpcmluZ1xuICAgKiBzb21lIGZvcm0gb2YgdXNlciBpbnRlcmFjdGlvbiAoY2xpY2svdGFwL2V0YykuXG4gICAqIEluIHRob3NlIGNhc2VzLCBhdWRpbyB3aWxsIGJlIHNpbGVudCB1bnRpbCBhIGNsaWNrL3RhcCB0cmlnZ2VyaW5nIG9uZSBvZiB0aGUgZm9sbG93aW5nXG4gICAqIC0gYHN0YXJ0QXVkaW9gXG4gICAqIC0gYGdldFVzZXJNZWRpYWBcbiAgICovXG4gIHN0YXJ0QXVkaW8gPSBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgZWxlbWVudHM6IEFycmF5PEhUTUxNZWRpYUVsZW1lbnQ+ID0gW107XG4gICAgY29uc3QgYnJvd3NlciA9IGdldEJyb3dzZXIoKTtcbiAgICBpZiAoYnJvd3NlciAmJiBicm93c2VyLm9zID09PSAnaU9TJykge1xuICAgICAgLyoqXG4gICAgICAgKiBpT1MgYmxvY2tzIGF1ZGlvIGVsZW1lbnQgcGxheWJhY2sgaWZcbiAgICAgICAqIC0gdXNlciBpcyBub3QgcHVibGlzaGluZyBhdWRpbyB0aGVtc2VsdmVzIGFuZFxuICAgICAgICogLSBubyBvdGhlciBhdWRpbyBzb3VyY2UgaXMgcGxheWluZ1xuICAgICAgICpcbiAgICAgICAqIGFzIGEgd29ya2Fyb3VuZCwgd2UgY3JlYXRlIGFuIGF1ZGlvIGVsZW1lbnQgd2l0aCBhbiBlbXB0eSB0cmFjaywgc28gdGhhdFxuICAgICAgICogc2lsZW50IGF1ZGlvIGlzIGFsd2F5cyBwbGF5aW5nXG4gICAgICAgKi9cbiAgICAgIGNvbnN0IGF1ZGlvSWQgPSAnbGl2ZWtpdC1kdW1teS1hdWRpby1lbCc7XG4gICAgICBsZXQgZHVtbXlBdWRpb0VsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYXVkaW9JZCkgYXMgSFRNTEF1ZGlvRWxlbWVudCB8IG51bGw7XG4gICAgICBpZiAoIWR1bW15QXVkaW9FbCkge1xuICAgICAgICBkdW1teUF1ZGlvRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhdWRpbycpO1xuICAgICAgICBkdW1teUF1ZGlvRWwuaWQgPSBhdWRpb0lkO1xuICAgICAgICBkdW1teUF1ZGlvRWwuYXV0b3BsYXkgPSB0cnVlO1xuICAgICAgICBkdW1teUF1ZGlvRWwuaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgdHJhY2sgPSBnZXRFbXB0eUF1ZGlvU3RyZWFtVHJhY2soKTtcbiAgICAgICAgdHJhY2suZW5hYmxlZCA9IHRydWU7XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IG5ldyBNZWRpYVN0cmVhbShbdHJhY2tdKTtcbiAgICAgICAgZHVtbXlBdWRpb0VsLnNyY09iamVjdCA9IHN0cmVhbTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsICgpID0+IHtcbiAgICAgICAgICBpZiAoIWR1bW15QXVkaW9FbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBzZXQgdGhlIHNyY09iamVjdCB0byBudWxsIG9uIHBhZ2UgaGlkZSBpbiBvcmRlciB0byBwcmV2ZW50IGxvY2sgc2NyZWVuIGNvbnRyb2xzIHRvIHNob3cgdXAgZm9yIGl0XG4gICAgICAgICAgZHVtbXlBdWRpb0VsLnNyY09iamVjdCA9IGRvY3VtZW50LmhpZGRlbiA/IG51bGwgOiBzdHJlYW07XG4gICAgICAgICAgaWYgKCFkb2N1bWVudC5oaWRkZW4pIHtcbiAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKFxuICAgICAgICAgICAgICAncGFnZSB2aXNpYmxlIGFnYWluLCB0cmlnZ2VyaW5nIHN0YXJ0QXVkaW8gdG8gcmVzdW1lIHBsYXliYWNrIGFuZCB1cGRhdGUgcGxheWJhY2sgc3RhdHVzJyxcbiAgICAgICAgICAgICAgdGhpcy5sb2dDb250ZXh0LFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRBdWRpbygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kKGR1bW15QXVkaW9FbCk7XG4gICAgICAgIHRoaXMub25jZShSb29tRXZlbnQuRGlzY29ubmVjdGVkLCAoKSA9PiB7XG4gICAgICAgICAgZHVtbXlBdWRpb0VsPy5yZW1vdmUoKTtcbiAgICAgICAgICBkdW1teUF1ZGlvRWwgPSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGVsZW1lbnRzLnB1c2goZHVtbXlBdWRpb0VsKTtcbiAgICB9XG5cbiAgICB0aGlzLnBhcnRpY2lwYW50cy5mb3JFYWNoKChwKSA9PiB7XG4gICAgICBwLmF1ZGlvVHJhY2tzLmZvckVhY2goKHQpID0+IHtcbiAgICAgICAgaWYgKHQudHJhY2spIHtcbiAgICAgICAgICB0LnRyYWNrLmF0dGFjaGVkRWxlbWVudHMuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgICAgICAgZWxlbWVudHMucHVzaChlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0cnkge1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICB0aGlzLmFjcXVpcmVBdWRpb0NvbnRleHQoKSxcbiAgICAgICAgLi4uZWxlbWVudHMubWFwKChlKSA9PiB7XG4gICAgICAgICAgZS5tdXRlZCA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBlLnBsYXkoKTtcbiAgICAgICAgfSksXG4gICAgICBdKTtcbiAgICAgIHRoaXMuaGFuZGxlQXVkaW9QbGF5YmFja1N0YXJ0ZWQoKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMuaGFuZGxlQXVkaW9QbGF5YmFja0ZhaWxlZChlcnIpO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfTtcblxuICBzdGFydFZpZGVvID0gYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IGVsZW1lbnRzOiBIVE1MTWVkaWFFbGVtZW50W10gPSBbXTtcbiAgICBmb3IgKGNvbnN0IHAgb2YgdGhpcy5wYXJ0aWNpcGFudHMudmFsdWVzKCkpIHtcbiAgICAgIHAudmlkZW9UcmFja3MuZm9yRWFjaCgodHIpID0+IHtcbiAgICAgICAgdHIudHJhY2s/LmF0dGFjaGVkRWxlbWVudHMuZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgICAgICBpZiAoIWVsZW1lbnRzLmluY2x1ZGVzKGVsKSkge1xuICAgICAgICAgICAgZWxlbWVudHMucHVzaChlbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBhd2FpdCBQcm9taXNlLmFsbChlbGVtZW50cy5tYXAoKGVsKSA9PiBlbC5wbGF5KCkpKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLmhhbmRsZVZpZGVvUGxheWJhY2tTdGFydGVkKCk7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgIGlmIChlLm5hbWUgPT09ICdOb3RBbGxvd2VkRXJyb3InKSB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVWaWRlb1BsYXliYWNrRmFpbGVkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5sb2cud2FybihcbiAgICAgICAgICAgICdSZXN1bWluZyB2aWRlbyBwbGF5YmFjayBmYWlsZWQsIG1ha2Ugc3VyZSB5b3UgY2FsbCBgc3RhcnRWaWRlb2AgZGlyZWN0bHkgaW4gYSB1c2VyIGdlc3R1cmUgaGFuZGxlcicsXG4gICAgICAgICAgICB0aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBhdWRpbyBwbGF5YmFjayBpcyBlbmFibGVkXG4gICAqL1xuICBnZXQgY2FuUGxheWJhY2tBdWRpbygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5hdWRpb0VuYWJsZWQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHZpZGVvIHBsYXliYWNrIGlzIGVuYWJsZWRcbiAgICovXG4gIGdldCBjYW5QbGF5YmFja1ZpZGVvKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhdGhpcy5pc1ZpZGVvUGxheWJhY2tCbG9ja2VkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFjdGl2ZSBhdWRpbyBvdXRwdXQgZGV2aWNlIHVzZWQgaW4gdGhpcyByb29tLlxuICAgKiBAcmV0dXJuIHRoZSBwcmV2aW91c2x5IHN1Y2Nlc3NmdWxseSBzZXQgYXVkaW8gb3V0cHV0IGRldmljZSBJRCBvciBhbiBlbXB0eSBzdHJpbmcgaWYgdGhlIGRlZmF1bHQgZGV2aWNlIGlzIHVzZWQuXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgZ2V0QWN0aXZlRGV2aWNlKCdhdWRpb291dHB1dCcpYCBpbnN0ZWFkXG4gICAqL1xuICBnZXRBY3RpdmVBdWRpb091dHB1dERldmljZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuYXVkaW9PdXRwdXQ/LmRldmljZUlkID8/ICcnO1xuICB9XG5cbiAgZ2V0QWN0aXZlRGV2aWNlKGtpbmQ6IE1lZGlhRGV2aWNlS2luZCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5hY3RpdmVEZXZpY2VNYXAuZ2V0KGtpbmQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN3aXRjaGVzIGFsbCBhY3RpdmUgZGV2aWNlcyB1c2VkIGluIHRoaXMgcm9vbSB0byB0aGUgZ2l2ZW4gZGV2aWNlLlxuICAgKlxuICAgKiBOb3RlOiBzZXR0aW5nIEF1ZGlvT3V0cHV0IGlzIG5vdCBzdXBwb3J0ZWQgb24gc29tZSBicm93c2Vycy4gU2VlIFtzZXRTaW5rSWRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IVE1MTWVkaWFFbGVtZW50L3NldFNpbmtJZCNicm93c2VyX2NvbXBhdGliaWxpdHkpXG4gICAqXG4gICAqIEBwYXJhbSBraW5kIHVzZSBgdmlkZW9pbnB1dGAgZm9yIGNhbWVyYSB0cmFjayxcbiAgICogIGBhdWRpb2lucHV0YCBmb3IgbWljcm9waG9uZSB0cmFjayxcbiAgICogIGBhdWRpb291dHB1dGAgdG8gc2V0IHNwZWFrZXIgZm9yIGFsbCBpbmNvbWluZyBhdWRpbyB0cmFja3NcbiAgICogQHBhcmFtIGRldmljZUlkXG4gICAqL1xuICBhc3luYyBzd2l0Y2hBY3RpdmVEZXZpY2Uoa2luZDogTWVkaWFEZXZpY2VLaW5kLCBkZXZpY2VJZDogc3RyaW5nLCBleGFjdDogYm9vbGVhbiA9IGZhbHNlKSB7XG4gICAgbGV0IGRldmljZUhhc0NoYW5nZWQgPSBmYWxzZTtcbiAgICBsZXQgc3VjY2VzcyA9IHRydWU7XG4gICAgY29uc3QgZGV2aWNlQ29uc3RyYWludCA9IGV4YWN0ID8geyBleGFjdDogZGV2aWNlSWQgfSA6IGRldmljZUlkO1xuICAgIGlmIChraW5kID09PSAnYXVkaW9pbnB1dCcpIHtcbiAgICAgIGNvbnN0IHByZXZEZXZpY2VJZCA9IHRoaXMub3B0aW9ucy5hdWRpb0NhcHR1cmVEZWZhdWx0cyEuZGV2aWNlSWQ7XG4gICAgICB0aGlzLm9wdGlvbnMuYXVkaW9DYXB0dXJlRGVmYXVsdHMhLmRldmljZUlkID0gZGV2aWNlQ29uc3RyYWludDtcbiAgICAgIGRldmljZUhhc0NoYW5nZWQgPSBwcmV2RGV2aWNlSWQgIT09IGRldmljZUNvbnN0cmFpbnQ7XG4gICAgICBjb25zdCB0cmFja3MgPSBBcnJheS5mcm9tKHRoaXMubG9jYWxQYXJ0aWNpcGFudC5hdWRpb1RyYWNrcy52YWx1ZXMoKSkuZmlsdGVyKFxuICAgICAgICAodHJhY2spID0+IHRyYWNrLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLk1pY3JvcGhvbmUsXG4gICAgICApO1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3VjY2VzcyA9IChcbiAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0cmFja3MubWFwKCh0KSA9PiB0LmF1ZGlvVHJhY2s/LnNldERldmljZUlkKGRldmljZUNvbnN0cmFpbnQpKSlcbiAgICAgICAgKS5ldmVyeSgodmFsKSA9PiB2YWwgPT09IHRydWUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMuYXVkaW9DYXB0dXJlRGVmYXVsdHMhLmRldmljZUlkID0gcHJldkRldmljZUlkO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoa2luZCA9PT0gJ3ZpZGVvaW5wdXQnKSB7XG4gICAgICBjb25zdCBwcmV2RGV2aWNlSWQgPSB0aGlzLm9wdGlvbnMudmlkZW9DYXB0dXJlRGVmYXVsdHMhLmRldmljZUlkO1xuICAgICAgdGhpcy5vcHRpb25zLnZpZGVvQ2FwdHVyZURlZmF1bHRzIS5kZXZpY2VJZCA9IGRldmljZUNvbnN0cmFpbnQ7XG4gICAgICBkZXZpY2VIYXNDaGFuZ2VkID0gcHJldkRldmljZUlkICE9PSBkZXZpY2VDb25zdHJhaW50O1xuICAgICAgY29uc3QgdHJhY2tzID0gQXJyYXkuZnJvbSh0aGlzLmxvY2FsUGFydGljaXBhbnQudmlkZW9UcmFja3MudmFsdWVzKCkpLmZpbHRlcihcbiAgICAgICAgKHRyYWNrKSA9PiB0cmFjay5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5DYW1lcmEsXG4gICAgICApO1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3VjY2VzcyA9IChcbiAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0cmFja3MubWFwKCh0KSA9PiB0LnZpZGVvVHJhY2s/LnNldERldmljZUlkKGRldmljZUNvbnN0cmFpbnQpKSlcbiAgICAgICAgKS5ldmVyeSgodmFsKSA9PiB2YWwgPT09IHRydWUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMudmlkZW9DYXB0dXJlRGVmYXVsdHMhLmRldmljZUlkID0gcHJldkRldmljZUlkO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoa2luZCA9PT0gJ2F1ZGlvb3V0cHV0Jykge1xuICAgICAgaWYgKFxuICAgICAgICAoIXN1cHBvcnRzU2V0U2lua0lkKCkgJiYgIXRoaXMub3B0aW9ucy5leHBXZWJBdWRpb01peCkgfHxcbiAgICAgICAgKHRoaXMub3B0aW9ucy5leHBXZWJBdWRpb01peCAmJiB0aGlzLmF1ZGlvQ29udGV4dCAmJiAhKCdzZXRTaW5rSWQnIGluIHRoaXMuYXVkaW9Db250ZXh0KSlcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBzd2l0Y2ggYXVkaW8gb3V0cHV0LCBzZXRTaW5rSWQgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgfVxuICAgICAgdGhpcy5vcHRpb25zLmF1ZGlvT3V0cHV0ID8/PSB7fTtcbiAgICAgIGNvbnN0IHByZXZEZXZpY2VJZCA9IHRoaXMub3B0aW9ucy5hdWRpb091dHB1dC5kZXZpY2VJZDtcbiAgICAgIHRoaXMub3B0aW9ucy5hdWRpb091dHB1dC5kZXZpY2VJZCA9IGRldmljZUlkO1xuICAgICAgZGV2aWNlSGFzQ2hhbmdlZCA9IHByZXZEZXZpY2VJZCAhPT0gZGV2aWNlQ29uc3RyYWludDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5leHBXZWJBdWRpb01peCkge1xuICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3Igc2V0U2lua0lkIGlzIG5vdCB5ZXQgaW4gdGhlIHR5cGVzY3JpcHQgdHlwZSBvZiBBdWRpb0NvbnRleHRcbiAgICAgICAgICB0aGlzLmF1ZGlvQ29udGV4dD8uc2V0U2lua0lkKGRldmljZUlkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICAgIEFycmF5LmZyb20odGhpcy5wYXJ0aWNpcGFudHMudmFsdWVzKCkpLm1hcCgocCkgPT4gcC5zZXRBdWRpb091dHB1dCh7IGRldmljZUlkIH0pKSxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5hdWRpb091dHB1dC5kZXZpY2VJZCA9IHByZXZEZXZpY2VJZDtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRldmljZUhhc0NoYW5nZWQgJiYgc3VjY2Vzcykge1xuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmFjdGl2ZURldmljZU1hcC5zZXQoa2luZCwgZGV2aWNlSWQpO1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5BY3RpdmVEZXZpY2VDaGFuZ2VkLCBraW5kLCBkZXZpY2VJZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1Y2Nlc3M7XG4gIH1cblxuICBwcml2YXRlIHNldHVwTG9jYWxQYXJ0aWNpcGFudEV2ZW50cygpIHtcbiAgICB0aGlzLmxvY2FsUGFydGljaXBhbnRcbiAgICAgIC5vbihQYXJ0aWNpcGFudEV2ZW50LlBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkLCB0aGlzLm9uTG9jYWxQYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZClcbiAgICAgIC5vbihQYXJ0aWNpcGFudEV2ZW50LlBhcnRpY2lwYW50TmFtZUNoYW5nZWQsIHRoaXMub25Mb2NhbFBhcnRpY2lwYW50TmFtZUNoYW5nZWQpXG4gICAgICAub24oUGFydGljaXBhbnRFdmVudC5UcmFja011dGVkLCB0aGlzLm9uTG9jYWxUcmFja011dGVkKVxuICAgICAgLm9uKFBhcnRpY2lwYW50RXZlbnQuVHJhY2tVbm11dGVkLCB0aGlzLm9uTG9jYWxUcmFja1VubXV0ZWQpXG4gICAgICAub24oUGFydGljaXBhbnRFdmVudC5Mb2NhbFRyYWNrUHVibGlzaGVkLCB0aGlzLm9uTG9jYWxUcmFja1B1Ymxpc2hlZClcbiAgICAgIC5vbihQYXJ0aWNpcGFudEV2ZW50LkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCwgdGhpcy5vbkxvY2FsVHJhY2tVbnB1Ymxpc2hlZClcbiAgICAgIC5vbihQYXJ0aWNpcGFudEV2ZW50LkNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCwgdGhpcy5vbkxvY2FsQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkKVxuICAgICAgLm9uKFBhcnRpY2lwYW50RXZlbnQuTWVkaWFEZXZpY2VzRXJyb3IsIHRoaXMub25NZWRpYURldmljZXNFcnJvcilcbiAgICAgIC5vbihQYXJ0aWNpcGFudEV2ZW50LkF1ZGlvU3RyZWFtQWNxdWlyZWQsIHRoaXMuc3RhcnRBdWRpbylcbiAgICAgIC5vbihcbiAgICAgICAgUGFydGljaXBhbnRFdmVudC5QYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZCxcbiAgICAgICAgdGhpcy5vbkxvY2FsUGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWQsXG4gICAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSByZWNyZWF0ZUVuZ2luZSgpIHtcbiAgICB0aGlzLmVuZ2luZT8uY2xvc2UoKTtcbiAgICAvKiBAdHMtaWdub3JlICovXG4gICAgdGhpcy5lbmdpbmUgPSB1bmRlZmluZWQ7XG5cbiAgICAvLyBjbGVhciBvdXQgZXhpc3RpbmcgcmVtb3RlIHBhcnRpY2lwYW50cywgc2luY2UgdGhleSBtYXkgaGF2ZSBhdHRhY2hlZFxuICAgIC8vIHRoZSBvbGQgZW5naW5lXG4gICAgdGhpcy5wYXJ0aWNpcGFudHMuY2xlYXIoKTtcbiAgICB0aGlzLmJ1ZmZlcmVkRXZlbnRzID0gW107XG4gICAgdGhpcy5tYXliZUNyZWF0ZUVuZ2luZSgpO1xuICB9XG5cbiAgcHJpdmF0ZSBvblRyYWNrQWRkZWQoXG4gICAgbWVkaWFUcmFjazogTWVkaWFTdHJlYW1UcmFjayxcbiAgICBzdHJlYW06IE1lZGlhU3RyZWFtLFxuICAgIHJlY2VpdmVyPzogUlRDUnRwUmVjZWl2ZXIsXG4gICkge1xuICAgIC8vIGRvbid0IGZpcmUgb25TdWJzY3JpYmVkIHdoZW4gY29ubmVjdGluZ1xuICAgIC8vIFdlYlJUQyBmaXJlcyBvblRyYWNrIGFzIHNvb24gYXMgc2V0UmVtb3RlRGVzY3JpcHRpb24gaXMgY2FsbGVkIG9uIHRoZSBvZmZlclxuICAgIC8vIGF0IHRoYXQgdGltZSwgSUNFIGNvbm5lY3Rpdml0eSBoYXMgbm90IGJlZW4gZXN0YWJsaXNoZWQgc28gdGhlIHRyYWNrIGlzIG5vdFxuICAgIC8vIHRlY2huaWNhbGx5IHN1YnNjcmliZWQuXG4gICAgLy8gV2UnbGwgZGVmZXIgdGhlc2UgZXZlbnRzIHVudGlsIHdoZW4gdGhlIHJvb20gaXMgY29ubmVjdGVkIG9yIGV2ZW50dWFsbHkgZGlzY29ubmVjdGVkLlxuICAgIGlmICh0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGluZyB8fCB0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuUmVjb25uZWN0aW5nKSB7XG4gICAgICBjb25zdCByZWNvbm5lY3RlZEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMub25UcmFja0FkZGVkKG1lZGlhVHJhY2ssIHN0cmVhbSwgcmVjZWl2ZXIpO1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICB9O1xuICAgICAgY29uc3QgY2xlYW51cCA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5vZmYoUm9vbUV2ZW50LlJlY29ubmVjdGVkLCByZWNvbm5lY3RlZEhhbmRsZXIpO1xuICAgICAgICB0aGlzLm9mZihSb29tRXZlbnQuQ29ubmVjdGVkLCByZWNvbm5lY3RlZEhhbmRsZXIpO1xuICAgICAgICB0aGlzLm9mZihSb29tRXZlbnQuRGlzY29ubmVjdGVkLCBjbGVhbnVwKTtcbiAgICAgIH07XG4gICAgICB0aGlzLm9uY2UoUm9vbUV2ZW50LlJlY29ubmVjdGVkLCByZWNvbm5lY3RlZEhhbmRsZXIpO1xuICAgICAgdGhpcy5vbmNlKFJvb21FdmVudC5Db25uZWN0ZWQsIHJlY29ubmVjdGVkSGFuZGxlcik7XG4gICAgICB0aGlzLm9uY2UoUm9vbUV2ZW50LkRpc2Nvbm5lY3RlZCwgY2xlYW51cCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuRGlzY29ubmVjdGVkKSB7XG4gICAgICB0aGlzLmxvZy53YXJuKCdza2lwcGluZyBpbmNvbWluZyB0cmFjayBhZnRlciBSb29tIGRpc2Nvbm5lY3RlZCcsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBhcnRzID0gdW5wYWNrU3RyZWFtSWQoc3RyZWFtLmlkKTtcbiAgICBjb25zdCBwYXJ0aWNpcGFudElkID0gcGFydHNbMF07XG4gICAgbGV0IHN0cmVhbUlkID0gcGFydHNbMV07XG4gICAgbGV0IHRyYWNrSWQgPSBtZWRpYVRyYWNrLmlkO1xuICAgIC8vIGZpcmVmb3ggd2lsbCBnZXQgc3RyZWFtSWQgKHBJRHx0cmFja0lkKSBpbnN0ZWFkIG9mIChwSUR8c3RyZWFtSWQpIGFzIGl0IGRvZXNuJ3Qgc3VwcG9ydCBzeW5jIHRyYWNrcyBieSBzdHJlYW1cbiAgICAvLyBhbmQgZ2VuZXJhdGVzIGl0cyBvd24gdHJhY2sgaWQgaW5zdGVhZCBvZiBpbmZlciBmcm9tIHNkcCB0cmFjayBpZC5cbiAgICBpZiAoc3RyZWFtSWQgJiYgc3RyZWFtSWQuc3RhcnRzV2l0aCgnVFInKSkgdHJhY2tJZCA9IHN0cmVhbUlkO1xuXG4gICAgaWYgKHBhcnRpY2lwYW50SWQgPT09IHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zaWQpIHtcbiAgICAgIHRoaXMubG9nLndhcm4oJ3RyaWVkIHRvIGNyZWF0ZSBSZW1vdGVQYXJ0aWNpcGFudCBmb3IgbG9jYWwgcGFydGljaXBhbnQnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHBhcnRpY2lwYW50ID0gdGhpcy5wYXJ0aWNpcGFudHMuZ2V0KHBhcnRpY2lwYW50SWQpIGFzIFJlbW90ZVBhcnRpY2lwYW50IHwgdW5kZWZpbmVkO1xuXG4gICAgaWYgKCFwYXJ0aWNpcGFudCkge1xuICAgICAgdGhpcy5sb2cuZXJyb3IoXG4gICAgICAgIGBUcmllZCB0byBhZGQgYSB0cmFjayBmb3IgYSBwYXJ0aWNpcGFudCwgdGhhdCdzIG5vdCBwcmVzZW50LiBTaWQ6ICR7cGFydGljaXBhbnRJZH1gLFxuICAgICAgICB0aGlzLmxvZ0NvbnRleHQsXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBhZGFwdGl2ZVN0cmVhbVNldHRpbmdzOiBBZGFwdGl2ZVN0cmVhbVNldHRpbmdzIHwgdW5kZWZpbmVkO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYWRhcHRpdmVTdHJlYW0pIHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmFkYXB0aXZlU3RyZWFtID09PSAnb2JqZWN0Jykge1xuICAgICAgICBhZGFwdGl2ZVN0cmVhbVNldHRpbmdzID0gdGhpcy5vcHRpb25zLmFkYXB0aXZlU3RyZWFtO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWRhcHRpdmVTdHJlYW1TZXR0aW5ncyA9IHt9O1xuICAgICAgfVxuICAgIH1cbiAgICBwYXJ0aWNpcGFudC5hZGRTdWJzY3JpYmVkTWVkaWFUcmFjayhcbiAgICAgIG1lZGlhVHJhY2ssXG4gICAgICB0cmFja0lkLFxuICAgICAgc3RyZWFtLFxuICAgICAgcmVjZWl2ZXIsXG4gICAgICBhZGFwdGl2ZVN0cmVhbVNldHRpbmdzLFxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZVJlc3RhcnRpbmcgPSAoKSA9PiB7XG4gICAgdGhpcy5jbGVhckNvbm5lY3Rpb25SZWNvbmNpbGUoKTtcbiAgICAvLyBhbHNvIHVud2luZCBleGlzdGluZyBwYXJ0aWNpcGFudHMgJiBleGlzdGluZyBzdWJzY3JpcHRpb25zXG4gICAgZm9yIChjb25zdCBwIG9mIHRoaXMucGFydGljaXBhbnRzLnZhbHVlcygpKSB7XG4gICAgICB0aGlzLmhhbmRsZVBhcnRpY2lwYW50RGlzY29ubmVjdGVkKHAuc2lkLCBwKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zZXRBbmRFbWl0Q29ubmVjdGlvblN0YXRlKENvbm5lY3Rpb25TdGF0ZS5SZWNvbm5lY3RpbmcpKSB7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlJlY29ubmVjdGluZyk7XG4gICAgfVxuICB9O1xuXG4gIHByaXZhdGUgaGFuZGxlU2lnbmFsUmVzdGFydGVkID0gYXN5bmMgKGpvaW5SZXNwb25zZTogSm9pblJlc3BvbnNlKSA9PiB7XG4gICAgdGhpcy5sb2cuZGVidWcoYHNpZ25hbCByZWNvbm5lY3RlZCB0byBzZXJ2ZXIsIHJlZ2lvbiAke2pvaW5SZXNwb25zZS5zZXJ2ZXJSZWdpb259YCwge1xuICAgICAgLi4udGhpcy5sb2dDb250ZXh0LFxuICAgICAgcmVnaW9uOiBqb2luUmVzcG9uc2Uuc2VydmVyUmVnaW9uLFxuICAgIH0pO1xuICAgIHRoaXMuYnVmZmVyZWRFdmVudHMgPSBbXTtcblxuICAgIHRoaXMuYXBwbHlKb2luUmVzcG9uc2Uoam9pblJlc3BvbnNlKTtcblxuICAgIHRyeSB7XG4gICAgICAvLyB1bnB1Ymxpc2ggJiByZXB1Ymxpc2ggdHJhY2tzXG4gICAgICBhd2FpdCB0aGlzLmxvY2FsUGFydGljaXBhbnQucmVwdWJsaXNoQWxsVHJhY2tzKHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMubG9nLmVycm9yKCdlcnJvciB0cnlpbmcgdG8gcmUtcHVibGlzaCB0cmFja3MgYWZ0ZXIgcmVjb25uZWN0aW9uJywge1xuICAgICAgICAuLi50aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgIGVycm9yLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuZW5naW5lLndhaXRGb3JSZXN0YXJ0ZWQoKTtcbiAgICAgIHRoaXMubG9nLmRlYnVnKGBmdWxseSByZWNvbm5lY3RlZCB0byBzZXJ2ZXJgLCB7XG4gICAgICAgIC4uLnRoaXMubG9nQ29udGV4dCxcbiAgICAgICAgcmVnaW9uOiBqb2luUmVzcG9uc2Uuc2VydmVyUmVnaW9uLFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICAvLyByZWNvbm5lY3Rpb24gZmFpbGVkLCBoYW5kbGVEaXNjb25uZWN0IGlzIGJlaW5nIGludm9rZWQgYWxyZWFkeSwganVzdCByZXR1cm4gaGVyZVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNldEFuZEVtaXRDb25uZWN0aW9uU3RhdGUoQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RlZCk7XG4gICAgdGhpcy5lbWl0KFJvb21FdmVudC5SZWNvbm5lY3RlZCk7XG4gICAgdGhpcy5yZWdpc3RlckNvbm5lY3Rpb25SZWNvbmNpbGUoKTtcbiAgICB0aGlzLmVtaXRCdWZmZXJlZEV2ZW50cygpO1xuICB9O1xuXG4gIHByaXZhdGUgaGFuZGxlRGlzY29ubmVjdChzaG91bGRTdG9wVHJhY2tzID0gdHJ1ZSwgcmVhc29uPzogRGlzY29ubmVjdFJlYXNvbikge1xuICAgIHRoaXMuY2xlYXJDb25uZWN0aW9uUmVjb25jaWxlKCk7XG4gICAgdGhpcy5idWZmZXJlZEV2ZW50cyA9IFtdO1xuICAgIGlmICh0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuRGlzY29ubmVjdGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5yZWdpb25VcmwgPSB1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgdGhpcy5wYXJ0aWNpcGFudHMuZm9yRWFjaCgocCkgPT4ge1xuICAgICAgICBwLnRyYWNrcy5mb3JFYWNoKChwdWIpID0+IHtcbiAgICAgICAgICBwLnVucHVibGlzaFRyYWNrKHB1Yi50cmFja1NpZCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC50cmFja3MuZm9yRWFjaCgocHViKSA9PiB7XG4gICAgICAgIGlmIChwdWIudHJhY2spIHtcbiAgICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQudW5wdWJsaXNoVHJhY2socHViLnRyYWNrLCBzaG91bGRTdG9wVHJhY2tzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkU3RvcFRyYWNrcykge1xuICAgICAgICAgIHB1Yi50cmFjaz8uZGV0YWNoKCk7XG4gICAgICAgICAgcHViLnRyYWNrPy5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnRcbiAgICAgICAgLm9mZihQYXJ0aWNpcGFudEV2ZW50LlBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkLCB0aGlzLm9uTG9jYWxQYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZClcbiAgICAgICAgLm9mZihQYXJ0aWNpcGFudEV2ZW50LlBhcnRpY2lwYW50TmFtZUNoYW5nZWQsIHRoaXMub25Mb2NhbFBhcnRpY2lwYW50TmFtZUNoYW5nZWQpXG4gICAgICAgIC5vZmYoUGFydGljaXBhbnRFdmVudC5UcmFja011dGVkLCB0aGlzLm9uTG9jYWxUcmFja011dGVkKVxuICAgICAgICAub2ZmKFBhcnRpY2lwYW50RXZlbnQuVHJhY2tVbm11dGVkLCB0aGlzLm9uTG9jYWxUcmFja1VubXV0ZWQpXG4gICAgICAgIC5vZmYoUGFydGljaXBhbnRFdmVudC5Mb2NhbFRyYWNrUHVibGlzaGVkLCB0aGlzLm9uTG9jYWxUcmFja1B1Ymxpc2hlZClcbiAgICAgICAgLm9mZihQYXJ0aWNpcGFudEV2ZW50LkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCwgdGhpcy5vbkxvY2FsVHJhY2tVbnB1Ymxpc2hlZClcbiAgICAgICAgLm9mZihQYXJ0aWNpcGFudEV2ZW50LkNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCwgdGhpcy5vbkxvY2FsQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkKVxuICAgICAgICAub2ZmKFBhcnRpY2lwYW50RXZlbnQuTWVkaWFEZXZpY2VzRXJyb3IsIHRoaXMub25NZWRpYURldmljZXNFcnJvcilcbiAgICAgICAgLm9mZihQYXJ0aWNpcGFudEV2ZW50LkF1ZGlvU3RyZWFtQWNxdWlyZWQsIHRoaXMuc3RhcnRBdWRpbylcbiAgICAgICAgLm9mZihcbiAgICAgICAgICBQYXJ0aWNpcGFudEV2ZW50LlBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkLFxuICAgICAgICAgIHRoaXMub25Mb2NhbFBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkLFxuICAgICAgICApO1xuXG4gICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQudHJhY2tzLmNsZWFyKCk7XG4gICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQudmlkZW9UcmFja3MuY2xlYXIoKTtcbiAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5hdWRpb1RyYWNrcy5jbGVhcigpO1xuXG4gICAgICB0aGlzLnBhcnRpY2lwYW50cy5jbGVhcigpO1xuICAgICAgdGhpcy5hY3RpdmVTcGVha2VycyA9IFtdO1xuICAgICAgaWYgKHRoaXMuYXVkaW9Db250ZXh0ICYmIHR5cGVvZiB0aGlzLm9wdGlvbnMuZXhwV2ViQXVkaW9NaXggPT09ICdib29sZWFuJykge1xuICAgICAgICB0aGlzLmF1ZGlvQ29udGV4dC5jbG9zZSgpO1xuICAgICAgICB0aGlzLmF1ZGlvQ29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmIChpc1dlYigpKSB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCB0aGlzLm9uUGFnZUxlYXZlKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BhZ2VoaWRlJywgdGhpcy5vblBhZ2VMZWF2ZSk7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdmcmVlemUnLCB0aGlzLm9uUGFnZUxlYXZlKTtcbiAgICAgICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcz8ucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGV2aWNlY2hhbmdlJywgdGhpcy5oYW5kbGVEZXZpY2VDaGFuZ2UpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLnNldEFuZEVtaXRDb25uZWN0aW9uU3RhdGUoQ29ubmVjdGlvblN0YXRlLkRpc2Nvbm5lY3RlZCk7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkRpc2Nvbm5lY3RlZCwgcmVhc29uKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZVBhcnRpY2lwYW50VXBkYXRlcyA9IChwYXJ0aWNpcGFudEluZm9zOiBQYXJ0aWNpcGFudEluZm9bXSkgPT4ge1xuICAgIC8vIGhhbmRsZSBjaGFuZ2VzIHRvIHBhcnRpY2lwYW50IHN0YXRlLCBhbmQgc2VuZCBldmVudHNcbiAgICBwYXJ0aWNpcGFudEluZm9zLmZvckVhY2goKGluZm8pID0+IHtcbiAgICAgIGlmIChpbmZvLmlkZW50aXR5ID09PSB0aGlzLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHkpIHtcbiAgICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LnVwZGF0ZUluZm8oaW5mbyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gZW5zdXJlIGlkZW50aXR5IDw9PiBzaWQgbWFwcGluZ1xuICAgICAgY29uc3Qgc2lkID0gdGhpcy5pZGVudGl0eVRvU2lkLmdldChpbmZvLmlkZW50aXR5KTtcbiAgICAgIGlmIChzaWQgJiYgc2lkICE9PSBpbmZvLnNpZCkge1xuICAgICAgICAvLyBzaWQgaGFkIGNoYW5nZWQsIG5lZWQgdG8gcmVtb3ZlIHByZXZpb3VzIHBhcnRpY2lwYW50XG4gICAgICAgIHRoaXMuaGFuZGxlUGFydGljaXBhbnREaXNjb25uZWN0ZWQoc2lkLCB0aGlzLnBhcnRpY2lwYW50cy5nZXQoc2lkKSk7XG4gICAgICB9XG5cbiAgICAgIGxldCByZW1vdGVQYXJ0aWNpcGFudCA9IHRoaXMucGFydGljaXBhbnRzLmdldChpbmZvLnNpZCk7XG4gICAgICBjb25zdCBpc05ld1BhcnRpY2lwYW50ID0gIXJlbW90ZVBhcnRpY2lwYW50O1xuXG4gICAgICAvLyB3aGVuIGl0J3MgZGlzY29ubmVjdGVkLCBzZW5kIHVwZGF0ZXNcbiAgICAgIGlmIChpbmZvLnN0YXRlID09PSBQYXJ0aWNpcGFudEluZm9fU3RhdGUuRElTQ09OTkVDVEVEKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlUGFydGljaXBhbnREaXNjb25uZWN0ZWQoaW5mby5zaWQsIHJlbW90ZVBhcnRpY2lwYW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNyZWF0ZSBwYXJ0aWNpcGFudCBpZiBkb2Vzbid0IGV4aXN0XG4gICAgICAgIHJlbW90ZVBhcnRpY2lwYW50ID0gdGhpcy5nZXRPckNyZWF0ZVBhcnRpY2lwYW50KGluZm8uc2lkLCBpbmZvKTtcbiAgICAgICAgaWYgKCFpc05ld1BhcnRpY2lwYW50KSB7XG4gICAgICAgICAgLy8ganVzdCB1cGRhdGUsIG5vIGV2ZW50c1xuICAgICAgICAgIHJlbW90ZVBhcnRpY2lwYW50LnVwZGF0ZUluZm8oaW5mbyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBwcml2YXRlIGhhbmRsZVBhcnRpY2lwYW50RGlzY29ubmVjdGVkKHNpZDogc3RyaW5nLCBwYXJ0aWNpcGFudD86IFJlbW90ZVBhcnRpY2lwYW50KSB7XG4gICAgLy8gcmVtb3ZlIGFuZCBzZW5kIGV2ZW50XG4gICAgdGhpcy5wYXJ0aWNpcGFudHMuZGVsZXRlKHNpZCk7XG4gICAgaWYgKCFwYXJ0aWNpcGFudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuaWRlbnRpdHlUb1NpZC5kZWxldGUocGFydGljaXBhbnQuaWRlbnRpdHkpO1xuICAgIHBhcnRpY2lwYW50LnRyYWNrcy5mb3JFYWNoKChwdWJsaWNhdGlvbikgPT4ge1xuICAgICAgcGFydGljaXBhbnQudW5wdWJsaXNoVHJhY2socHVibGljYXRpb24udHJhY2tTaWQsIHRydWUpO1xuICAgIH0pO1xuICAgIHRoaXMuZW1pdChSb29tRXZlbnQuUGFydGljaXBhbnREaXNjb25uZWN0ZWQsIHBhcnRpY2lwYW50KTtcbiAgfVxuXG4gIC8vIHVwZGF0ZXMgYXJlIHNlbnQgb25seSB3aGVuIHRoZXJlJ3MgYSBjaGFuZ2UgdG8gc3BlYWtlciBvcmRlcmluZ1xuICBwcml2YXRlIGhhbmRsZUFjdGl2ZVNwZWFrZXJzVXBkYXRlID0gKHNwZWFrZXJzOiBTcGVha2VySW5mb1tdKSA9PiB7XG4gICAgY29uc3QgYWN0aXZlU3BlYWtlcnM6IFBhcnRpY2lwYW50W10gPSBbXTtcbiAgICBjb25zdCBzZWVuU2lkczogYW55ID0ge307XG4gICAgc3BlYWtlcnMuZm9yRWFjaCgoc3BlYWtlcikgPT4ge1xuICAgICAgc2VlblNpZHNbc3BlYWtlci5zaWRdID0gdHJ1ZTtcbiAgICAgIGlmIChzcGVha2VyLnNpZCA9PT0gdGhpcy5sb2NhbFBhcnRpY2lwYW50LnNpZCkge1xuICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuYXVkaW9MZXZlbCA9IHNwZWFrZXIubGV2ZWw7XG4gICAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zZXRJc1NwZWFraW5nKHRydWUpO1xuICAgICAgICBhY3RpdmVTcGVha2Vycy5wdXNoKHRoaXMubG9jYWxQYXJ0aWNpcGFudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBwID0gdGhpcy5wYXJ0aWNpcGFudHMuZ2V0KHNwZWFrZXIuc2lkKTtcbiAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICBwLmF1ZGlvTGV2ZWwgPSBzcGVha2VyLmxldmVsO1xuICAgICAgICAgIHAuc2V0SXNTcGVha2luZyh0cnVlKTtcbiAgICAgICAgICBhY3RpdmVTcGVha2Vycy5wdXNoKHApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoIXNlZW5TaWRzW3RoaXMubG9jYWxQYXJ0aWNpcGFudC5zaWRdKSB7XG4gICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuYXVkaW9MZXZlbCA9IDA7XG4gICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuc2V0SXNTcGVha2luZyhmYWxzZSk7XG4gICAgfVxuICAgIHRoaXMucGFydGljaXBhbnRzLmZvckVhY2goKHApID0+IHtcbiAgICAgIGlmICghc2VlblNpZHNbcC5zaWRdKSB7XG4gICAgICAgIHAuYXVkaW9MZXZlbCA9IDA7XG4gICAgICAgIHAuc2V0SXNTcGVha2luZyhmYWxzZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLmFjdGl2ZVNwZWFrZXJzID0gYWN0aXZlU3BlYWtlcnM7XG4gICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuQWN0aXZlU3BlYWtlcnNDaGFuZ2VkLCBhY3RpdmVTcGVha2Vycyk7XG4gIH07XG5cbiAgLy8gcHJvY2VzcyBsaXN0IG9mIGNoYW5nZWQgc3BlYWtlcnNcbiAgcHJpdmF0ZSBoYW5kbGVTcGVha2Vyc0NoYW5nZWQgPSAoc3BlYWtlclVwZGF0ZXM6IFNwZWFrZXJJbmZvW10pID0+IHtcbiAgICBjb25zdCBsYXN0U3BlYWtlcnMgPSBuZXcgTWFwPHN0cmluZywgUGFydGljaXBhbnQ+KCk7XG4gICAgdGhpcy5hY3RpdmVTcGVha2Vycy5mb3JFYWNoKChwKSA9PiB7XG4gICAgICBsYXN0U3BlYWtlcnMuc2V0KHAuc2lkLCBwKTtcbiAgICB9KTtcbiAgICBzcGVha2VyVXBkYXRlcy5mb3JFYWNoKChzcGVha2VyKSA9PiB7XG4gICAgICBsZXQgcDogUGFydGljaXBhbnQgfCB1bmRlZmluZWQgPSB0aGlzLnBhcnRpY2lwYW50cy5nZXQoc3BlYWtlci5zaWQpO1xuICAgICAgaWYgKHNwZWFrZXIuc2lkID09PSB0aGlzLmxvY2FsUGFydGljaXBhbnQuc2lkKSB7XG4gICAgICAgIHAgPSB0aGlzLmxvY2FsUGFydGljaXBhbnQ7XG4gICAgICB9XG4gICAgICBpZiAoIXApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcC5hdWRpb0xldmVsID0gc3BlYWtlci5sZXZlbDtcbiAgICAgIHAuc2V0SXNTcGVha2luZyhzcGVha2VyLmFjdGl2ZSk7XG5cbiAgICAgIGlmIChzcGVha2VyLmFjdGl2ZSkge1xuICAgICAgICBsYXN0U3BlYWtlcnMuc2V0KHNwZWFrZXIuc2lkLCBwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxhc3RTcGVha2Vycy5kZWxldGUoc3BlYWtlci5zaWQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGFjdGl2ZVNwZWFrZXJzID0gQXJyYXkuZnJvbShsYXN0U3BlYWtlcnMudmFsdWVzKCkpO1xuICAgIGFjdGl2ZVNwZWFrZXJzLnNvcnQoKGEsIGIpID0+IGIuYXVkaW9MZXZlbCAtIGEuYXVkaW9MZXZlbCk7XG4gICAgdGhpcy5hY3RpdmVTcGVha2VycyA9IGFjdGl2ZVNwZWFrZXJzO1xuICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LkFjdGl2ZVNwZWFrZXJzQ2hhbmdlZCwgYWN0aXZlU3BlYWtlcnMpO1xuICB9O1xuXG4gIHByaXZhdGUgaGFuZGxlU3RyZWFtU3RhdGVVcGRhdGUgPSAoc3RyZWFtU3RhdGVVcGRhdGU6IFN0cmVhbVN0YXRlVXBkYXRlKSA9PiB7XG4gICAgc3RyZWFtU3RhdGVVcGRhdGUuc3RyZWFtU3RhdGVzLmZvckVhY2goKHN0cmVhbVN0YXRlKSA9PiB7XG4gICAgICBjb25zdCBwYXJ0aWNpcGFudCA9IHRoaXMucGFydGljaXBhbnRzLmdldChzdHJlYW1TdGF0ZS5wYXJ0aWNpcGFudFNpZCk7XG4gICAgICBpZiAoIXBhcnRpY2lwYW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHB1YiA9IHBhcnRpY2lwYW50LmdldFRyYWNrUHVibGljYXRpb24oc3RyZWFtU3RhdGUudHJhY2tTaWQpO1xuICAgICAgaWYgKCFwdWIgfHwgIXB1Yi50cmFjaykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBwdWIudHJhY2suc3RyZWFtU3RhdGUgPSBUcmFjay5zdHJlYW1TdGF0ZUZyb21Qcm90byhzdHJlYW1TdGF0ZS5zdGF0ZSk7XG4gICAgICBwYXJ0aWNpcGFudC5lbWl0KFBhcnRpY2lwYW50RXZlbnQuVHJhY2tTdHJlYW1TdGF0ZUNoYW5nZWQsIHB1YiwgcHViLnRyYWNrLnN0cmVhbVN0YXRlKTtcbiAgICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoXG4gICAgICAgIFJvb21FdmVudC5UcmFja1N0cmVhbVN0YXRlQ2hhbmdlZCxcbiAgICAgICAgcHViLFxuICAgICAgICBwdWIudHJhY2suc3RyZWFtU3RhdGUsXG4gICAgICAgIHBhcnRpY2lwYW50LFxuICAgICAgKTtcbiAgICB9KTtcbiAgfTtcblxuICBwcml2YXRlIGhhbmRsZVN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUgPSAodXBkYXRlOiBTdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlKSA9PiB7XG4gICAgY29uc3QgcGFydGljaXBhbnQgPSB0aGlzLnBhcnRpY2lwYW50cy5nZXQodXBkYXRlLnBhcnRpY2lwYW50U2lkKTtcbiAgICBpZiAoIXBhcnRpY2lwYW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHB1YiA9IHBhcnRpY2lwYW50LmdldFRyYWNrUHVibGljYXRpb24odXBkYXRlLnRyYWNrU2lkKTtcbiAgICBpZiAoIXB1Yikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHB1Yi5zZXRBbGxvd2VkKHVwZGF0ZS5hbGxvd2VkKTtcbiAgfTtcblxuICBwcml2YXRlIGhhbmRsZVN1YnNjcmlwdGlvbkVycm9yID0gKHVwZGF0ZTogU3Vic2NyaXB0aW9uUmVzcG9uc2UpID0+IHtcbiAgICBjb25zdCBwYXJ0aWNpcGFudCA9IEFycmF5LmZyb20odGhpcy5wYXJ0aWNpcGFudHMudmFsdWVzKCkpLmZpbmQoKHApID0+XG4gICAgICBwLnRyYWNrcy5oYXModXBkYXRlLnRyYWNrU2lkKSxcbiAgICApO1xuICAgIGlmICghcGFydGljaXBhbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcHViID0gcGFydGljaXBhbnQuZ2V0VHJhY2tQdWJsaWNhdGlvbih1cGRhdGUudHJhY2tTaWQpO1xuICAgIGlmICghcHViKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcHViLnNldFN1YnNjcmlwdGlvbkVycm9yKHVwZGF0ZS5lcnIpO1xuICB9O1xuXG4gIHByaXZhdGUgaGFuZGxlRGF0YVBhY2tldCA9ICh1c2VyUGFja2V0OiBVc2VyUGFja2V0LCBraW5kOiBEYXRhUGFja2V0X0tpbmQpID0+IHtcbiAgICAvLyBmaW5kIHRoZSBwYXJ0aWNpcGFudFxuICAgIGNvbnN0IHBhcnRpY2lwYW50ID0gdGhpcy5wYXJ0aWNpcGFudHMuZ2V0KHVzZXJQYWNrZXQucGFydGljaXBhbnRTaWQpO1xuXG4gICAgdGhpcy5lbWl0KFJvb21FdmVudC5EYXRhUmVjZWl2ZWQsIHVzZXJQYWNrZXQucGF5bG9hZCwgcGFydGljaXBhbnQsIGtpbmQsIHVzZXJQYWNrZXQudG9waWMpO1xuXG4gICAgLy8gYWxzbyBlbWl0IG9uIHRoZSBwYXJ0aWNpcGFudFxuICAgIHBhcnRpY2lwYW50Py5lbWl0KFBhcnRpY2lwYW50RXZlbnQuRGF0YVJlY2VpdmVkLCB1c2VyUGFja2V0LnBheWxvYWQsIGtpbmQpO1xuICB9O1xuXG4gIHByaXZhdGUgaGFuZGxlQXVkaW9QbGF5YmFja1N0YXJ0ZWQgPSAoKSA9PiB7XG4gICAgaWYgKHRoaXMuY2FuUGxheWJhY2tBdWRpbykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmF1ZGlvRW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5lbWl0KFJvb21FdmVudC5BdWRpb1BsYXliYWNrU3RhdHVzQ2hhbmdlZCwgdHJ1ZSk7XG4gIH07XG5cbiAgcHJpdmF0ZSBoYW5kbGVBdWRpb1BsYXliYWNrRmFpbGVkID0gKGU6IGFueSkgPT4ge1xuICAgIHRoaXMubG9nLndhcm4oJ2NvdWxkIG5vdCBwbGF5YmFjayBhdWRpbycsIHsgLi4udGhpcy5sb2dDb250ZXh0LCBlcnJvcjogZSB9KTtcbiAgICBpZiAoIXRoaXMuY2FuUGxheWJhY2tBdWRpbykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmF1ZGlvRW5hYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdChSb29tRXZlbnQuQXVkaW9QbGF5YmFja1N0YXR1c0NoYW5nZWQsIGZhbHNlKTtcbiAgfTtcblxuICBwcml2YXRlIGhhbmRsZVZpZGVvUGxheWJhY2tTdGFydGVkID0gKCkgPT4ge1xuICAgIGlmICh0aGlzLmlzVmlkZW9QbGF5YmFja0Jsb2NrZWQpIHtcbiAgICAgIHRoaXMuaXNWaWRlb1BsYXliYWNrQmxvY2tlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5WaWRlb1BsYXliYWNrU3RhdHVzQ2hhbmdlZCwgdHJ1ZSk7XG4gICAgfVxuICB9O1xuXG4gIHByaXZhdGUgaGFuZGxlVmlkZW9QbGF5YmFja0ZhaWxlZCA9ICgpID0+IHtcbiAgICBpZiAoIXRoaXMuaXNWaWRlb1BsYXliYWNrQmxvY2tlZCkge1xuICAgICAgdGhpcy5pc1ZpZGVvUGxheWJhY2tCbG9ja2VkID0gdHJ1ZTtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuVmlkZW9QbGF5YmFja1N0YXR1c0NoYW5nZWQsIGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgcHJpdmF0ZSBoYW5kbGVEZXZpY2VDaGFuZ2UgPSBhc3luYyAoKSA9PiB7XG4gICAgdGhpcy5lbWl0KFJvb21FdmVudC5NZWRpYURldmljZXNDaGFuZ2VkKTtcbiAgfTtcblxuICBwcml2YXRlIGhhbmRsZVJvb21VcGRhdGUgPSAocm9vbTogUm9vbU1vZGVsKSA9PiB7XG4gICAgY29uc3Qgb2xkUm9vbSA9IHRoaXMucm9vbUluZm87XG4gICAgdGhpcy5yb29tSW5mbyA9IHJvb207XG4gICAgaWYgKG9sZFJvb20gJiYgb2xkUm9vbS5tZXRhZGF0YSAhPT0gcm9vbS5tZXRhZGF0YSkge1xuICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuUm9vbU1ldGFkYXRhQ2hhbmdlZCwgcm9vbS5tZXRhZGF0YSk7XG4gICAgfVxuICAgIGlmIChvbGRSb29tPy5hY3RpdmVSZWNvcmRpbmcgIT09IHJvb20uYWN0aXZlUmVjb3JkaW5nKSB7XG4gICAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFJvb21FdmVudC5SZWNvcmRpbmdTdGF0dXNDaGFuZ2VkLCByb29tLmFjdGl2ZVJlY29yZGluZyk7XG4gICAgfVxuICB9O1xuXG4gIHByaXZhdGUgaGFuZGxlQ29ubmVjdGlvblF1YWxpdHlVcGRhdGUgPSAodXBkYXRlOiBDb25uZWN0aW9uUXVhbGl0eVVwZGF0ZSkgPT4ge1xuICAgIHVwZGF0ZS51cGRhdGVzLmZvckVhY2goKGluZm8pID0+IHtcbiAgICAgIGlmIChpbmZvLnBhcnRpY2lwYW50U2lkID09PSB0aGlzLmxvY2FsUGFydGljaXBhbnQuc2lkKSB7XG4gICAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zZXRDb25uZWN0aW9uUXVhbGl0eShpbmZvLnF1YWxpdHkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBwYXJ0aWNpcGFudCA9IHRoaXMucGFydGljaXBhbnRzLmdldChpbmZvLnBhcnRpY2lwYW50U2lkKTtcbiAgICAgIGlmIChwYXJ0aWNpcGFudCkge1xuICAgICAgICBwYXJ0aWNpcGFudC5zZXRDb25uZWN0aW9uUXVhbGl0eShpbmZvLnF1YWxpdHkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHByaXZhdGUgYXN5bmMgYWNxdWlyZUF1ZGlvQ29udGV4dCgpIHtcbiAgICBpZiAoXG4gICAgICB0eXBlb2YgdGhpcy5vcHRpb25zLmV4cFdlYkF1ZGlvTWl4ICE9PSAnYm9vbGVhbicgJiZcbiAgICAgIHRoaXMub3B0aW9ucy5leHBXZWJBdWRpb01peC5hdWRpb0NvbnRleHRcbiAgICApIHtcbiAgICAgIC8vIG92ZXJyaWRlIGF1ZGlvIGNvbnRleHQgd2l0aCBjdXN0b20gYXVkaW8gY29udGV4dCBpZiBzdXBwbGllZCBieSB1c2VyXG4gICAgICB0aGlzLmF1ZGlvQ29udGV4dCA9IHRoaXMub3B0aW9ucy5leHBXZWJBdWRpb01peC5hdWRpb0NvbnRleHQ7XG4gICAgfSBlbHNlIGlmICghdGhpcy5hdWRpb0NvbnRleHQgfHwgdGhpcy5hdWRpb0NvbnRleHQuc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICAvLyBieSB1c2luZyBhbiBBdWRpb0NvbnRleHQsIGl0IHJlZHVjZXMgbGFnIG9uIGF1ZGlvIGVsZW1lbnRzXG4gICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy85ODExNDI5L2h0bWw1LWF1ZGlvLXRhZy1vbi1zYWZhcmktaGFzLWEtZGVsYXkvNTQxMTk4NTQjNTQxMTk4NTRcbiAgICAgIHRoaXMuYXVkaW9Db250ZXh0ID0gZ2V0TmV3QXVkaW9Db250ZXh0KCkgPz8gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmF1ZGlvQ29udGV4dCAmJiB0aGlzLmF1ZGlvQ29udGV4dC5zdGF0ZSA9PT0gJ3N1c3BlbmRlZCcpIHtcbiAgICAgIC8vIGZvciBpT1MgYSBuZXdseSBjcmVhdGVkIEF1ZGlvQ29udGV4dCBpcyBhbHdheXMgaW4gYHN1c3BlbmRlZGAgc3RhdGUuXG4gICAgICAvLyB3ZSB0cnkgb3VyIGJlc3QgdG8gcmVzdW1lIHRoZSBjb250ZXh0IGhlcmUsIGlmIHRoYXQgZG9lc24ndCB3b3JrLCB3ZSBqdXN0IGNvbnRpbnVlIHdpdGggcmVndWxhciBwcm9jZXNzaW5nXG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLmF1ZGlvQ29udGV4dC5yZXN1bWUoKTtcbiAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgICB0aGlzLmxvZy53YXJuKCdDb3VsZCBub3QgcmVzdW1lIGF1ZGlvIGNvbnRleHQnLCB7IC4uLnRoaXMubG9nQ29udGV4dCwgZXJyb3I6IGUgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5leHBXZWJBdWRpb01peCkge1xuICAgICAgdGhpcy5wYXJ0aWNpcGFudHMuZm9yRWFjaCgocGFydGljaXBhbnQpID0+IHBhcnRpY2lwYW50LnNldEF1ZGlvQ29udGV4dCh0aGlzLmF1ZGlvQ29udGV4dCkpO1xuICAgIH1cblxuICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zZXRBdWRpb0NvbnRleHQodGhpcy5hdWRpb0NvbnRleHQpO1xuXG4gICAgY29uc3QgbmV3Q29udGV4dElzUnVubmluZyA9IHRoaXMuYXVkaW9Db250ZXh0Py5zdGF0ZSA9PT0gJ3J1bm5pbmcnO1xuICAgIGlmIChuZXdDb250ZXh0SXNSdW5uaW5nICE9PSB0aGlzLmNhblBsYXliYWNrQXVkaW8pIHtcbiAgICAgIHRoaXMuYXVkaW9FbmFibGVkID0gbmV3Q29udGV4dElzUnVubmluZztcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuQXVkaW9QbGF5YmFja1N0YXR1c0NoYW5nZWQsIG5ld0NvbnRleHRJc1J1bm5pbmcpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlUGFydGljaXBhbnQoaWQ6IHN0cmluZywgaW5mbz86IFBhcnRpY2lwYW50SW5mbyk6IFJlbW90ZVBhcnRpY2lwYW50IHtcbiAgICBsZXQgcGFydGljaXBhbnQ6IFJlbW90ZVBhcnRpY2lwYW50O1xuICAgIGlmIChpbmZvKSB7XG4gICAgICBwYXJ0aWNpcGFudCA9IFJlbW90ZVBhcnRpY2lwYW50LmZyb21QYXJ0aWNpcGFudEluZm8odGhpcy5lbmdpbmUuY2xpZW50LCBpbmZvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFydGljaXBhbnQgPSBuZXcgUmVtb3RlUGFydGljaXBhbnQodGhpcy5lbmdpbmUuY2xpZW50LCBpZCwgJycsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB7XG4gICAgICAgIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0LFxuICAgICAgICBsb2dnZXJOYW1lOiB0aGlzLm9wdGlvbnMubG9nZ2VyTmFtZSxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmV4cFdlYkF1ZGlvTWl4KSB7XG4gICAgICBwYXJ0aWNpcGFudC5zZXRBdWRpb0NvbnRleHQodGhpcy5hdWRpb0NvbnRleHQpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmF1ZGlvT3V0cHV0Py5kZXZpY2VJZCkge1xuICAgICAgcGFydGljaXBhbnRcbiAgICAgICAgLnNldEF1ZGlvT3V0cHV0KHRoaXMub3B0aW9ucy5hdWRpb091dHB1dClcbiAgICAgICAgLmNhdGNoKChlKSA9PiB0aGlzLmxvZy53YXJuKGBDb3VsZCBub3Qgc2V0IGF1ZGlvIG91dHB1dDogJHtlLm1lc3NhZ2V9YCwgdGhpcy5sb2dDb250ZXh0KSk7XG4gICAgfVxuICAgIHJldHVybiBwYXJ0aWNpcGFudDtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0T3JDcmVhdGVQYXJ0aWNpcGFudChpZDogc3RyaW5nLCBpbmZvOiBQYXJ0aWNpcGFudEluZm8pOiBSZW1vdGVQYXJ0aWNpcGFudCB7XG4gICAgaWYgKHRoaXMucGFydGljaXBhbnRzLmhhcyhpZCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnRpY2lwYW50cy5nZXQoaWQpIGFzIFJlbW90ZVBhcnRpY2lwYW50O1xuICAgIH1cbiAgICBjb25zdCBwYXJ0aWNpcGFudCA9IHRoaXMuY3JlYXRlUGFydGljaXBhbnQoaWQsIGluZm8pO1xuICAgIHRoaXMucGFydGljaXBhbnRzLnNldChpZCwgcGFydGljaXBhbnQpO1xuXG4gICAgdGhpcy5pZGVudGl0eVRvU2lkLnNldChpbmZvLmlkZW50aXR5LCBpbmZvLnNpZCk7XG4gICAgLy8gaWYgd2UgaGF2ZSB2YWxpZCBpbmZvIGFuZCB0aGUgcGFydGljaXBhbnQgd2Fzbid0IGluIHRoZSBtYXAgYmVmb3JlLCB3ZSBjYW4gYXNzdW1lIHRoZSBwYXJ0aWNpcGFudCBpcyBuZXdcbiAgICAvLyBmaXJpbmcgaGVyZSB0byBtYWtlIHN1cmUgdGhhdCBgUGFydGljaXBhbnRDb25uZWN0ZWRgIGZpcmVzIGJlZm9yZSB0aGUgaW5pdGlhbCB0cmFjayBldmVudHNcbiAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFJvb21FdmVudC5QYXJ0aWNpcGFudENvbm5lY3RlZCwgcGFydGljaXBhbnQpO1xuXG4gICAgLy8gYWxzbyBmb3J3YXJkIGV2ZW50c1xuICAgIC8vIHRyYWNrUHVibGlzaGVkIGlzIG9ubHkgZmlyZWQgZm9yIHRyYWNrcyBhZGRlZCBhZnRlciBib3RoIGxvY2FsIHBhcnRpY2lwYW50XG4gICAgLy8gYW5kIHJlbW90ZSBwYXJ0aWNpcGFudCBqb2luZWQgdGhlIHJvb21cbiAgICBwYXJ0aWNpcGFudFxuICAgICAgLm9uKFBhcnRpY2lwYW50RXZlbnQuVHJhY2tQdWJsaXNoZWQsICh0cmFja1B1YmxpY2F0aW9uOiBSZW1vdGVUcmFja1B1YmxpY2F0aW9uKSA9PiB7XG4gICAgICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LlRyYWNrUHVibGlzaGVkLCB0cmFja1B1YmxpY2F0aW9uLCBwYXJ0aWNpcGFudCk7XG4gICAgICB9KVxuICAgICAgLm9uKFxuICAgICAgICBQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3Vic2NyaWJlZCxcbiAgICAgICAgKHRyYWNrOiBSZW1vdGVUcmFjaywgcHVibGljYXRpb246IFJlbW90ZVRyYWNrUHVibGljYXRpb24pID0+IHtcbiAgICAgICAgICAvLyBtb25pdG9yIHBsYXliYWNrIHN0YXR1c1xuICAgICAgICAgIGlmICh0cmFjay5raW5kID09PSBUcmFjay5LaW5kLkF1ZGlvKSB7XG4gICAgICAgICAgICB0cmFjay5vbihUcmFja0V2ZW50LkF1ZGlvUGxheWJhY2tTdGFydGVkLCB0aGlzLmhhbmRsZUF1ZGlvUGxheWJhY2tTdGFydGVkKTtcbiAgICAgICAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuQXVkaW9QbGF5YmFja0ZhaWxlZCwgdGhpcy5oYW5kbGVBdWRpb1BsYXliYWNrRmFpbGVkKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRyYWNrLmtpbmQgPT09IFRyYWNrLktpbmQuVmlkZW8pIHtcbiAgICAgICAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuVmlkZW9QbGF5YmFja0ZhaWxlZCwgdGhpcy5oYW5kbGVWaWRlb1BsYXliYWNrRmFpbGVkKTtcbiAgICAgICAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuVmlkZW9QbGF5YmFja1N0YXJ0ZWQsIHRoaXMuaGFuZGxlVmlkZW9QbGF5YmFja1N0YXJ0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlRyYWNrU3Vic2NyaWJlZCwgdHJhY2ssIHB1YmxpY2F0aW9uLCBwYXJ0aWNpcGFudCk7XG4gICAgICAgIH0sXG4gICAgICApXG4gICAgICAub24oUGFydGljaXBhbnRFdmVudC5UcmFja1VucHVibGlzaGVkLCAocHVibGljYXRpb246IFJlbW90ZVRyYWNrUHVibGljYXRpb24pID0+IHtcbiAgICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5UcmFja1VucHVibGlzaGVkLCBwdWJsaWNhdGlvbiwgcGFydGljaXBhbnQpO1xuICAgICAgfSlcbiAgICAgIC5vbihcbiAgICAgICAgUGFydGljaXBhbnRFdmVudC5UcmFja1Vuc3Vic2NyaWJlZCxcbiAgICAgICAgKHRyYWNrOiBSZW1vdGVUcmFjaywgcHVibGljYXRpb246IFJlbW90ZVRyYWNrUHVibGljYXRpb24pID0+IHtcbiAgICAgICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlRyYWNrVW5zdWJzY3JpYmVkLCB0cmFjaywgcHVibGljYXRpb24sIHBhcnRpY2lwYW50KTtcbiAgICAgICAgfSxcbiAgICAgIClcbiAgICAgIC5vbihQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3Vic2NyaXB0aW9uRmFpbGVkLCAoc2lkOiBzdHJpbmcpID0+IHtcbiAgICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5UcmFja1N1YnNjcmlwdGlvbkZhaWxlZCwgc2lkLCBwYXJ0aWNpcGFudCk7XG4gICAgICB9KVxuICAgICAgLm9uKFBhcnRpY2lwYW50RXZlbnQuVHJhY2tNdXRlZCwgKHB1YjogVHJhY2tQdWJsaWNhdGlvbikgPT4ge1xuICAgICAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFJvb21FdmVudC5UcmFja011dGVkLCBwdWIsIHBhcnRpY2lwYW50KTtcbiAgICAgIH0pXG4gICAgICAub24oUGFydGljaXBhbnRFdmVudC5UcmFja1VubXV0ZWQsIChwdWI6IFRyYWNrUHVibGljYXRpb24pID0+IHtcbiAgICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuVHJhY2tVbm11dGVkLCBwdWIsIHBhcnRpY2lwYW50KTtcbiAgICAgIH0pXG4gICAgICAub24oUGFydGljaXBhbnRFdmVudC5QYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZCwgKG1ldGFkYXRhOiBzdHJpbmcgfCB1bmRlZmluZWQpID0+IHtcbiAgICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuUGFydGljaXBhbnRNZXRhZGF0YUNoYW5nZWQsIG1ldGFkYXRhLCBwYXJ0aWNpcGFudCk7XG4gICAgICB9KVxuICAgICAgLm9uKFBhcnRpY2lwYW50RXZlbnQuUGFydGljaXBhbnROYW1lQ2hhbmdlZCwgKG5hbWUpID0+IHtcbiAgICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuUGFydGljaXBhbnROYW1lQ2hhbmdlZCwgbmFtZSwgcGFydGljaXBhbnQpO1xuICAgICAgfSlcbiAgICAgIC5vbihQYXJ0aWNpcGFudEV2ZW50LkNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCwgKHF1YWxpdHk6IENvbm5lY3Rpb25RdWFsaXR5KSA9PiB7XG4gICAgICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LkNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCwgcXVhbGl0eSwgcGFydGljaXBhbnQpO1xuICAgICAgfSlcbiAgICAgIC5vbihcbiAgICAgICAgUGFydGljaXBhbnRFdmVudC5QYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZCxcbiAgICAgICAgKHByZXZQZXJtaXNzaW9ucz86IFBhcnRpY2lwYW50UGVybWlzc2lvbikgPT4ge1xuICAgICAgICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoXG4gICAgICAgICAgICBSb29tRXZlbnQuUGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWQsXG4gICAgICAgICAgICBwcmV2UGVybWlzc2lvbnMsXG4gICAgICAgICAgICBwYXJ0aWNpcGFudCxcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgKVxuICAgICAgLm9uKFBhcnRpY2lwYW50RXZlbnQuVHJhY2tTdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkLCAocHViLCBzdGF0dXMpID0+IHtcbiAgICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuVHJhY2tTdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkLCBwdWIsIHN0YXR1cywgcGFydGljaXBhbnQpO1xuICAgICAgfSlcbiAgICAgIC5vbihQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3Vic2NyaXB0aW9uRmFpbGVkLCAodHJhY2tTaWQsIGVycm9yKSA9PiB7XG4gICAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuVHJhY2tTdWJzY3JpcHRpb25GYWlsZWQsIHRyYWNrU2lkLCBwYXJ0aWNpcGFudCwgZXJyb3IpO1xuICAgICAgfSlcbiAgICAgIC5vbihQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWQsIChwdWIsIHN0YXR1cykgPT4ge1xuICAgICAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFxuICAgICAgICAgIFJvb21FdmVudC5UcmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkLFxuICAgICAgICAgIHB1YixcbiAgICAgICAgICBzdGF0dXMsXG4gICAgICAgICAgcGFydGljaXBhbnQsXG4gICAgICAgICk7XG4gICAgICB9KTtcblxuICAgIC8vIHVwZGF0ZSBpbmZvIGF0IHRoZSBlbmQgYWZ0ZXIgY2FsbGJhY2tzIGhhdmUgYmVlbiBzZXQgdXBcbiAgICBpZiAoaW5mbykge1xuICAgICAgcGFydGljaXBhbnQudXBkYXRlSW5mbyhpbmZvKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnRpY2lwYW50O1xuICB9XG5cbiAgcHJpdmF0ZSBzZW5kU3luY1N0YXRlKCkge1xuICAgIGNvbnN0IHJlbW90ZVRyYWNrcyA9IEFycmF5LmZyb20odGhpcy5wYXJ0aWNpcGFudHMudmFsdWVzKCkpLnJlZHVjZSgoYWNjLCBwYXJ0aWNpcGFudCkgPT4ge1xuICAgICAgYWNjLnB1c2goLi4uKHBhcnRpY2lwYW50LmdldFRyYWNrcygpIGFzIFJlbW90ZVRyYWNrUHVibGljYXRpb25bXSkpOyAvLyBGSVhNRSB3b3VsZCBiZSBuaWNlIHRvIGhhdmUgdGhpcyByZXR1cm4gUmVtb3RlVHJhY2tQdWJsaWNhdGlvbnMgZGlyZWN0bHkgaW5zdGVhZCBvZiB0aGUgdHlwZSBjYXN0XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIFtdIGFzIFJlbW90ZVRyYWNrUHVibGljYXRpb25bXSk7XG4gICAgY29uc3QgbG9jYWxUcmFja3MgPSB0aGlzLmxvY2FsUGFydGljaXBhbnQuZ2V0VHJhY2tzKCkgYXMgTG9jYWxUcmFja1B1YmxpY2F0aW9uW107IC8vIEZJWE1FIHdvdWxkIGJlIG5pY2UgdG8gaGF2ZSB0aGlzIHJldHVybiBMb2NhbFRyYWNrUHVibGljYXRpb25zIGRpcmVjdGx5IGluc3RlYWQgb2YgdGhlIHR5cGUgY2FzdFxuICAgIHRoaXMuZW5naW5lLnNlbmRTeW5jU3RhdGUocmVtb3RlVHJhY2tzLCBsb2NhbFRyYWNrcyk7XG4gIH1cblxuICAvKipcbiAgICogQWZ0ZXIgcmVzdW1pbmcsIHdlJ2xsIG5lZWQgdG8gbm90aWZ5IHRoZSBzZXJ2ZXIgb2YgdGhlIGN1cnJlbnRcbiAgICogc3Vic2NyaXB0aW9uIHNldHRpbmdzLlxuICAgKi9cbiAgcHJpdmF0ZSB1cGRhdGVTdWJzY3JpcHRpb25zKCkge1xuICAgIGZvciAoY29uc3QgcCBvZiB0aGlzLnBhcnRpY2lwYW50cy52YWx1ZXMoKSkge1xuICAgICAgZm9yIChjb25zdCBwdWIgb2YgcC52aWRlb1RyYWNrcy52YWx1ZXMoKSkge1xuICAgICAgICBpZiAocHViLmlzU3Vic2NyaWJlZCAmJiBwdWIgaW5zdGFuY2VvZiBSZW1vdGVUcmFja1B1YmxpY2F0aW9uKSB7XG4gICAgICAgICAgcHViLmVtaXRUcmFja1VwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSByZWdpc3RlckNvbm5lY3Rpb25SZWNvbmNpbGUoKSB7XG4gICAgdGhpcy5jbGVhckNvbm5lY3Rpb25SZWNvbmNpbGUoKTtcbiAgICBsZXQgY29uc2VjdXRpdmVGYWlsdXJlcyA9IDA7XG4gICAgdGhpcy5jb25uZWN0aW9uUmVjb25jaWxlSW50ZXJ2YWwgPSBDcml0aWNhbFRpbWVycy5zZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgIC8vIGVuc3VyZSB3ZSBkaWRuJ3QgdGVhciBpdCBkb3duXG4gICAgICAgICF0aGlzLmVuZ2luZSB8fFxuICAgICAgICAvLyBlbmdpbmUgZGV0ZWN0ZWQgY2xvc2UsIGJ1dCBSb29tIG1pc3NlZCBpdFxuICAgICAgICB0aGlzLmVuZ2luZS5pc0Nsb3NlZCB8fFxuICAgICAgICAvLyB0cmFuc3BvcnRzIGZhaWxlZCB3aXRob3V0IG5vdGlmeWluZyBlbmdpbmVcbiAgICAgICAgIXRoaXMuZW5naW5lLnZlcmlmeVRyYW5zcG9ydCgpXG4gICAgICApIHtcbiAgICAgICAgY29uc2VjdXRpdmVGYWlsdXJlcysrO1xuICAgICAgICB0aGlzLmxvZy53YXJuKCdkZXRlY3RlZCBjb25uZWN0aW9uIHN0YXRlIG1pc21hdGNoJywge1xuICAgICAgICAgIC4uLnRoaXMubG9nQ29udGV4dCxcbiAgICAgICAgICBudW1GYWlsdXJlczogY29uc2VjdXRpdmVGYWlsdXJlcyxcbiAgICAgICAgICBlbmdpbmU6IHtcbiAgICAgICAgICAgIGNsb3NlZDogdGhpcy5lbmdpbmUuaXNDbG9zZWQsXG4gICAgICAgICAgICB0cmFuc3BvcnRzQ29ubmVjdGVkOiB0aGlzLmVuZ2luZS52ZXJpZnlUcmFuc3BvcnQoKSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNvbnNlY3V0aXZlRmFpbHVyZXMgPj0gMykge1xuICAgICAgICAgIHRoaXMucmVjcmVhdGVFbmdpbmUoKTtcbiAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QoXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuc3RvcExvY2FsVHJhY2tPblVucHVibGlzaCxcbiAgICAgICAgICAgIERpc2Nvbm5lY3RSZWFzb24uU1RBVEVfTUlTTUFUQ0gsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc2VjdXRpdmVGYWlsdXJlcyA9IDA7XG4gICAgICB9XG4gICAgfSwgY29ubmVjdGlvblJlY29uY2lsZUZyZXF1ZW5jeSk7XG4gIH1cblxuICBwcml2YXRlIGNsZWFyQ29ubmVjdGlvblJlY29uY2lsZSgpIHtcbiAgICBpZiAodGhpcy5jb25uZWN0aW9uUmVjb25jaWxlSW50ZXJ2YWwpIHtcbiAgICAgIENyaXRpY2FsVGltZXJzLmNsZWFySW50ZXJ2YWwodGhpcy5jb25uZWN0aW9uUmVjb25jaWxlSW50ZXJ2YWwpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc2V0QW5kRW1pdENvbm5lY3Rpb25TdGF0ZShzdGF0ZTogQ29ubmVjdGlvblN0YXRlKTogYm9vbGVhbiB7XG4gICAgaWYgKHN0YXRlID09PSB0aGlzLnN0YXRlKSB7XG4gICAgICAvLyB1bmNoYW5nZWRcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIHRoaXMuZW1pdChSb29tRXZlbnQuQ29ubmVjdGlvblN0YXRlQ2hhbmdlZCwgdGhpcy5zdGF0ZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBwcml2YXRlIGVtaXRCdWZmZXJlZEV2ZW50cygpIHtcbiAgICB0aGlzLmJ1ZmZlcmVkRXZlbnRzLmZvckVhY2goKFtldiwgYXJnc10pID0+IHtcbiAgICAgIHRoaXMuZW1pdChldiwgLi4uYXJncyk7XG4gICAgfSk7XG4gICAgdGhpcy5idWZmZXJlZEV2ZW50cyA9IFtdO1xuICB9XG5cbiAgcHJpdmF0ZSBlbWl0V2hlbkNvbm5lY3RlZDxFIGV4dGVuZHMga2V5b2YgUm9vbUV2ZW50Q2FsbGJhY2tzPihcbiAgICBldmVudDogRSxcbiAgICAuLi5hcmdzOiBQYXJhbWV0ZXJzPFJvb21FdmVudENhbGxiYWNrc1tFXT5cbiAgKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0ZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmVtaXQoZXZlbnQsIC4uLmFyZ3MpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLlJlY29ubmVjdGluZykge1xuICAgICAgLy8gaW4gY2FzZSB0aGUgcm9vbSBpcyByZWNvbm5lY3RpbmcsIGJ1ZmZlciB0aGUgZXZlbnRzIGJ5IGZpcmluZyB0aGVtIGxhdGVyIGFmdGVyIGVtaXR0aW5nIFJvb21FdmVudC5SZWNvbm5lY3RlZFxuICAgICAgdGhpcy5idWZmZXJlZEV2ZW50cy5wdXNoKFtldmVudCwgYXJnc10pO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwcml2YXRlIG9uTG9jYWxQYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZCA9IChtZXRhZGF0YTogc3RyaW5nIHwgdW5kZWZpbmVkKSA9PiB7XG4gICAgdGhpcy5lbWl0KFJvb21FdmVudC5QYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZCwgbWV0YWRhdGEsIHRoaXMubG9jYWxQYXJ0aWNpcGFudCk7XG4gIH07XG5cbiAgcHJpdmF0ZSBvbkxvY2FsUGFydGljaXBhbnROYW1lQ2hhbmdlZCA9IChuYW1lOiBzdHJpbmcpID0+IHtcbiAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlBhcnRpY2lwYW50TmFtZUNoYW5nZWQsIG5hbWUsIHRoaXMubG9jYWxQYXJ0aWNpcGFudCk7XG4gIH07XG5cbiAgcHJpdmF0ZSBvbkxvY2FsVHJhY2tNdXRlZCA9IChwdWI6IFRyYWNrUHVibGljYXRpb24pID0+IHtcbiAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlRyYWNrTXV0ZWQsIHB1YiwgdGhpcy5sb2NhbFBhcnRpY2lwYW50KTtcbiAgfTtcblxuICBwcml2YXRlIG9uTG9jYWxUcmFja1VubXV0ZWQgPSAocHViOiBUcmFja1B1YmxpY2F0aW9uKSA9PiB7XG4gICAgdGhpcy5lbWl0KFJvb21FdmVudC5UcmFja1VubXV0ZWQsIHB1YiwgdGhpcy5sb2NhbFBhcnRpY2lwYW50KTtcbiAgfTtcblxuICBwcml2YXRlIG9uTG9jYWxUcmFja1B1Ymxpc2hlZCA9IGFzeW5jIChwdWI6IExvY2FsVHJhY2tQdWJsaWNhdGlvbikgPT4ge1xuICAgIHRoaXMuZW1pdChSb29tRXZlbnQuTG9jYWxUcmFja1B1Ymxpc2hlZCwgcHViLCB0aGlzLmxvY2FsUGFydGljaXBhbnQpO1xuICAgIGlmIChwdWIudHJhY2sgaW5zdGFuY2VvZiBMb2NhbEF1ZGlvVHJhY2spIHtcbiAgICAgIGNvbnN0IHRyYWNrSXNTaWxlbnQgPSBhd2FpdCBwdWIudHJhY2suY2hlY2tGb3JTaWxlbmNlKCk7XG4gICAgICBpZiAodHJhY2tJc1NpbGVudCkge1xuICAgICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkxvY2FsQXVkaW9TaWxlbmNlRGV0ZWN0ZWQsIHB1Yik7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGRldmljZUlkID0gYXdhaXQgcHViLnRyYWNrPy5nZXREZXZpY2VJZCgpO1xuICAgIGNvbnN0IGRldmljZUtpbmQgPSBzb3VyY2VUb0tpbmQocHViLnNvdXJjZSk7XG4gICAgaWYgKFxuICAgICAgZGV2aWNlS2luZCAmJlxuICAgICAgZGV2aWNlSWQgJiZcbiAgICAgIGRldmljZUlkICE9PSB0aGlzLmxvY2FsUGFydGljaXBhbnQuYWN0aXZlRGV2aWNlTWFwLmdldChkZXZpY2VLaW5kKVxuICAgICkge1xuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmFjdGl2ZURldmljZU1hcC5zZXQoZGV2aWNlS2luZCwgZGV2aWNlSWQpO1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5BY3RpdmVEZXZpY2VDaGFuZ2VkLCBkZXZpY2VLaW5kLCBkZXZpY2VJZCk7XG4gICAgfVxuICB9O1xuXG4gIHByaXZhdGUgb25Mb2NhbFRyYWNrVW5wdWJsaXNoZWQgPSAocHViOiBMb2NhbFRyYWNrUHVibGljYXRpb24pID0+IHtcbiAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCwgcHViLCB0aGlzLmxvY2FsUGFydGljaXBhbnQpO1xuICB9O1xuXG4gIHByaXZhdGUgb25Mb2NhbENvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCA9IChxdWFsaXR5OiBDb25uZWN0aW9uUXVhbGl0eSkgPT4ge1xuICAgIHRoaXMuZW1pdChSb29tRXZlbnQuQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkLCBxdWFsaXR5LCB0aGlzLmxvY2FsUGFydGljaXBhbnQpO1xuICB9O1xuXG4gIHByaXZhdGUgb25NZWRpYURldmljZXNFcnJvciA9IChlOiBFcnJvcikgPT4ge1xuICAgIHRoaXMuZW1pdChSb29tRXZlbnQuTWVkaWFEZXZpY2VzRXJyb3IsIGUpO1xuICB9O1xuXG4gIHByaXZhdGUgb25Mb2NhbFBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkID0gKHByZXZQZXJtaXNzaW9ucz86IFBhcnRpY2lwYW50UGVybWlzc2lvbikgPT4ge1xuICAgIHRoaXMuZW1pdChSb29tRXZlbnQuUGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWQsIHByZXZQZXJtaXNzaW9ucywgdGhpcy5sb2NhbFBhcnRpY2lwYW50KTtcbiAgfTtcblxuICAvKipcbiAgICogQWxsb3dzIHRvIHBvcHVsYXRlIGEgcm9vbSB3aXRoIHNpbXVsYXRlZCBwYXJ0aWNpcGFudHMuXG4gICAqIE5vIGFjdHVhbCBjb25uZWN0aW9uIHRvIGEgc2VydmVyIHdpbGwgYmUgZXN0YWJsaXNoZWQsIGFsbCBzdGF0ZSBpc1xuICAgKiBAZXhwZXJpbWVudGFsXG4gICAqL1xuICBhc3luYyBzaW11bGF0ZVBhcnRpY2lwYW50cyhvcHRpb25zOiBTaW11bGF0aW9uT3B0aW9ucykge1xuICAgIGNvbnN0IHB1Ymxpc2hPcHRpb25zID0ge1xuICAgICAgYXVkaW86IHRydWUsXG4gICAgICB2aWRlbzogdHJ1ZSxcbiAgICAgIHVzZVJlYWxUcmFja3M6IGZhbHNlLFxuICAgICAgLi4ub3B0aW9ucy5wdWJsaXNoLFxuICAgIH07XG4gICAgY29uc3QgcGFydGljaXBhbnRPcHRpb25zID0ge1xuICAgICAgY291bnQ6IDksXG4gICAgICBhdWRpbzogZmFsc2UsXG4gICAgICB2aWRlbzogdHJ1ZSxcbiAgICAgIGFzcGVjdFJhdGlvczogWzEuNjYsIDEuNywgMS4zXSxcbiAgICAgIC4uLm9wdGlvbnMucGFydGljaXBhbnRzLFxuICAgIH07XG4gICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KCk7XG4gICAgdGhpcy5yb29tSW5mbyA9IG5ldyBSb29tTW9kZWwoe1xuICAgICAgc2lkOiAnUk1fU0lNVUxBVEVEJyxcbiAgICAgIG5hbWU6ICdzaW11bGF0ZWQtcm9vbScsXG4gICAgICBlbXB0eVRpbWVvdXQ6IDAsXG4gICAgICBtYXhQYXJ0aWNpcGFudHM6IDAsXG4gICAgICBjcmVhdGlvblRpbWU6IHByb3RvSW50NjQucGFyc2UobmV3IERhdGUoKS5nZXRUaW1lKCkpLFxuICAgICAgbWV0YWRhdGE6ICcnLFxuICAgICAgbnVtUGFydGljaXBhbnRzOiAxLFxuICAgICAgbnVtUHVibGlzaGVyczogMSxcbiAgICAgIHR1cm5QYXNzd29yZDogJycsXG4gICAgICBlbmFibGVkQ29kZWNzOiBbXSxcbiAgICAgIGFjdGl2ZVJlY29yZGluZzogZmFsc2UsXG4gICAgfSk7XG5cbiAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQudXBkYXRlSW5mbyhcbiAgICAgIG5ldyBQYXJ0aWNpcGFudEluZm8oe1xuICAgICAgICBpZGVudGl0eTogJ3NpbXVsYXRlZC1sb2NhbCcsXG4gICAgICAgIG5hbWU6ICdsb2NhbC1uYW1lJyxcbiAgICAgIH0pLFxuICAgICk7XG4gICAgdGhpcy5zZXR1cExvY2FsUGFydGljaXBhbnRFdmVudHMoKTtcbiAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlNpZ25hbENvbm5lY3RlZCk7XG4gICAgdGhpcy5lbWl0KFJvb21FdmVudC5Db25uZWN0ZWQpO1xuICAgIHRoaXMuc2V0QW5kRW1pdENvbm5lY3Rpb25TdGF0ZShDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGVkKTtcbiAgICBpZiAocHVibGlzaE9wdGlvbnMudmlkZW8pIHtcbiAgICAgIGNvbnN0IGNhbVB1YiA9IG5ldyBMb2NhbFRyYWNrUHVibGljYXRpb24oXG4gICAgICAgIFRyYWNrLktpbmQuVmlkZW8sXG4gICAgICAgIG5ldyBUcmFja0luZm8oe1xuICAgICAgICAgIHNvdXJjZTogVHJhY2tTb3VyY2UuQ0FNRVJBLFxuICAgICAgICAgIHNpZDogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTBfMDAwKS50b1N0cmluZygpLFxuICAgICAgICAgIHR5cGU6IFRyYWNrVHlwZS5BVURJTyxcbiAgICAgICAgICBuYW1lOiAndmlkZW8tZHVtbXknLFxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IExvY2FsVmlkZW9UcmFjayhcbiAgICAgICAgICBwdWJsaXNoT3B0aW9ucy51c2VSZWFsVHJhY2tzXG4gICAgICAgICAgICA/IChcbiAgICAgICAgICAgICAgICBhd2FpdCB3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoeyB2aWRlbzogdHJ1ZSB9KVxuICAgICAgICAgICAgICApLmdldFZpZGVvVHJhY2tzKClbMF1cbiAgICAgICAgICAgIDogY3JlYXRlRHVtbXlWaWRlb1N0cmVhbVRyYWNrKFxuICAgICAgICAgICAgICAgIDE2MCAqIChwYXJ0aWNpcGFudE9wdGlvbnMuYXNwZWN0UmF0aW9zWzBdID8/IDEpLFxuICAgICAgICAgICAgICAgIDE2MCxcbiAgICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIHsgbG9nZ2VyTmFtZTogdGhpcy5vcHRpb25zLmxvZ2dlck5hbWUsIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0IH0sXG4gICAgICAgICksXG4gICAgICAgIHsgbG9nZ2VyTmFtZTogdGhpcy5vcHRpb25zLmxvZ2dlck5hbWUsIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0IH0sXG4gICAgICApO1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmFkZFRyYWNrUHVibGljYXRpb24oY2FtUHViKTtcbiAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5lbWl0KFBhcnRpY2lwYW50RXZlbnQuTG9jYWxUcmFja1B1Ymxpc2hlZCwgY2FtUHViKTtcbiAgICB9XG4gICAgaWYgKHB1Ymxpc2hPcHRpb25zLmF1ZGlvKSB7XG4gICAgICBjb25zdCBhdWRpb1B1YiA9IG5ldyBMb2NhbFRyYWNrUHVibGljYXRpb24oXG4gICAgICAgIFRyYWNrLktpbmQuQXVkaW8sXG4gICAgICAgIG5ldyBUcmFja0luZm8oe1xuICAgICAgICAgIHNvdXJjZTogVHJhY2tTb3VyY2UuTUlDUk9QSE9ORSxcbiAgICAgICAgICBzaWQ6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwXzAwMCkudG9TdHJpbmcoKSxcbiAgICAgICAgICB0eXBlOiBUcmFja1R5cGUuQVVESU8sXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgTG9jYWxBdWRpb1RyYWNrKFxuICAgICAgICAgIHB1Ymxpc2hPcHRpb25zLnVzZVJlYWxUcmFja3NcbiAgICAgICAgICAgID8gKGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHsgYXVkaW86IHRydWUgfSkpLmdldEF1ZGlvVHJhY2tzKClbMF1cbiAgICAgICAgICAgIDogZ2V0RW1wdHlBdWRpb1N0cmVhbVRyYWNrKCksXG4gICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIHRoaXMuYXVkaW9Db250ZXh0LFxuICAgICAgICAgIHsgbG9nZ2VyTmFtZTogdGhpcy5vcHRpb25zLmxvZ2dlck5hbWUsIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0IH0sXG4gICAgICAgICksXG4gICAgICAgIHsgbG9nZ2VyTmFtZTogdGhpcy5vcHRpb25zLmxvZ2dlck5hbWUsIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0IH0sXG4gICAgICApO1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmFkZFRyYWNrUHVibGljYXRpb24oYXVkaW9QdWIpO1xuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmVtaXQoUGFydGljaXBhbnRFdmVudC5Mb2NhbFRyYWNrUHVibGlzaGVkLCBhdWRpb1B1Yik7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0aWNpcGFudE9wdGlvbnMuY291bnQgLSAxOyBpICs9IDEpIHtcbiAgICAgIGxldCBpbmZvOiBQYXJ0aWNpcGFudEluZm8gPSBuZXcgUGFydGljaXBhbnRJbmZvKHtcbiAgICAgICAgc2lkOiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMF8wMDApLnRvU3RyaW5nKCksXG4gICAgICAgIGlkZW50aXR5OiBgc2ltdWxhdGVkLSR7aX1gLFxuICAgICAgICBzdGF0ZTogUGFydGljaXBhbnRJbmZvX1N0YXRlLkFDVElWRSxcbiAgICAgICAgdHJhY2tzOiBbXSxcbiAgICAgICAgam9pbmVkQXQ6IHByb3RvSW50NjQucGFyc2UoRGF0ZS5ub3coKSksXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHAgPSB0aGlzLmdldE9yQ3JlYXRlUGFydGljaXBhbnQoaW5mby5pZGVudGl0eSwgaW5mbyk7XG4gICAgICBpZiAocGFydGljaXBhbnRPcHRpb25zLnZpZGVvKSB7XG4gICAgICAgIGNvbnN0IGR1bW15VmlkZW8gPSBjcmVhdGVEdW1teVZpZGVvU3RyZWFtVHJhY2soXG4gICAgICAgICAgMTYwICogKHBhcnRpY2lwYW50T3B0aW9ucy5hc3BlY3RSYXRpb3NbaSAlIHBhcnRpY2lwYW50T3B0aW9ucy5hc3BlY3RSYXRpb3MubGVuZ3RoXSA/PyAxKSxcbiAgICAgICAgICAxNjAsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgdmlkZW9UcmFjayA9IG5ldyBUcmFja0luZm8oe1xuICAgICAgICAgIHNvdXJjZTogVHJhY2tTb3VyY2UuQ0FNRVJBLFxuICAgICAgICAgIHNpZDogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTBfMDAwKS50b1N0cmluZygpLFxuICAgICAgICAgIHR5cGU6IFRyYWNrVHlwZS5BVURJTyxcbiAgICAgICAgfSk7XG4gICAgICAgIHAuYWRkU3Vic2NyaWJlZE1lZGlhVHJhY2soZHVtbXlWaWRlbywgdmlkZW9UcmFjay5zaWQsIG5ldyBNZWRpYVN0cmVhbShbZHVtbXlWaWRlb10pKTtcbiAgICAgICAgaW5mby50cmFja3MgPSBbLi4uaW5mby50cmFja3MsIHZpZGVvVHJhY2tdO1xuICAgICAgfVxuICAgICAgaWYgKHBhcnRpY2lwYW50T3B0aW9ucy5hdWRpbykge1xuICAgICAgICBjb25zdCBkdW1teVRyYWNrID0gZ2V0RW1wdHlBdWRpb1N0cmVhbVRyYWNrKCk7XG4gICAgICAgIGNvbnN0IGF1ZGlvVHJhY2sgPSBuZXcgVHJhY2tJbmZvKHtcbiAgICAgICAgICBzb3VyY2U6IFRyYWNrU291cmNlLk1JQ1JPUEhPTkUsXG4gICAgICAgICAgc2lkOiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMF8wMDApLnRvU3RyaW5nKCksXG4gICAgICAgICAgdHlwZTogVHJhY2tUeXBlLkFVRElPLFxuICAgICAgICB9KTtcbiAgICAgICAgcC5hZGRTdWJzY3JpYmVkTWVkaWFUcmFjayhkdW1teVRyYWNrLCBhdWRpb1RyYWNrLnNpZCwgbmV3IE1lZGlhU3RyZWFtKFtkdW1teVRyYWNrXSkpO1xuICAgICAgICBpbmZvLnRyYWNrcyA9IFsuLi5pbmZvLnRyYWNrcywgYXVkaW9UcmFja107XG4gICAgICB9XG5cbiAgICAgIHAudXBkYXRlSW5mbyhpbmZvKTtcbiAgICB9XG4gIH1cblxuICAvLyAvKiogQGludGVybmFsICovXG4gIGVtaXQ8RSBleHRlbmRzIGtleW9mIFJvb21FdmVudENhbGxiYWNrcz4oXG4gICAgZXZlbnQ6IEUsXG4gICAgLi4uYXJnczogUGFyYW1ldGVyczxSb29tRXZlbnRDYWxsYmFja3NbRV0+XG4gICk6IGJvb2xlYW4ge1xuICAgIC8vIGFjdGl2ZSBzcGVha2VyIHVwZGF0ZXMgYXJlIHRvbyBzcGFtbXlcbiAgICBpZiAoZXZlbnQgIT09IFJvb21FdmVudC5BY3RpdmVTcGVha2Vyc0NoYW5nZWQpIHtcbiAgICAgIC8vIG9ubHkgZXh0cmFjdCBsb2dDb250ZXh0IGZyb20gYXJndW1lbnRzIGluIG9yZGVyIHRvIGF2b2lkIGxvZ2dpbmcgdGhlIHdob2xlIG9iamVjdCB0cmVlXG4gICAgICBjb25zdCBtaW5pbWl6ZWRBcmdzID0gbWFwQXJncyhhcmdzKS5maWx0ZXIoKGFyZzogdW5rbm93bikgPT4gYXJnICE9PSB1bmRlZmluZWQpO1xuICAgICAgdGhpcy5sb2cuZGVidWcoYHJvb20gZXZlbnQgJHtldmVudH1gLCB7IC4uLnRoaXMubG9nQ29udGV4dCwgZXZlbnQsIGFyZ3M6IG1pbmltaXplZEFyZ3MgfSk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5lbWl0KGV2ZW50LCAuLi5hcmdzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXBBcmdzKGFyZ3M6IHVua25vd25bXSk6IGFueSB7XG4gIHJldHVybiBhcmdzLm1hcCgoYXJnOiB1bmtub3duKSA9PiB7XG4gICAgaWYgKCFhcmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgcmV0dXJuIG1hcEFyZ3MoYXJnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhcmcgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gJ2xvZ0NvbnRleHQnIGluIGFyZyAmJiBhcmcubG9nQ29udGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIGFyZztcbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFJvb207XG5cbmV4cG9ydCB0eXBlIFJvb21FdmVudENhbGxiYWNrcyA9IHtcbiAgY29ubmVjdGVkOiAoKSA9PiB2b2lkO1xuICByZWNvbm5lY3Rpbmc6ICgpID0+IHZvaWQ7XG4gIHJlY29ubmVjdGVkOiAoKSA9PiB2b2lkO1xuICBkaXNjb25uZWN0ZWQ6IChyZWFzb24/OiBEaXNjb25uZWN0UmVhc29uKSA9PiB2b2lkO1xuICAvKiogQGRlcHJlY2F0ZWQgc3RhdGVDaGFuZ2VkIGhhcyBiZWVuIHJlbmFtZWQgdG8gY29ubmVjdGlvblN0YXRlQ2hhbmdlZCAqL1xuICBzdGF0ZUNoYW5nZWQ6IChzdGF0ZTogQ29ubmVjdGlvblN0YXRlKSA9PiB2b2lkO1xuICBjb25uZWN0aW9uU3RhdGVDaGFuZ2VkOiAoc3RhdGU6IENvbm5lY3Rpb25TdGF0ZSkgPT4gdm9pZDtcbiAgbWVkaWFEZXZpY2VzQ2hhbmdlZDogKCkgPT4gdm9pZDtcbiAgcGFydGljaXBhbnRDb25uZWN0ZWQ6IChwYXJ0aWNpcGFudDogUmVtb3RlUGFydGljaXBhbnQpID0+IHZvaWQ7XG4gIHBhcnRpY2lwYW50RGlzY29ubmVjdGVkOiAocGFydGljaXBhbnQ6IFJlbW90ZVBhcnRpY2lwYW50KSA9PiB2b2lkO1xuICB0cmFja1B1Ymxpc2hlZDogKHB1YmxpY2F0aW9uOiBSZW1vdGVUcmFja1B1YmxpY2F0aW9uLCBwYXJ0aWNpcGFudDogUmVtb3RlUGFydGljaXBhbnQpID0+IHZvaWQ7XG4gIHRyYWNrU3Vic2NyaWJlZDogKFxuICAgIHRyYWNrOiBSZW1vdGVUcmFjayxcbiAgICBwdWJsaWNhdGlvbjogUmVtb3RlVHJhY2tQdWJsaWNhdGlvbixcbiAgICBwYXJ0aWNpcGFudDogUmVtb3RlUGFydGljaXBhbnQsXG4gICkgPT4gdm9pZDtcbiAgdHJhY2tTdWJzY3JpcHRpb25GYWlsZWQ6IChcbiAgICB0cmFja1NpZDogc3RyaW5nLFxuICAgIHBhcnRpY2lwYW50OiBSZW1vdGVQYXJ0aWNpcGFudCxcbiAgICByZWFzb24/OiBTdWJzY3JpcHRpb25FcnJvcixcbiAgKSA9PiB2b2lkO1xuICB0cmFja1VucHVibGlzaGVkOiAocHVibGljYXRpb246IFJlbW90ZVRyYWNrUHVibGljYXRpb24sIHBhcnRpY2lwYW50OiBSZW1vdGVQYXJ0aWNpcGFudCkgPT4gdm9pZDtcbiAgdHJhY2tVbnN1YnNjcmliZWQ6IChcbiAgICB0cmFjazogUmVtb3RlVHJhY2ssXG4gICAgcHVibGljYXRpb246IFJlbW90ZVRyYWNrUHVibGljYXRpb24sXG4gICAgcGFydGljaXBhbnQ6IFJlbW90ZVBhcnRpY2lwYW50LFxuICApID0+IHZvaWQ7XG4gIHRyYWNrTXV0ZWQ6IChwdWJsaWNhdGlvbjogVHJhY2tQdWJsaWNhdGlvbiwgcGFydGljaXBhbnQ6IFBhcnRpY2lwYW50KSA9PiB2b2lkO1xuICB0cmFja1VubXV0ZWQ6IChwdWJsaWNhdGlvbjogVHJhY2tQdWJsaWNhdGlvbiwgcGFydGljaXBhbnQ6IFBhcnRpY2lwYW50KSA9PiB2b2lkO1xuICBsb2NhbFRyYWNrUHVibGlzaGVkOiAocHVibGljYXRpb246IExvY2FsVHJhY2tQdWJsaWNhdGlvbiwgcGFydGljaXBhbnQ6IExvY2FsUGFydGljaXBhbnQpID0+IHZvaWQ7XG4gIGxvY2FsVHJhY2tVbnB1Ymxpc2hlZDogKFxuICAgIHB1YmxpY2F0aW9uOiBMb2NhbFRyYWNrUHVibGljYXRpb24sXG4gICAgcGFydGljaXBhbnQ6IExvY2FsUGFydGljaXBhbnQsXG4gICkgPT4gdm9pZDtcbiAgbG9jYWxBdWRpb1NpbGVuY2VEZXRlY3RlZDogKHB1YmxpY2F0aW9uOiBMb2NhbFRyYWNrUHVibGljYXRpb24pID0+IHZvaWQ7XG4gIHBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkOiAoXG4gICAgbWV0YWRhdGE6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICBwYXJ0aWNpcGFudDogUmVtb3RlUGFydGljaXBhbnQgfCBMb2NhbFBhcnRpY2lwYW50LFxuICApID0+IHZvaWQ7XG4gIHBhcnRpY2lwYW50TmFtZUNoYW5nZWQ6IChuYW1lOiBzdHJpbmcsIHBhcnRpY2lwYW50OiBSZW1vdGVQYXJ0aWNpcGFudCB8IExvY2FsUGFydGljaXBhbnQpID0+IHZvaWQ7XG4gIHBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkOiAoXG4gICAgcHJldlBlcm1pc3Npb25zOiBQYXJ0aWNpcGFudFBlcm1pc3Npb24gfCB1bmRlZmluZWQsXG4gICAgcGFydGljaXBhbnQ6IFJlbW90ZVBhcnRpY2lwYW50IHwgTG9jYWxQYXJ0aWNpcGFudCxcbiAgKSA9PiB2b2lkO1xuICBhY3RpdmVTcGVha2Vyc0NoYW5nZWQ6IChzcGVha2VyczogQXJyYXk8UGFydGljaXBhbnQ+KSA9PiB2b2lkO1xuICByb29tTWV0YWRhdGFDaGFuZ2VkOiAobWV0YWRhdGE6IHN0cmluZykgPT4gdm9pZDtcbiAgZGF0YVJlY2VpdmVkOiAoXG4gICAgcGF5bG9hZDogVWludDhBcnJheSxcbiAgICBwYXJ0aWNpcGFudD86IFJlbW90ZVBhcnRpY2lwYW50LFxuICAgIGtpbmQ/OiBEYXRhUGFja2V0X0tpbmQsXG4gICAgdG9waWM/OiBzdHJpbmcsXG4gICkgPT4gdm9pZDtcbiAgY29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkOiAocXVhbGl0eTogQ29ubmVjdGlvblF1YWxpdHksIHBhcnRpY2lwYW50OiBQYXJ0aWNpcGFudCkgPT4gdm9pZDtcbiAgbWVkaWFEZXZpY2VzRXJyb3I6IChlcnJvcjogRXJyb3IpID0+IHZvaWQ7XG4gIHRyYWNrU3RyZWFtU3RhdGVDaGFuZ2VkOiAoXG4gICAgcHVibGljYXRpb246IFJlbW90ZVRyYWNrUHVibGljYXRpb24sXG4gICAgc3RyZWFtU3RhdGU6IFRyYWNrLlN0cmVhbVN0YXRlLFxuICAgIHBhcnRpY2lwYW50OiBSZW1vdGVQYXJ0aWNpcGFudCxcbiAgKSA9PiB2b2lkO1xuICB0cmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkOiAoXG4gICAgcHVibGljYXRpb246IFJlbW90ZVRyYWNrUHVibGljYXRpb24sXG4gICAgc3RhdHVzOiBUcmFja1B1YmxpY2F0aW9uLlBlcm1pc3Npb25TdGF0dXMsXG4gICAgcGFydGljaXBhbnQ6IFJlbW90ZVBhcnRpY2lwYW50LFxuICApID0+IHZvaWQ7XG4gIHRyYWNrU3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZDogKFxuICAgIHB1YmxpY2F0aW9uOiBSZW1vdGVUcmFja1B1YmxpY2F0aW9uLFxuICAgIHN0YXR1czogVHJhY2tQdWJsaWNhdGlvbi5TdWJzY3JpcHRpb25TdGF0dXMsXG4gICAgcGFydGljaXBhbnQ6IFJlbW90ZVBhcnRpY2lwYW50LFxuICApID0+IHZvaWQ7XG4gIGF1ZGlvUGxheWJhY2tDaGFuZ2VkOiAocGxheWluZzogYm9vbGVhbikgPT4gdm9pZDtcbiAgdmlkZW9QbGF5YmFja0NoYW5nZWQ6IChwbGF5aW5nOiBib29sZWFuKSA9PiB2b2lkO1xuICBzaWduYWxDb25uZWN0ZWQ6ICgpID0+IHZvaWQ7XG4gIHJlY29yZGluZ1N0YXR1c0NoYW5nZWQ6IChyZWNvcmRpbmc6IGJvb2xlYW4pID0+IHZvaWQ7XG4gIHBhcnRpY2lwYW50RW5jcnlwdGlvblN0YXR1c0NoYW5nZWQ6IChlbmNyeXB0ZWQ6IGJvb2xlYW4sIHBhcnRpY2lwYW50PzogUGFydGljaXBhbnQpID0+IHZvaWQ7XG4gIGVuY3J5cHRpb25FcnJvcjogKGVycm9yOiBFcnJvcikgPT4gdm9pZDtcbiAgZGNCdWZmZXJTdGF0dXNDaGFuZ2VkOiAoaXNMb3c6IGJvb2xlYW4sIGtpbmQ6IERhdGFQYWNrZXRfS2luZCkgPT4gdm9pZDtcbiAgYWN0aXZlRGV2aWNlQ2hhbmdlZDogKGtpbmQ6IE1lZGlhRGV2aWNlS2luZCwgZGV2aWNlSWQ6IHN0cmluZykgPT4gdm9pZDtcbn07XG4iLCJpbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnO1xuaW1wb3J0IHR5cGUgVHlwZWRFbWl0dGVyIGZyb20gJ3R5cGVkLWVtaXR0ZXInO1xuaW1wb3J0IHR5cGUgeyBSb29tQ29ubmVjdE9wdGlvbnMsIFJvb21PcHRpb25zIH0gZnJvbSAnLi4vLi4vb3B0aW9ucyc7XG5pbXBvcnQgdHlwZSBSVENFbmdpbmUgZnJvbSAnLi4vLi4vcm9vbS9SVENFbmdpbmUnO1xuaW1wb3J0IFJvb20sIHsgQ29ubmVjdGlvblN0YXRlIH0gZnJvbSAnLi4vLi4vcm9vbS9Sb29tJztcblxudHlwZSBMb2dNZXNzYWdlID0ge1xuICBsZXZlbDogJ2luZm8nIHwgJ3dhcm5pbmcnIHwgJ2Vycm9yJztcbiAgbWVzc2FnZTogc3RyaW5nO1xufTtcblxuZXhwb3J0IGVudW0gQ2hlY2tTdGF0dXMge1xuICBJRExFLFxuICBSVU5OSU5HLFxuICBTS0lQUEVELFxuICBTVUNDRVNTLFxuICBGQUlMRUQsXG59XG5cbmV4cG9ydCB0eXBlIENoZWNrSW5mbyA9IHtcbiAgbmFtZTogc3RyaW5nO1xuICBsb2dzOiBBcnJheTxMb2dNZXNzYWdlPjtcbiAgc3RhdHVzOiBDaGVja1N0YXR1cztcbiAgZGVzY3JpcHRpb246IHN0cmluZztcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hlY2tlck9wdGlvbnMge1xuICBlcnJvcnNBc1dhcm5pbmdzPzogYm9vbGVhbjtcbiAgcm9vbU9wdGlvbnM/OiBSb29tT3B0aW9ucztcbiAgY29ubmVjdE9wdGlvbnM/OiBSb29tQ29ubmVjdE9wdGlvbnM7XG59XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBDaGVja2VyIGV4dGVuZHMgKEV2ZW50RW1pdHRlciBhcyBuZXcgKCkgPT4gVHlwZWRFbWl0dGVyPENoZWNrZXJDYWxsYmFja3M+KSB7XG4gIHByb3RlY3RlZCB1cmw6IHN0cmluZztcblxuICBwcm90ZWN0ZWQgdG9rZW46IHN0cmluZztcblxuICByb29tOiBSb29tO1xuXG4gIGNvbm5lY3RPcHRpb25zPzogUm9vbUNvbm5lY3RPcHRpb25zO1xuXG4gIHN0YXR1czogQ2hlY2tTdGF0dXMgPSBDaGVja1N0YXR1cy5JRExFO1xuXG4gIGxvZ3M6IEFycmF5PExvZ01lc3NhZ2U+ID0gW107XG5cbiAgZXJyb3JzQXNXYXJuaW5nczogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIG5hbWU6IHN0cmluZztcblxuICBjb25zdHJ1Y3Rvcih1cmw6IHN0cmluZywgdG9rZW46IHN0cmluZywgb3B0aW9uczogQ2hlY2tlck9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgIHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICB0aGlzLnJvb20gPSBuZXcgUm9vbShvcHRpb25zLnJvb21PcHRpb25zKTtcbiAgICB0aGlzLmNvbm5lY3RPcHRpb25zID0gb3B0aW9ucy5jb25uZWN0T3B0aW9ucztcbiAgICBpZiAob3B0aW9ucy5lcnJvcnNBc1dhcm5pbmdzKSB7XG4gICAgICB0aGlzLmVycm9yc0FzV2FybmluZ3MgPSBvcHRpb25zLmVycm9yc0FzV2FybmluZ3M7XG4gICAgfVxuICB9XG5cbiAgYWJzdHJhY3QgZ2V0IGRlc2NyaXB0aW9uKCk6IHN0cmluZztcblxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgcGVyZm9ybSgpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIGFzeW5jIHJ1bihvbkNvbXBsZXRlPzogKCkgPT4gdm9pZCkge1xuICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gQ2hlY2tTdGF0dXMuSURMRSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ2NoZWNrIGlzIHJ1bm5pbmcgYWxyZWFkeScpO1xuICAgIH1cbiAgICB0aGlzLnNldFN0YXR1cyhDaGVja1N0YXR1cy5SVU5OSU5HKTtcblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLnBlcmZvcm0oKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBpZiAodGhpcy5lcnJvcnNBc1dhcm5pbmdzKSB7XG4gICAgICAgICAgdGhpcy5hcHBlbmRXYXJuaW5nKGVyci5tZXNzYWdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmFwcGVuZEVycm9yKGVyci5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGF3YWl0IHRoaXMuZGlzY29ubmVjdCgpO1xuXG4gICAgLy8gc2xlZXAgZm9yIGEgYml0IHRvIGVuc3VyZSBkaXNjb25uZWN0XG4gICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKSk7XG5cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKHRoaXMuc3RhdHVzICE9PSBDaGVja1N0YXR1cy5TS0lQUEVEKSB7XG4gICAgICB0aGlzLnNldFN0YXR1cyh0aGlzLmlzU3VjY2VzcygpID8gQ2hlY2tTdGF0dXMuU1VDQ0VTUyA6IENoZWNrU3RhdHVzLkZBSUxFRCk7XG4gICAgfVxuXG4gICAgaWYgKG9uQ29tcGxldGUpIHtcbiAgICAgIG9uQ29tcGxldGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5mbygpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGlzU3VjY2VzcygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gIXRoaXMubG9ncy5zb21lKChsKSA9PiBsLmxldmVsID09PSAnZXJyb3InKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBjb25uZWN0KCk6IFByb21pc2U8Um9vbT4ge1xuICAgIGlmICh0aGlzLnJvb20uc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0ZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnJvb207XG4gICAgfVxuICAgIGF3YWl0IHRoaXMucm9vbS5jb25uZWN0KHRoaXMudXJsLCB0aGlzLnRva2VuKTtcbiAgICByZXR1cm4gdGhpcy5yb29tO1xuICB9XG5cbiAgcHJvdGVjdGVkIGFzeW5jIGRpc2Nvbm5lY3QoKSB7XG4gICAgaWYgKHRoaXMucm9vbSAmJiB0aGlzLnJvb20uc3RhdGUgIT09IENvbm5lY3Rpb25TdGF0ZS5EaXNjb25uZWN0ZWQpIHtcbiAgICAgIGF3YWl0IHRoaXMucm9vbS5kaXNjb25uZWN0KCk7XG4gICAgICAvLyB3YWl0IGZvciBpdCB0byBnbyB0aHJvdWdoXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgc2tpcCgpIHtcbiAgICB0aGlzLnNldFN0YXR1cyhDaGVja1N0YXR1cy5TS0lQUEVEKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhcHBlbmRNZXNzYWdlKG1lc3NhZ2U6IHN0cmluZykge1xuICAgIHRoaXMubG9ncy5wdXNoKHsgbGV2ZWw6ICdpbmZvJywgbWVzc2FnZSB9KTtcbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIHRoaXMuZ2V0SW5mbygpKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhcHBlbmRXYXJuaW5nKG1lc3NhZ2U6IHN0cmluZykge1xuICAgIHRoaXMubG9ncy5wdXNoKHsgbGV2ZWw6ICd3YXJuaW5nJywgbWVzc2FnZSB9KTtcbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIHRoaXMuZ2V0SW5mbygpKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhcHBlbmRFcnJvcihtZXNzYWdlOiBzdHJpbmcpIHtcbiAgICB0aGlzLmxvZ3MucHVzaCh7IGxldmVsOiAnZXJyb3InLCBtZXNzYWdlIH0pO1xuICAgIHRoaXMuZW1pdCgndXBkYXRlJywgdGhpcy5nZXRJbmZvKCkpO1xuICB9XG5cbiAgcHJvdGVjdGVkIHNldFN0YXR1cyhzdGF0dXM6IENoZWNrU3RhdHVzKSB7XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgdGhpcy5lbWl0KCd1cGRhdGUnLCB0aGlzLmdldEluZm8oKSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0IGVuZ2luZSgpOiBSVENFbmdpbmUgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLnJvb20/LmVuZ2luZTtcbiAgfVxuXG4gIGdldEluZm8oKTogQ2hlY2tJbmZvIHtcbiAgICByZXR1cm4ge1xuICAgICAgbG9nczogdGhpcy5sb2dzLFxuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLmRlc2NyaXB0aW9uLFxuICAgIH07XG4gIH1cbn1cbmV4cG9ydCB0eXBlIEluc3RhbnRpYWJsZUNoZWNrPFQgZXh0ZW5kcyBDaGVja2VyPiA9IHtcbiAgbmV3ICh1cmw6IHN0cmluZywgdG9rZW46IHN0cmluZywgb3B0aW9ucz86IENoZWNrZXJPcHRpb25zKTogVDtcbn07XG5cbnR5cGUgQ2hlY2tlckNhbGxiYWNrcyA9IHtcbiAgdXBkYXRlOiAoaW5mbzogQ2hlY2tJbmZvKSA9PiB2b2lkO1xufTtcbiIsImltcG9ydCBEZXZpY2VNYW5hZ2VyIGZyb20gJy4uL0RldmljZU1hbmFnZXInO1xuaW1wb3J0IHsgYXVkaW9EZWZhdWx0cywgdmlkZW9EZWZhdWx0cyB9IGZyb20gJy4uL2RlZmF1bHRzJztcbmltcG9ydCB7IERldmljZVVuc3VwcG9ydGVkRXJyb3IsIFRyYWNrSW52YWxpZEVycm9yIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IG1lZGlhVHJhY2tUb0xvY2FsVHJhY2sgfSBmcm9tICcuLi9wYXJ0aWNpcGFudC9wdWJsaXNoVXRpbHMnO1xuaW1wb3J0IHsgaXNTYWZhcmkxNyB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCBMb2NhbEF1ZGlvVHJhY2sgZnJvbSAnLi9Mb2NhbEF1ZGlvVHJhY2snO1xuaW1wb3J0IHR5cGUgTG9jYWxUcmFjayBmcm9tICcuL0xvY2FsVHJhY2snO1xuaW1wb3J0IExvY2FsVmlkZW9UcmFjayBmcm9tICcuL0xvY2FsVmlkZW9UcmFjayc7XG5pbXBvcnQgeyBUcmFjayB9IGZyb20gJy4vVHJhY2snO1xuaW1wb3J0IHR5cGUge1xuICBBdWRpb0NhcHR1cmVPcHRpb25zLFxuICBDcmVhdGVMb2NhbFRyYWNrc09wdGlvbnMsXG4gIFNjcmVlblNoYXJlQ2FwdHVyZU9wdGlvbnMsXG4gIFZpZGVvQ2FwdHVyZU9wdGlvbnMsXG59IGZyb20gJy4vb3B0aW9ucyc7XG5pbXBvcnQgeyBTY3JlZW5TaGFyZVByZXNldHMgfSBmcm9tICcuL29wdGlvbnMnO1xuaW1wb3J0IHtcbiAgY29uc3RyYWludHNGb3JPcHRpb25zLFxuICBtZXJnZURlZmF1bHRPcHRpb25zLFxuICBzY3JlZW5DYXB0dXJlVG9EaXNwbGF5TWVkaWFTdHJlYW1PcHRpb25zLFxufSBmcm9tICcuL3V0aWxzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbG9jYWwgdmlkZW8gYW5kIGF1ZGlvIHRyYWNrIGF0IHRoZSBzYW1lIHRpbWUuIFdoZW4gYWNxdWlyaW5nIGJvdGhcbiAqIGF1ZGlvIGFuZCB2aWRlbyB0cmFja3MgdG9nZXRoZXIsIGl0J2xsIGRpc3BsYXkgYSBzaW5nbGUgcGVybWlzc2lvbiBwcm9tcHQgdG9cbiAqIHRoZSB1c2VyIGluc3RlYWQgb2YgdHdvIHNlcGFyYXRlIG9uZXMuXG4gKiBAcGFyYW0gb3B0aW9uc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlTG9jYWxUcmFja3MoXG4gIG9wdGlvbnM/OiBDcmVhdGVMb2NhbFRyYWNrc09wdGlvbnMsXG4pOiBQcm9taXNlPEFycmF5PExvY2FsVHJhY2s+PiB7XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnMgdG8gdHJ1ZVxuICBvcHRpb25zID8/PSB7fTtcbiAgb3B0aW9ucy5hdWRpbyA/Pz0gdHJ1ZTtcbiAgb3B0aW9ucy52aWRlbyA/Pz0gdHJ1ZTtcblxuICBjb25zdCBvcHRzID0gbWVyZ2VEZWZhdWx0T3B0aW9ucyhvcHRpb25zLCBhdWRpb0RlZmF1bHRzLCB2aWRlb0RlZmF1bHRzKTtcbiAgY29uc3QgY29uc3RyYWludHMgPSBjb25zdHJhaW50c0Zvck9wdGlvbnMob3B0cyk7XG5cbiAgLy8gS2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgcHJvbWlzZSBvbiBEZXZpY2VNYW5hZ2VyIGFuZCBhd2FpdCBpdCBpbiBnZXRMb2NhbERldmljZXMoKVxuICAvLyB3b3JrcyBhcm91bmQgaU9TIFNhZmFyaSBCdWcgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE3OTM2M1xuICBjb25zdCBtZWRpYVByb21pc2UgPSBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cyk7XG5cbiAgaWYgKG9wdGlvbnMuYXVkaW8pIHtcbiAgICBEZXZpY2VNYW5hZ2VyLnVzZXJNZWRpYVByb21pc2VNYXAuc2V0KCdhdWRpb2lucHV0JywgbWVkaWFQcm9taXNlKTtcbiAgICBtZWRpYVByb21pc2UuY2F0Y2goKCkgPT4gRGV2aWNlTWFuYWdlci51c2VyTWVkaWFQcm9taXNlTWFwLmRlbGV0ZSgnYXVkaW9pbnB1dCcpKTtcbiAgfVxuICBpZiAob3B0aW9ucy52aWRlbykge1xuICAgIERldmljZU1hbmFnZXIudXNlck1lZGlhUHJvbWlzZU1hcC5zZXQoJ3ZpZGVvaW5wdXQnLCBtZWRpYVByb21pc2UpO1xuICAgIG1lZGlhUHJvbWlzZS5jYXRjaCgoKSA9PiBEZXZpY2VNYW5hZ2VyLnVzZXJNZWRpYVByb21pc2VNYXAuZGVsZXRlKCd2aWRlb2lucHV0JykpO1xuICB9XG5cbiAgY29uc3Qgc3RyZWFtID0gYXdhaXQgbWVkaWFQcm9taXNlO1xuICByZXR1cm4gc3RyZWFtLmdldFRyYWNrcygpLm1hcCgobWVkaWFTdHJlYW1UcmFjaykgPT4ge1xuICAgIGNvbnN0IGlzQXVkaW8gPSBtZWRpYVN0cmVhbVRyYWNrLmtpbmQgPT09ICdhdWRpbyc7XG4gICAgbGV0IHRyYWNrT3B0aW9ucyA9IGlzQXVkaW8gPyBvcHRpb25zIS5hdWRpbyA6IG9wdGlvbnMhLnZpZGVvO1xuICAgIGlmICh0eXBlb2YgdHJhY2tPcHRpb25zID09PSAnYm9vbGVhbicgfHwgIXRyYWNrT3B0aW9ucykge1xuICAgICAgdHJhY2tPcHRpb25zID0ge307XG4gICAgfVxuICAgIGxldCB0cmFja0NvbnN0cmFpbnRzOiBNZWRpYVRyYWNrQ29uc3RyYWludHMgfCB1bmRlZmluZWQ7XG4gICAgY29uc3QgY29uT3JCb29sID0gaXNBdWRpbyA/IGNvbnN0cmFpbnRzLmF1ZGlvIDogY29uc3RyYWludHMudmlkZW87XG4gICAgaWYgKHR5cGVvZiBjb25PckJvb2wgIT09ICdib29sZWFuJykge1xuICAgICAgdHJhY2tDb25zdHJhaW50cyA9IGNvbk9yQm9vbDtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgdGhlIGNvbnN0cmFpbnRzIHdpdGggdGhlIGRldmljZSBpZCB0aGUgdXNlciBnYXZlIHBlcm1pc3Npb25zIHRvIGluIHRoZSBwZXJtaXNzaW9uIHByb21wdFxuICAgIC8vIG90aGVyd2lzZSBlYWNoIHRyYWNrIHJlc3RhcnQgKGUuZy4gbXV0ZSAtIHVubXV0ZSkgd2lsbCB0cnkgdG8gaW5pdGlhbGl6ZSB0aGUgZGV2aWNlIGFnYWluIC0+IGNhdXNpbmcgYWRkaXRpb25hbCBwZXJtaXNzaW9uIHByb21wdHNcbiAgICBpZiAodHJhY2tDb25zdHJhaW50cykge1xuICAgICAgdHJhY2tDb25zdHJhaW50cy5kZXZpY2VJZCA9IG1lZGlhU3RyZWFtVHJhY2suZ2V0U2V0dGluZ3MoKS5kZXZpY2VJZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhY2tDb25zdHJhaW50cyA9IHsgZGV2aWNlSWQ6IG1lZGlhU3RyZWFtVHJhY2suZ2V0U2V0dGluZ3MoKS5kZXZpY2VJZCB9O1xuICAgIH1cblxuICAgIGNvbnN0IHRyYWNrID0gbWVkaWFUcmFja1RvTG9jYWxUcmFjayhtZWRpYVN0cmVhbVRyYWNrLCB0cmFja0NvbnN0cmFpbnRzKTtcbiAgICBpZiAodHJhY2sua2luZCA9PT0gVHJhY2suS2luZC5WaWRlbykge1xuICAgICAgdHJhY2suc291cmNlID0gVHJhY2suU291cmNlLkNhbWVyYTtcbiAgICB9IGVsc2UgaWYgKHRyYWNrLmtpbmQgPT09IFRyYWNrLktpbmQuQXVkaW8pIHtcbiAgICAgIHRyYWNrLnNvdXJjZSA9IFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lO1xuICAgIH1cbiAgICB0cmFjay5tZWRpYVN0cmVhbSA9IHN0cmVhbTtcbiAgICByZXR1cm4gdHJhY2s7XG4gIH0pO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBbW0xvY2FsVmlkZW9UcmFja11dIHdpdGggZ2V0VXNlck1lZGlhKClcbiAqIEBwYXJhbSBvcHRpb25zXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVMb2NhbFZpZGVvVHJhY2soXG4gIG9wdGlvbnM/OiBWaWRlb0NhcHR1cmVPcHRpb25zLFxuKTogUHJvbWlzZTxMb2NhbFZpZGVvVHJhY2s+IHtcbiAgY29uc3QgdHJhY2tzID0gYXdhaXQgY3JlYXRlTG9jYWxUcmFja3Moe1xuICAgIGF1ZGlvOiBmYWxzZSxcbiAgICB2aWRlbzogb3B0aW9ucyxcbiAgfSk7XG4gIHJldHVybiA8TG9jYWxWaWRlb1RyYWNrPnRyYWNrc1swXTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUxvY2FsQXVkaW9UcmFjayhcbiAgb3B0aW9ucz86IEF1ZGlvQ2FwdHVyZU9wdGlvbnMsXG4pOiBQcm9taXNlPExvY2FsQXVkaW9UcmFjaz4ge1xuICBjb25zdCB0cmFja3MgPSBhd2FpdCBjcmVhdGVMb2NhbFRyYWNrcyh7XG4gICAgYXVkaW86IG9wdGlvbnMsXG4gICAgdmlkZW86IGZhbHNlLFxuICB9KTtcbiAgcmV0dXJuIDxMb2NhbEF1ZGlvVHJhY2s+dHJhY2tzWzBdO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBzY3JlZW4gY2FwdHVyZSB0cmFja3Mgd2l0aCBnZXREaXNwbGF5TWVkaWEoKS5cbiAqIEEgTG9jYWxWaWRlb1RyYWNrIGlzIGFsd2F5cyBjcmVhdGVkIGFuZCByZXR1cm5lZC5cbiAqIElmIHsgYXVkaW86IHRydWUgfSwgYW5kIHRoZSBicm93c2VyIHN1cHBvcnRzIGF1ZGlvIGNhcHR1cmUsIGEgTG9jYWxBdWRpb1RyYWNrIGlzIGFsc28gY3JlYXRlZC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUxvY2FsU2NyZWVuVHJhY2tzKFxuICBvcHRpb25zPzogU2NyZWVuU2hhcmVDYXB0dXJlT3B0aW9ucyxcbik6IFByb21pc2U8QXJyYXk8TG9jYWxUcmFjaz4+IHtcbiAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBpZiAob3B0aW9ucy5yZXNvbHV0aW9uID09PSB1bmRlZmluZWQgJiYgIWlzU2FmYXJpMTcoKSkge1xuICAgIG9wdGlvbnMucmVzb2x1dGlvbiA9IFNjcmVlblNoYXJlUHJlc2V0cy5oMTA4MGZwczMwLnJlc29sdXRpb247XG4gIH1cblxuICBpZiAobmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXREaXNwbGF5TWVkaWEgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBEZXZpY2VVbnN1cHBvcnRlZEVycm9yKCdnZXREaXNwbGF5TWVkaWEgbm90IHN1cHBvcnRlZCcpO1xuICB9XG5cbiAgY29uc3QgY29uc3RyYWludHMgPSBzY3JlZW5DYXB0dXJlVG9EaXNwbGF5TWVkaWFTdHJlYW1PcHRpb25zKG9wdGlvbnMpO1xuICBjb25zdCBzdHJlYW06IE1lZGlhU3RyZWFtID0gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXREaXNwbGF5TWVkaWEoY29uc3RyYWludHMpO1xuXG4gIGNvbnN0IHRyYWNrcyA9IHN0cmVhbS5nZXRWaWRlb1RyYWNrcygpO1xuICBpZiAodHJhY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBUcmFja0ludmFsaWRFcnJvcignbm8gdmlkZW8gdHJhY2sgZm91bmQnKTtcbiAgfVxuICBjb25zdCBzY3JlZW5WaWRlbyA9IG5ldyBMb2NhbFZpZGVvVHJhY2sodHJhY2tzWzBdLCB1bmRlZmluZWQsIGZhbHNlKTtcbiAgc2NyZWVuVmlkZW8uc291cmNlID0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlO1xuICBjb25zdCBsb2NhbFRyYWNrczogQXJyYXk8TG9jYWxUcmFjaz4gPSBbc2NyZWVuVmlkZW9dO1xuICBpZiAoc3RyZWFtLmdldEF1ZGlvVHJhY2tzKCkubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IHNjcmVlbkF1ZGlvID0gbmV3IExvY2FsQXVkaW9UcmFjayhzdHJlYW0uZ2V0QXVkaW9UcmFja3MoKVswXSwgdW5kZWZpbmVkLCBmYWxzZSk7XG4gICAgc2NyZWVuQXVkaW8uc291cmNlID0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlQXVkaW87XG4gICAgbG9jYWxUcmFja3MucHVzaChzY3JlZW5BdWRpbyk7XG4gIH1cbiAgcmV0dXJuIGxvY2FsVHJhY2tzO1xufVxuIiwiaW1wb3J0IHsgY3JlYXRlTG9jYWxBdWRpb1RyYWNrIH0gZnJvbSAnLi4vLi4vcm9vbS90cmFjay9jcmVhdGUnO1xuaW1wb3J0IHsgQ2hlY2tlciB9IGZyb20gJy4vQ2hlY2tlcic7XG5cbmV4cG9ydCBjbGFzcyBQdWJsaXNoQXVkaW9DaGVjayBleHRlbmRzIENoZWNrZXIge1xuICBnZXQgZGVzY3JpcHRpb24oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ0NhbiBwdWJsaXNoIGF1ZGlvJztcbiAgfVxuXG4gIGFzeW5jIHBlcmZvcm0oKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3Qgcm9vbSA9IGF3YWl0IHRoaXMuY29ubmVjdCgpO1xuXG4gICAgY29uc3QgdHJhY2sgPSBhd2FpdCBjcmVhdGVMb2NhbEF1ZGlvVHJhY2soKTtcbiAgICByb29tLmxvY2FsUGFydGljaXBhbnQucHVibGlzaFRyYWNrKHRyYWNrKTtcbiAgICAvLyB3YWl0IGZvciBhIGZldyBzZWNvbmRzIHRvIHB1Ymxpc2hcbiAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAzMDAwKSk7XG5cbiAgICAvLyB2ZXJpZnkgUlRDIHN0YXRzIHRoYXQgaXQncyBwdWJsaXNoaW5nXG4gICAgY29uc3Qgc3RhdHMgPSBhd2FpdCB0cmFjay5zZW5kZXI/LmdldFN0YXRzKCk7XG4gICAgaWYgKCFzdGF0cykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZ2V0IFJUQ1N0YXRzJyk7XG4gICAgfVxuICAgIGxldCBudW1QYWNrZXRzID0gMDtcbiAgICBzdGF0cy5mb3JFYWNoKChzdGF0KSA9PiB7XG4gICAgICBpZiAoc3RhdC50eXBlID09PSAnb3V0Ym91bmQtcnRwJyAmJiBzdGF0Lm1lZGlhVHlwZSA9PT0gJ2F1ZGlvJykge1xuICAgICAgICBudW1QYWNrZXRzID0gc3RhdC5wYWNrZXRzU2VudDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAobnVtUGFja2V0cyA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZGV0ZXJtaW5lIHBhY2tldHMgYXJlIHNlbnQnKTtcbiAgICB9XG4gICAgdGhpcy5hcHBlbmRNZXNzYWdlKGBwdWJsaXNoZWQgJHtudW1QYWNrZXRzfSBhdWRpbyBwYWNrZXRzYCk7XG4gIH1cbn1cbiIsImltcG9ydCB7IGNyZWF0ZUxvY2FsVmlkZW9UcmFjayB9IGZyb20gJy4uLy4uL3Jvb20vdHJhY2svY3JlYXRlJztcbmltcG9ydCB7IENoZWNrZXIgfSBmcm9tICcuL0NoZWNrZXInO1xuXG5leHBvcnQgY2xhc3MgUHVibGlzaFZpZGVvQ2hlY2sgZXh0ZW5kcyBDaGVja2VyIHtcbiAgZ2V0IGRlc2NyaXB0aW9uKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICdDYW4gcHVibGlzaCB2aWRlbyc7XG4gIH1cblxuICBhc3luYyBwZXJmb3JtKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHJvb20gPSBhd2FpdCB0aGlzLmNvbm5lY3QoKTtcblxuICAgIGNvbnN0IHRyYWNrID0gYXdhaXQgY3JlYXRlTG9jYWxWaWRlb1RyYWNrKCk7XG4gICAgcm9vbS5sb2NhbFBhcnRpY2lwYW50LnB1Ymxpc2hUcmFjayh0cmFjayk7XG4gICAgLy8gd2FpdCBmb3IgYSBmZXcgc2Vjb25kcyB0byBwdWJsaXNoXG4gICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMzAwMCkpO1xuXG4gICAgLy8gdmVyaWZ5IFJUQyBzdGF0cyB0aGF0IGl0J3MgcHVibGlzaGluZ1xuICAgIGNvbnN0IHN0YXRzID0gYXdhaXQgdHJhY2suc2VuZGVyPy5nZXRTdGF0cygpO1xuICAgIGlmICghc3RhdHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGdldCBSVENTdGF0cycpO1xuICAgIH1cbiAgICBsZXQgbnVtUGFja2V0cyA9IDA7XG4gICAgc3RhdHMuZm9yRWFjaCgoc3RhdCkgPT4ge1xuICAgICAgaWYgKHN0YXQudHlwZSA9PT0gJ291dGJvdW5kLXJ0cCcgJiYgc3RhdC5tZWRpYVR5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgICAgbnVtUGFja2V0cyA9IHN0YXQucGFja2V0c1NlbnQ7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKG51bVBhY2tldHMgPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGRldGVybWluZSBwYWNrZXRzIGFyZSBzZW50Jyk7XG4gICAgfVxuICAgIHRoaXMuYXBwZW5kTWVzc2FnZShgcHVibGlzaGVkICR7bnVtUGFja2V0c30gdmlkZW8gcGFja2V0c2ApO1xuICB9XG59XG4iLCJpbXBvcnQgeyBDb25uZWN0aW9uU3RhdGUgfSBmcm9tICcuLi8uLi9yb29tL1Jvb20nO1xuaW1wb3J0IHsgUm9vbUV2ZW50IH0gZnJvbSAnLi4vLi4vcm9vbS9ldmVudHMnO1xuaW1wb3J0IHsgQ2hlY2tlciB9IGZyb20gJy4vQ2hlY2tlcic7XG5cbmV4cG9ydCBjbGFzcyBSZWNvbm5lY3RDaGVjayBleHRlbmRzIENoZWNrZXIge1xuICBnZXQgZGVzY3JpcHRpb24oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ1Jlc3VtaW5nIGNvbm5lY3Rpb24gYWZ0ZXIgaW50ZXJydXB0aW9uJztcbiAgfVxuXG4gIGFzeW5jIHBlcmZvcm0oKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3Qgcm9vbSA9IGF3YWl0IHRoaXMuY29ubmVjdCgpO1xuICAgIGxldCByZWNvbm5lY3RpbmdUcmlnZ2VyZWQgPSBmYWxzZTtcbiAgICBsZXQgcmVjb25uZWN0ZWQgPSBmYWxzZTtcblxuICAgIGxldCByZWNvbm5lY3RSZXNvbHZlcjogKHZhbHVlOiB1bmtub3duKSA9PiB2b2lkO1xuICAgIGNvbnN0IHJlY29ubmVjdFRpbWVvdXQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgc2V0VGltZW91dChyZXNvbHZlLCA1MDAwKTtcbiAgICAgIHJlY29ubmVjdFJlc29sdmVyID0gcmVzb2x2ZTtcbiAgICB9KTtcblxuICAgIHJvb21cbiAgICAgIC5vbihSb29tRXZlbnQuUmVjb25uZWN0aW5nLCAoKSA9PiB7XG4gICAgICAgIHJlY29ubmVjdGluZ1RyaWdnZXJlZCA9IHRydWU7XG4gICAgICB9KVxuICAgICAgLm9uKFJvb21FdmVudC5SZWNvbm5lY3RlZCwgKCkgPT4ge1xuICAgICAgICByZWNvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgIHJlY29ubmVjdFJlc29sdmVyKHRydWUpO1xuICAgICAgfSk7XG5cbiAgICByb29tLmVuZ2luZS5jbGllbnQud3M/LmNsb3NlKCk7XG4gICAgY29uc3Qgb25DbG9zZSA9IHJvb20uZW5naW5lLmNsaWVudC5vbkNsb3NlO1xuICAgIGlmIChvbkNsb3NlKSB7XG4gICAgICBvbkNsb3NlKCcnKTtcbiAgICB9XG5cbiAgICBhd2FpdCByZWNvbm5lY3RUaW1lb3V0O1xuXG4gICAgaWYgKCFyZWNvbm5lY3RpbmdUcmlnZ2VyZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRGlkIG5vdCBhdHRlbXB0IHRvIHJlY29ubmVjdCcpO1xuICAgIH0gZWxzZSBpZiAoIXJlY29ubmVjdGVkIHx8IHJvb20uc3RhdGUgIT09IENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0ZWQpIHtcbiAgICAgIHRoaXMuYXBwZW5kV2FybmluZygncmVjb25uZWN0aW9uIGlzIG9ubHkgcG9zc2libGUgaW4gUmVkaXMtYmFzZWQgY29uZmlndXJhdGlvbnMnKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGFibGUgdG8gcmVjb25uZWN0Jyk7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgeyBTaWduYWxDbGllbnQgfSBmcm9tICcuLi8uLi9hcGkvU2lnbmFsQ2xpZW50JztcbmltcG9ydCB7IENoZWNrZXIgfSBmcm9tICcuL0NoZWNrZXInO1xuXG5leHBvcnQgY2xhc3MgVFVSTkNoZWNrIGV4dGVuZHMgQ2hlY2tlciB7XG4gIGdldCBkZXNjcmlwdGlvbigpOiBzdHJpbmcge1xuICAgIHJldHVybiAnQ2FuIGNvbm5lY3QgdmlhIFRVUk4nO1xuICB9XG5cbiAgYXN5bmMgcGVyZm9ybSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBzaWduYWxDbGllbnQgPSBuZXcgU2lnbmFsQ2xpZW50KCk7XG4gICAgY29uc3Qgam9pblJlcyA9IGF3YWl0IHNpZ25hbENsaWVudC5qb2luKHRoaXMudXJsLCB0aGlzLnRva2VuLCB7XG4gICAgICBhdXRvU3Vic2NyaWJlOiB0cnVlLFxuICAgICAgbWF4UmV0cmllczogMCxcbiAgICAgIGUyZWVFbmFibGVkOiBmYWxzZSxcbiAgICAgIHdlYnNvY2tldFRpbWVvdXQ6IDE1XzAwMCxcbiAgICB9KTtcblxuICAgIGxldCBoYXNUTFMgPSBmYWxzZTtcbiAgICBsZXQgaGFzVFVSTiA9IGZhbHNlO1xuICAgIGxldCBoYXNTVFVOID0gZmFsc2U7XG5cbiAgICBmb3IgKGxldCBpY2VTZXJ2ZXIgb2Ygam9pblJlcy5pY2VTZXJ2ZXJzKSB7XG4gICAgICBmb3IgKGxldCB1cmwgb2YgaWNlU2VydmVyLnVybHMpIHtcbiAgICAgICAgaWYgKHVybC5zdGFydHNXaXRoKCd0dXJuOicpKSB7XG4gICAgICAgICAgaGFzVFVSTiA9IHRydWU7XG4gICAgICAgICAgaGFzU1RVTiA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAodXJsLnN0YXJ0c1dpdGgoJ3R1cm5zOicpKSB7XG4gICAgICAgICAgaGFzVFVSTiA9IHRydWU7XG4gICAgICAgICAgaGFzU1RVTiA9IHRydWU7XG4gICAgICAgICAgaGFzVExTID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXJsLnN0YXJ0c1dpdGgoJ3N0dW46JykpIHtcbiAgICAgICAgICBoYXNTVFVOID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWhhc1NUVU4pIHtcbiAgICAgIHRoaXMuYXBwZW5kV2FybmluZygnTm8gU1RVTiBzZXJ2ZXJzIGNvbmZpZ3VyZWQgb24gc2VydmVyIHNpZGUuJyk7XG4gICAgfSBlbHNlIGlmIChoYXNUVVJOICYmICFoYXNUTFMpIHtcbiAgICAgIHRoaXMuYXBwZW5kV2FybmluZygnVFVSTiBpcyBjb25maWd1cmVkIHNlcnZlciBzaWRlLCBidXQgVFVSTi9UTFMgaXMgdW5hdmFpbGFibGUuJyk7XG4gICAgfVxuICAgIGF3YWl0IHNpZ25hbENsaWVudC5jbG9zZSgpO1xuICAgIGlmICh0aGlzLmNvbm5lY3RPcHRpb25zPy5ydGNDb25maWc/LmljZVNlcnZlcnMgfHwgaGFzVFVSTikge1xuICAgICAgYXdhaXQgdGhpcy5yb29tIS5jb25uZWN0KHRoaXMudXJsLCB0aGlzLnRva2VuLCB7XG4gICAgICAgIHJ0Y0NvbmZpZzoge1xuICAgICAgICAgIGljZVRyYW5zcG9ydFBvbGljeTogJ3JlbGF5JyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFwcGVuZFdhcm5pbmcoJ05vIFRVUk4gc2VydmVycyBjb25maWd1cmVkLicpO1xuICAgICAgdGhpcy5za2lwKCk7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAwKSk7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgbG9nIGZyb20gJy4uLy4uL2xvZ2dlcic7XG5pbXBvcnQgeyBSb29tRXZlbnQgfSBmcm9tICcuLi8uLi9yb29tL2V2ZW50cyc7XG5pbXBvcnQgeyBDaGVja2VyIH0gZnJvbSAnLi9DaGVja2VyJztcblxuZXhwb3J0IGNsYXNzIFdlYlJUQ0NoZWNrIGV4dGVuZHMgQ2hlY2tlciB7XG4gIGdldCBkZXNjcmlwdGlvbigpOiBzdHJpbmcge1xuICAgIHJldHVybiAnRXN0YWJsaXNoaW5nIFdlYlJUQyBjb25uZWN0aW9uJztcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBwZXJmb3JtKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGxldCBoYXNUY3AgPSBmYWxzZTtcbiAgICBsZXQgaGFzSXB2NFVkcCA9IGZhbHNlO1xuICAgIHRoaXMucm9vbS5vbihSb29tRXZlbnQuU2lnbmFsQ29ubmVjdGVkLCAoKSA9PiB7XG4gICAgICBjb25zdCBwcmV2VHJpY2tsZSA9IHRoaXMucm9vbS5lbmdpbmUuY2xpZW50Lm9uVHJpY2tsZTtcblxuICAgICAgY29uc3QgY2FuZGlkYXRlczogUlRDSWNlQ2FuZGlkYXRlW10gPSBbXTtcbiAgICAgIHRoaXMucm9vbS5lbmdpbmUuY2xpZW50Lm9uVHJpY2tsZSA9IChzZCwgdGFyZ2V0KSA9PiB7XG4gICAgICAgIGlmIChzZC5jYW5kaWRhdGUpIHtcbiAgICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSBuZXcgUlRDSWNlQ2FuZGlkYXRlKHNkKTtcbiAgICAgICAgICBjYW5kaWRhdGVzLnB1c2goY2FuZGlkYXRlKTtcbiAgICAgICAgICBsZXQgc3RyID0gYCR7Y2FuZGlkYXRlLnByb3RvY29sfSAke2NhbmRpZGF0ZS5hZGRyZXNzfToke2NhbmRpZGF0ZS5wb3J0fSAke2NhbmRpZGF0ZS50eXBlfWA7XG4gICAgICAgICAgaWYgKGNhbmRpZGF0ZS5hZGRyZXNzKSB7XG4gICAgICAgICAgICBpZiAoaXNJUFByaXZhdGUoY2FuZGlkYXRlLmFkZHJlc3MpKSB7XG4gICAgICAgICAgICAgIHN0ciArPSAnIChwcml2YXRlKSc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoY2FuZGlkYXRlLnByb3RvY29sID09PSAndGNwJyAmJiBjYW5kaWRhdGUudGNwVHlwZSA9PT0gJ3Bhc3NpdmUnKSB7XG4gICAgICAgICAgICAgICAgaGFzVGNwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdHIgKz0gJyAocGFzc2l2ZSknO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNhbmRpZGF0ZS5wcm90b2NvbCA9PT0gJ3VkcCcpIHtcbiAgICAgICAgICAgICAgICBoYXNJcHY0VWRwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmFwcGVuZE1lc3NhZ2Uoc3RyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldlRyaWNrbGUpIHtcbiAgICAgICAgICBwcmV2VHJpY2tsZShzZCwgdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMucm9vbS5lbmdpbmUucGNNYW5hZ2VyKSB7XG4gICAgICAgIHRoaXMucm9vbS5lbmdpbmUucGNNYW5hZ2VyLnN1YnNjcmliZXIub25JY2VDYW5kaWRhdGVFcnJvciA9IChldikgPT4ge1xuICAgICAgICAgIGlmIChldiBpbnN0YW5jZW9mIFJUQ1BlZXJDb25uZWN0aW9uSWNlRXJyb3JFdmVudCkge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRXYXJuaW5nKFxuICAgICAgICAgICAgICBgZXJyb3Igd2l0aCBJQ0UgY2FuZGlkYXRlOiAke2V2LmVycm9yQ29kZX0gJHtldi5lcnJvclRleHR9ICR7ZXYudXJsfWAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5jb25uZWN0KCk7XG4gICAgICBsb2cuaW5mbygnbm93IHRoZSByb29tIGlzIGNvbm5lY3RlZCcpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5hcHBlbmRXYXJuaW5nKCdwb3J0cyBuZWVkIHRvIGJlIG9wZW4gb24gZmlyZXdhbGwgaW4gb3JkZXIgdG8gY29ubmVjdC4nKTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gICAgaWYgKCFoYXNUY3ApIHtcbiAgICAgIHRoaXMuYXBwZW5kV2FybmluZygnU2VydmVyIGlzIG5vdCBjb25maWd1cmVkIGZvciBJQ0UvVENQJyk7XG4gICAgfVxuICAgIGlmICghaGFzSXB2NFVkcCkge1xuICAgICAgdGhpcy5hcHBlbmRXYXJuaW5nKFxuICAgICAgICAnTm8gcHVibGljIElQdjQgVURQIGNhbmRpZGF0ZXMgd2VyZSBmb3VuZC4gWW91ciBzZXJ2ZXIgaXMgbGlrZWx5IG5vdCBjb25maWd1cmVkIGNvcnJlY3RseScsXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc0lQUHJpdmF0ZShhZGRyZXNzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgY29uc3QgcGFydHMgPSBhZGRyZXNzLnNwbGl0KCcuJyk7XG4gIGlmIChwYXJ0cy5sZW5ndGggPT09IDQpIHtcbiAgICBpZiAocGFydHNbMF0gPT09ICcxMCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAocGFydHNbMF0gPT09ICcxOTInICYmIHBhcnRzWzFdID09PSAnMTY4Jykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChwYXJ0c1swXSA9PT0gJzE3MicpIHtcbiAgICAgIGNvbnN0IHNlY29uZCA9IHBhcnNlSW50KHBhcnRzWzFdLCAxMCk7XG4gICAgICBpZiAoc2Vjb25kID49IDE2ICYmIHNlY29uZCA8PSAzMSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuIiwiaW1wb3J0IHsgU2lnbmFsQ2xpZW50IH0gZnJvbSAnLi4vLi4vYXBpL1NpZ25hbENsaWVudCc7XG5pbXBvcnQgeyBTZXJ2ZXJJbmZvX0VkaXRpb24gfSBmcm9tICcuLi8uLi9wcm90by9saXZla2l0X21vZGVsc19wYic7XG5pbXBvcnQgeyBDaGVja2VyIH0gZnJvbSAnLi9DaGVja2VyJztcblxuZXhwb3J0IGNsYXNzIFdlYlNvY2tldENoZWNrIGV4dGVuZHMgQ2hlY2tlciB7XG4gIGdldCBkZXNjcmlwdGlvbigpOiBzdHJpbmcge1xuICAgIHJldHVybiAnQ29ubmVjdGluZyB0byBzaWduYWwgY29ubmVjdGlvbiB2aWEgV2ViU29ja2V0JztcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBwZXJmb3JtKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICh0aGlzLnVybC5zdGFydHNXaXRoKCd3czonKSB8fCB0aGlzLnVybC5zdGFydHNXaXRoKCdodHRwOicpKSB7XG4gICAgICB0aGlzLmFwcGVuZFdhcm5pbmcoJ1NlcnZlciBpcyBpbnNlY3VyZSwgY2xpZW50cyBtYXkgYmxvY2sgY29ubmVjdGlvbnMgdG8gaXQnKTtcbiAgICB9XG5cbiAgICBsZXQgc2lnbmFsQ2xpZW50ID0gbmV3IFNpZ25hbENsaWVudCgpO1xuICAgIGNvbnN0IGpvaW5SZXMgPSBhd2FpdCBzaWduYWxDbGllbnQuam9pbih0aGlzLnVybCwgdGhpcy50b2tlbiwge1xuICAgICAgYXV0b1N1YnNjcmliZTogdHJ1ZSxcbiAgICAgIG1heFJldHJpZXM6IDAsXG4gICAgICBlMmVlRW5hYmxlZDogZmFsc2UsXG4gICAgICB3ZWJzb2NrZXRUaW1lb3V0OiAxNV8wMDAsXG4gICAgfSk7XG4gICAgdGhpcy5hcHBlbmRNZXNzYWdlKGBDb25uZWN0ZWQgdG8gc2VydmVyLCB2ZXJzaW9uICR7am9pblJlcy5zZXJ2ZXJWZXJzaW9ufS5gKTtcbiAgICBpZiAoam9pblJlcy5zZXJ2ZXJJbmZvPy5lZGl0aW9uID09PSBTZXJ2ZXJJbmZvX0VkaXRpb24uQ2xvdWQgJiYgam9pblJlcy5zZXJ2ZXJJbmZvPy5yZWdpb24pIHtcbiAgICAgIHRoaXMuYXBwZW5kTWVzc2FnZShgTGl2ZUtpdCBDbG91ZDogJHtqb2luUmVzLnNlcnZlckluZm8/LnJlZ2lvbn1gKTtcbiAgICB9XG4gICAgYXdhaXQgc2lnbmFsQ2xpZW50LmNsb3NlKCk7XG4gIH1cbn1cbiIsImltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgdHlwZSBUeXBlZEVtaXR0ZXIgZnJvbSAndHlwZWQtZW1pdHRlcic7XG5pbXBvcnQgeyBDaGVja1N0YXR1cywgQ2hlY2tlciB9IGZyb20gJy4vY2hlY2tzL0NoZWNrZXInO1xuaW1wb3J0IHR5cGUgeyBDaGVja0luZm8sIEluc3RhbnRpYWJsZUNoZWNrIH0gZnJvbSAnLi9jaGVja3MvQ2hlY2tlcic7XG5pbXBvcnQgeyBQdWJsaXNoQXVkaW9DaGVjayB9IGZyb20gJy4vY2hlY2tzL3B1Ymxpc2hBdWRpbyc7XG5pbXBvcnQgeyBQdWJsaXNoVmlkZW9DaGVjayB9IGZyb20gJy4vY2hlY2tzL3B1Ymxpc2hWaWRlbyc7XG5pbXBvcnQgeyBSZWNvbm5lY3RDaGVjayB9IGZyb20gJy4vY2hlY2tzL3JlY29ubmVjdCc7XG5pbXBvcnQgeyBUVVJOQ2hlY2sgfSBmcm9tICcuL2NoZWNrcy90dXJuJztcbmltcG9ydCB7IFdlYlJUQ0NoZWNrIH0gZnJvbSAnLi9jaGVja3Mvd2VicnRjJztcbmltcG9ydCB7IFdlYlNvY2tldENoZWNrIH0gZnJvbSAnLi9jaGVja3Mvd2Vic29ja2V0JztcblxuZXhwb3J0IHR5cGUgeyBDaGVja0luZm8sIENoZWNrU3RhdHVzIH07XG5cbmV4cG9ydCBjbGFzcyBDb25uZWN0aW9uQ2hlY2sgZXh0ZW5kcyAoRXZlbnRFbWl0dGVyIGFzIG5ldyAoKSA9PiBUeXBlZEVtaXR0ZXI8Q29ubmVjdGlvbkNoZWNrQ2FsbGJhY2tzPikge1xuICB0b2tlbjogc3RyaW5nO1xuXG4gIHVybDogc3RyaW5nO1xuXG4gIHByaXZhdGUgY2hlY2tSZXN1bHRzOiBNYXA8bnVtYmVyLCBDaGVja0luZm8+ID0gbmV3IE1hcCgpO1xuXG4gIGNvbnN0cnVjdG9yKHVybDogc3RyaW5nLCB0b2tlbjogc3RyaW5nKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnVybCA9IHVybDtcbiAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gIH1cblxuICBwcml2YXRlIGdldE5leHRDaGVja0lkKCkge1xuICAgIGNvbnN0IG5leHRJZCA9IHRoaXMuY2hlY2tSZXN1bHRzLnNpemU7XG4gICAgdGhpcy5jaGVja1Jlc3VsdHMuc2V0KG5leHRJZCwge1xuICAgICAgbG9nczogW10sXG4gICAgICBzdGF0dXM6IENoZWNrU3RhdHVzLklETEUsXG4gICAgICBuYW1lOiAnJyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnJyxcbiAgICB9KTtcbiAgICByZXR1cm4gbmV4dElkO1xuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVDaGVjayhjaGVja0lkOiBudW1iZXIsIGluZm86IENoZWNrSW5mbykge1xuICAgIHRoaXMuY2hlY2tSZXN1bHRzLnNldChjaGVja0lkLCBpbmZvKTtcbiAgICB0aGlzLmVtaXQoJ2NoZWNrVXBkYXRlJywgY2hlY2tJZCwgaW5mbyk7XG4gIH1cblxuICBpc1N1Y2Nlc3MoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5jaGVja1Jlc3VsdHMudmFsdWVzKCkpLmV2ZXJ5KChyKSA9PiByLnN0YXR1cyAhPT0gQ2hlY2tTdGF0dXMuRkFJTEVEKTtcbiAgfVxuXG4gIGdldFJlc3VsdHMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5jaGVja1Jlc3VsdHMudmFsdWVzKCkpO1xuICB9XG5cbiAgYXN5bmMgY3JlYXRlQW5kUnVuQ2hlY2s8VCBleHRlbmRzIENoZWNrZXI+KGNoZWNrOiBJbnN0YW50aWFibGVDaGVjazxUPikge1xuICAgIGNvbnN0IGNoZWNrSWQgPSB0aGlzLmdldE5leHRDaGVja0lkKCk7XG4gICAgY29uc3QgdGVzdCA9IG5ldyBjaGVjayh0aGlzLnVybCwgdGhpcy50b2tlbik7XG4gICAgY29uc3QgaGFuZGxlVXBkYXRlID0gKGluZm86IENoZWNrSW5mbykgPT4ge1xuICAgICAgdGhpcy51cGRhdGVDaGVjayhjaGVja0lkLCBpbmZvKTtcbiAgICB9O1xuICAgIHRlc3Qub24oJ3VwZGF0ZScsIGhhbmRsZVVwZGF0ZSk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGVzdC5ydW4oKTtcbiAgICB0ZXN0Lm9mZigndXBkYXRlJywgaGFuZGxlVXBkYXRlKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgYXN5bmMgY2hlY2tXZWJzb2NrZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlQW5kUnVuQ2hlY2soV2ViU29ja2V0Q2hlY2spO1xuICB9XG5cbiAgYXN5bmMgY2hlY2tXZWJSVEMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlQW5kUnVuQ2hlY2soV2ViUlRDQ2hlY2spO1xuICB9XG5cbiAgYXN5bmMgY2hlY2tUVVJOKCkge1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZUFuZFJ1bkNoZWNrKFRVUk5DaGVjayk7XG4gIH1cblxuICBhc3luYyBjaGVja1JlY29ubmVjdCgpIHtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVBbmRSdW5DaGVjayhSZWNvbm5lY3RDaGVjayk7XG4gIH1cblxuICBhc3luYyBjaGVja1B1Ymxpc2hBdWRpbygpIHtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVBbmRSdW5DaGVjayhQdWJsaXNoQXVkaW9DaGVjayk7XG4gIH1cblxuICBhc3luYyBjaGVja1B1Ymxpc2hWaWRlbygpIHtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVBbmRSdW5DaGVjayhQdWJsaXNoVmlkZW9DaGVjayk7XG4gIH1cbn1cblxudHlwZSBDb25uZWN0aW9uQ2hlY2tDYWxsYmFja3MgPSB7XG4gIGNoZWNrVXBkYXRlOiAoaWQ6IG51bWJlciwgaW5mbzogQ2hlY2tJbmZvKSA9PiB2b2lkO1xufTtcbiIsImltcG9ydCBsb2cgZnJvbSAnLi4vLi4vbG9nZ2VyJztcbmltcG9ydCBMb2NhbFRyYWNrIGZyb20gJy4vTG9jYWxUcmFjayc7XG5pbXBvcnQgdHlwZSB7IFZpZGVvQ2FwdHVyZU9wdGlvbnMgfSBmcm9tICcuL29wdGlvbnMnO1xuXG50eXBlIEZhY2luZ01vZGUgPSBOb25OdWxsYWJsZTxWaWRlb0NhcHR1cmVPcHRpb25zWydmYWNpbmdNb2RlJ10+O1xudHlwZSBGYWNpbmdNb2RlRnJvbUxvY2FsVHJhY2tPcHRpb25zID0ge1xuICAvKipcbiAgICogSWYgbm8gZmFjaW5nIG1vZGUgY2FuIGJlIGRldGVybWluZWQsIHRoaXMgdmFsdWUgd2lsbCBiZSB1c2VkLlxuICAgKiBAZGVmYXVsdFZhbHVlICd1c2VyJ1xuICAgKi9cbiAgZGVmYXVsdEZhY2luZ01vZGU/OiBGYWNpbmdNb2RlO1xufTtcbnR5cGUgRmFjaW5nTW9kZUZyb21Mb2NhbFRyYWNrUmV0dXJuVmFsdWUgPSB7XG4gIC8qKlxuICAgKiBUaGUgKHByb2JhYmxlKSBmYWNpbmdNb2RlIG9mIHRoZSB0cmFjay5cbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01lZGlhVHJhY2tDb25zdHJhaW50cy9mYWNpbmdNb2RlIHwgTUROIGRvY3Mgb24gZmFjaW5nTW9kZX1cbiAgICovXG4gIGZhY2luZ01vZGU6IEZhY2luZ01vZGU7XG4gIC8qKlxuICAgKiBUaGUgY29uZmlkZW5jZSB0aGF0IHRoZSByZXR1cm5lZCBmYWNpbmdNb2RlIGlzIGNvcnJlY3QuXG4gICAqL1xuICBjb25maWRlbmNlOiAnaGlnaCcgfCAnbWVkaXVtJyB8ICdsb3cnO1xufTtcblxuLyoqXG4gKiBUcnkgdG8gYW5hbHl6ZSB0aGUgbG9jYWwgdHJhY2sgdG8gZGV0ZXJtaW5lIHRoZSBmYWNpbmcgbW9kZSBvZiBhIHRyYWNrLlxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGVyZSBpcyBubyBwcm9wZXJ0eSBzdXBwb3J0ZWQgYnkgYWxsIGJyb3dzZXJzIHRvIGRldGVjdCB3aGV0aGVyIGEgdmlkZW8gdHJhY2sgb3JpZ2luYXRlZCBmcm9tIGEgdXNlci0gb3IgZW52aXJvbm1lbnQtZmFjaW5nIGNhbWVyYSBkZXZpY2UuXG4gKiBGb3IgdGhpcyByZWFzb24sIHdlIHVzZSB0aGUgYGZhY2luZ01vZGVgIHByb3BlcnR5IHdoZW4gYXZhaWxhYmxlLCBidXQgd2lsbCBmYWxsIGJhY2sgb24gYSBzdHJpbmctYmFzZWQgYW5hbHlzaXMgb2YgdGhlIGRldmljZSBsYWJlbCB0byBkZXRlcm1pbmUgdGhlIGZhY2luZyBtb2RlLlxuICogSWYgYm90aCBtZXRob2RzIGZhaWwsIHRoZSBkZWZhdWx0IGZhY2luZyBtb2RlIHdpbGwgYmUgdXNlZC5cbiAqXG4gKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTWVkaWFUcmFja0NvbnN0cmFpbnRzL2ZhY2luZ01vZGUgfCBNRE4gZG9jcyBvbiBmYWNpbmdNb2RlfVxuICogQGV4cGVyaW1lbnRhbFxuICovXG5leHBvcnQgZnVuY3Rpb24gZmFjaW5nTW9kZUZyb21Mb2NhbFRyYWNrKFxuICBsb2NhbFRyYWNrOiBMb2NhbFRyYWNrIHwgTWVkaWFTdHJlYW1UcmFjayxcbiAgb3B0aW9uczogRmFjaW5nTW9kZUZyb21Mb2NhbFRyYWNrT3B0aW9ucyA9IHt9LFxuKTogRmFjaW5nTW9kZUZyb21Mb2NhbFRyYWNrUmV0dXJuVmFsdWUge1xuICBjb25zdCB0cmFjayA9IGxvY2FsVHJhY2sgaW5zdGFuY2VvZiBMb2NhbFRyYWNrID8gbG9jYWxUcmFjay5tZWRpYVN0cmVhbVRyYWNrIDogbG9jYWxUcmFjaztcbiAgY29uc3QgdHJhY2tTZXR0aW5ncyA9IHRyYWNrLmdldFNldHRpbmdzKCk7XG4gIGxldCByZXN1bHQ6IEZhY2luZ01vZGVGcm9tTG9jYWxUcmFja1JldHVyblZhbHVlID0ge1xuICAgIGZhY2luZ01vZGU6IG9wdGlvbnMuZGVmYXVsdEZhY2luZ01vZGUgPz8gJ3VzZXInLFxuICAgIGNvbmZpZGVuY2U6ICdsb3cnLFxuICB9O1xuXG4gIC8vIDEuIFRyeSB0byBnZXQgZmFjaW5nTW9kZSBmcm9tIHRyYWNrIHNldHRpbmdzLlxuICBpZiAoJ2ZhY2luZ01vZGUnIGluIHRyYWNrU2V0dGluZ3MpIHtcbiAgICBjb25zdCByYXdGYWNpbmdNb2RlID0gdHJhY2tTZXR0aW5ncy5mYWNpbmdNb2RlO1xuICAgIGxvZy5kZWJ1ZygncmF3RmFjaW5nTW9kZScsIHsgcmF3RmFjaW5nTW9kZSB9KTtcbiAgICBpZiAocmF3RmFjaW5nTW9kZSAmJiB0eXBlb2YgcmF3RmFjaW5nTW9kZSA9PT0gJ3N0cmluZycgJiYgaXNGYWNpbmdNb2RlVmFsdWUocmF3RmFjaW5nTW9kZSkpIHtcbiAgICAgIHJlc3VsdCA9IHsgZmFjaW5nTW9kZTogcmF3RmFjaW5nTW9kZSwgY29uZmlkZW5jZTogJ2hpZ2gnIH07XG4gICAgfVxuICB9XG5cbiAgLy8gMi4gSWYgd2UgZG9uJ3QgaGF2ZSBhIGhpZ2ggY29uZmlkZW5jZSB3ZSB0cnkgdG8gZ2V0IHRoZSBmYWNpbmcgbW9kZSBmcm9tIHRoZSBkZXZpY2UgbGFiZWwuXG4gIGlmIChbJ2xvdycsICdtZWRpdW0nXS5pbmNsdWRlcyhyZXN1bHQuY29uZmlkZW5jZSkpIHtcbiAgICBsb2cuZGVidWcoYFRyeSB0byBnZXQgZmFjaW5nIG1vZGUgZnJvbSBkZXZpY2UgbGFiZWw6ICgke3RyYWNrLmxhYmVsfSlgKTtcbiAgICBjb25zdCBsYWJlbEFuYWx5c2lzUmVzdWx0ID0gZmFjaW5nTW9kZUZyb21EZXZpY2VMYWJlbCh0cmFjay5sYWJlbCk7XG4gICAgaWYgKGxhYmVsQW5hbHlzaXNSZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVzdWx0ID0gbGFiZWxBbmFseXNpc1Jlc3VsdDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5jb25zdCBrbm93bkRldmljZUxhYmVscyA9IG5ldyBNYXA8c3RyaW5nLCBGYWNpbmdNb2RlRnJvbUxvY2FsVHJhY2tSZXR1cm5WYWx1ZT4oW1xuICBbJ29icyB2aXJ0dWFsIGNhbWVyYScsIHsgZmFjaW5nTW9kZTogJ2Vudmlyb25tZW50JywgY29uZmlkZW5jZTogJ21lZGl1bScgfV0sXG5dKTtcbmNvbnN0IGtub3duRGV2aWNlTGFiZWxTZWN0aW9ucyA9IG5ldyBNYXA8c3RyaW5nLCBGYWNpbmdNb2RlRnJvbUxvY2FsVHJhY2tSZXR1cm5WYWx1ZT4oW1xuICBbJ2lwaG9uZScsIHsgZmFjaW5nTW9kZTogJ2Vudmlyb25tZW50JywgY29uZmlkZW5jZTogJ21lZGl1bScgfV0sXG4gIFsnaXBhZCcsIHsgZmFjaW5nTW9kZTogJ2Vudmlyb25tZW50JywgY29uZmlkZW5jZTogJ21lZGl1bScgfV0sXG5dKTtcbi8qKlxuICogQXR0ZW1wdCB0byBhbmFseXplIHRoZSBkZXZpY2UgbGFiZWwgdG8gZGV0ZXJtaW5lIHRoZSBmYWNpbmcgbW9kZS5cbiAqXG4gKiBAZXhwZXJpbWVudGFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmYWNpbmdNb2RlRnJvbURldmljZUxhYmVsKFxuICBkZXZpY2VMYWJlbDogc3RyaW5nLFxuKTogRmFjaW5nTW9kZUZyb21Mb2NhbFRyYWNrUmV0dXJuVmFsdWUgfCB1bmRlZmluZWQge1xuICBjb25zdCBsYWJlbCA9IGRldmljZUxhYmVsLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAvLyBFbXB0eSBzdHJpbmcgaXMgYSB2YWxpZCBkZXZpY2UgbGFiZWwgYnV0IHdlIGNhbid0IGluZmVyIGFueXRoaW5nIGZyb20gaXQuXG4gIGlmIChsYWJlbCA9PT0gJycpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLy8gQ2FuIHdlIG1hdGNoIGFnYWluc3Qgd2lkZWx5IGtub3duIGRldmljZSBsYWJlbHMuXG4gIGlmIChrbm93bkRldmljZUxhYmVscy5oYXMobGFiZWwpKSB7XG4gICAgcmV0dXJuIGtub3duRGV2aWNlTGFiZWxzLmdldChsYWJlbCk7XG4gIH1cblxuICAvLyBDYW4gd2UgbWF0Y2ggYWdhaW5zdCBzZWN0aW9ucyBvZiB0aGUgZGV2aWNlIGxhYmVsLlxuICByZXR1cm4gQXJyYXkuZnJvbShrbm93bkRldmljZUxhYmVsU2VjdGlvbnMuZW50cmllcygpKS5maW5kKChbc2VjdGlvbl0pID0+XG4gICAgbGFiZWwuaW5jbHVkZXMoc2VjdGlvbiksXG4gICk/LlsxXTtcbn1cblxuZnVuY3Rpb24gaXNGYWNpbmdNb2RlVmFsdWUoaXRlbTogc3RyaW5nKTogaXRlbSBpcyBGYWNpbmdNb2RlIHtcbiAgY29uc3QgYWxsb3dlZFZhbHVlczogRmFjaW5nTW9kZVtdID0gWyd1c2VyJywgJ2Vudmlyb25tZW50JywgJ2xlZnQnLCAncmlnaHQnXTtcbiAgcmV0dXJuIGl0ZW0gPT09IHVuZGVmaW5lZCB8fCBhbGxvd2VkVmFsdWVzLmluY2x1ZGVzKGl0ZW0gYXMgRmFjaW5nTW9kZSk7XG59XG4iXSwibmFtZXMiOlsicm9vdCIsImRlZmluaXRpb24iLCJtb2R1bGUiLCJleHBvcnRzIiwibG9nIiwidGhpcyIsIm5vb3AiLCJ1bmRlZmluZWRUeXBlIiwiaXNJRSIsIndpbmRvdyIsIm5hdmlnYXRvciIsInRlc3QiLCJ1c2VyQWdlbnQiLCJsb2dNZXRob2RzIiwiYmluZE1ldGhvZCIsIm9iaiIsIm1ldGhvZE5hbWUiLCJtZXRob2QiLCJiaW5kIiwiRnVuY3Rpb24iLCJwcm90b3R5cGUiLCJjYWxsIiwiZSIsImFwcGx5IiwiYXJndW1lbnRzIiwidHJhY2VGb3JJRSIsImNvbnNvbGUiLCJ0cmFjZSIsInJlYWxNZXRob2QiLCJ1bmRlZmluZWQiLCJyZXBsYWNlTG9nZ2luZ01ldGhvZHMiLCJsZXZlbCIsImxvZ2dlck5hbWUiLCJpIiwibGVuZ3RoIiwibWV0aG9kRmFjdG9yeSIsImRlYnVnIiwiZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcyIsImRlZmF1bHRNZXRob2RGYWN0b3J5IiwiTG9nZ2VyIiwibmFtZSIsImRlZmF1bHRMZXZlbCIsImZhY3RvcnkiLCJzZWxmIiwiY3VycmVudExldmVsIiwic3RvcmFnZUtleSIsInBlcnNpc3RMZXZlbElmUG9zc2libGUiLCJsZXZlbE51bSIsImxldmVsTmFtZSIsInRvVXBwZXJDYXNlIiwibG9jYWxTdG9yYWdlIiwiaWdub3JlIiwiZG9jdW1lbnQiLCJjb29raWUiLCJlbmNvZGVVUklDb21wb25lbnQiLCJnZXRQZXJzaXN0ZWRMZXZlbCIsInN0b3JlZExldmVsIiwibG9jYXRpb24iLCJpbmRleE9mIiwiZXhlYyIsInNsaWNlIiwibGV2ZWxzIiwiY2xlYXJQZXJzaXN0ZWRMZXZlbCIsInJlbW92ZUl0ZW0iLCJnZXRMZXZlbCIsInNldExldmVsIiwicGVyc2lzdCIsIlNJTEVOVCIsInNldERlZmF1bHRMZXZlbCIsInJlc2V0TGV2ZWwiLCJlbmFibGVBbGwiLCJUUkFDRSIsImRpc2FibGVBbGwiLCJpbml0aWFsTGV2ZWwiLCJkZWZhdWx0TG9nZ2VyIiwiX2xvZ2dlcnNCeU5hbWUiLCJnZXRMb2dnZXIiLCJUeXBlRXJyb3IiLCJsb2dnZXIiLCJfbG9nIiwibm9Db25mbGljdCIsImdldExvZ2dlcnMiLCJMb2dMZXZlbCIsIkxvZ2dlck5hbWVzIiwibGl2ZWtpdExvZ2dlciIsImluZm8iLCJzZXRMb2dMZXZlbCIsIk9iamVjdCIsImVudHJpZXMiLCJmaWx0ZXIiLCJfcmVmIiwibG9nck5hbWUiLCJzdGFydHNXaXRoIiwibWFwIiwiX3JlZjIiLCJsb2dyIiwic2V0TG9nRXh0ZW5zaW9uIiwiZXh0ZW5zaW9uIiwib3JpZ2luYWxGYWN0b3J5IiwiY29uZmlnTGV2ZWwiLCJyYXdNZXRob2QiLCJsb2dMZXZlbCIsIm5lZWRMb2ciLCJzaWxlbnQiLCJtc2ciLCJjb250ZXh0IiwiYXNzZXJ0IiwiY29uZGl0aW9uIiwiRXJyb3IiLCJGTE9BVDMyX01BWCIsIkZMT0FUMzJfTUlOIiwiVUlOVDMyX01BWCIsIklOVDMyX01BWCIsIklOVDMyX01JTiIsImFzc2VydEludDMyIiwiYXJnIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiYXNzZXJ0VUludDMyIiwiYXNzZXJ0RmxvYXQzMiIsImlzRmluaXRlIiwiZW51bVR5cGVTeW1ib2wiLCJTeW1ib2wiLCJnZXRFbnVtVHlwZSIsImVudW1PYmplY3QiLCJ0Iiwic2V0RW51bVR5cGUiLCJ0eXBlTmFtZSIsInZhbHVlcyIsIm9wdCIsIm1ha2VFbnVtVHlwZSIsInYiLCJubyIsImxvY2FsTmFtZSIsIl9vcHQiLCJuYW1lcyIsImNyZWF0ZSIsIm51bWJlcnMiLCJub3JtYWxWYWx1ZXMiLCJ2YWx1ZSIsIm4iLCJub3JtYWxpemVFbnVtVmFsdWUiLCJwdXNoIiwiZmluZE5hbWUiLCJmaW5kTnVtYmVyIiwibWFrZUVudW0iLCJhc3NpZ24iLCJNZXNzYWdlIiwiZXF1YWxzIiwib3RoZXIiLCJnZXRUeXBlIiwicnVudGltZSIsInV0aWwiLCJjbG9uZSIsImZyb21CaW5hcnkiLCJieXRlcyIsIm9wdGlvbnMiLCJ0eXBlIiwiZm9ybWF0IiwiYmluIiwibWFrZVJlYWRPcHRpb25zIiwicmVhZE1lc3NhZ2UiLCJyZWFkZXJGYWN0b3J5IiwiYnl0ZUxlbmd0aCIsImZyb21Kc29uIiwianNvblZhbHVlIiwianNvbiIsImZyb21Kc29uU3RyaW5nIiwianNvblN0cmluZyIsIkpTT04iLCJwYXJzZSIsImNvbmNhdCIsIm1lc3NhZ2UiLCJTdHJpbmciLCJ0b0JpbmFyeSIsIm1ha2VXcml0ZU9wdGlvbnMiLCJ3cml0ZXIiLCJ3cml0ZXJGYWN0b3J5Iiwid3JpdGVNZXNzYWdlIiwiZmluaXNoIiwidG9Kc29uIiwidG9Kc29uU3RyaW5nIiwiX2EiLCJzdHJpbmdpZnkiLCJwcmV0dHlTcGFjZXMiLCJ0b0pTT04iLCJlbWl0RGVmYXVsdFZhbHVlcyIsImdldFByb3RvdHlwZU9mIiwiY29uc3RydWN0b3IiLCJtYWtlTWVzc2FnZVR5cGUiLCJmaWVsZHMiLCJzdWJzdHJpbmciLCJsYXN0SW5kZXhPZiIsImRhdGEiLCJpbml0RmllbGRzIiwiaW5pdFBhcnRpYWwiLCJzZXRQcm90b3R5cGVPZiIsIm5ld0ZpZWxkTGlzdCIsImEiLCJiIiwibWFrZVByb3RvUnVudGltZSIsInN5bnRheCIsIlNjYWxhclR5cGUiLCJMb25nVHlwZSIsInZhcmludDY0cmVhZCIsImxvd0JpdHMiLCJoaWdoQml0cyIsInNoaWZ0IiwiYnVmIiwicG9zIiwiYXNzZXJ0Qm91bmRzIiwibWlkZGxlQnl0ZSIsInZhcmludDY0d3JpdGUiLCJsbyIsImhpIiwiaGFzTmV4dCIsImJ5dGUiLCJzcGxpdEJpdHMiLCJoYXNNb3JlQml0cyIsIlRXT19QV1JfMzJfREJMIiwiaW50NjRGcm9tU3RyaW5nIiwiZGVjIiwibWludXMiLCJiYXNlIiwiYWRkMWU2ZGlnaXQiLCJiZWdpbiIsImVuZCIsImRpZ2l0MWU2IiwibmVnYXRlIiwibmV3Qml0cyIsImludDY0VG9TdHJpbmciLCJiaXRzIiwibmVnYXRpdmUiLCJyZXN1bHQiLCJ1SW50NjRUb1N0cmluZyIsInRvVW5zaWduZWQiLCJsb3ciLCJtaWQiLCJoaWdoIiwiZGlnaXRBIiwiZGlnaXRCIiwiZGlnaXRDIiwiTWF0aCIsImZsb29yIiwidG9TdHJpbmciLCJkZWNpbWFsRnJvbTFlN1dpdGhMZWFkaW5nWmVyb3MiLCJkaWdpdDFlNyIsInBhcnRpYWwiLCJ2YXJpbnQzMndyaXRlIiwidmFyaW50MzJyZWFkIiwicmVhZEJ5dGVzIiwibWFrZUludDY0U3VwcG9ydCIsImR2IiwiRGF0YVZpZXciLCJBcnJheUJ1ZmZlciIsIm9rIiwiQmlnSW50IiwiZ2V0QmlnSW50NjQiLCJnZXRCaWdVaW50NjQiLCJzZXRCaWdJbnQ2NCIsInNldEJpZ1VpbnQ2NCIsInByb2Nlc3MiLCJlbnYiLCJCVUZfQklHSU5UX0RJU0FCTEUiLCJNSU4iLCJNQVgiLCJVTUlOIiwiVU1BWCIsInplcm8iLCJzdXBwb3J0ZWQiLCJiaSIsInVQYXJzZSIsImVuYyIsImdldEludDMyIiwidUVuYyIsInNldEludDMyIiwidURlYyIsImFzc2VydEludDY0U3RyaW5nIiwiYXNzZXJ0VUludDY0U3RyaW5nIiwicHJvdG9JbnQ2NCIsIldpcmVUeXBlIiwiQmluYXJ5V3JpdGVyIiwidGV4dEVuY29kZXIiLCJzdGFjayIsIlRleHRFbmNvZGVyIiwiY2h1bmtzIiwiVWludDhBcnJheSIsImxlbiIsIm9mZnNldCIsInNldCIsImZvcmsiLCJqb2luIiwiY2h1bmsiLCJwcmV2IiwicG9wIiwidWludDMyIiwicmF3IiwidGFnIiwiZmllbGRObyIsImludDMyIiwiYm9vbCIsInN0cmluZyIsImVuY29kZSIsImZsb2F0IiwiYnVmZmVyIiwic2V0RmxvYXQzMiIsImRvdWJsZSIsInNldEZsb2F0NjQiLCJmaXhlZDMyIiwic2V0VWludDMyIiwic2ZpeGVkMzIiLCJzaW50MzIiLCJzZml4ZWQ2NCIsInZpZXciLCJ0YyIsImZpeGVkNjQiLCJpbnQ2NCIsInNpbnQ2NCIsInNpZ24iLCJ1aW50NjQiLCJCaW5hcnlSZWFkZXIiLCJ0ZXh0RGVjb2RlciIsInZhcmludDY0IiwiYnl0ZU9mZnNldCIsIlRleHREZWNvZGVyIiwid2lyZVR5cGUiLCJza2lwIiwic3RhcnQiLCJWYXJpbnQiLCJCaXQ2NCIsIkJpdDMyIiwiTGVuZ3RoRGVsaW1pdGVkIiwiU3RhcnRHcm91cCIsIkVuZEdyb3VwIiwic3ViYXJyYXkiLCJSYW5nZUVycm9yIiwienplIiwicyIsImdldFVpbnQzMiIsImdldEZsb2F0MzIiLCJnZXRGbG9hdDY0IiwiZGVjb2RlIiwid3JhcEZpZWxkIiwiZmllbGRXcmFwcGVyIiwiRE9VQkxFIiwiRkxPQVQiLCJJTlQ2NCIsIlVJTlQ2NCIsIklOVDMyIiwiVUlOVDMyIiwiQk9PTCIsIlNUUklORyIsIkJZVEVTIiwic2NhbGFyRXF1YWxzIiwiRklYRUQ2NCIsIlNGSVhFRDY0IiwiU0lOVDY0Iiwic2NhbGFyRGVmYXVsdFZhbHVlIiwibG9uZ1R5cGUiLCJzY2FsYXJUeXBlSW5mbyIsImlzVW5kZWZpbmVkIiwiaXNJbnRyaW5zaWNEZWZhdWx0IiwiRklYRUQzMiIsIlNGSVhFRDMyIiwidG9Mb3dlckNhc2UiLCJ1bmtub3duRmllbGRzU3ltYm9sIiwicmVhZERlZmF1bHRzIiwicmVhZFVua25vd25GaWVsZHMiLCJ3cml0ZURlZmF1bHRzIiwid3JpdGVVbmtub3duRmllbGRzIiwibWFrZUJpbmFyeUZvcm1hdENvbW1vbiIsImxpc3RVbmtub3duRmllbGRzIiwiZGlzY2FyZFVua25vd25GaWVsZHMiLCJtIiwiYyIsImYiLCJvblVua25vd25GaWVsZCIsIkFycmF5IiwiaXNBcnJheSIsInJlYWRlciIsImZpZWxkIiwiZmluZCIsInRhcmdldCIsInJlcGVhdGVkIiwib25lb2YiLCJjYXNlIiwia2luZCIsInNjYWxhclR5cGUiLCJUIiwicmVhZCIsInJlYWRTY2FsYXIiLCJMIiwicmVhZFNjYWxhckxUU3RyaW5nIiwiYXJyIiwibWVzc2FnZVR5cGUiLCJyZWFkTWVzc2FnZUZpZWxkIiwidW53cmFwRmllbGQiLCJtYXBLZXkiLCJtYXBWYWwiLCJyZWFkTWFwRW50cnkiLCJrZXkiLCJ2YWwiLCJLIiwiViIsImtleVJhdyIsIkJJR0lOVCIsIlNJTlQzMiIsIndyaXRlTWFwRW50cnkiLCJrZXlWYWx1ZSIsInBhcnNlSW50Iiwid3JpdGVTY2FsYXIiLCJ3cml0ZU1lc3NhZ2VGaWVsZCIsImVtaXRJbnRyaW5zaWNEZWZhdWx0Iiwid3JpdGVQYWNrZWQiLCJtYWtlQmluYXJ5Rm9ybWF0UHJvdG8zIiwiYnlOdW1iZXIiLCJwYWNrZWQiLCJpdGVtIiwiZW5jVGFibGUiLCJzcGxpdCIsImRlY1RhYmxlIiwiY2hhckNvZGVBdCIsInByb3RvQmFzZTY0IiwiYmFzZTY0U3RyIiwiZXMiLCJieXRlUG9zIiwiZ3JvdXBQb3MiLCJwIiwiYmFzZTY0IiwianNvblJlYWREZWZhdWx0cyIsImlnbm9yZVVua25vd25GaWVsZHMiLCJqc29uV3JpdGVEZWZhdWx0cyIsImVudW1Bc0ludGVnZXIiLCJ1c2VQcm90b0ZpZWxkTmFtZSIsIm1ha2VKc29uRm9ybWF0Q29tbW9uIiwibWFrZVdyaXRlRmllbGQiLCJ3cml0ZUZpZWxkIiwid3JpdGVFbnVtIiwib25lb2ZTZWVuIiwianNvbktleSIsImZpbmRKc29uTmFtZSIsInNlZW4iLCJ0YXJnZXRBcnJheSIsImpzb25JdGVtIiwicmVhZEVudW0iLCJ0YXJnZXRNYXAiLCJqc29uTWFwS2V5IiwianNvbk1hcFZhbHVlIiwiZW51bVZhbHVlIiwibWVtYmVyIiwiYnlNZW1iZXIiLCJmaW5kRmllbGQiLCJqc29uTmFtZSIsInIiLCJkZWJ1Z0pzb25WYWx1ZSIsIk5hTiIsIlBPU0lUSVZFX0lORklOSVRZIiwiTkVHQVRJVkVfSU5GSU5JVFkiLCJ0cmltIiwiaXNOYU4iLCJsb25nIiwidUxvbmciLCJtYWtlSnNvbkZvcm1hdFByb3RvMyIsImpzb25PYmoiLCJlbnRyeUtleSIsImVudHJ5VmFsdWUiLCJlbnVtVHlwZSIsImtleXMiLCJqc29uQXJyIiwibWFrZVV0aWxDb21tb24iLCJzb3VyY2UiLCJzayIsInNvdXJjZUZpZWxkIiwidG9VOEFyciIsImNvcHkiLCJrIiwibXQiLCJldmVyeSIsInZhIiwidmIiLCJhbnkiLCJjbG9uZVNpbmd1bGFyRmllbGQiLCJpbnB1dCIsIkludGVybmFsRmllbGRMaXN0Iiwibm9ybWFsaXplciIsIl9maWVsZHMiLCJfbm9ybWFsaXplciIsImpzb25OYW1lcyIsImxpc3QiLCJhbGwiLCJudW1iZXJzQXNjIiwic29ydCIsIm1lbWJlcnMiLCJvIiwibG9jYWxGaWVsZE5hbWUiLCJwcm90b05hbWUiLCJpbk9uZW9mIiwicHJvdG9DYW1lbENhc2UiLCJzYWZlT2JqZWN0UHJvcGVydHkiLCJzYWZlTWVzc2FnZVByb3BlcnR5IiwibG9jYWxPbmVvZk5hbWUiLCJmaWVsZEpzb25OYW1lIiwic25ha2VDYXNlIiwiY2FwTmV4dCIsImNoYXJBdCIsInJlc2VydmVkT2JqZWN0UHJvcGVydGllcyIsIlNldCIsInJlc2VydmVkTWVzc2FnZVByb3BlcnRpZXMiLCJmYWxsYmFjayIsImhhcyIsIkludGVybmFsT25lb2ZJbmZvIiwiZGVmYXVsdCIsImFkZEZpZWxkIiwiX2xvb2t1cCIsInByb3RvMyIsIm5vcm1hbGl6ZUZpZWxkSW5mb3NQcm90bzMiLCJmaWVsZEluZm9zIiwiX2IiLCJfYyIsIl9kIiwib29uYW1lIiwiVGltZXN0YW1wIiwic2Vjb25kcyIsIm5hbm9zIiwibWF0Y2hlcyIsIm1hdGNoIiwibXMiLCJEYXRlIiwicmVwZWF0IiwieiIsIm5hbm9zU3RyIiwidG9JU09TdHJpbmciLCJyZXBsYWNlIiwidG9EYXRlIiwiY2VpbCIsIm5vdyIsImZyb21EYXRlIiwiZGF0ZSIsImdldFRpbWUiLCJBdWRpb0NvZGVjIiwiVmlkZW9Db2RlYyIsIkltYWdlQ29kZWMiLCJUcmFja1R5cGUiLCJUcmFja1NvdXJjZSIsIlZpZGVvUXVhbGl0eSIsIkNvbm5lY3Rpb25RdWFsaXR5IiwiQ2xpZW50Q29uZmlnU2V0dGluZyIsIkRpc2Nvbm5lY3RSZWFzb24iLCJSZWNvbm5lY3RSZWFzb24iLCJTdWJzY3JpcHRpb25FcnJvciIsIlJvb20iLCJzaWQiLCJlbXB0eVRpbWVvdXQiLCJtYXhQYXJ0aWNpcGFudHMiLCJjcmVhdGlvblRpbWUiLCJ0dXJuUGFzc3dvcmQiLCJlbmFibGVkQ29kZWNzIiwibWV0YWRhdGEiLCJudW1QYXJ0aWNpcGFudHMiLCJudW1QdWJsaXNoZXJzIiwiYWN0aXZlUmVjb3JkaW5nIiwiQ29kZWMiLCJtaW1lIiwiZm10cExpbmUiLCJQbGF5b3V0RGVsYXkiLCJlbmFibGVkIiwibWluIiwibWF4IiwiUGFydGljaXBhbnRQZXJtaXNzaW9uIiwiY2FuU3Vic2NyaWJlIiwiY2FuUHVibGlzaCIsImNhblB1Ymxpc2hEYXRhIiwiY2FuUHVibGlzaFNvdXJjZXMiLCJoaWRkZW4iLCJyZWNvcmRlciIsImNhblVwZGF0ZU1ldGFkYXRhIiwiYWdlbnQiLCJQYXJ0aWNpcGFudEluZm8iLCJpZGVudGl0eSIsInN0YXRlIiwiUGFydGljaXBhbnRJbmZvX1N0YXRlIiwiSk9JTklORyIsInRyYWNrcyIsImpvaW5lZEF0IiwidmVyc2lvbiIsInJlZ2lvbiIsImlzUHVibGlzaGVyIiwiVHJhY2tJbmZvIiwiRW5jcnlwdGlvbiIsIkVuY3J5cHRpb25fVHlwZSIsIlNpbXVsY2FzdENvZGVjSW5mbyIsIm1pbWVUeXBlIiwiY2lkIiwibGF5ZXJzIiwiVmlkZW9MYXllciIsIkFVRElPIiwibXV0ZWQiLCJ3aWR0aCIsImhlaWdodCIsInNpbXVsY2FzdCIsImRpc2FibGVEdHgiLCJVTktOT1dOIiwiY29kZWNzIiwic3RlcmVvIiwiZGlzYWJsZVJlZCIsImVuY3J5cHRpb24iLCJOT05FIiwic3RyZWFtIiwicXVhbGl0eSIsIkxPVyIsImJpdHJhdGUiLCJzc3JjIiwiRGF0YVBhY2tldCIsIkRhdGFQYWNrZXRfS2luZCIsIlJFTElBQkxFIiwiVXNlclBhY2tldCIsIkFjdGl2ZVNwZWFrZXJVcGRhdGUiLCJzcGVha2VycyIsIlNwZWFrZXJJbmZvIiwiYWN0aXZlIiwicGFydGljaXBhbnRTaWQiLCJwYXJ0aWNpcGFudElkZW50aXR5IiwicGF5bG9hZCIsImRlc3RpbmF0aW9uU2lkcyIsImRlc3RpbmF0aW9uSWRlbnRpdGllcyIsIlBhcnRpY2lwYW50VHJhY2tzIiwidHJhY2tTaWRzIiwiU2VydmVySW5mbyIsImVkaXRpb24iLCJTZXJ2ZXJJbmZvX0VkaXRpb24iLCJTdGFuZGFyZCIsInByb3RvY29sIiwibm9kZUlkIiwiZGVidWdJbmZvIiwiQ2xpZW50SW5mbyIsInNkayIsIkNsaWVudEluZm9fU0RLIiwib3MiLCJvc1ZlcnNpb24iLCJkZXZpY2VNb2RlbCIsImJyb3dzZXIiLCJicm93c2VyVmVyc2lvbiIsImFkZHJlc3MiLCJuZXR3b3JrIiwiQ2xpZW50Q29uZmlndXJhdGlvbiIsInJlc3VtZUNvbm5lY3Rpb24iLCJVTlNFVCIsImZvcmNlUmVsYXkiLCJWaWRlb0NvbmZpZ3VyYXRpb24iLCJEaXNhYmxlZENvZGVjcyIsImhhcmR3YXJlRW5jb2RlciIsInB1Ymxpc2giLCJSVFBEcmlmdCIsImR1cmF0aW9uIiwic3RhcnRUaW1lc3RhbXAiLCJlbmRUaW1lc3RhbXAiLCJydHBDbG9ja1RpY2tzIiwiZHJpZnRTYW1wbGVzIiwiZHJpZnRNcyIsImNsb2NrUmF0ZSIsIlJUUFN0YXRzIiwicGFja2V0cyIsInBhY2tldFJhdGUiLCJoZWFkZXJCeXRlcyIsInBhY2tldHNMb3N0IiwicGFja2V0TG9zc1JhdGUiLCJwYWNrZXRMb3NzUGVyY2VudGFnZSIsInBhY2tldHNEdXBsaWNhdGUiLCJwYWNrZXREdXBsaWNhdGVSYXRlIiwiYnl0ZXNEdXBsaWNhdGUiLCJoZWFkZXJCeXRlc0R1cGxpY2F0ZSIsImJpdHJhdGVEdXBsaWNhdGUiLCJwYWNrZXRzUGFkZGluZyIsInBhY2tldFBhZGRpbmdSYXRlIiwiYnl0ZXNQYWRkaW5nIiwiaGVhZGVyQnl0ZXNQYWRkaW5nIiwiYml0cmF0ZVBhZGRpbmciLCJwYWNrZXRzT3V0T2ZPcmRlciIsImZyYW1lcyIsImZyYW1lUmF0ZSIsImppdHRlckN1cnJlbnQiLCJqaXR0ZXJNYXgiLCJnYXBIaXN0b2dyYW0iLCJuYWNrcyIsIm5hY2tBY2tzIiwibmFja01pc3NlcyIsIm5hY2tSZXBlYXRlZCIsInBsaXMiLCJmaXJzIiwicnR0Q3VycmVudCIsInJ0dE1heCIsImtleUZyYW1lcyIsImxheWVyTG9ja1BsaXMiLCJUaW1lZFZlcnNpb24iLCJ1bml4TWljcm8iLCJ0aWNrcyIsIm1heFJldHJ5RGVsYXkiLCJERUZBVUxUX1JFVFJZX0RFTEFZU19JTl9NUyIsIkRlZmF1bHRSZWNvbm5lY3RQb2xpY3kiLCJyZXRyeURlbGF5cyIsIl9yZXRyeURlbGF5cyIsIm5leHRSZXRyeURlbGF5SW5NcyIsInJldHJ5Q291bnQiLCJyZXRyeURlbGF5IiwicmFuZG9tIiwiUiIsIlJlZmxlY3QiLCJSZWZsZWN0QXBwbHkiLCJyZWNlaXZlciIsImFyZ3MiLCJSZWZsZWN0T3duS2V5cyIsIm93bktleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiUHJvY2Vzc0VtaXRXYXJuaW5nIiwid2FybmluZyIsIndhcm4iLCJOdW1iZXJJc05hTiIsIkV2ZW50RW1pdHRlciIsImluaXQiLCJldmVudHNNb2R1bGUiLCJvbmNlIiwiX2V2ZW50cyIsIl9ldmVudHNDb3VudCIsIl9tYXhMaXN0ZW5lcnMiLCJkZWZhdWx0TWF4TGlzdGVuZXJzIiwiY2hlY2tMaXN0ZW5lciIsImxpc3RlbmVyIiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiZ2V0Iiwic2V0TWF4TGlzdGVuZXJzIiwiX2dldE1heExpc3RlbmVycyIsInRoYXQiLCJnZXRNYXhMaXN0ZW5lcnMiLCJlbWl0IiwiZG9FcnJvciIsImV2ZW50cyIsImVycm9yIiwiZXIiLCJlcnIiLCJoYW5kbGVyIiwibGlzdGVuZXJzIiwiYXJyYXlDbG9uZSIsIl9hZGRMaXN0ZW5lciIsInByZXBlbmQiLCJleGlzdGluZyIsIm5ld0xpc3RlbmVyIiwidW5zaGlmdCIsIndhcm5lZCIsInciLCJlbWl0dGVyIiwiY291bnQiLCJhZGRMaXN0ZW5lciIsIm9uIiwicHJlcGVuZExpc3RlbmVyIiwib25jZVdyYXBwZXIiLCJmaXJlZCIsInJlbW92ZUxpc3RlbmVyIiwid3JhcEZuIiwiX29uY2VXcmFwIiwid3JhcHBlZCIsInByZXBlbmRPbmNlTGlzdGVuZXIiLCJwb3NpdGlvbiIsIm9yaWdpbmFsTGlzdGVuZXIiLCJzcGxpY2VPbmUiLCJvZmYiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJfbGlzdGVuZXJzIiwidW53cmFwIiwiZXZsaXN0ZW5lciIsInVud3JhcExpc3RlbmVycyIsInJhd0xpc3RlbmVycyIsImxpc3RlbmVyQ291bnQiLCJldmVudE5hbWVzIiwiaW5kZXgiLCJyZXQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImVycm9yTGlzdGVuZXIiLCJyZXNvbHZlciIsImV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lciIsImFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyIiwiZmxhZ3MiLCJhZGRFdmVudExpc3RlbmVyIiwid3JhcExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImxvZ0Rpc2FibGVkXyIsImRlcHJlY2F0aW9uV2FybmluZ3NfIiwiZXh0cmFjdFZlcnNpb24iLCJ1YXN0cmluZyIsImV4cHIiLCJ3cmFwUGVlckNvbm5lY3Rpb25FdmVudCIsImV2ZW50TmFtZVRvV3JhcCIsIndyYXBwZXIiLCJSVENQZWVyQ29ubmVjdGlvbiIsInByb3RvIiwibmF0aXZlQWRkRXZlbnRMaXN0ZW5lciIsIm5hdGl2ZUV2ZW50TmFtZSIsImNiIiwid3JhcHBlZENhbGxiYWNrIiwibW9kaWZpZWRFdmVudCIsImhhbmRsZUV2ZW50IiwiX2V2ZW50TWFwIiwiTWFwIiwibmF0aXZlUmVtb3ZlRXZlbnRMaXN0ZW5lciIsInVud3JhcHBlZENiIiwiZGVsZXRlIiwic2l6ZSIsImNvbmZpZ3VyYWJsZSIsImRpc2FibGVMb2ciLCJkaXNhYmxlV2FybmluZ3MiLCJkZXByZWNhdGVkIiwib2xkTWV0aG9kIiwibmV3TWV0aG9kIiwiZGV0ZWN0QnJvd3NlciIsIm1vekdldFVzZXJNZWRpYSIsIndlYmtpdEdldFVzZXJNZWRpYSIsImlzU2VjdXJlQ29udGV4dCIsIndlYmtpdFJUQ1BlZXJDb25uZWN0aW9uIiwic3VwcG9ydHNVbmlmaWVkUGxhbiIsIlJUQ1J0cFRyYW5zY2VpdmVyIiwiaXNPYmplY3QiLCJjb21wYWN0T2JqZWN0IiwicmVkdWNlIiwiYWNjdW11bGF0b3IiLCJpc09iaiIsImlzRW1wdHlPYmplY3QiLCJ3YWxrU3RhdHMiLCJzdGF0cyIsInJlc3VsdFNldCIsImlkIiwiZm9yRWFjaCIsImVuZHNXaXRoIiwiZmlsdGVyU3RhdHMiLCJ0cmFjayIsIm91dGJvdW5kIiwic3RyZWFtU3RhdHNUeXBlIiwiZmlsdGVyZWRSZXN1bHQiLCJ0cmFja1N0YXRzIiwidHJhY2tJZGVudGlmaWVyIiwidHJhY2tTdGF0IiwidHJhY2tJZCIsImxvZ2dpbmciLCJ1dGlscyIsInNoaW1HZXRVc2VyTWVkaWEiLCJicm93c2VyRGV0YWlscyIsIm1lZGlhRGV2aWNlcyIsImNvbnN0cmFpbnRzVG9DaHJvbWVfIiwibWFuZGF0b3J5Iiwib3B0aW9uYWwiLCJjYyIsImlkZWFsIiwiZXhhY3QiLCJvbGRuYW1lXyIsInByZWZpeCIsIm9jIiwibWl4IiwiYWR2YW5jZWQiLCJzaGltQ29uc3RyYWludHNfIiwiY29uc3RyYWludHMiLCJmdW5jIiwiYXVkaW8iLCJyZW1hcCIsInZpZGVvIiwiZmFjZSIsImZhY2luZ01vZGUiLCJnZXRTdXBwb3J0ZWRGYWNpbmdNb2RlTGllcyIsImdldFN1cHBvcnRlZENvbnN0cmFpbnRzIiwiZW51bWVyYXRlRGV2aWNlcyIsInRoZW4iLCJkZXZpY2VzIiwiZCIsImRldiIsInNvbWUiLCJsYWJlbCIsImluY2x1ZGVzIiwiZGV2aWNlSWQiLCJzaGltRXJyb3JfIiwiUGVybWlzc2lvbkRlbmllZEVycm9yIiwiUGVybWlzc2lvbkRpc21pc3NlZEVycm9yIiwiSW52YWxpZFN0YXRlRXJyb3IiLCJEZXZpY2VzTm90Rm91bmRFcnJvciIsIkNvbnN0cmFpbnROb3RTYXRpc2ZpZWRFcnJvciIsIlRyYWNrU3RhcnRFcnJvciIsIk1lZGlhRGV2aWNlRmFpbGVkRHVlVG9TaHV0ZG93biIsIk1lZGlhRGV2aWNlS2lsbFN3aXRjaE9uIiwiVGFiQ2FwdHVyZUVycm9yIiwiU2NyZWVuQ2FwdHVyZUVycm9yIiwiRGV2aWNlQ2FwdHVyZUVycm9yIiwiY29uc3RyYWludCIsImNvbnN0cmFpbnROYW1lIiwiZ2V0VXNlck1lZGlhXyIsIm9uU3VjY2VzcyIsIm9uRXJyb3IiLCJnZXRVc2VyTWVkaWEiLCJvcmlnR2V0VXNlck1lZGlhIiwiY3MiLCJnZXRBdWRpb1RyYWNrcyIsImdldFZpZGVvVHJhY2tzIiwiZ2V0VHJhY2tzIiwic3RvcCIsIkRPTUV4Y2VwdGlvbiIsInNoaW1HZXREaXNwbGF5TWVkaWEiLCJnZXRTb3VyY2VJZCIsImdldERpc3BsYXlNZWRpYSIsInNvdXJjZUlkIiwid2lkdGhTcGVjaWZpZWQiLCJoZWlnaHRTcGVjaWZpZWQiLCJmcmFtZVJhdGVTcGVjaWZpZWQiLCJjaHJvbWVNZWRpYVNvdXJjZSIsImNocm9tZU1lZGlhU291cmNlSWQiLCJtYXhGcmFtZVJhdGUiLCJtYXhXaWR0aCIsIm1heEhlaWdodCIsInNoaW1NZWRpYVN0cmVhbSIsIk1lZGlhU3RyZWFtIiwid2Via2l0TWVkaWFTdHJlYW0iLCJzaGltT25UcmFjayIsIl9vbnRyYWNrIiwib3JpZ1NldFJlbW90ZURlc2NyaXB0aW9uIiwic2V0UmVtb3RlRGVzY3JpcHRpb24iLCJfb250cmFja3BvbHkiLCJ0ZSIsImdldFJlY2VpdmVycyIsImV2ZW50IiwiRXZlbnQiLCJ0cmFuc2NlaXZlciIsInN0cmVhbXMiLCJkaXNwYXRjaEV2ZW50Iiwic2hpbUdldFNlbmRlcnNXaXRoRHRtZiIsInNoaW1TZW5kZXJXaXRoRHRtZiIsInBjIiwiZHRtZiIsIl9kdG1mIiwiY3JlYXRlRFRNRlNlbmRlciIsIl9wYyIsImdldFNlbmRlcnMiLCJfc2VuZGVycyIsIm9yaWdBZGRUcmFjayIsImFkZFRyYWNrIiwic2VuZGVyIiwib3JpZ1JlbW92ZVRyYWNrIiwicmVtb3ZlVHJhY2siLCJpZHgiLCJzcGxpY2UiLCJvcmlnQWRkU3RyZWFtIiwiYWRkU3RyZWFtIiwib3JpZ1JlbW92ZVN0cmVhbSIsInJlbW92ZVN0cmVhbSIsIlJUQ1J0cFNlbmRlciIsIm9yaWdHZXRTZW5kZXJzIiwic2VuZGVycyIsInNoaW1HZXRTdGF0cyIsIm9yaWdHZXRTdGF0cyIsImdldFN0YXRzIiwic2VsZWN0b3IiLCJvblN1Y2MiLCJvbkVyciIsImZpeENocm9tZVN0YXRzXyIsInJlc3BvbnNlIiwic3RhbmRhcmRSZXBvcnQiLCJyZXBvcnRzIiwicmVwb3J0Iiwic3RhbmRhcmRTdGF0cyIsInRpbWVzdGFtcCIsImxvY2FsY2FuZGlkYXRlIiwicmVtb3RlY2FuZGlkYXRlIiwic3RhdCIsIm1ha2VNYXBTdGF0cyIsInN1Y2Nlc3NDYWxsYmFja1dyYXBwZXJfIiwic2hpbVNlbmRlclJlY2VpdmVyR2V0U3RhdHMiLCJSVENSdHBSZWNlaXZlciIsIm9yaWdHZXRSZWNlaXZlcnMiLCJyZWNlaXZlcnMiLCJzcmNFbGVtZW50IiwiTWVkaWFTdHJlYW1UcmFjayIsInNoaW1BZGRUcmFja1JlbW92ZVRyYWNrV2l0aE5hdGl2ZSIsImdldExvY2FsU3RyZWFtcyIsIl9zaGltbWVkTG9jYWxTdHJlYW1zIiwic3RyZWFtSWQiLCJhbHJlYWR5RXhpc3RzIiwiZXhpc3RpbmdTZW5kZXJzIiwibmV3U2VuZGVycyIsIm5ld1NlbmRlciIsInNoaW1BZGRUcmFja1JlbW92ZVRyYWNrIiwib3JpZ0dldExvY2FsU3RyZWFtcyIsIm5hdGl2ZVN0cmVhbXMiLCJfcmV2ZXJzZVN0cmVhbXMiLCJfc3RyZWFtcyIsIm5ld1N0cmVhbSIsInNpZ25hbGluZ1N0YXRlIiwib2xkU3RyZWFtIiwicmVwbGFjZUludGVybmFsU3RyZWFtSWQiLCJkZXNjcmlwdGlvbiIsInNkcCIsImludGVybmFsSWQiLCJleHRlcm5hbFN0cmVhbSIsImludGVybmFsU3RyZWFtIiwiUmVnRXhwIiwiUlRDU2Vzc2lvbkRlc2NyaXB0aW9uIiwicmVwbGFjZUV4dGVybmFsU3RyZWFtSWQiLCJuYXRpdmVNZXRob2QiLCJtZXRob2RPYmoiLCJpc0xlZ2FjeUNhbGwiLCJkZXNjIiwib3JpZ1NldExvY2FsRGVzY3JpcHRpb24iLCJzZXRMb2NhbERlc2NyaXB0aW9uIiwib3JpZ0xvY2FsRGVzY3JpcHRpb24iLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJpc0xvY2FsIiwic3RyZWFtaWQiLCJoYXNUcmFjayIsInNoaW1QZWVyQ29ubmVjdGlvbiIsIlJUQ0ljZUNhbmRpZGF0ZSIsImZpeE5lZ290aWF0aW9uTmVlZGVkIiwiZ2V0Q29uZmlndXJhdGlvbiIsInNkcFNlbWFudGljcyIsIm5hdGl2ZUdldFVzZXJNZWRpYSIsImdldFNldHRpbmdzIiwibmF0aXZlR2V0U2V0dGluZ3MiLCJhcHBseUNvbnN0cmFpbnRzIiwibmF0aXZlQXBwbHlDb25zdHJhaW50cyIsInByZWZlcnJlZE1lZGlhU291cmNlIiwiY29kZSIsIm1lZGlhU291cmNlIiwiUlRDVHJhY2tFdmVudCIsIm1velJUQ1BlZXJDb25uZWN0aW9uIiwibW9kZXJuU3RhdHNUeXBlcyIsImluYm91bmRydHAiLCJvdXRib3VuZHJ0cCIsImNhbmRpZGF0ZXBhaXIiLCJuYXRpdmVHZXRTdGF0cyIsInNoaW1TZW5kZXJHZXRTdGF0cyIsInNoaW1SZWNlaXZlckdldFN0YXRzIiwic2hpbVJlbW92ZVN0cmVhbSIsInNoaW1SVENEYXRhQ2hhbm5lbCIsIkRhdGFDaGFubmVsIiwiUlRDRGF0YUNoYW5uZWwiLCJzaGltQWRkVHJhbnNjZWl2ZXIiLCJvcmlnQWRkVHJhbnNjZWl2ZXIiLCJhZGRUcmFuc2NlaXZlciIsInNldFBhcmFtZXRlcnNQcm9taXNlcyIsInNlbmRFbmNvZGluZ3MiLCJzaG91bGRQZXJmb3JtQ2hlY2siLCJlbmNvZGluZ1BhcmFtIiwicmlkUmVnZXgiLCJyaWQiLCJwYXJzZUZsb2F0Iiwic2NhbGVSZXNvbHV0aW9uRG93bkJ5IiwibWF4RnJhbWVyYXRlIiwicGFyYW1zIiwiZ2V0UGFyYW1ldGVycyIsImVuY29kaW5ncyIsInNldFBhcmFtZXRlcnMiLCJjYXRjaCIsInNoaW1HZXRQYXJhbWV0ZXJzIiwib3JpZ0dldFBhcmFtZXRlcnMiLCJzaGltQ3JlYXRlT2ZmZXIiLCJvcmlnQ3JlYXRlT2ZmZXIiLCJjcmVhdGVPZmZlciIsImZpbmFsbHkiLCJzaGltQ3JlYXRlQW5zd2VyIiwib3JpZ0NyZWF0ZUFuc3dlciIsImNyZWF0ZUFuc3dlciIsInNoaW1Mb2NhbFN0cmVhbXNBUEkiLCJfbG9jYWxTdHJlYW1zIiwiX2FkZFRyYWNrIiwiX2xlbiIsIl9rZXkiLCJzaGltUmVtb3RlU3RyZWFtc0FQSSIsImdldFJlbW90ZVN0cmVhbXMiLCJfcmVtb3RlU3RyZWFtcyIsIl9vbmFkZHN0cmVhbSIsIl9vbmFkZHN0cmVhbXBvbHkiLCJzaGltQ2FsbGJhY2tzQVBJIiwiYWRkSWNlQ2FuZGlkYXRlIiwic3VjY2Vzc0NhbGxiYWNrIiwiZmFpbHVyZUNhbGxiYWNrIiwicHJvbWlzZSIsIndpdGhDYWxsYmFjayIsImNhbmRpZGF0ZSIsIl9nZXRVc2VyTWVkaWEiLCJzaGltQ29uc3RyYWludHMiLCJlcnJjYiIsInNoaW1SVENJY2VTZXJ2ZXJVcmxzIiwiT3JpZ1BlZXJDb25uZWN0aW9uIiwicGNDb25maWciLCJwY0NvbnN0cmFpbnRzIiwiaWNlU2VydmVycyIsIm5ld0ljZVNlcnZlcnMiLCJzZXJ2ZXIiLCJ1cmxzIiwidXJsIiwiZ2VuZXJhdGVDZXJ0aWZpY2F0ZSIsInNoaW1UcmFja0V2ZW50VHJhbnNjZWl2ZXIiLCJzaGltQ3JlYXRlT2ZmZXJMZWdhY3kiLCJvZmZlck9wdGlvbnMiLCJvZmZlclRvUmVjZWl2ZUF1ZGlvIiwiYXVkaW9UcmFuc2NlaXZlciIsImdldFRyYW5zY2VpdmVycyIsImRpcmVjdGlvbiIsInNldERpcmVjdGlvbiIsIm9mZmVyVG9SZWNlaXZlVmlkZW8iLCJ2aWRlb1RyYW5zY2VpdmVyIiwic2hpbUF1ZGlvQ29udGV4dCIsIkF1ZGlvQ29udGV4dCIsIndlYmtpdEF1ZGlvQ29udGV4dCIsIlNEUFV0aWxzIiwiZ2VuZXJhdGVJZGVudGlmaWVyIiwibG9jYWxDTmFtZSIsInNwbGl0TGluZXMiLCJibG9iIiwibGluZSIsInNwbGl0U2VjdGlvbnMiLCJwYXJ0cyIsInBhcnQiLCJnZXREZXNjcmlwdGlvbiIsInNlY3Rpb25zIiwiZ2V0TWVkaWFTZWN0aW9ucyIsIm1hdGNoUHJlZml4IiwicGFyc2VDYW5kaWRhdGUiLCJmb3VuZGF0aW9uIiwiY29tcG9uZW50IiwicHJpb3JpdHkiLCJpcCIsInBvcnQiLCJyZWxhdGVkQWRkcmVzcyIsInJlbGF0ZWRQb3J0IiwidGNwVHlwZSIsInVmcmFnIiwidXNlcm5hbWVGcmFnbWVudCIsIndyaXRlQ2FuZGlkYXRlIiwicGFyc2VJY2VPcHRpb25zIiwicGFyc2VSdHBNYXAiLCJwYXJzZWQiLCJwYXlsb2FkVHlwZSIsImNoYW5uZWxzIiwibnVtQ2hhbm5lbHMiLCJ3cml0ZVJ0cE1hcCIsImNvZGVjIiwicHQiLCJwcmVmZXJyZWRQYXlsb2FkVHlwZSIsInBhcnNlRXh0bWFwIiwidXJpIiwiYXR0cmlidXRlcyIsIndyaXRlRXh0bWFwIiwiaGVhZGVyRXh0ZW5zaW9uIiwicHJlZmVycmVkSWQiLCJwYXJzZUZtdHAiLCJrdiIsImoiLCJ3cml0ZUZtdHAiLCJwYXJhbWV0ZXJzIiwicGFyYW0iLCJwYXJzZVJ0Y3BGYiIsInBhcmFtZXRlciIsIndyaXRlUnRjcEZiIiwibGluZXMiLCJydGNwRmVlZGJhY2siLCJmYiIsInBhcnNlU3NyY01lZGlhIiwic3AiLCJjb2xvbiIsImF0dHJpYnV0ZSIsInBhcnNlU3NyY0dyb3VwIiwic2VtYW50aWNzIiwic3NyY3MiLCJnZXRNaWQiLCJtZWRpYVNlY3Rpb24iLCJwYXJzZUZpbmdlcnByaW50IiwiYWxnb3JpdGhtIiwiZ2V0RHRsc1BhcmFtZXRlcnMiLCJzZXNzaW9ucGFydCIsInJvbGUiLCJmaW5nZXJwcmludHMiLCJ3cml0ZUR0bHNQYXJhbWV0ZXJzIiwic2V0dXBUeXBlIiwiZnAiLCJwYXJzZUNyeXB0b0xpbmUiLCJjcnlwdG9TdWl0ZSIsImtleVBhcmFtcyIsInNlc3Npb25QYXJhbXMiLCJ3cml0ZUNyeXB0b0xpbmUiLCJ3cml0ZUNyeXB0b0tleVBhcmFtcyIsInBhcnNlQ3J5cHRvS2V5UGFyYW1zIiwia2V5TWV0aG9kIiwia2V5U2FsdCIsImxpZmVUaW1lIiwibWtpVmFsdWUiLCJta2lMZW5ndGgiLCJnZXRDcnlwdG9QYXJhbWV0ZXJzIiwiZ2V0SWNlUGFyYW1ldGVycyIsInB3ZCIsInBhc3N3b3JkIiwid3JpdGVJY2VQYXJhbWV0ZXJzIiwiaWNlTGl0ZSIsInBhcnNlUnRwUGFyYW1ldGVycyIsImhlYWRlckV4dGVuc2lvbnMiLCJmZWNNZWNoYW5pc21zIiwicnRjcCIsIm1saW5lIiwicHJvZmlsZSIsInJ0cG1hcGxpbmUiLCJmbXRwcyIsIndpbGRjYXJkUnRjcEZiIiwiZHVwbGljYXRlIiwiZXhpc3RpbmdGZWVkYmFjayIsIndyaXRlUnRwRGVzY3JpcHRpb24iLCJjYXBzIiwibWF4cHRpbWUiLCJwYXJzZVJ0cEVuY29kaW5nUGFyYW1ldGVycyIsImVuY29kaW5nUGFyYW1ldGVycyIsImhhc1JlZCIsImhhc1VscGZlYyIsInByaW1hcnlTc3JjIiwic2Vjb25kYXJ5U3NyYyIsImZsb3dzIiwiYXB0IiwiZW5jUGFyYW0iLCJjb2RlY1BheWxvYWRUeXBlIiwicnR4IiwiZmVjIiwibWVjaGFuaXNtIiwiYmFuZHdpZHRoIiwibWF4Qml0cmF0ZSIsInBhcnNlUnRjcFBhcmFtZXRlcnMiLCJydGNwUGFyYW1ldGVycyIsInJlbW90ZVNzcmMiLCJjbmFtZSIsInJzaXplIiwicmVkdWNlZFNpemUiLCJjb21wb3VuZCIsIm11eCIsIndyaXRlUnRjcFBhcmFtZXRlcnMiLCJwYXJzZU1zaWQiLCJzcGVjIiwicGxhbkIiLCJtc2lkUGFydHMiLCJwYXJzZVNjdHBEZXNjcmlwdGlvbiIsInBhcnNlTUxpbmUiLCJtYXhTaXplTGluZSIsIm1heE1lc3NhZ2VTaXplIiwic2N0cFBvcnQiLCJmbXQiLCJzY3RwTWFwTGluZXMiLCJ3cml0ZVNjdHBEZXNjcmlwdGlvbiIsIm1lZGlhIiwic2N0cCIsIm91dHB1dCIsImdlbmVyYXRlU2Vzc2lvbklkIiwic3Vic3RyIiwid3JpdGVTZXNzaW9uQm9pbGVycGxhdGUiLCJzZXNzSWQiLCJzZXNzVmVyIiwic2Vzc1VzZXIiLCJzZXNzaW9uSWQiLCJ1c2VyIiwiZ2V0RGlyZWN0aW9uIiwiZ2V0S2luZCIsImlzUmVqZWN0ZWQiLCJwYXJzZU9MaW5lIiwidXNlcm5hbWUiLCJzZXNzaW9uVmVyc2lvbiIsIm5ldFR5cGUiLCJhZGRyZXNzVHlwZSIsImlzVmFsaWRTRFAiLCJzaGltUlRDSWNlQ2FuZGlkYXRlIiwiTmF0aXZlUlRDSWNlQ2FuZGlkYXRlIiwibmF0aXZlQ2FuZGlkYXRlIiwicGFyc2VkQ2FuZGlkYXRlIiwic2RwTWlkIiwic2RwTUxpbmVJbmRleCIsIndyaXRhYmxlIiwic2hpbVJUQ0ljZUNhbmRpZGF0ZVJlbGF5UHJvdG9jb2wiLCJyZWxheVByb3RvY29sIiwic2hpbU1heE1lc3NhZ2VTaXplIiwiX3NjdHAiLCJzY3RwSW5EZXNjcmlwdGlvbiIsIm1MaW5lIiwiZ2V0UmVtb3RlRmlyZWZveFZlcnNpb24iLCJnZXRDYW5TZW5kTWF4TWVzc2FnZVNpemUiLCJyZW1vdGVJc0ZpcmVmb3giLCJjYW5TZW5kTWF4TWVzc2FnZVNpemUiLCJnZXRNYXhNZXNzYWdlU2l6ZSIsImlzRmlyZWZveCIsImNhblNlbmRNTVMiLCJyZW1vdGVNTVMiLCJzaGltU2VuZFRocm93VHlwZUVycm9yIiwid3JhcERjU2VuZCIsImRjIiwib3JpZ0RhdGFDaGFubmVsU2VuZCIsInNlbmQiLCJyZWFkeVN0YXRlIiwib3JpZ0NyZWF0ZURhdGFDaGFubmVsIiwiY3JlYXRlRGF0YUNoYW5uZWwiLCJkYXRhQ2hhbm5lbCIsImNoYW5uZWwiLCJzaGltQ29ubmVjdGlvblN0YXRlIiwiY29tcGxldGVkIiwiY2hlY2tpbmciLCJpY2VDb25uZWN0aW9uU3RhdGUiLCJfb25jb25uZWN0aW9uc3RhdGVjaGFuZ2UiLCJvcmlnTWV0aG9kIiwiX2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZXBvbHkiLCJfbGFzdENvbm5lY3Rpb25TdGF0ZSIsImNvbm5lY3Rpb25TdGF0ZSIsIm5ld0V2ZW50IiwicmVtb3ZlRXh0bWFwQWxsb3dNaXhlZCIsIm5hdGl2ZVNSRCIsInNoaW1BZGRJY2VDYW5kaWRhdGVOdWxsT3JFbXB0eSIsIm5hdGl2ZUFkZEljZUNhbmRpZGF0ZSIsInNoaW1QYXJhbWV0ZXJsZXNzU2V0TG9jYWxEZXNjcmlwdGlvbiIsIm5hdGl2ZVNldExvY2FsRGVzY3JpcHRpb24iLCJhZGFwdGVyRmFjdG9yeSIsInNoaW1DaHJvbWUiLCJzaGltRmlyZWZveCIsInNoaW1TYWZhcmkiLCJhZGFwdGVyIiwiY29tbW9uU2hpbSIsImNocm9tZVNoaW0iLCJicm93c2VyU2hpbSIsImZpcmVmb3hTaGltIiwic2FmYXJpU2hpbSIsIkVOQ1JZUFRJT05fQUxHT1JJVEhNIiwiREVDUllQVElPTl9GQUlMVVJFX1RPTEVSQU5DRSIsIkUyRUVfRkxBRyIsIlNBTFQiLCJLRVlfUFJPVklERVJfREVGQVVMVFMiLCJzaGFyZWRLZXkiLCJyYXRjaGV0U2FsdCIsInJhdGNoZXRXaW5kb3dTaXplIiwiZmFpbHVyZVRvbGVyYW5jZSIsIktleVByb3ZpZGVyRXZlbnQiLCJLZXlIYW5kbGVyRXZlbnQiLCJFbmNyeXB0aW9uRXZlbnQiLCJDcnlwdG9yRXZlbnQiLCJpc0UyRUVTdXBwb3J0ZWQiLCJpc0luc2VydGFibGVTdHJlYW1TdXBwb3J0ZWQiLCJpc1NjcmlwdFRyYW5zZm9ybVN1cHBvcnRlZCIsIlJUQ1J0cFNjcmlwdFRyYW5zZm9ybSIsImNyZWF0ZUVuY29kZWRTdHJlYW1zIiwiaXNWaWRlb0ZyYW1lIiwiZnJhbWUiLCJpbXBvcnRLZXkiLCJrZXlCeXRlcyIsInVzYWdlIiwiY3J5cHRvIiwic3VidGxlIiwiY3JlYXRlS2V5TWF0ZXJpYWxGcm9tU3RyaW5nIiwia2V5TWF0ZXJpYWwiLCJjcmVhdGVLZXlNYXRlcmlhbEZyb21CdWZmZXIiLCJjcnlwdG9CdWZmZXIiLCJnZXRBbGdvT3B0aW9ucyIsImFsZ29yaXRobU5hbWUiLCJzYWx0IiwiZW5jb2RlZFNhbHQiLCJoYXNoIiwiaXRlcmF0aW9ucyIsImRlcml2ZUtleXMiLCJtYXRlcmlhbCIsImFsZ29yaXRobU9wdGlvbnMiLCJlbmNyeXB0aW9uS2V5IiwiZGVyaXZlS2V5IiwiY3JlYXRlRTJFRUtleSIsImdldFJhbmRvbVZhbHVlcyIsInJhdGNoZXQiLCJkZXJpdmVCaXRzIiwibmVlZHNSYnNwVW5lc2NhcGluZyIsImZyYW1lRGF0YSIsInBhcnNlUmJzcCIsImRhdGFPdXQiLCJrWmVyb3NJblN0YXJ0U2VxdWVuY2UiLCJrRW11bGF0aW9uQnl0ZSIsIndyaXRlUmJzcCIsImRhdGFfaW4iLCJudW1Db25zZWN1dGl2ZVplcm9zIiwiQmFzZUtleVByb3ZpZGVyIiwib25LZXlSYXRjaGV0ZWQiLCJrZXlJbmRleCIsImtleUluZm9NYXAiLCJLZXlSYXRjaGV0ZWQiLCJvblNldEVuY3J5cHRpb25LZXkiLCJrZXlJbmZvIiwiU2V0S2V5IiwiZ2V0S2V5cyIsImZyb20iLCJnZXRPcHRpb25zIiwicmF0Y2hldEtleSIsIlJhdGNoZXRSZXF1ZXN0IiwiRXh0ZXJuYWxFMkVFS2V5UHJvdmlkZXIiLCJvcHRzIiwic2V0S2V5IiwiZGVyaXZlZEtleSIsIkxpdmVraXRFcnJvciIsIkNvbm5lY3Rpb25FcnJvciIsInJlYXNvbiIsInN0YXR1cyIsIkRldmljZVVuc3VwcG9ydGVkRXJyb3IiLCJUcmFja0ludmFsaWRFcnJvciIsIlVuc3VwcG9ydGVkU2VydmVyIiwiVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSIsIk5lZ290aWF0aW9uRXJyb3IiLCJQdWJsaXNoRGF0YUVycm9yIiwiTWVkaWFEZXZpY2VGYWlsdXJlIiwiZ2V0RmFpbHVyZSIsIk5vdEZvdW5kIiwiUGVybWlzc2lvbkRlbmllZCIsIkRldmljZUluVXNlIiwiT3RoZXIiLCJSb29tRXZlbnQiLCJQYXJ0aWNpcGFudEV2ZW50IiwiRW5naW5lRXZlbnQiLCJUcmFja0V2ZW50IiwiaXNJbW1lZGlhdGUiLCJ1IiwiY2FsbGJhY2siLCJtYXhXYWl0IiwibCIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJjYW5jZWwiLCJjb21tb25WZXJzaW9uSWRlbnRpZmllciIsImdldEJyb3dzZXIiLCJmb3JjZSIsInVhIiwiYnJvd3NlcnNMaXN0IiwiZGVzY3JpYmUiLCJnZXRNYXRjaCIsImV4cCIsInByb3RvY29sVmVyc2lvbiIsIkNyaXRpY2FsVGltZXJzIiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwiVmlkZW9QcmVzZXQiLCJlbmNvZGluZyIsInJlc29sdXRpb24iLCJhc3BlY3RSYXRpbyIsImJhY2t1cENvZGVjcyIsInZpZGVvQ29kZWNzIiwiaXNCYWNrdXBDb2RlYyIsImJhY2t1cCIsIkF1ZGlvUHJlc2V0cyIsInRlbGVwaG9uZSIsInNwZWVjaCIsIm11c2ljIiwibXVzaWNTdGVyZW8iLCJtdXNpY0hpZ2hRdWFsaXR5IiwibXVzaWNIaWdoUXVhbGl0eVN0ZXJlbyIsIlZpZGVvUHJlc2V0cyIsImg5MCIsImgxODAiLCJoMjE2IiwiaDM2MCIsImg1NDAiLCJoNzIwIiwiaDEwODAiLCJoMTQ0MCIsImgyMTYwIiwiVmlkZW9QcmVzZXRzNDMiLCJoMTIwIiwiaDI0MCIsImg0ODAiLCJTY3JlZW5TaGFyZVByZXNldHMiLCJoMzYwZnBzMyIsImgzNjBmcHMxNSIsImg3MjBmcHM1IiwiaDcyMGZwczE1IiwiaDcyMGZwczMwIiwiaDEwODBmcHMxNSIsImgxMDgwZnBzMzAiLCJvcmlnaW5hbCIsIlNpZ25hbFRhcmdldCIsIlN0cmVhbVN0YXRlIiwiQ2FuZGlkYXRlUHJvdG9jb2wiLCJTaWduYWxSZXF1ZXN0IiwiU2Vzc2lvbkRlc2NyaXB0aW9uIiwiVHJpY2tsZVJlcXVlc3QiLCJBZGRUcmFja1JlcXVlc3QiLCJNdXRlVHJhY2tSZXF1ZXN0IiwiVXBkYXRlU3Vic2NyaXB0aW9uIiwiVXBkYXRlVHJhY2tTZXR0aW5ncyIsIkxlYXZlUmVxdWVzdCIsIlVwZGF0ZVZpZGVvTGF5ZXJzIiwiU3Vic2NyaXB0aW9uUGVybWlzc2lvbiIsIlN5bmNTdGF0ZSIsIlNpbXVsYXRlU2NlbmFyaW8iLCJVcGRhdGVQYXJ0aWNpcGFudE1ldGFkYXRhIiwiUGluZyIsIlNpZ25hbFJlc3BvbnNlIiwiSm9pblJlc3BvbnNlIiwiUGFydGljaXBhbnRVcGRhdGUiLCJUcmFja1B1Ymxpc2hlZFJlc3BvbnNlIiwiU3BlYWtlcnNDaGFuZ2VkIiwiUm9vbVVwZGF0ZSIsIkNvbm5lY3Rpb25RdWFsaXR5VXBkYXRlIiwiU3RyZWFtU3RhdGVVcGRhdGUiLCJTdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSIsIlN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUiLCJUcmFja1VucHVibGlzaGVkUmVzcG9uc2UiLCJSZWNvbm5lY3RSZXNwb25zZSIsIlBvbmciLCJTdWJzY3JpcHRpb25SZXNwb25zZSIsIlNpbXVsY2FzdENvZGVjIiwic2ltdWxjYXN0Q29kZWNzIiwiY2FuZGlkYXRlSW5pdCIsIlBVQkxJU0hFUiIsIm90aGVyUGFydGljaXBhbnRzIiwic2VydmVyVmVyc2lvbiIsInN1YnNjcmliZXJQcmltYXJ5IiwiYWx0ZXJuYXRpdmVVcmwiLCJzZXJ2ZXJSZWdpb24iLCJwaW5nVGltZW91dCIsInBpbmdJbnRlcnZhbCIsInNpZlRyYWlsZXIiLCJJQ0VTZXJ2ZXIiLCJ0cmFja1NpZCIsInBhcnRpY2lwYW50cyIsInN1YnNjcmliZSIsInBhcnRpY2lwYW50VHJhY2tzIiwiZGlzYWJsZWQiLCJmcHMiLCJjYW5SZWNvbm5lY3QiLCJVTktOT1dOX1JFQVNPTiIsImNyZWRlbnRpYWwiLCJDb25uZWN0aW9uUXVhbGl0eUluZm8iLCJQT09SIiwic2NvcmUiLCJ1cGRhdGVzIiwiU3RyZWFtU3RhdGVJbmZvIiwiQUNUSVZFIiwic3RyZWFtU3RhdGVzIiwiU3Vic2NyaWJlZFF1YWxpdHkiLCJTdWJzY3JpYmVkQ29kZWMiLCJxdWFsaXRpZXMiLCJzdWJzY3JpYmVkUXVhbGl0aWVzIiwic3Vic2NyaWJlZENvZGVjcyIsIlRyYWNrUGVybWlzc2lvbiIsImFsbFRyYWNrcyIsImFsbFBhcnRpY2lwYW50cyIsInRyYWNrUGVybWlzc2lvbnMiLCJhbGxvd2VkIiwicHVibGlzaFRyYWNrcyIsImRhdGFDaGFubmVscyIsIkRhdGFDaGFubmVsSW5mbyIsInNjZW5hcmlvIiwicnR0IiwibGFzdFBpbmdUaW1lc3RhbXAiLCJSZWdpb25TZXR0aW5ncyIsInJlZ2lvbnMiLCJSZWdpb25JbmZvIiwiZGlzdGFuY2UiLCJTRV9VTktOT1dOIiwiY2xvbmVEZWVwIiwic3RydWN0dXJlZENsb25lIiwiQkFDS0dST1VORF9SRUFDVElPTl9ERUxBWSIsInJlY3ljbGVkRWxlbWVudHMiLCJUcmFjayIsIm1lZGlhVHJhY2siLCJsb2dnZXJPcHRpb25zIiwiYXR0YWNoZWRFbGVtZW50cyIsImlzTXV0ZWQiLCJzdHJlYW1TdGF0ZSIsIkFjdGl2ZSIsImlzSW5CYWNrZ3JvdW5kIiwiX2N1cnJlbnRCaXRyYXRlIiwiYXBwVmlzaWJpbGl0eUNoYW5nZWRMaXN0ZW5lciIsImJhY2tncm91bmRUaW1lb3V0IiwidmlzaWJpbGl0eVN0YXRlIiwiaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWQiLCJsb2dnZXJDb250ZXh0Q2IiLCJfbWVkaWFTdHJlYW1UcmFjayIsIl9tZWRpYVN0cmVhbUlEIiwiU291cmNlIiwiVW5rbm93biIsImxvZ0NvbnRleHQiLCJnZXRMb2dDb250ZXh0RnJvbVRyYWNrIiwiY3VycmVudEJpdHJhdGUiLCJtZWRpYVN0cmVhbVRyYWNrIiwibWVkaWFTdHJlYW1JRCIsImF0dGFjaCIsImVsZW1lbnQiLCJlbGVtZW50VHlwZSIsIktpbmQiLCJWaWRlbyIsImFkZEFwcFZpc2liaWxpdHlMaXN0ZW5lciIsInBhcmVudEVsZW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiYXR0YWNoVG9FbGVtZW50IiwiYWxsTWVkaWFTdHJlYW1UcmFja3MiLCJzcmNPYmplY3QiLCJoYXNBdWRpbyIsInRyIiwicGxheSIsIkF1ZGlvUGxheWJhY2tTdGFydGVkIiwiVmlkZW9QbGF5YmFja1N0YXJ0ZWQiLCJBdWRpb1BsYXliYWNrRmFpbGVkIiwiVmlkZW9QbGF5YmFja0ZhaWxlZCIsIkVsZW1lbnRBdHRhY2hlZCIsImRldGFjaCIsImRldGFjaFRyYWNrIiwicmVjeWNsZUVsZW1lbnQiLCJFbGVtZW50RGV0YWNoZWQiLCJkZXRhY2hlZCIsImVsbSIsInJlbW92ZUFwcFZpc2liaWxpdHlMaXN0ZW5lciIsInN0b3BNb25pdG9yIiwiZW5hYmxlIiwiZGlzYWJsZSIsIm1vbml0b3JJbnRlcnZhbCIsInVwZGF0ZUxvZ2dlck9wdGlvbnMiLCJIVE1MQXVkaW9FbGVtZW50Iiwic2hvdWxkQ2FjaGUiLCJwYXVzZSIsImlzV2ViIiwibWVkaWFTdHJlYW0iLCJleGlzdGluZ1RyYWNrcyIsImV0IiwiaXNTYWZhcmkiLCJIVE1MVmlkZW9FbGVtZW50IiwiYXV0b3BsYXkiLCJwbGF5c0lubGluZSIsImlzRmlyZUZveCIsImtpbmRUb1Byb3RvIiwiQXVkaW8iLCJWSURFTyIsIkRBVEEiLCJraW5kRnJvbVByb3RvIiwic291cmNlVG9Qcm90byIsIkNhbWVyYSIsIkNBTUVSQSIsIk1pY3JvcGhvbmUiLCJNSUNST1BIT05FIiwiU2NyZWVuU2hhcmUiLCJTQ1JFRU5fU0hBUkUiLCJTY3JlZW5TaGFyZUF1ZGlvIiwiU0NSRUVOX1NIQVJFX0FVRElPIiwic291cmNlRnJvbVByb3RvIiwic3RyZWFtU3RhdGVGcm9tUHJvdG8iLCJQcm90b1N0cmVhbVN0YXRlIiwiUEFVU0VEIiwiUGF1c2VkIiwibWVyZ2VEZWZhdWx0T3B0aW9ucyIsImF1ZGlvRGVmYXVsdHMiLCJ2aWRlb0RlZmF1bHRzIiwibWVyZ2VPYmplY3RXaXRob3V0T3ZlcndyaXRpbmciLCJtYWluT2JqZWN0Iiwib2JqZWN0VG9NZXJnZSIsImNvbnN0cmFpbnRzRm9yT3B0aW9ucyIsInZpZGVvT3B0aW9ucyIsImRldGVjdFNpbGVuY2UiLCJ0aW1lT2Zmc2V0IiwiY3R4IiwiZ2V0TmV3QXVkaW9Db250ZXh0IiwiYW5hbHlzZXIiLCJjcmVhdGVBbmFseXNlciIsImZmdFNpemUiLCJidWZmZXJMZW5ndGgiLCJmcmVxdWVuY3lCaW5Db3VudCIsImRhdGFBcnJheSIsImNyZWF0ZU1lZGlhU3RyZWFtU291cmNlIiwiY29ubmVjdCIsInNsZWVwIiwiZ2V0Qnl0ZVRpbWVEb21haW5EYXRhIiwic29tZU5vaXNlIiwic2FtcGxlIiwiY2xvc2UiLCJsYXRlbmN5SGludCIsInNvdXJjZVRvS2luZCIsInNjcmVlbkNhcHR1cmVUb0Rpc3BsYXlNZWRpYVN0cmVhbU9wdGlvbnMiLCJ2aWRlb0NvbnN0cmFpbnRzIiwiY29udHJvbGxlciIsInNlbGZCcm93c2VyU3VyZmFjZSIsInN1cmZhY2VTd2l0Y2hpbmciLCJzeXN0ZW1BdWRpbyIsIm1pbWVUeXBlVG9WaWRlb0NvZGVjU3RyaW5nIiwiZ2V0VHJhY2tQdWJsaWNhdGlvbkluZm8iLCJpbmZvcyIsInRyYWNrSW5mbyIsInRyYWNrU291cmNlIiwidHJhY2tNdXRlZCIsInRyYWNrRW5hYmxlZCIsInRyYWNrS2luZCIsInRyYWNrTmFtZSIsImlzRW5hYmxlZCIsInRyYWNrRW5jcnlwdGVkIiwiaXNFbmNyeXB0ZWQiLCJ0cmFja01pbWVUeXBlIiwic2VwYXJhdG9yIiwiZGRFeHRlbnNpb25VUkkiLCJ1bnBhY2tTdHJlYW1JZCIsInN1cHBvcnRzVHJhbnNjZWl2ZXIiLCJzdXBwb3J0c0FkZFRyYWNrIiwic3VwcG9ydHNBZGFwdGl2ZVN0cmVhbSIsIlJlc2l6ZU9ic2VydmVyIiwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJzdXBwb3J0c0R5bmFjYXN0Iiwic3VwcG9ydHNBVjEiLCJjYXBhYmlsaXRpZXMiLCJnZXRDYXBhYmlsaXRpZXMiLCJoYXNBVjEiLCJzdXBwb3J0c1ZQOSIsImNvbXBhcmVWZXJzaW9ucyIsImhhc1ZQOSIsImlzU1ZDQ29kZWMiLCJzdXBwb3J0c1NldFNpbmtJZCIsInNldENvZGVjUHJlZmVyZW5jZXNWZXJzaW9ucyIsIkNocm9tZSIsIlNhZmFyaSIsIkZpcmVmb3giLCJzdXBwb3J0c1NldENvZGVjUHJlZmVyZW5jZXMiLCJpc0Jyb3dzZXJTdXBwb3J0ZWQiLCJpc0Nocm9taXVtQmFzZWQiLCJpc1NhZmFyaTE3IiwiaXNNb2JpbGUiLCJpc1JlYWN0TmF0aXZlIiwicHJvZHVjdCIsImlzQ2xvdWQiLCJzZXJ2ZXJVcmwiLCJob3N0bmFtZSIsImdldExLUmVhY3ROYXRpdmVJbmZvIiwiZ2xvYmFsIiwiTGl2ZUtpdFJlYWN0TmF0aXZlR2xvYmFsIiwiZ2V0UmVhY3ROYXRpdmVPcyIsInBsYXRmb3JtIiwiZ2V0RGV2aWNlUGl4ZWxSYXRpbyIsImRldmljZVBpeGVsUmF0aW8iLCJ2MSIsInYyIiwicGFydHMxIiwicGFydHMyIiwicDEiLCJwMiIsInJvRGlzcGF0Y2hDYWxsYmFjayIsImVudHJ5IiwiaGFuZGxlUmVzaXplIiwiaW9EaXNwYXRjaENhbGxiYWNrIiwiaGFuZGxlVmlzaWJpbGl0eUNoYW5nZWQiLCJyZXNpemVPYnNlcnZlciIsImdldFJlc2l6ZU9ic2VydmVyIiwiaW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJnZXRJbnRlcnNlY3Rpb25PYnNlcnZlciIsInJvb3RNYXJnaW4iLCJnZXRDbGllbnRJbmZvIiwiSlMiLCJlbXB0eVZpZGVvU3RyZWFtVHJhY2siLCJnZXRFbXB0eVZpZGVvU3RyZWFtVHJhY2siLCJjcmVhdGVEdW1teVZpZGVvU3RyZWFtVHJhY2siLCJwYWludENvbnRlbnQiLCJjYW52YXMiLCJnZXRDb250ZXh0IiwiZmlsbFJlY3QiLCJiZWdpblBhdGgiLCJhcmMiLCJQSSIsImNsb3NlUGF0aCIsImZpbGxTdHlsZSIsImZpbGwiLCJkdW1teVN0cmVhbSIsImNhcHR1cmVTdHJlYW0iLCJkdW1teVRyYWNrIiwiZW1wdHlBdWRpb1N0cmVhbVRyYWNrIiwiZ2V0RW1wdHlBdWRpb1N0cmVhbVRyYWNrIiwib3NjaWxsYXRvciIsImNyZWF0ZU9zY2lsbGF0b3IiLCJnYWluIiwiY3JlYXRlR2FpbiIsInNldFZhbHVlQXRUaW1lIiwiZHN0IiwiY3JlYXRlTWVkaWFTdHJlYW1EZXN0aW5hdGlvbiIsIkZ1dHVyZSIsImZ1dHVyZUJhc2UiLCJvbkZpbmFsbHkiLCJfX2F3YWl0ZXIiLCJjcmVhdGVBdWRpb0FuYWx5c2VyIiwiY2xvbmVUcmFjayIsInNtb290aGluZ1RpbWVDb25zdGFudCIsIm1pbkRlY2liZWxzIiwibWF4RGVjaWJlbHMiLCJhdWRpb0NvbnRleHQiLCJzdHJlYW1UcmFjayIsIm1lZGlhU3RyZWFtU291cmNlIiwiY2FsY3VsYXRlVm9sdW1lIiwiZ2V0Qnl0ZUZyZXF1ZW5jeURhdGEiLCJzdW0iLCJhbXBsaXR1ZGUiLCJwb3ciLCJ2b2x1bWUiLCJzcXJ0IiwiY2xlYW51cCIsIk11dGV4IiwiX2xvY2tpbmciLCJfbG9ja3MiLCJpc0xvY2tlZCIsImxvY2siLCJ1bmxvY2tOZXh0Iiwid2lsbExvY2siLCJ3aWxsVW5sb2NrIiwiaXNWaWRlb0NvZGVjIiwibWF5YmVDb2RlYyIsInVud3JhcENvbnN0cmFpbnQiLCJ0b1dlYnNvY2tldFVybCIsInRvSHR0cFVybCIsImRlZmF1bHRJZCIsIkRldmljZU1hbmFnZXIiLCJnZXRJbnN0YW5jZSIsImluc3RhbmNlIiwiZ2V0RGV2aWNlcyIsInJlcXVlc3RQZXJtaXNzaW9ucyIsInVzZXJNZWRpYVByb21pc2VNYXAiLCJoYXNEZXZpY2VJblVzZSIsImlzRHVtbXlEZXZpY2VPckVtcHR5IiwiZGV2aWNlIiwibm9MYWJlbCIsImlzUmVsZXZhbnQiLCJwZXJtaXNzaW9uc1RvQWNxdWlyZSIsIm5vcm1hbGl6ZURldmljZUlkIiwiZ3JvdXBJZCIsIm1lZGlhRGV2aWNlS2luZHMiLCJkZWZhdWx0RGltZW5zaW9uc1RpbWVvdXQiLCJMb2NhbFRyYWNrIiwiX2NvbnN0cmFpbnRzIiwidXNlclByb3ZpZGVkVHJhY2siLCJfaXNVcHN0cmVhbVBhdXNlZCIsImhhbmRsZVRyYWNrTXV0ZUV2ZW50IiwiZGVib3VuY2VkVHJhY2tNdXRlSGFuZGxlciIsImRlYm91bmNlIiwicGF1c2VVcHN0cmVhbSIsImhhbmRsZVRyYWNrVW5tdXRlRXZlbnQiLCJyZXN1bWVVcHN0cmVhbSIsImhhbmRsZUVuZGVkIiwicmVhY3F1aXJlVHJhY2siLCJFbmRlZCIsInByb3ZpZGVkQnlVc2VyIiwibXV0ZUxvY2siLCJwYXVzZVVwc3RyZWFtTG9jayIsInByb2Nlc3NvckxvY2siLCJzZXRNZWRpYVN0cmVhbVRyYWNrIiwiZ2V0Q29uc3RyYWludHMiLCJkaW1lbnNpb25zIiwiaXNVcHN0cmVhbVBhdXNlZCIsImlzVXNlclByb3ZpZGVkIiwicHJvY2Vzc29yIiwicHJvY2Vzc2VkVHJhY2siLCJuZXdUcmFjayIsImVsIiwicHJvY2Vzc29yRWxlbWVudCIsInJlc3RhcnQiLCJyZXBsYWNlVHJhY2siLCJ3YWl0Rm9yRGltZW5zaW9ucyIsInRpbWVvdXQiLCJzdGFydGVkIiwiZGltcyIsImdldERldmljZUlkIiwibXV0ZSIsInNldFRyYWNrTXV0ZWQiLCJ1bm11dGUiLCJzdG9wUHJvY2Vzc29yIiwic3RyZWFtQ29uc3RyYWludHMiLCJSZXN0YXJ0ZWQiLCJNdXRlZCIsIlVubXV0ZWQiLCJuZWVkc1JlQWNxdWlzaXRpb24iLCJfc3VwZXIiLCJkZXN0cm95IiwidW5sb2NrIiwiVXBzdHJlYW1QYXVzZWQiLCJVcHN0cmVhbVJlc3VtZWQiLCJnZXRSVENTdGF0c1JlcG9ydCIsInN0YXRzUmVwb3J0Iiwic2V0UHJvY2Vzc29yIiwic2hvd1Byb2Nlc3NlZFN0cmVhbUxvY2FsbHkiLCJwcm9jZXNzb3JPcHRpb25zIiwiZ2V0UHJvY2Vzc29yIiwicmVtb3ZlIiwiRTJFRU1hbmFnZXIiLCJvbldvcmtlck1lc3NhZ2UiLCJldiIsIkVuY3J5cHRpb25FcnJvciIsImtleVByb3ZpZGVyIiwicG9zdEtleSIsImVuY3J5cHRpb25FbmFibGVkIiwicm9vbSIsImxvY2FsUGFydGljaXBhbnQiLCJQYXJ0aWNpcGFudEVuY3J5cHRpb25TdGF0dXNDaGFuZ2VkIiwicGFydGljaXBhbnQiLCJnZXRQYXJ0aWNpcGFudEJ5SWRlbnRpdHkiLCJvbldvcmtlckVycm9yIiwid29ya2VyIiwic2V0dXAiLCJzZXR1cEV2ZW50TGlzdGVuZXJzIiwia2V5UHJvdmlkZXJPcHRpb25zIiwib25tZXNzYWdlIiwib25lcnJvciIsInBvc3RNZXNzYWdlIiwic2V0UGFydGljaXBhbnRDcnlwdG9yRW5hYmxlZCIsInBvc3RFbmFibGUiLCJzZXRTaWZUcmFpbGVyIiwidHJhaWxlciIsInBvc3RTaWZUcmFpbGVyIiwic2V0dXBFbmdpbmUiLCJlbmdpbmUiLCJSVFBWaWRlb01hcFVwZGF0ZSIsInJ0cE1hcCIsInBvc3RSVFBNYXAiLCJUcmFja1B1Ymxpc2hlZCIsInB1YiIsIkNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQiLCJDb25uZWN0aW9uU3RhdGUiLCJDb25uZWN0ZWQiLCJUcmFja1Vuc3Vic2NyaWJlZCIsIl8iLCJUcmFja1N1YnNjcmliZWQiLCJzZXR1cEUyRUVSZWNlaXZlciIsIlNpZ25hbENvbm5lY3RlZCIsImlzRTJFRUVuYWJsZWQiLCJMb2NhbFRyYWNrUHVibGlzaGVkIiwicHVibGljYXRpb24iLCJzZXR1cEUyRUVTZW5kZXIiLCJwYXJ0aWNpcGFudElkIiwicG9zdFJhdGNoZXRSZXF1ZXN0IiwiZW5hYmxlTXNnIiwiUmVmZXJlbmNlRXJyb3IiLCJyZW1vdGVJZCIsImhhbmRsZVJlY2VpdmVyIiwiaGFuZGxlU2VuZGVyIiwidHJhbnNmb3JtIiwid3JpdGFibGVTdHJlYW0iLCJyZWFkYWJsZSIsInJlYWRhYmxlU3RyZWFtIiwicmVjZWl2ZXJTdHJlYW1zIiwic2VuZGVyU3RyZWFtcyIsIlF1ZXVlVGFza1N0YXR1cyIsIkFzeW5jUXVldWUiLCJwZW5kaW5nVGFza3MiLCJ0YXNrTXV0ZXgiLCJuZXh0VGFza0luZGV4IiwicnVuIiwidGFzayIsInRhc2tJbmZvIiwiZW5xdWV1ZWRBdCIsIldBSVRJTkciLCJleGVjdXRlZEF0IiwiUlVOTklORyIsIkNPTVBMRVRFRCIsImZsdXNoIiwic25hcHNob3QiLCJwYXNzVGhyb3VnaFF1ZXVlU2lnbmFscyIsImNhblBhc3NUaHJvdWdoUXVldWUiLCJyZXEiLCJjYW5QYXNzIiwiU2lnbmFsQ29ubmVjdGlvblN0YXRlIiwiU2lnbmFsQ2xpZW50IiwiY3VycmVudFN0YXRlIiwiaXNEaXNjb25uZWN0ZWQiLCJESVNDT05ORUNUSU5HIiwiRElTQ09OTkVDVEVEIiwiaXNFc3RhYmxpc2hpbmdDb25uZWN0aW9uIiwiQ09OTkVDVElORyIsIlJFQ09OTkVDVElORyIsInVzZUpTT04iLCJyZXNldENhbGxiYWNrcyIsIm9uQW5zd2VyIiwib25MZWF2ZSIsIm9uTG9jYWxUcmFja1B1Ymxpc2hlZCIsIm9uTG9jYWxUcmFja1VucHVibGlzaGVkIiwib25OZWdvdGlhdGVSZXF1ZXN0ZWQiLCJvbk9mZmVyIiwib25SZW1vdGVNdXRlQ2hhbmdlZCIsIm9uU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUiLCJvblRva2VuUmVmcmVzaCIsIm9uVHJpY2tsZSIsIm9uQ2xvc2UiLCJTaWduYWwiLCJyZXF1ZXN0UXVldWUiLCJxdWV1ZWRSZXF1ZXN0cyIsImNsb3NpbmdMb2NrIiwiY29ubmVjdGlvbkxvY2siLCJ0b2tlbiIsImFib3J0U2lnbmFsIiwicmVzIiwicmVjb25uZWN0IiwiY2xlYXJQaW5nSW50ZXJ2YWwiLCJyZWNvbm5lY3RSZWFzb24iLCJjb25uZWN0T3B0aW9ucyIsImNsaWVudEluZm8iLCJjcmVhdGVDb25uZWN0aW9uUGFyYW1zIiwiYWJvcnRIYW5kbGVyIiwid3NUaW1lb3V0Iiwid2Vic29ja2V0VGltZW91dCIsImFib3J0ZWQiLCJ3cyIsIldlYlNvY2tldCIsImJpbmFyeVR5cGUiLCJvbm9wZW4iLCJDT05ORUNURUQiLCJyZXNwIiwiZmV0Y2giLCJ0b0ZpeGVkIiwidGV4dCIsImhhbmRsZVdTRXJyb3IiLCJzaG91bGRQcm9jZXNzTWVzc2FnZSIsInBpbmdUaW1lb3V0RHVyYXRpb24iLCJwaW5nSW50ZXJ2YWxEdXJhdGlvbiIsImludGVydmFsIiwic3RhcnRQaW5nSW50ZXJ2YWwiLCJzaWduYWxMYXRlbmN5IiwiaGFuZGxlU2lnbmFsUmVzcG9uc2UiLCJvbmNsb3NlIiwiaGFuZGxlT25DbG9zZSIsInVwZGF0ZVN0YXRlIiwiY2xvc2VQcm9taXNlIiwiQ0xPU0lORyIsInJhY2UiLCJzZW5kT2ZmZXIiLCJvZmZlciIsIm9mZmVyU2RwIiwic2VuZFJlcXVlc3QiLCJ0b1Byb3RvU2Vzc2lvbkRlc2NyaXB0aW9uIiwic2VuZEFuc3dlciIsImFuc3dlciIsImFuc3dlclNkcCIsInNlbmRJY2VDYW5kaWRhdGUiLCJzZW5kTXV0ZVRyYWNrIiwic2VuZEFkZFRyYWNrIiwic2VuZFVwZGF0ZUxvY2FsTWV0YWRhdGEiLCJzZW5kVXBkYXRlVHJhY2tTZXR0aW5ncyIsInNldHRpbmdzIiwic2VuZFVwZGF0ZVN1YnNjcmlwdGlvbiIsInN1YiIsInNlbmRTeW5jU3RhdGUiLCJzeW5jIiwic2VuZFVwZGF0ZVZpZGVvTGF5ZXJzIiwic2VuZFVwZGF0ZVN1YnNjcmlwdGlvblBlcm1pc3Npb25zIiwic2VuZFNpbXVsYXRlU2NlbmFyaW8iLCJzZW5kUGluZyIsInNlbmRMZWF2ZSIsIkNMSUVOVF9JTklUSUFURUQiLCJmcm9tUXVldWUiLCJjYW5RdWV1ZSIsIk9QRU4iLCJwaW5nSGFuZGxlZCIsInNkIiwiZnJvbVByb3RvU2Vzc2lvbkRlc2NyaXB0aW9uIiwib25QYXJ0aWNpcGFudFVwZGF0ZSIsIm9uU3BlYWtlcnNDaGFuZ2VkIiwib25Sb29tVXBkYXRlIiwib25Db25uZWN0aW9uUXVhbGl0eSIsIm9uU3RyZWFtU3RhdGVVcGRhdGUiLCJvblN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUiLCJvblN1YnNjcmlwdGlvbkVycm9yIiwicmVzZXRQaW5nVGltZW91dCIsIm1zZ0Nhc2UiLCJzZXRSZWNvbm5lY3RlZCIsIm9uQ2xvc2VDYWxsYmFjayIsImNsZWFyUGluZ1RpbWVvdXQiLCJ0b1VUQ1N0cmluZyIsInJzZCIsIlVSTFNlYXJjaFBhcmFtcyIsImF1dG9TdWJzY3JpYmUiLCJwdWJsaXNoT25seSIsImFkYXB0aXZlU3RyZWFtIiwiY29ubmVjdGlvbiIsImdyYW1tYXIiLCJncmFtbWFyTW9kdWxlIiwicmVnIiwicmF0ZSIsInN1YnR5cGUiLCJjb25maWciLCJzZXNzaW9uQ29uZmlnIiwic3RyIiwicmFkZHIiLCJ0Y3B0eXBlIiwiZ2VuZXJhdGlvbiIsImRpcjIiLCJjbGtzcmNFeHQiLCJtZWRpYUNsb2NrVmFsdWUiLCJyYXRlTnVtZXJhdG9yIiwicmF0ZURlbm9taW5hdG9yIiwib2JqcyIsInRvSW50SWZJbnQiLCJhdHRhY2hQcm9wZXJ0aWVzIiwicmF3TmFtZSIsInBhcnNlUmVnIiwiY29udGVudCIsIm5lZWRzQmxhbmsiLCJrZXlMb2NhdGlvbiIsInJlcXVpcmUkJDAiLCJ2YWxpZExpbmUiLCJzZXNzaW9uIiwicnRwIiwiZm10cCIsInBhcmFtUmVkdWNlciIsImFjYyIsInBhcnNlUGFyYW1zIiwicGFyc2VGbXRwQ29uZmlnIiwicGFyc2VQYXlsb2FkcyIsInBhcnNlUmVtb3RlQ2FuZGlkYXRlcyIsImNhbmRpZGF0ZXMiLCJwYXJzZUltYWdlQXR0cmlidXRlcyIsInBhcnNlU2ltdWxjYXN0U3RyZWFtTGlzdCIsInNjaWQiLCJwYXVzZWQiLCJmb3JtYXRSZWdFeHAiLCJmb3JtYXRTdHIiLCJ4IiwibWFrZUxpbmUiLCJkZWZhdWx0T3V0ZXJPcmRlciIsImRlZmF1bHRJbm5lck9yZGVyIiwicGF5bG9hZHMiLCJvdXRlck9yZGVyIiwiaW5uZXJPcmRlciIsInBhcnNlciIsInJlcXVpcmUkJDEiLCJ3cml0ZSIsInN0YXJ0Qml0cmF0ZUZvclNWQyIsIlBDRXZlbnRzIiwiTmVnb3RpYXRpb25TdGFydGVkIiwiTmVnb3RpYXRpb25Db21wbGV0ZSIsIlJUUFZpZGVvUGF5bG9hZFR5cGVzIiwiUENUcmFuc3BvcnQiLCJjcmVhdGVQQyIsIm1lZGlhQ29uc3RyYWludHMiLCJwZW5kaW5nQ2FuZGlkYXRlcyIsInJlc3RhcnRpbmdJY2UiLCJyZW5lZ290aWF0ZSIsInRyYWNrQml0cmF0ZXMiLCJyZW1vdGVTdGVyZW9NaWRzIiwicmVtb3RlTmFja01pZHMiLCJuZWdvdGlhdGUiLCJjcmVhdGVBbmRTZW5kT2ZmZXIiLCJvbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSIsIm9uaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlIiwib25pY2VnYXRoZXJpbmdzdGF0ZWNoYW5nZSIsIm9uZGF0YWNoYW5uZWwiLCJvbm5lZ290aWF0aW9ubmVlZGVkIiwib25zaWduYWxpbmdzdGF0ZWNoYW5nZSIsIm9uaWNlY2FuZGlkYXRlIiwib250cmFjayIsIm9uSWNlQ2FuZGlkYXRlIiwib25pY2VjYW5kaWRhdGVlcnJvciIsIm9uSWNlQ2FuZGlkYXRlRXJyb3IiLCJvbkljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZSIsIm9uU2lnbmFsaW5nU3RhdGVjaGFuZ2UiLCJvbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZSIsIm9uRGF0YUNoYW5uZWwiLCJvblRyYWNrIiwiaXNJQ0VDb25uZWN0ZWQiLCJyZW1vdGVEZXNjcmlwdGlvbiIsIm11bmdlZFNEUCIsInN0ZXJlb01pZHMiLCJuYWNrTWlkcyIsImV4dHJhY3RTdGVyZW9BbmROYWNrQXVkaW9Gcm9tT2ZmZXIiLCJzZHBQYXJzZWQiLCJ0cmFja2JyIiwiY29kZWNQYXlsb2FkIiwiZm10cEZvdW5kIiwiYXR0ciIsIm1heGJyIiwic2V0TXVuZ2VkU0RQIiwiaWNlUmVzdGFydCIsImN1cnJlbnRTRCIsImVuc3VyZUF1ZGlvTmFja0FuZFN0ZXJlbyIsImVuc3VyZVZpZGVvRERFeHRlbnNpb25Gb3JTVkMiLCJtc2lkIiwicm91bmQiLCJjcmVhdGVBbmRTZXRBbnN3ZXIiLCJkYXRhQ2hhbm5lbERpY3QiLCJ0cmFuc2NlaXZlckluaXQiLCJzZXRUcmFja0NvZGVjQml0cmF0ZSIsInNldENvbmZpZ3VyYXRpb24iLCJydGNDb25maWciLCJjYW5SZW1vdmVUcmFjayIsImdldENvbm5lY3Rpb25TdGF0ZSIsImdldElDRUNvbm5lY3Rpb25TdGF0ZSIsImdldFNpZ25hbGxpbmdTdGF0ZSIsImdldExvY2FsRGVzY3JpcHRpb24iLCJsb2NhbERlc2NyaXB0aW9uIiwiZ2V0UmVtb3RlRGVzY3JpcHRpb24iLCJnZXRDb25uZWN0ZWRBZGRyZXNzIiwic2VsZWN0ZWRDYW5kaWRhdGVQYWlySWQiLCJjYW5kaWRhdGVQYWlycyIsInNlbGVjdGVkIiwic2VsZWN0ZWRJRCIsInJlbW90ZUNhbmRpZGF0ZUlkIiwibXVuZ2VkIiwicmVtb3RlIiwib3JpZ2luYWxTZHAiLCJyZW1vdGVTZHAiLCJvcHVzUGF5bG9hZCIsInJ0Y3BGYiIsIm1heElEIiwiZGRGb3VuZCIsImV4dCIsImRlZmF1bHRWaWRlb0NvZGVjIiwicHVibGlzaERlZmF1bHRzIiwiYXVkaW9CaXRyYXRlIiwiYXVkaW9QcmVzZXQiLCJkdHgiLCJyZWQiLCJmb3JjZVN0ZXJlbyIsInNjcmVlblNoYXJlRW5jb2RpbmciLCJzdG9wTWljVHJhY2tPbk11dGUiLCJ2aWRlb0NvZGVjIiwiYmFja3VwQ29kZWMiLCJhdXRvR2FpbkNvbnRyb2wiLCJlY2hvQ2FuY2VsbGF0aW9uIiwibm9pc2VTdXBwcmVzc2lvbiIsInJvb21PcHRpb25EZWZhdWx0cyIsImR5bmFjYXN0Iiwic3RvcExvY2FsVHJhY2tPblVucHVibGlzaCIsInJlY29ubmVjdFBvbGljeSIsImRpc2Nvbm5lY3RPblBhZ2VMZWF2ZSIsImV4cFdlYkF1ZGlvTWl4Iiwicm9vbUNvbm5lY3RPcHRpb25EZWZhdWx0cyIsIm1heFJldHJpZXMiLCJwZWVyQ29ubmVjdGlvblRpbWVvdXQiLCJQQ1RyYW5zcG9ydFN0YXRlIiwiUENUcmFuc3BvcnRNYW5hZ2VyIiwibmVlZHNQdWJsaXNoZXIiLCJpc1B1Ymxpc2hlckNvbm5lY3Rpb25SZXF1aXJlZCIsIm5lZWRzU3Vic2NyaWJlciIsImlzU3Vic2NyaWJlckNvbm5lY3Rpb25SZXF1aXJlZCIsInByZXZpb3VzU3RhdGUiLCJjb25uZWN0aW9uU3RhdGVzIiwicmVxdWlyZWRUcmFuc3BvcnRzIiwic3QiLCJGQUlMRUQiLCJDTE9TRUQiLCJORVciLCJvblN0YXRlQ2hhbmdlIiwicHVibGlzaGVyIiwic3Vic2NyaWJlciIsIlBDTWFuYWdlciIsImdvb2dDb25zdHJhaW50cyIsImdvb2dEc2NwIiwiU1VCU0NSSUJFUiIsIm9uUHVibGlzaGVyT2ZmZXIiLCJyZXF1aXJlUHVibGlzaGVyIiwicmVxdWlyZSIsInJlcXVpcmVTdWJzY3JpYmVyIiwiY3JlYXRlQW5kU2VuZFB1Ymxpc2hlck9mZmVyIiwic2V0UHVibGlzaGVyQW5zd2VyIiwidHJpZ2dlckljZVJlc3RhcnQiLCJjcmVhdGVTdWJzY3JpYmVyQW5zd2VyRnJvbU9mZmVyIiwiUlRDU2RwVHlwZSIsInVwZGF0ZUNvbmZpZ3VyYXRpb24iLCJlbnN1cmVQQ1RyYW5zcG9ydENvbm5lY3Rpb24iLCJhYm9ydENvbnRyb2xsZXIiLCJ0cmFuc3BvcnQiLCJlbnN1cmVUcmFuc3BvcnRDb25uZWN0ZWQiLCJuZWdvdGlhdGlvblRpbWVvdXQiLCJzaWduYWwiLCJhZGRQdWJsaXNoZXJUcmFuc2NlaXZlciIsImFkZFB1Ymxpc2hlclRyYWNrIiwiY3JlYXRlUHVibGlzaGVyRGF0YUNoYW5uZWwiLCJ0cmFuc3BvcnRzIiwicGNUcmFuc3BvcnQiLCJjb25uZWN0VGltZW91dCIsImxvc3N5RGF0YUNoYW5uZWwiLCJyZWxpYWJsZURhdGFDaGFubmVsIiwibWluUmVjb25uZWN0V2FpdCIsImxlYXZlUmVjb25uZWN0IiwiUENTdGF0ZSIsIlJUQ0VuZ2luZSIsImlzQ2xvc2VkIiwiX2lzQ2xvc2VkIiwiZnVsbFJlY29ubmVjdE9uTmV4dCIsInBjU3RhdGUiLCJOZXciLCJwZW5kaW5nVHJhY2tSZXNvbHZlcnMiLCJyZWNvbm5lY3RBdHRlbXB0cyIsInJlY29ubmVjdFN0YXJ0IiwiYXR0ZW1wdGluZ1JlY29ubmVjdCIsImpvaW5BdHRlbXB0cyIsIm1heEpvaW5BdHRlbXB0cyIsInNob3VsZEZhaWxOZXh0IiwiaGFuZGxlRGF0YUNoYW5uZWwiLCJyZWxpYWJsZURDU3ViIiwibG9zc3lEQ1N1YiIsImhhbmRsZURhdGFNZXNzYWdlIiwiZGF0YVByb2Nlc3NMb2NrIiwiQmxvYiIsImFycmF5QnVmZmVyIiwiZHAiLCJBY3RpdmVTcGVha2Vyc1VwZGF0ZSIsIkRhdGFQYWNrZXRSZWNlaXZlZCIsImhhbmRsZURhdGFFcnJvciIsImN1cnJlbnRUYXJnZXQiLCJjaGFubmVsS2luZCIsIm1heFJldHJhbnNtaXRzIiwiRXJyb3JFdmVudCIsImhhbmRsZUJ1ZmZlcmVkQW1vdW50TG93IiwiTE9TU1kiLCJ1cGRhdGVBbmRFbWl0RENCdWZmZXJTdGF0dXMiLCJoYW5kbGVEaXNjb25uZWN0IiwiZGlzY29ubmVjdFJlYXNvbiIsImRpc2Nvbm5lY3QiLCJEaXNjb25uZWN0ZWQiLCJkZWxheSIsImdldE5leHRSZXRyeURlbGF5IiwiZWxhcHNlZE1zIiwiY2xlYXJSZWNvbm5lY3RUaW1lb3V0IiwicmVnaW9uVXJsUHJvdmlkZXIiLCJ1cGRhdGVUb2tlbiIsInJlY29ubmVjdFRpbWVvdXQiLCJhdHRlbXB0UmVjb25uZWN0Iiwid2FpdEZvclJlc3RhcnRlZCIsIm9uUmVzdGFydGVkIiwib25EaXNjb25uZWN0ZWQiLCJpc0J1ZmZlclN0YXR1c0xvdyIsImRjQnVmZmVyU3RhdHVzIiwiRENCdWZmZXJTdGF0dXNDaGFuZ2VkIiwiZGF0YUNoYW5uZWxGb3JLaW5kIiwiYnVmZmVyZWRBbW91bnQiLCJidWZmZXJlZEFtb3VudExvd1RocmVzaG9sZCIsImhhbmRsZUJyb3dzZXJPbkxpbmUiLCJjbGllbnQiLCJSUl9TSUdOQUxfRElTQ09OTkVDVEVEIiwiRW5naW5lIiwiZXhwU2lnbmFsTGF0ZW5jeSIsInJlZ2lzdGVyT25MaW5lTGlzdGVuZXIiLCJ1cGRhdGUiLCJTdHJlYW1TdGF0ZUNoYW5nZWQiLCJsYXRlc3RKb2luUmVzcG9uc2UiLCJyb29tU2lkIiwiX2UiLCJfZiIsInNpZ25hbE9wdHMiLCJzZXR1cFNpZ25hbENsaWVudENhbGxiYWNrcyIsImpvaW5SZXNwb25zZSIsInBjTWFuYWdlciIsImNvbmZpZ3VyZSIsImNsaWVudENvbmZpZ3VyYXRpb24iLCJDbG9zaW5nIiwiZGVyZWdpc3Rlck9uTGluZUxpc3RlbmVyIiwiY2xlYXJQZW5kaW5nUmVjb25uZWN0IiwiY2xlYW51cFBlZXJDb25uZWN0aW9ucyIsImNsZWFudXBDbGllbnQiLCJkY0NsZWFudXAiLCJvbmJ1ZmZlcmVkYW1vdW50bG93Iiwib25jbG9zaW5nIiwibG9zc3lEQyIsInJlbGlhYmxlREMiLCJwdWJsaWNhdGlvblRpbWVvdXQiLCJ1cGRhdGVNdXRlU3RhdHVzIiwiZGF0YVN1YnNjcmliZXJSZWFkeVN0YXRlIiwiZ2V0Q29ubmVjdGVkU2VydmVyQWRkcmVzcyIsInNldFJlZ2lvblVybFByb3ZpZGVyIiwicHJvdmlkZXIiLCJtYWtlUlRDQ29uZmlndXJhdGlvbiIsIlRyYW5zcG9ydHNDcmVhdGVkIiwicHVibGlzaGVyU3RhdGUiLCJzdWJzY3JpYmVyU3RhdGUiLCJzaG91bGRFbWl0IiwiUlJfU1VCU0NSSUJFUl9GQUlMRUQiLCJSUl9QVUJMSVNIRVJfRkFJTEVEIiwiTWVkaWFUcmFja0FkZGVkIiwiY3JlYXRlRGF0YUNoYW5uZWxzIiwiTG9jYWxUcmFja1VucHVibGlzaGVkIiwiUmVtb3RlTXV0ZSIsImxlYXZlIiwic2VydmVyUmVzcG9uc2UiLCJlMmVlRW5hYmxlZCIsImVuY29kZWRJbnNlcnRhYmxlU3RyZWFtcyIsInJ0Y0ljZVNlcnZlcnMiLCJpY2VTZXJ2ZXIiLCJydGNJY2VTZXJ2ZXIiLCJFTkFCTEVEIiwiaWNlVHJhbnNwb3J0UG9saWN5IiwiY29udGludWFsR2F0aGVyaW5nUG9saWN5Iiwib3JkZXJlZCIsInNldFByZWZlcnJlZENvZGVjIiwiY2FwIiwibWF0Y2hlZCIsInBhcnRpYWxNYXRjaGVkIiwidW5tYXRjaGVkIiwibWF0Y2hlc1ZpZGVvQ29kZWMiLCJzZHBGbXRwTGluZSIsInNldENvZGVjUHJlZmVyZW5jZXMiLCJjcmVhdGVTZW5kZXIiLCJjcmVhdGVUcmFuc2NlaXZlclJUQ1J0cFNlbmRlciIsImNyZWF0ZVJUQ1J0cFNlbmRlciIsImNyZWF0ZVNpbXVsY2FzdFNlbmRlciIsInNpbXVsY2FzdFRyYWNrIiwiY3JlYXRlU2ltdWxjYXN0VHJhbnNjZWl2ZXJTZW5kZXIiLCJzZXRTaW11bGNhc3RUcmFja1NlbmRlciIsIkRJU0FCTEVEIiwicmVzdGFydENvbm5lY3Rpb24iLCJyZWNvdmVyYWJsZSIsIlNpZ25hbFJlY29ubmVjdEVycm9yIiwiUlJfVU5LTk9XTiIsInJlZ2lvblVybCIsIlJlc3RhcnRpbmciLCJTaWduYWxSZXN0YXJ0ZWQiLCJ3YWl0Rm9yUENSZWNvbm5lY3RlZCIsInJlc2V0QXR0ZW1wdHMiLCJuZXh0UmVnaW9uVXJsIiwiZ2V0TmV4dEJlc3RSZWdpb25VcmwiLCJSZXN1bWluZyIsIlNpZ25hbFJlc3VtZWQiLCJSZXN1bWVkIiwid2FpdEZvclBDSW5pdGlhbENvbm5lY3Rpb24iLCJSZWNvbm5lY3RpbmciLCJzZW5kRGF0YVBhY2tldCIsInBhY2tldCIsImVuc3VyZVB1Ymxpc2hlckNvbm5lY3RlZCIsImVuc3VyZURhdGFUcmFuc3BvcnRDb25uZWN0ZWQiLCJ0cmFuc3BvcnROYW1lIiwidGFyZ2V0Q2hhbm5lbCIsImVuZFRpbWUiLCJ2ZXJpZnlUcmFuc3BvcnQiLCJBYm9ydENvbnRyb2xsZXIiLCJoYW5kbGVDbG9zZWQiLCJhYm9ydCIsInJ0cFR5cGVzIiwicmVtb3RlVHJhY2tzIiwibG9jYWxUcmFja3MiLCJwcmV2aW91c0Fuc3dlciIsInByZXZpb3VzT2ZmZXIiLCJpc0Rlc2lyZWQiLCJzdWJzY3JpcHRpb24iLCJkYXRhQ2hhbm5lbHNJbmZvIiwiZmFpbE5leHQiLCJnZXRJbmZvIiwiUmVnaW9uVXJsUHJvdmlkZXIiLCJsYXN0VXBkYXRlQXQiLCJzZXR0aW5nc0NhY2hlVGltZSIsImF0dGVtcHRlZFJlZ2lvbnMiLCJVUkwiLCJnZXRTZXJ2ZXJVcmwiLCJyZWdpb25TZXR0aW5ncyIsImZldGNoUmVnaW9uU2V0dGluZ3MiLCJyZWdpb25zTGVmdCIsImF0dGVtcHRlZCIsIm5leHRSZWdpb24iLCJyZWdpb25TZXR0aW5nc1Jlc3BvbnNlIiwiZ2V0Q2xvdWRDb25maWdVcmwiLCJoZWFkZXJzIiwiYXV0aG9yaXphdGlvbiIsInN0YXR1c1RleHQiLCJob3N0IiwibW9uaXRvckZyZXF1ZW5jeSIsImNvbXB1dGVCaXRyYXRlIiwiY3VycmVudFN0YXRzIiwicHJldlN0YXRzIiwiYnl0ZXNOb3ciLCJieXRlc1ByZXYiLCJieXRlc1JlY2VpdmVkIiwiYnl0ZXNTZW50IiwiTG9jYWxBdWRpb1RyYWNrIiwic3RvcE9uTXV0ZSIsIm1vbml0b3JTZW5kZXIiLCJnZXRTZW5kZXJTdGF0cyIsImNoZWNrRm9yU2lsZW5jZSIsInNldERldmljZUlkIiwicmVzdGFydFRyYWNrIiwiZGV2aWNlSGFzQ2hhbmdlZCIsInN0YXJ0TW9uaXRvciIsInNldEF1ZGlvQ29udGV4dCIsImF1ZGlvU3RhdHMiLCJwYWNrZXRzU2VudCIsInJvdW5kVHJpcFRpbWUiLCJqaXR0ZXIiLCJ0cmFja0lzU2lsZW50IiwiQXVkaW9TaWxlbmNlRGV0ZWN0ZWQiLCJtZWRpYVRyYWNrVG9Mb2NhbFRyYWNrIiwiTG9jYWxWaWRlb1RyYWNrIiwicHJlc2V0czE2OSIsInByZXNldHM0MyIsInByZXNldHNTY3JlZW5TaGFyZSIsImRlZmF1bHRTaW11bGNhc3RQcmVzZXRzMTY5IiwiZGVmYXVsdFNpbXVsY2FzdFByZXNldHM0MyIsImNvbXB1dGVEZWZhdWx0U2NyZWVuU2hhcmVTaW11bGNhc3RQcmVzZXRzIiwiZnJvbVByZXNldCIsInZpZGVvUmlkcyIsImNvbXB1dGVWaWRlb0VuY29kaW5ncyIsImlzU2NyZWVuU2hhcmUiLCJ2aWRlb0VuY29kaW5nIiwidXNlU2ltdWxjYXN0Iiwic2NhbGFiaWxpdHlNb2RlIiwiZGV0ZXJtaW5lQXBwcm9wcmlhdGVFbmNvZGluZyIsInNtIiwiU2NhbGFiaWxpdHlNb2RlIiwic3BhdGlhbCIsInByZXNldHMiLCJzb3J0UHJlc2V0cyIsInNjcmVlblNoYXJlU2ltdWxjYXN0TGF5ZXJzIiwiZGVmYXVsdFNpbXVsY2FzdExheWVycyIsInZpZGVvU2ltdWxjYXN0TGF5ZXJzIiwibWlkUHJlc2V0IiwibG93UHJlc2V0IiwiZW5jb2RpbmdzRnJvbVByZXNldHMiLCJjb21wdXRlVHJhY2tCYWNrdXBFbmNvZGluZ3MiLCJzZXJ2ZXJSZXF1ZXN0ZWQiLCJwcmVzZXRzRm9yUmVzb2x1dGlvbiIsInByZXNldCIsImFzcGVjdCIsImFicyIsImNhblNldFByaW9yaXR5IiwibmV0d29ya1ByaW9yaXR5IiwidG9wRnJhbWVyYXRlIiwibm90aWZ5T25jZSIsImFFbmMiLCJiRW5jIiwicmVzdWx0cyIsInRlbXBvcmFsIiwic3VmZml4IiwicmVmcmVzaFN1YnNjcmliZWRDb2RlY0FmdGVyTmV3Q29kZWMiLCJzdGF0c01hcCIsInRvdGFsQml0cmF0ZSIsInNlbmRlckxvY2siLCJpc1NpbXVsY2FzdCIsInNpZ25hbENsaWVudCIsIl9fYXN5bmNWYWx1ZXMiLCJfZyIsIm5leHQiLCJkb25lIiwic2MiLCJpdGVtcyIsInZzIiwiZnJhbWVIZWlnaHQiLCJmcmFtZVdpZHRoIiwiZmlyQ291bnQiLCJwbGlDb3VudCIsIm5hY2tDb3VudCIsImZyYW1lc1NlbnQiLCJyZXRyYW5zbWl0dGVkUGFja2V0c1NlbnQiLCJxdWFsaXR5TGltaXRhdGlvblJlYXNvbiIsInF1YWxpdHlMaW1pdGF0aW9uUmVzb2x1dGlvbkNoYW5nZXMiLCJzZXRQdWJsaXNoaW5nUXVhbGl0eSIsIm1heFF1YWxpdHkiLCJxIiwiSElHSCIsInNldFB1Ymxpc2hpbmdMYXllcnMiLCJfaCIsImFkZFNpbXVsY2FzdFRyYWNrIiwic2ltdWxjYXN0Q29kZWNJbmZvIiwic2V0UHVibGlzaGluZ0NvZGVjcyIsImN1cnJlbnRDb2RlYyIsIm5ld0NvZGVjcyIsImNvZGVjc18xIiwiY29kZWNzXzFfMSIsInNldFB1Ymxpc2hpbmdMYXllcnNGb3JTZW5kZXIiLCJzZW5kZXJFbmNvZGluZ3MiLCJoYXNDaGFuZ2VkIiwiY2xvc2FibGVTcGF0aWFsIiwidmlkZW9RdWFsaXR5Rm9yUmlkIiwic3Vic2NyaWJlZFF1YWxpdHkiLCJNRURJVU0iLCJ2aWRlb0xheWVyc0Zyb21FbmNvZGluZ3MiLCJzdmMiLCJlbmNvZGluZ1NNIiwic2NhbGUiLCJSZW1vdGVUcmFjayIsInNldE11dGVkIiwic2V0TWVkaWFTdHJlYW0iLCJvblJlbW92ZVRyYWNrIiwibW9uaXRvclJlY2VpdmVyIiwiUmVtb3RlQXVkaW9UcmFjayIsImF1ZGlvT3V0cHV0IiwiZ2V0UmVjZWl2ZXJTdGF0cyIsIndlYkF1ZGlvUGx1Z2luTm9kZXMiLCJzaW5rSWQiLCJzZXRWb2x1bWUiLCJnYWluTm9kZSIsInNldFRhcmdldEF0VGltZSIsIl9zZXRWb2x1bWUiLCJlbGVtZW50Vm9sdW1lIiwiZ2V0Vm9sdW1lIiwiaGlnaGVzdFZvbHVtZSIsInNldFNpbmtJZCIsIm5lZWRzTmV3V2ViQXVkaW9Db25uZWN0aW9uIiwiY29ubmVjdFdlYkF1ZGlvIiwiZGlzY29ubmVjdFdlYkF1ZGlvIiwic2V0V2ViQXVkaW9QbHVnaW5zIiwibm9kZXMiLCJzb3VyY2VOb2RlIiwibGFzdE5vZGUiLCJub2RlIiwiZGVzdGluYXRpb24iLCJyZXN1bWUiLCJyZWNlaXZlclN0YXRzIiwiY29uY2VhbGVkU2FtcGxlcyIsImNvbmNlYWxtZW50RXZlbnRzIiwic2lsZW50Q29uY2VhbGVkU2FtcGxlcyIsInNpbGVudENvbmNlYWxtZW50RXZlbnRzIiwidG90YWxBdWRpb0VuZXJneSIsInRvdGFsU2FtcGxlc0R1cmF0aW9uIiwiUkVBQ1RJT05fREVMQVkiLCJSZW1vdGVWaWRlb1RyYWNrIiwiYWRhcHRpdmVTdHJlYW1TZXR0aW5ncyIsImVsZW1lbnRJbmZvcyIsImRlYm91bmNlZEhhbmRsZVJlc2l6ZSIsInVwZGF0ZURpbWVuc2lvbnMiLCJpc0FkYXB0aXZlU3RyZWFtIiwiZWxlbWVudEluZm8iLCJIVE1MRWxlbWVudEluZm8iLCJvYnNlcnZlRWxlbWVudEluZm8iLCJ1cGRhdGVWaXNpYmlsaXR5Iiwib2JzZXJ2ZSIsInN0b3BPYnNlcnZpbmdFbGVtZW50SW5mbyIsInN0b3BFbGVtZW50SW5mb3MiLCJzdG9wT2JzZXJ2aW5nIiwiZGV0YWNoZWRFbGVtZW50cyIsInN0b3BPYnNlcnZpbmdFbGVtZW50IiwiZ2V0RGVjb2RlckltcGxlbWVudGF0aW9uIiwiZGVjb2RlckltcGxlbWVudGF0aW9uIiwiY29kZWNJRCIsImNvZGVjSWQiLCJmcmFtZXNEZWNvZGVkIiwiZnJhbWVzRHJvcHBlZCIsImZyYW1lc1JlY2VpdmVkIiwicGFja2V0c1JlY2VpdmVkIiwibGFzdFZpc2liaWxpdHlDaGFuZ2UiLCJ2aXNpYmlsaXR5Q2hhbmdlZEF0IiwiYmFja2dyb3VuZFBhdXNlIiwicGF1c2VWaWRlb0luQmFja2dyb3VuZCIsImlzUGlQTW9kZSIsInBpY3R1cmVJblBpY3R1cmUiLCJpc1Zpc2libGUiLCJ2aXNpYmxlIiwibGFzdFZpc2libGUiLCJWaXNpYmlsaXR5Q2hhbmdlZCIsInBpeGVsRGVuc2l0eSIsImdldFBpeGVsRGVuc2l0eSIsImN1cnJlbnRFbGVtZW50V2lkdGgiLCJjdXJyZW50RWxlbWVudEhlaWdodCIsImxhc3REaW1lbnNpb25zIiwiVmlkZW9EaW1lbnNpb25zQ2hhbmdlZCIsImlzUGlQIiwiaXNJbnRlcnNlY3RpbmciLCJvblZpc2liaWxpdHlDaGFuZ2VkIiwib25FbnRlclBpUCIsIm9uTGVhdmVQaVAiLCJpc0VsZW1lbnRJblZpZXdwb3J0IiwicGljdHVyZUluUGljdHVyZUVsZW1lbnQiLCJjbGllbnRXaWR0aCIsImNsaWVudEhlaWdodCIsInVub2JzZXJ2ZSIsInRvcCIsIm9mZnNldFRvcCIsImxlZnQiLCJvZmZzZXRMZWZ0Iiwib2Zmc2V0V2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJvcGFjaXR5IiwiZGlzcGxheSIsImdldENvbXB1dGVkU3R5bGUiLCJvZmZzZXRQYXJlbnQiLCJwYWdlWU9mZnNldCIsImlubmVySGVpZ2h0IiwicGFnZVhPZmZzZXQiLCJpbm5lcldpZHRoIiwiVHJhY2tQdWJsaWNhdGlvbiIsIm1ldGFkYXRhTXV0ZWQiLCJoYW5kbGVNdXRlZCIsImhhbmRsZVVubXV0ZWQiLCJQdWJsaWNhdGlvbiIsInNldFRyYWNrIiwiaXNTdWJzY3JpYmVkIiwiYXVkaW9UcmFjayIsInZpZGVvVHJhY2siLCJ1cGRhdGVJbmZvIiwic2ltdWxjYXN0ZWQiLCJTdWJzY3JpcHRpb25TdGF0dXMiLCJQZXJtaXNzaW9uU3RhdHVzIiwiTG9jYWxUcmFja1B1YmxpY2F0aW9uIiwidGkiLCJoYW5kbGVUcmFja0VuZGVkIiwicXVhbGl0eUZyb21Qcm90byIsIlByb3RvUXVhbGl0eSIsIkVYQ0VMTEVOVCIsIkV4Y2VsbGVudCIsIkdPT0QiLCJHb29kIiwiUG9vciIsIkxPU1QiLCJMb3N0IiwiUGFydGljaXBhbnQiLCJpc0FnZW50IiwicGVybWlzc2lvbnMiLCJhdWRpb0xldmVsIiwiaXNTcGVha2luZyIsIl9jb25uZWN0aW9uUXVhbGl0eSIsImF1ZGlvVHJhY2tzIiwidmlkZW9UcmFja3MiLCJnZXRUcmFjayIsImdldFRyYWNrQnlOYW1lIiwiY29ubmVjdGlvblF1YWxpdHkiLCJpc0NhbWVyYUVuYWJsZWQiLCJpc01pY3JvcGhvbmVFbmFibGVkIiwiaXNTY3JlZW5TaGFyZUVuYWJsZWQiLCJwYXJ0aWNpcGFudEluZm8iLCJfc2V0TmFtZSIsIl9zZXRNZXRhZGF0YSIsInBlcm1pc3Npb24iLCJzZXRQZXJtaXNzaW9ucyIsIm1kIiwiY2hhbmdlZCIsInByZXZNZXRhZGF0YSIsIlBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkIiwiUGFydGljaXBhbnROYW1lQ2hhbmdlZCIsInByZXZQZXJtaXNzaW9ucyIsIlBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkIiwic2V0SXNTcGVha2luZyIsInNwZWFraW5nIiwibGFzdFNwb2tlQXQiLCJJc1NwZWFraW5nQ2hhbmdlZCIsInNldENvbm5lY3Rpb25RdWFsaXR5IiwicHJldlF1YWxpdHkiLCJDb25uZWN0aW9uUXVhbGl0eUNoYW5nZWQiLCJhZGRUcmFja1B1YmxpY2F0aW9uIiwiVHJhY2tNdXRlZCIsIlRyYWNrVW5tdXRlZCIsInRyYWNrUGVybWlzc2lvblRvUHJvdG8iLCJwZXJtcyIsImFsbG93QWxsIiwiYWxsb3dlZFRyYWNrU2lkcyIsIlJlbW90ZVRyYWNrUHVibGljYXRpb24iLCJjdXJyZW50VmlkZW9RdWFsaXR5IiwiaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSIsImVtaXRUcmFja1VwZGF0ZSIsImhhbmRsZVZpZGVvRGltZW5zaW9uc0NoYW5nZSIsInZpZGVvRGltZW5zaW9ucyIsInN1YnNjcmliZWQiLCJzZXRTdWJzY3JpYmVkIiwicHJldlN0YXR1cyIsInN1YnNjcmlwdGlvblN0YXR1cyIsInByZXZQZXJtaXNzaW9uIiwicGVybWlzc2lvblN0YXR1cyIsImVtaXRTdWJzY3JpcHRpb25VcGRhdGVJZkNoYW5nZWQiLCJlbWl0UGVybWlzc2lvblVwZGF0ZUlmQ2hhbmdlZCIsIlVuc3Vic2NyaWJlZCIsIkRlc2lyZWQiLCJTdWJzY3JpYmVkIiwiQWxsb3dlZCIsIk5vdEFsbG93ZWQiLCJzZXRFbmFibGVkIiwiaXNNYW51YWxPcGVyYXRpb25BbGxvd2VkIiwic2V0VmlkZW9RdWFsaXR5Iiwic2V0VmlkZW9EaW1lbnNpb25zIiwic2V0VmlkZW9GUFMiLCJ2aWRlb1F1YWxpdHkiLCJwcmV2VHJhY2siLCJzZXRBbGxvd2VkIiwic2V0U3Vic2NyaXB0aW9uRXJyb3IiLCJTdWJzY3JpcHRpb25GYWlsZWQiLCJwcmV2TWV0YWRhdGFNdXRlZCIsInByZXZpb3VzU3RhdHVzIiwiY3VycmVudFN0YXR1cyIsIlN1YnNjcmlwdGlvblN0YXR1c0NoYW5nZWQiLCJwcmV2aW91c1Blcm1pc3Npb25TdGF0dXMiLCJjdXJyZW50UGVybWlzc2lvblN0YXR1cyIsIlN1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkIiwiVXBkYXRlU2V0dGluZ3MiLCJSZW1vdGVQYXJ0aWNpcGFudCIsImZyb21QYXJ0aWNpcGFudEluZm8iLCJwaSIsInZvbHVtZU1hcCIsIlRyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWQiLCJUcmFja1N1YnNjcmlwdGlvblN0YXR1c0NoYW5nZWQiLCJwcmV2aW91c1RyYWNrIiwiVHJhY2tTdWJzY3JpcHRpb25GYWlsZWQiLCJhdWRpb1B1YmxpY2F0aW9uIiwiYWRkU3Vic2NyaWJlZE1lZGlhVHJhY2siLCJ0cmllc0xlZnQiLCJnZXRUcmFja1B1YmxpY2F0aW9uIiwiaXNWaWRlbyIsImhhc01ldGFkYXRhIiwidmFsaWRUcmFja3MiLCJuZXdUcmFja3MiLCJleGlzdGluZ1RyYWNrT2ZTb3VyY2UiLCJwdWJsaXNoZWRUcmFjayIsIm9sZFRyYWNrIiwidW5wdWJsaXNoVHJhY2siLCJzZW5kVW5wdWJsaXNoIiwiVHJhY2tVbnB1Ymxpc2hlZCIsInNldEF1ZGlvT3V0cHV0IiwicHJvbWlzZXMiLCJMb2NhbFBhcnRpY2lwYW50IiwicGVuZGluZ1B1Ymxpc2hpbmciLCJwZW5kaW5nUHVibGlzaFByb21pc2VzIiwicGFydGljaXBhbnRUcmFja1Blcm1pc3Npb25zIiwiYWxsUGFydGljaXBhbnRzQWxsb3dlZFRvU3Vic2NyaWJlIiwiZW5jcnlwdGlvblR5cGUiLCJoYW5kbGVSZWNvbm5lY3RpbmciLCJyZWNvbm5lY3RGdXR1cmUiLCJoYW5kbGVSZWNvbm5lY3RlZCIsInVwZGF0ZVRyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbnMiLCJoYW5kbGVEaXNjb25uZWN0ZWQiLCJhbGxQYXJ0aWNpcGFudHNBbGxvd2VkIiwib25UcmFja1VubXV0ZWQiLCJvblRyYWNrTXV0ZWQiLCJvblRyYWNrVXBzdHJlYW1QYXVzZWQiLCJvblRyYWNrVXBzdHJlYW1SZXN1bWVkIiwiaGFuZGxlU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUiLCJyb29tT3B0aW9ucyIsIm5ld0NvZGVjc18xIiwibmV3Q29kZWNzXzFfMSIsInB1Ymxpc2hBZGRpdGlvbmFsQ29kZWNGb3JUcmFjayIsImhhbmRsZUxvY2FsVHJhY2tVbnB1Ymxpc2hlZCIsInVucHVibGlzaGVkIiwiY3VycmVudFBlcm1pc3Npb25zIiwicXVlcnkiLCJvbmNoYW5nZSIsImFjdGl2ZURldmljZU1hcCIsImxhc3RDYW1lcmFFcnJvciIsImNhbWVyYUVycm9yIiwibGFzdE1pY3JvcGhvbmVFcnJvciIsIm1pY3JvcGhvbmVFcnJvciIsInNldE1ldGFkYXRhIiwic2V0TmFtZSIsInNldENhbWVyYUVuYWJsZWQiLCJwdWJsaXNoT3B0aW9ucyIsInNldFRyYWNrRW5hYmxlZCIsInNldE1pY3JvcGhvbmVFbmFibGVkIiwic2V0U2NyZWVuU2hhcmVFbmFibGVkIiwic2V0RTJFRUVuYWJsZWQiLCJHQ00iLCJyZXB1Ymxpc2hBbGxUcmFja3MiLCJhZGQiLCJjcmVhdGVUcmFja3MiLCJjcmVhdGVTY3JlZW5UcmFja3MiLCJwdWJsaXNoUHJvbWlzZXMiLCJsb2NhbFRyYWNrIiwicHVibGlzaFRyYWNrIiwicHVibGlzaGVkVHJhY2tzIiwiTWVkaWFEZXZpY2VzRXJyb3IiLCJzY3JlZW5BdWRpb1RyYWNrIiwiZW5hYmxlQ2FtZXJhQW5kTWljcm9waG9uZSIsImF1ZGlvQ2FwdHVyZURlZmF1bHRzIiwidmlkZW9DYXB0dXJlRGVmYXVsdHMiLCJBdWRpb1N0cmVhbUFjcXVpcmVkIiwiaXNBdWRpbyIsInRyYWNrQ29uc3RyYWludHMiLCJjb25PckJvb2wiLCJzY3JlZW5WaWRlbyIsImNvbnRlbnRIaW50Iiwic2NyZWVuQXVkaW8iLCJkZWZhdWx0Q29uc3RyYWludHMiLCJkZXZpY2VLaW5kIiwiZXhpc3RpbmdQdWJsaWNhdGlvbiIsImlzU3RlcmVvSW5wdXQiLCJjaGFubmVsQ291bnQiLCJpc1N0ZXJlbyIsImUyZWUiLCJwdWJsaXNoUHJvbWlzZSIsImRlZmF1bHRSZXMiLCJfaiIsIl9rIiwiX2wiLCJwcmltYXJ5Q29kZWNNaW1lIiwidXBkYXRlZENvZGVjIiwidHJhY2tUcmFuc2NlaXZlciIsIl9tIiwiX28iLCJzdG9wT25VbnB1Ymxpc2giLCJnZXRQdWJsaWNhdGlvbkZvclRyYWNrIiwicHViTG9nQ29udGV4dCIsIm5lZ290aWF0aW9uTmVlZGVkIiwidHJhY2tTZW5kZXIiLCJjbGVhciIsInVucHVibGlzaFRyYWNrcyIsInJlc3RhcnRUcmFja3MiLCJsb2NhbFB1YnMiLCJwdWJsaXNoRGF0YSIsInRvcGljIiwic2V0VHJhY2tTdWJzY3JpcHRpb25QZXJtaXNzaW9ucyIsIm11dGVkT25TZXJ2ZXIiLCJjb25uZWN0aW9uUmVjb25jaWxlRnJlcXVlbmN5IiwiUm9vbVN0YXRlIiwiX3RoaXMiLCJhY3RpdmVTcGVha2VycyIsImF1ZGlvRW5hYmxlZCIsImlzVmlkZW9QbGF5YmFja0Jsb2NrZWQiLCJidWZmZXJlZEV2ZW50cyIsInVubG9ja0Rpc2Nvbm5lY3QiLCJkaXNjb25uZWN0TG9jayIsImNvbm5lY3RGdXR1cmUiLCJzZXRBbmRFbWl0Q29ubmVjdGlvblN0YXRlIiwiQ29ubmVjdGluZyIsImNvbm5lY3RGbiIsImF0dGVtcHRDb25uZWN0aW9uIiwibmV4dFVybCIsImNsZWFyQ29ubmVjdGlvbkZ1dHVyZXMiLCJjb25uZWN0U2lnbmFsIiwiZTJlZU1hbmFnZXIiLCJzZXJ2ZXJJbmZvIiwiYXBwbHlKb2luUmVzcG9uc2UiLCJoYW5kbGVQYXJ0aWNpcGFudFVwZGF0ZXMiLCJoYW5kbGVSb29tVXBkYXRlIiwicmVjcmVhdGVFbmdpbmUiLCJtYXliZUNyZWF0ZUVuZ2luZSIsImFjcXVpcmVBdWRpb0NvbnRleHQiLCJjb25uT3B0aW9ucyIsInNldHVwTG9jYWxQYXJ0aWNpcGFudEV2ZW50cyIsInJlc3VsdGluZ0Vycm9yIiwib25QYWdlTGVhdmUiLCJoYW5kbGVEZXZpY2VDaGFuZ2UiLCJyZWdpc3RlckNvbm5lY3Rpb25SZWNvbmNpbGUiLCJzdG9wVHJhY2tzIiwic3RhcnRBdWRpbyIsImVsZW1lbnRzIiwiYXVkaW9JZCIsImR1bW15QXVkaW9FbCIsImdldEVsZW1lbnRCeUlkIiwiYm9keSIsImFwcGVuZCIsImhhbmRsZUF1ZGlvUGxheWJhY2tTdGFydGVkIiwiaGFuZGxlQXVkaW9QbGF5YmFja0ZhaWxlZCIsInN0YXJ0VmlkZW8iLCJoYW5kbGVWaWRlb1BsYXliYWNrU3RhcnRlZCIsImhhbmRsZVZpZGVvUGxheWJhY2tGYWlsZWQiLCJoYW5kbGVSZXN0YXJ0aW5nIiwiY2xlYXJDb25uZWN0aW9uUmVjb25jaWxlIiwiaGFuZGxlUGFydGljaXBhbnREaXNjb25uZWN0ZWQiLCJoYW5kbGVTaWduYWxSZXN0YXJ0ZWQiLCJfcCIsIlJlY29ubmVjdGVkIiwiZW1pdEJ1ZmZlcmVkRXZlbnRzIiwicGFydGljaXBhbnRJbmZvcyIsImlkZW50aXR5VG9TaWQiLCJyZW1vdGVQYXJ0aWNpcGFudCIsImlzTmV3UGFydGljaXBhbnQiLCJnZXRPckNyZWF0ZVBhcnRpY2lwYW50IiwiaGFuZGxlQWN0aXZlU3BlYWtlcnNVcGRhdGUiLCJzZWVuU2lkcyIsInNwZWFrZXIiLCJlbWl0V2hlbkNvbm5lY3RlZCIsIkFjdGl2ZVNwZWFrZXJzQ2hhbmdlZCIsImhhbmRsZVNwZWFrZXJzQ2hhbmdlZCIsInNwZWFrZXJVcGRhdGVzIiwibGFzdFNwZWFrZXJzIiwiaGFuZGxlU3RyZWFtU3RhdGVVcGRhdGUiLCJzdHJlYW1TdGF0ZVVwZGF0ZSIsIlRyYWNrU3RyZWFtU3RhdGVDaGFuZ2VkIiwiaGFuZGxlU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSIsImhhbmRsZVN1YnNjcmlwdGlvbkVycm9yIiwiaGFuZGxlRGF0YVBhY2tldCIsInVzZXJQYWNrZXQiLCJEYXRhUmVjZWl2ZWQiLCJjYW5QbGF5YmFja0F1ZGlvIiwiQXVkaW9QbGF5YmFja1N0YXR1c0NoYW5nZWQiLCJWaWRlb1BsYXliYWNrU3RhdHVzQ2hhbmdlZCIsIk1lZGlhRGV2aWNlc0NoYW5nZWQiLCJvbGRSb29tIiwicm9vbUluZm8iLCJSb29tTWV0YWRhdGFDaGFuZ2VkIiwiUmVjb3JkaW5nU3RhdHVzQ2hhbmdlZCIsImhhbmRsZUNvbm5lY3Rpb25RdWFsaXR5VXBkYXRlIiwib25Mb2NhbFBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkIiwib25Mb2NhbFBhcnRpY2lwYW50TmFtZUNoYW5nZWQiLCJvbkxvY2FsVHJhY2tNdXRlZCIsIm9uTG9jYWxUcmFja1VubXV0ZWQiLCJMb2NhbEF1ZGlvU2lsZW5jZURldGVjdGVkIiwiX3EiLCJBY3RpdmVEZXZpY2VDaGFuZ2VkIiwib25Mb2NhbENvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCIsIm9uTWVkaWFEZXZpY2VzRXJyb3IiLCJvbkxvY2FsUGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWQiLCJzd2l0Y2hBY3RpdmVEZXZpY2UiLCJzZXR1cEUyRUUiLCJpc1JlY29yZGluZyIsIm9uVHJhY2tBZGRlZCIsInVwZGF0ZVN1YnNjcmlwdGlvbnMiLCJnZXRMb2NhbERldmljZXMiLCJwcmVwYXJlQ29ubmVjdGlvbiIsInNpbXVsYXRlU2NlbmFyaW8iLCJwb3N0QWN0aW9uIiwiY2FuUGxheWJhY2tWaWRlbyIsImdldEFjdGl2ZUF1ZGlvT3V0cHV0RGV2aWNlIiwiZ2V0QWN0aXZlRGV2aWNlIiwic3VjY2VzcyIsImRldmljZUNvbnN0cmFpbnQiLCJwcmV2RGV2aWNlSWQiLCJyZWNvbm5lY3RlZEhhbmRsZXIiLCJzaG91bGRTdG9wVHJhY2tzIiwiUGFydGljaXBhbnREaXNjb25uZWN0ZWQiLCJuZXdDb250ZXh0SXNSdW5uaW5nIiwiY3JlYXRlUGFydGljaXBhbnQiLCJQYXJ0aWNpcGFudENvbm5lY3RlZCIsInRyYWNrUHVibGljYXRpb24iLCJjb25zZWN1dGl2ZUZhaWx1cmVzIiwiY29ubmVjdGlvblJlY29uY2lsZUludGVydmFsIiwibnVtRmFpbHVyZXMiLCJjbG9zZWQiLCJ0cmFuc3BvcnRzQ29ubmVjdGVkIiwiU1RBVEVfTUlTTUFUQ0giLCJzaW11bGF0ZVBhcnRpY2lwYW50cyIsInVzZVJlYWxUcmFja3MiLCJwYXJ0aWNpcGFudE9wdGlvbnMiLCJhc3BlY3RSYXRpb3MiLCJSb29tTW9kZWwiLCJjYW1QdWIiLCJhdWRpb1B1YiIsImR1bW15VmlkZW8iLCJfbGVuMiIsIl9rZXkyIiwibWluaW1pemVkQXJncyIsIm1hcEFyZ3MiLCJDaGVja1N0YXR1cyIsIkNoZWNrZXIiLCJJRExFIiwibG9ncyIsImVycm9yc0FzV2FybmluZ3MiLCJvbkNvbXBsZXRlIiwic2V0U3RhdHVzIiwicGVyZm9ybSIsImFwcGVuZFdhcm5pbmciLCJhcHBlbmRFcnJvciIsIlNLSVBQRUQiLCJpc1N1Y2Nlc3MiLCJTVUNDRVNTIiwiYXBwZW5kTWVzc2FnZSIsImNyZWF0ZUxvY2FsVHJhY2tzIiwibWVkaWFQcm9taXNlIiwiY3JlYXRlTG9jYWxWaWRlb1RyYWNrIiwiY3JlYXRlTG9jYWxBdWRpb1RyYWNrIiwiY3JlYXRlTG9jYWxTY3JlZW5UcmFja3MiLCJQdWJsaXNoQXVkaW9DaGVjayIsIm51bVBhY2tldHMiLCJtZWRpYVR5cGUiLCJQdWJsaXNoVmlkZW9DaGVjayIsIlJlY29ubmVjdENoZWNrIiwicmVjb25uZWN0aW5nVHJpZ2dlcmVkIiwicmVjb25uZWN0ZWQiLCJyZWNvbm5lY3RSZXNvbHZlciIsIlRVUk5DaGVjayIsImpvaW5SZXMiLCJoYXNUTFMiLCJoYXNUVVJOIiwiaGFzU1RVTiIsIldlYlJUQ0NoZWNrIiwiaGFzVGNwIiwiaGFzSXB2NFVkcCIsInByZXZUcmlja2xlIiwiaXNJUFByaXZhdGUiLCJSVENQZWVyQ29ubmVjdGlvbkljZUVycm9yRXZlbnQiLCJlcnJvckNvZGUiLCJlcnJvclRleHQiLCJzZWNvbmQiLCJXZWJTb2NrZXRDaGVjayIsIkNsb3VkIiwiQ29ubmVjdGlvbkNoZWNrIiwiY2hlY2tSZXN1bHRzIiwiZ2V0TmV4dENoZWNrSWQiLCJuZXh0SWQiLCJ1cGRhdGVDaGVjayIsImNoZWNrSWQiLCJnZXRSZXN1bHRzIiwiY3JlYXRlQW5kUnVuQ2hlY2siLCJjaGVjayIsImhhbmRsZVVwZGF0ZSIsImNoZWNrV2Vic29ja2V0IiwiY2hlY2tXZWJSVEMiLCJjaGVja1RVUk4iLCJjaGVja1JlY29ubmVjdCIsImNoZWNrUHVibGlzaEF1ZGlvIiwiY2hlY2tQdWJsaXNoVmlkZW8iLCJmYWNpbmdNb2RlRnJvbUxvY2FsVHJhY2siLCJ0cmFja1NldHRpbmdzIiwiZGVmYXVsdEZhY2luZ01vZGUiLCJjb25maWRlbmNlIiwicmF3RmFjaW5nTW9kZSIsImlzRmFjaW5nTW9kZVZhbHVlIiwibGFiZWxBbmFseXNpc1Jlc3VsdCIsImZhY2luZ01vZGVGcm9tRGV2aWNlTGFiZWwiLCJrbm93bkRldmljZUxhYmVscyIsImtub3duRGV2aWNlTGFiZWxTZWN0aW9ucyIsImRldmljZUxhYmVsIiwic2VjdGlvbiIsImFsbG93ZWRWYWx1ZXMiXSwiaWdub3JlTGlzdCI6WzAsMiwzLDQsNSw2LDcsOCw5LDEwLDExLDEyLDEzLDE0LDE1LDE2LDE3LDE4LDE5LDIwLDIxLDIyLDIzLDI2LDI3LDI4LDI5LDMwLDMxLDMyLDMzLDM0LDM1LDM2LDM3LDM4LDQ1LDYwLDYxLDYyLDYzXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/livekit-client@1.15.13/node_modules/livekit-client/dist/livekit-client.esm.mjs\n");

/***/ })

};
;